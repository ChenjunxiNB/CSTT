[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1920
PlayResY: 1080

[Aegisub Project Garbage]
Audio File: D:/python_code/video_tool/result/CS50x 2023 - Lecture 5 - Data Structures.mp4
Video File: D:/python_code/video_tool/result/CS50x 2023 - Lecture 5 - Data Structures.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.500000
Scroll Position: 3546
Active Line: 3555
Video Position: 191186

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.99999,1.99999,2,11,11,11,1
Style: 英文,Arial,29,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1.33333,1.33333,2,11,11,11,1
Style: 中文,微软雅黑,38,&H0029EEF1,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1.99999,1.99999,2,11,11,45,1
Style: 中文大字幕,Arial,38,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.99999,1.99999,2,11,11,11,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,
Dialogue: 0,0:01:12.50,0:01:25.61,英文,,0,0,0,,All right, this is CS50, and this is week five, which is going to be our last week in C. But what that means is that we'll have, OK.
Dialogue: 0,0:01:12.50,0:01:25.61,中文,,0,0,0,,好了，欢迎回到 CS50，这是第五周，也是我们学习 C 语言的最后一周，这意味着我们将会结束C。
Dialogue: 0,0:01:25.61,0:01:40.15,英文,,0,0,0,,But with this week, with last week, and really all of the weeks prior, have you been hopefully acquiring, if slowly and with some challenge, like some fundamental building blocks that are still going to underlie everything we continue doing in the semester, even as we transition to so-called higher level languages.
Dialogue: 0,0:01:25.61,0:01:40.15,中文,,0,0,0,,但希望在本周、上周以及之前所有的时间里，你已经慢慢地、克服了一些挑战，\N掌握了一些基本构建模块，这些模块将继续构成我们在本学期继续学习的基础，即使在我们过渡到所谓的高级语言之后也是如此。
Dialogue: 0,0:01:40.15,0:01:47.32,英文,,0,0,0,,Next week, indeed, we'll introduce Python, a very popular language that does not have pointers, does not have memory management at this very low level.
Dialogue: 0,0:01:40.15,0:01:47.32,中文,,0,0,0,,下周，我们将介绍 Python，这是一种非常流行的语言，它没有指针，也没有这种非常底层的内存管理。
Dialogue: 0,0:01:47.32,0:01:52.70,英文,,0,0,0,,But that's really just because someone else wrote the code that will do that for you. And it's going to make our lives easier.
Dialogue: 0,0:01:47.32,0:01:52.70,中文,,0,0,0,,但这实际上是因为别人帮你写了代码来做这件事，这会让我们的生活更轻松。
Dialogue: 0,0:01:52.70,0:02:03.51,英文,,0,0,0,,Because it means when you want to solve a problem conceptually up here, to just get real work done or build something amazing, you don't have to really get into the same weeds as we have been deliberately this week and now last.
Dialogue: 0,0:01:52.70,0:02:03.51,中文,,0,0,0,,因为这意味着，当你想要从概念上解决一个问题，\N想要真正完成一些工作或者构建一些了不起的东西时，你不需要像我们本周和上周那样深入到具体的细节中。
Dialogue: 0,0:02:03.51,0:02:10.75,英文,,0,0,0,,But the goal ultimately is that you better understand and can better harness, then, all that a computer can do, even in those higher-level languages.
Dialogue: 0,0:02:03.51,0:02:10.75,中文,,0,0,0,,但最终的目标是，让你更好地理解和利用计算机所能做的一切，即使是在那些高级语言中也是如此。
Dialogue: 0,0:02:10.75,0:02:18.45,英文,,0,0,0,,So today, we're going to focus particularly on data structures, how you might structure your data in memory, which really amounts to building things digitally,
Dialogue: 0,0:02:10.75,0:02:18.45,中文,,0,0,0,,今天，我们将特别关注数据结构，也就是如何在内存中构建数据，这实际上就是用数字的方式构建事物，
Dialogue: 0,0:02:18.45,0:02:24.82,英文,,0,0,0,,Stitching together ideas and concepts in memory using this new building block from last week, which, of course, are these pointers.
Dialogue: 0,0:02:18.45,0:02:24.82,中文,,0,0,0,,使用上周介绍的新构建模块——指针，将内存中的想法和概念拼接在一起。
Dialogue: 0,0:02:24.82,0:02:28.84,英文,,0,0,0,,Pointers allow you to store addresses in memory, like in variables.
Dialogue: 0,0:02:24.82,0:02:28.84,中文,,0,0,0,,指针允许你在内存中存储地址，就像在变量中一样。
Dialogue: 0,0:02:28.84,0:02:32.04,英文,,0,0,0,,But with those simple addresses, we can sort of leave these breadcrumbs.
Dialogue: 0,0:02:28.84,0:02:32.04,中文,,0,0,0,,但通过这些简单的地址，我们可以留下这些线索。
Dialogue: 0,0:02:32.04,0:02:33.60,英文,,0,0,0,,We can point from here to there.
Dialogue: 0,0:02:32.04,0:02:33.60,中文,,0,0,0,,我们可以从这里指向那里。
Dialogue: 0,0:02:33.60,0:02:37.33,英文,,0,0,0,,And we can conceptually stitch pieces of data together.
Dialogue: 0,0:02:33.60,0:02:37.33,中文,,0,0,0,,我们可以在概念上将数据片段拼接在一起。
Dialogue: 0,0:02:37.33,0:02:39.15,英文,,0,0,0,,But there's going to be different ways of doing that.
Dialogue: 0,0:02:37.33,0:02:39.15,中文,,0,0,0,,但这样做的方法有很多种。
Dialogue: 0,0:02:39.15,0:02:43.01,英文,,0,0,0,,And today, we'll focus first on what's generally known as an abstract data type.
Dialogue: 0,0:02:39.15,0:02:43.01,中文,,0,0,0,,今天，我们将首先关注通常被称为抽象数据类型的内容。
Dialogue: 0,0:02:43.01,0:02:47.21,英文,,0,0,0,,And similar to a type in C more generally, it does actually have some properties in it.
Dialogue: 0,0:02:43.01,0:02:47.21,中文,,0,0,0,,与更一般的 C 语言中的类型相似，它实际上确实具有一些属性。
Dialogue: 0,0:02:47.21,0:02:52.25,英文,,0,0,0,,But the underlying implementation details of an abstract data type are ultimately up to you.
Dialogue: 0,0:02:47.21,0:02:52.25,中文,,0,0,0,,但抽象数据类型的底层实现细节最终取决于你。
Dialogue: 0,0:02:52.25,0:02:56.42,英文,,0,0,0,,That is to say, an abstract data type can represent one thing and can do something.
Dialogue: 0,0:02:52.25,0:02:56.42,中文,,0,0,0,,也就是说，一个抽象数据类型可以表示一个事物，并且可以做某件事。
Dialogue: 0,0:02:56.42,0:03:00.58,英文,,0,0,0,,But how you implement it allows you some discretion underneath the hood.
Dialogue: 0,0:02:56.42,0:03:00.58,中文,,0,0,0,,但是你如何实现它，让你在底层有一定的自由度。
Dialogue: 0,0:03:00.58,0:03:05.62,英文,,0,0,0,,So for instance, in the world of computer science, A queue is actually a technical term.
Dialogue: 0,0:03:00.58,0:03:05.62,中文,,0,0,0,,例如，在计算机科学领域，队列实际上是一个技术术语。
Dialogue: 0,0:03:05.62,0:03:11.38,英文,,0,0,0,,This is a type of data structure that we could theoretically build in code in C or really any other language.
Dialogue: 0,0:03:05.62,0:03:11.38,中文,,0,0,0,,这是一种数据结构，我们理论上可以用 C 语言或其他任何语言的代码来构建。
Dialogue: 0,0:03:11.38,0:03:14.68,英文,,0,0,0,,But a queue has properties just like queues in the real world.
Dialogue: 0,0:03:11.38,0:03:14.68,中文,,0,0,0,,但是队列就像现实世界中的队列一样，也具有某些属性。
Dialogue: 0,0:03:14.68,0:03:26.39,英文,,0,0,0,,For instance, if you've ever lined up for something to get food in a restaurant or go into a store or wait for the airport to clear you, well, you've lined up in a queue, a queue being some sort of line.
Dialogue: 0,0:03:14.68,0:03:26.39,中文,,0,0,0,,例如，如果你曾经排队买过东西，比如在餐馆点餐、进商店或者在机场排队过安检，那你就是在排队，队列就是某种形式的队伍。
Dialogue: 0,0:03:26.39,0:03:30.99,英文,,0,0,0,,But what's noteworthy about queues are specific properties.
Dialogue: 0,0:03:26.39,0:03:30.99,中文,,0,0,0,,但队列的特殊属性值得注意。
Dialogue: 0,0:03:30.99,0:03:36.01,英文,,0,0,0,,First in, first out data structures, either virtually or in the human world.
Dialogue: 0,0:03:30.99,0:03:36.01,中文,,0,0,0,,无论是虚拟的还是现实世界中的队列，都是先进先出（FIFO）的数据结构。
Dialogue: 0,0:03:36.01,0:03:40.69,英文,,0,0,0,,Which is to say, the first person in the line should ideally be served first at the restaurant.
Dialogue: 0,0:03:36.01,0:03:40.69,中文,,0,0,0,,也就是说，理想情况下，排在队伍中的第一个人应该在餐厅第一个得到服务。
Dialogue: 0,0:03:40.69,0:03:43.87,英文,,0,0,0,,Or the first person in the line should get through airport security first.
Dialogue: 0,0:03:40.69,0:03:43.87,中文,,0,0,0,,或者排在队伍中的第一个人应该第一个通过机场安检。
Dialogue: 0,0:03:43.87,0:03:51.25,英文,,0,0,0,,By contrast, if it weren't first in, first out, you can imagine how frustrated you would be if you have this sort of inherent unfairness.
Dialogue: 0,0:03:43.87,0:03:51.25,中文,,0,0,0,,相比之下，如果不是先进先出，你可以想象你会多么沮丧， 如果你遇到这种固有的不公平待遇。
Dialogue: 0,0:03:51.25,0:04:02.74,英文,,0,0,0,,In fact, if you've ever been in line at a store, a supermarket, or the like, and all of a sudden they maybe open a new line, and now the person behind you gets to kind of cut ahead and go forward, that's because they've broken the concept of the cube.
Dialogue: 0,0:03:51.25,0:04:02.74,中文,,0,0,0,,事实上如果你曾经在商店、超市或类似的地方排队，突然间他们可能开了一条新队伍，你后面的人就可以插队往前走，因为他们破坏了队列的概念。
Dialogue: 0,0:04:02.74,0:04:09.28,英文,,0,0,0,,So it has this inherent potential for unfairness unless you maintain this first in, first out property.
Dialogue: 0,0:04:02.74,0:04:09.28,中文,,0,0,0,,所以除非保持这种先进先出的特性，否则它本身就具有潜在的不公平性。
Dialogue: 0,0:04:09.28,0:04:12.68,英文,,0,0,0,,This would be true, too, for like a to-do list, just for productivity's sake.
Dialogue: 0,0:04:09.28,0:04:12.68,中文,,0,0,0,,为了提高效率，待办事项列表也是如此。
Dialogue: 0,0:04:12.68,0:04:16.46,英文,,0,0,0,,If you're in the habit on paper or virtually making a to-do list,
Dialogue: 0,0:04:12.68,0:04:16.46,中文,,0,0,0,,如果你习惯于在纸上或虚拟地列出待办事项清单，
Dialogue: 0,0:04:16.46,0:04:25.31,英文,,0,0,0,,Ideally, you probably want to go through that list top to bottom so that you actually get the first stuff you thought of done first, rather than always focusing on your most recent thought.
Dialogue: 0,0:04:16.46,0:04:25.31,中文,,0,0,0,,理想情况下，你可能希望从上到下浏览清单，以便先完成你想到的第一件事，而不是总是专注于你最近的想法。
Dialogue: 0,0:04:25.31,0:04:34.53,英文,,0,0,0,,Now, within the world of queues, there's generally two operations, two functions, if you will, that any queue would have, either in the real world or in the virtual.
Dialogue: 0,0:04:25.31,0:04:34.53,中文,,0,0,0,,现在，在队列的世界里，通常有两个操作，两个函数，如果你愿意这样称呼的话，任何队列都会有，无论是在现实世界还是在虚拟世界中。
Dialogue: 0,0:04:34.53,0:04:38.41,英文,,0,0,0,,Enqueue is usually the technical term to mean adding something to a queue.
Dialogue: 0,0:04:34.53,0:04:38.41,中文,,0,0,0,,Enqueue 通常是技术术语，意思是向队列中添加东西。
Dialogue: 0,0:04:38.41,0:04:44.72,英文,,0,0,0,,But specifically, it means adding it to the end of the queue, so that someone isn't cutting in line, for instance, to go up front.
Dialogue: 0,0:04:38.41,0:04:44.72,中文,,0,0,0,,但具体来说，它是指将它添加到队列的末尾，这样就不会有人插队跑到前面去了。
Dialogue: 0,0:04:44.72,0:04:53.96,英文,,0,0,0,,And then dequeue is just the opposite. When it's time for the first person in line to be served, the time for the first person in line to go through security, they are dequeued, so to speak.
Dialogue: 0,0:04:44.72,0:04:53.96,中文,,0,0,0,,Dequeue 则正好相反。当排在队伍中的第一个人可以接受服务，排在队伍中的第一个人可以过安检时，他们就被“出队”了。
Dialogue: 0,0:04:53.96,0:04:59.76,英文,,0,0,0,,So a technical concept, ultimately, as it's implemented in code, but it's really just a real-world concept.
Dialogue: 0,0:04:53.96,0:04:59.76,中文,,0,0,0,,这最终是一个技术概念，因为它是在代码中实现的，但它实际上只是一个现实世界的概念。
Dialogue: 0,0:04:59.76,0:05:04.71,英文,,0,0,0,,And these are in contrast to another abstract data type that we might call a stack.
Dialogue: 0,0:04:59.76,0:05:04.71,中文,,0,0,0,,这些与我们可能称之为“栈”的另一种抽象数据类型形成对比。
Dialogue: 0,0:05:04.71,0:05:10.79,英文,,0,0,0,,And a stack, much like a stack of trays in the cafeteria, has sort of fundamentally different properties.
Dialogue: 0,0:05:04.71,0:05:10.79,中文,,0,0,0,,栈就像自助餐厅里的托盘堆一样，具有根本不同的属性。
Dialogue: 0,0:05:10.79,0:05:13.71,英文,,0,0,0,,You can still add and remove things from them. But consider what happens.
Dialogue: 0,0:05:10.79,0:05:13.71,中文,,0,0,0,,你仍然可以从中添加或移除东西。但是想一下会发生什么。
Dialogue: 0,0:05:13.71,0:05:22.87,英文,,0,0,0,,Whenever they clean all of the trays in the cafeteria or the dining hall, they put one of the trays down here, and then the next one on top of it, and then the next one on top of it, it, it, and so forth.
Dialogue: 0,0:05:13.71,0:05:22.87,中文,,0,0,0,,每当他们清理自助餐厅或食堂里的所有托盘时，他们会把其中一个托盘放在这里，然后把下一个放在上面，然后再把下一个放在上面，等等。
Dialogue: 0,0:05:22.87,0:05:28.90,英文,,0,0,0,,But of course, which tray do you presumably take as a user of that physical stack?
Dialogue: 0,0:05:22.87,0:05:28.90,中文,,0,0,0,,但是，作为这个物理堆栈的用户，你可能会拿哪个托盘呢？
Dialogue: 0,0:05:28.90,0:05:30.96,英文,,0,0,0,,The top one, presumably, right?
Dialogue: 0,0:05:28.90,0:05:30.96,中文,,0,0,0,,大概是最上面的那个，对吧？
Dialogue: 0,0:05:30.96,0:05:33.14,英文,,0,0,0,,Like, you're not going to futz down here and try to pull one out.
Dialogue: 0,0:05:30.96,0:05:33.14,中文,,0,0,0,,你不会费劲地从下面抽出一个来。
Dialogue: 0,0:05:33.14,0:05:36.08,英文,,0,0,0,,And so that would seem to have an opposite property, LIFO.
Dialogue: 0,0:05:33.14,0:05:36.08,中文,,0,0,0,,所以这似乎有一个相反的属性，LIFO（后进先出）。
Dialogue: 0,0:05:36.08,0:05:40.56,英文,,0,0,0,,Last in, first out, is what characterizes something like a stack.
Dialogue: 0,0:05:36.08,0:05:40.56,中文,,0,0,0,,后进先出，是像栈这样的数据结构的特点。
Dialogue: 0,0:05:40.56,0:05:50.62,英文,,0,0,0,,And that just makes sense, certainly in the physical world of stacking all of those cafeteria trays, because it just makes more sense to grab the most recently added one, the last added one, first.
Dialogue: 0,0:05:40.56,0:05:50.62,中文,,0,0,0,,这在堆放自助餐托盘的现实世界中是说得通的，因为拿最近添加的那个，也就是最后添加的那个，是最合理的。
Dialogue: 0,0:05:50.62,0:05:55.10,英文,,0,0,0,,And at least in that context, the trays don't necessarily care what order they're used in.
Dialogue: 0,0:05:50.62,0:05:55.10,中文,,0,0,0,,至少在这种情况下，托盘并不关心它们的使用顺序。
Dialogue: 0,0:05:55.10,0:06:03.33,英文,,0,0,0,,But even then, you could imagine that maybe there's some old, dirty, nasty tray at the very bottom that never gets used because you're constantly replenishing the stack.
Dialogue: 0,0:05:55.10,0:06:03.33,中文,,0,0,0,,但即便如此，你也可以想象，也许在最底部有一个又旧又脏又讨厌的托盘，从来没有被使用过，因为你一直在补充新的托盘。
Dialogue: 0,0:06:03.33,0:06:07.33,英文,,0,0,0,,So there might very well be side effects of these kinds of features.
Dialogue: 0,0:06:03.33,0:06:07.33,中文,,0,0,0,,所以这些特性很可能会产生副作用。
Dialogue: 0,0:06:07.33,0:06:11.45,英文,,0,0,0,,You might be familiar with using Gmail, for instance, or really any email program.
Dialogue: 0,0:06:07.33,0:06:11.45,中文,,0,0,0,,例如，你可能熟悉使用 Gmail，或者任何电子邮件程序。
Dialogue: 0,0:06:11.45,0:06:16.76,英文,,0,0,0,,What you're looking at in your inbox is technically a stack, at least if you've left the defaults configured.
Dialogue: 0,0:06:11.45,0:06:16.76,中文,,0,0,0,,你在收件箱中看到的内容技术上是一个栈，至少在你保留默认配置的情况下是这样。
Dialogue: 0,0:06:16.76,0:06:22.80,英文,,0,0,0,,Why? You get a new email. Where does it end up? Not like five pages of emails later, presumably right at the top.
Dialogue: 0,0:06:16.76,0:06:22.80,中文,,0,0,0,,为什么？你收到一封新邮件。它会出现在哪里？大概不会在五页邮件之后，而是在最上面。
Dialogue: 0,0:06:22.80,0:06:25.68,英文,,0,0,0,,And the next one's right at the top, right at the top, right at the top.
Dialogue: 0,0:06:22.80,0:06:25.68,中文,,0,0,0,,下一封邮件也在最上面，最上面，最上面。
Dialogue: 0,0:06:25.68,0:06:29.14,英文,,0,0,0,,And so if you're like me, you're guilty of eventually losing track of some emails.
Dialogue: 0,0:06:25.68,0:06:29.14,中文,,0,0,0,,如果你像我一样，你就会常常忘记一些邮件。
Dialogue: 0,0:06:29.14,0:06:29.70,英文,,0,0,0,,Why?
Dialogue: 0,0:06:29.14,0:06:29.70,中文,,0,0,0,,为什么？
Dialogue: 0,0:06:29.70,0:06:35.76,英文,,0,0,0,,Because you've pushed so many more emails onto the stack that you sort of lose track of the things you got.
Dialogue: 0,0:06:29.70,0:06:35.76,中文,,0,0,0,,因为你把太多邮件推到栈上了，以至于你忘记了你收到的东西。
Dialogue: 0,0:06:35.76,0:06:37.53,英文,,0,0,0,,Last in, first out, though, is maintained.
Dialogue: 0,0:06:35.76,0:06:37.53,中文,,0,0,0,,不过，后进先出的规则依然有效。
Dialogue: 0,0:06:37.53,0:06:45.13,英文,,0,0,0,,The most recent email you get might very well be the first one you reply to, but that's not necessarily good for responsiveness to everyone else out there.
Dialogue: 0,0:06:37.53,0:06:45.13,中文,,0,0,0,,你收到的最新邮件很可能是你第一封回复的邮件，但这对其他人的响应速度不一定有利。
Dialogue: 0,0:06:45.13,0:06:56.15,英文,,0,0,0,,Similarly, if you store all of your sweaters in a stack like this, like a pile of black ones below, which is a red and then a blue, stack might be perfectly fine for keeping things organized.
Dialogue: 0,0:06:45.13,0:06:56.15,中文,,0,0,0,,类似地，如果你把所有的毛衣像这样堆成一堆，比如一堆黑色毛衣在下面，\N上面是一件红色毛衣，再上面是一件蓝色毛衣，那么用堆栈来整理东西可能就足够好了。
Dialogue: 0,0:06:56.15,0:06:59.72,英文,,0,0,0,,It's sort of the sane way to do it if you just have a shelf in your dorm room or home.
Dialogue: 0,0:06:56.15,0:06:59.72,中文,,0,0,0,,如果你在宿舍或家里只有一个架子，这是一种合理的做法。
Dialogue: 0,0:06:59.72,0:07:02.34,英文,,0,0,0,,But what's going to be a side effect of using a stack?
Dialogue: 0,0:06:59.72,0:07:02.34,中文,,0,0,0,,但是，使用堆栈会有什么副作用呢？
Dialogue: 0,0:07:02.34,0:07:07.90,英文,,0,0,0,,to store your sweaters if they're these in this way, as opposed to a queue.
Dialogue: 0,0:07:02.34,0:07:07.90,中文,,0,0,0,,以这种方式存放毛衣，而不是队列。
Dialogue: 0,0:07:07.90,0:07:10.24,英文,,0,0,0,,Yeah?
Dialogue: 0,0:07:07.90,0:07:10.24,中文,,0,0,0,,嗯？
Dialogue: 0,0:07:10.24,0:07:11.72,英文,,0,0,0,,It's harder to get the red and blue ones.
Dialogue: 0,0:07:10.24,0:07:11.72,中文,,0,0,0,,红色的和蓝色的毛衣比较难拿。
Dialogue: 0,0:07:11.72,0:07:16.97,英文,,0,0,0,,So presumably, you're going to much more often wear, for instance, if you will, black instead there.
Dialogue: 0,0:07:11.72,0:07:16.97,中文,,0,0,0,,你可能会更经常穿，比如，黑色的而不是那件。
Dialogue: 0,0:07:16.97,0:07:22.91,英文,,0,0,0,,Now, the operations for adding things to a stack are similar in spirit, but just different vocabulary.
Dialogue: 0,0:07:16.97,0:07:22.91,中文,,0,0,0,,现在，向堆栈添加东西的操作在精神上是相似的，只是词汇不同。
Dialogue: 0,0:07:22.91,0:07:27.52,英文,,0,0,0,,You push something on top of a stack, even though it's more like in the tray world.
Dialogue: 0,0:07:22.91,0:07:27.52,中文,,0,0,0,,你把东西推到堆栈的顶部，即使它更像是在托盘世界里。
Dialogue: 0,0:07:27.52,0:07:28.94,英文,,0,0,0,,You sort of place it or rest it.
Dialogue: 0,0:07:27.52,0:07:28.94,中文,,0,0,0,,你把它放上去或者放上去。
Dialogue: 0,0:07:28.94,0:07:31.56,英文,,0,0,0,,But pushing means adding something to the top of the stack.
Dialogue: 0,0:07:28.94,0:07:31.56,中文,,0,0,0,,但是推入意味着在堆栈的顶部添加一些东西。
Dialogue: 0,0:07:31.56,0:07:36.28,英文,,0,0,0,,And popping means removing something also from the top of the stack.
Dialogue: 0,0:07:31.56,0:07:36.28,中文,,0,0,0,,而弹出意味着从堆栈顶部移除一些东西。
Dialogue: 0,0:07:36.28,0:07:41.45,英文,,0,0,0,,So it's not a matter of enqueuing at the end and dequeuing at the beginning with a stack.
Dialogue: 0,0:07:36.28,0:07:41.45,中文,,0,0,0,,因此，这不是在堆栈末尾入队和在堆栈开头出队的问题。
Dialogue: 0,0:07:41.45,0:07:42.91,英文,,0,0,0,,Everything's happening on top.
Dialogue: 0,0:07:41.45,0:07:42.91,中文,,0,0,0,,所有的事情都发生在顶部。
Dialogue: 0,0:07:42.91,0:07:46.27,英文,,0,0,0,,You're pushing onto the top and then popping off of the top.
Dialogue: 0,0:07:42.91,0:07:46.27,中文,,0,0,0,,你在顶部推入，然后从顶部弹出。
Dialogue: 0,0:07:46.27,0:07:49.37,英文,,0,0,0,,Now, when it comes to actual code, how might we implement something like this?
Dialogue: 0,0:07:46.27,0:07:49.37,中文,,0,0,0,,现在，当涉及到实际代码时，我们如何实现这样的东西呢？
Dialogue: 0,0:07:49.37,0:07:53.26,英文,,0,0,0,,Well, let's just focus on really how you might implement the data structure itself.
Dialogue: 0,0:07:49.37,0:07:53.26,中文,,0,0,0,,好吧，让我们只关注如何实现数据结构本身。
Dialogue: 0,0:07:53.26,0:07:55.02,英文,,0,0,0,,And we won't implement any functions.
Dialogue: 0,0:07:53.26,0:07:55.02,中文,,0,0,0,,我们不会实现任何函数。
Dialogue: 0,0:07:55.02,0:07:57.40,英文,,0,0,0,,You might implement the notion of a stack like this.
Dialogue: 0,0:07:55.02,0:07:57.40,中文,,0,0,0,,你可以像这样实现堆栈的概念。
Dialogue: 0,0:07:57.40,0:07:58.60,英文,,0,0,0,,We've seen typedef before.
Dialogue: 0,0:07:57.40,0:07:58.60,中文,,0,0,0,,我们以前见过 typedef。
Dialogue: 0,0:07:58.60,0:08:01.14,英文,,0,0,0,,It just means define a new type of my own.
Dialogue: 0,0:07:58.60,0:08:01.14,中文,,0,0,0,,这意味着可以自定义一种新类型。
Dialogue: 0,0:08:01.14,0:08:06.96,英文,,0,0,0,,Struct means here comes a structure, a.k.a. a data structure, of one or more variables within.
Dialogue: 0,0:08:01.14,0:08:06.96,中文,,0,0,0,,Struct 表示接下来要定义一个结构体，也就是数据结构，其中包含一个或多个变量。
Dialogue: 0,0:08:06.96,0:08:13.10,英文,,0,0,0,,And let's suppose, like, last time we defined already, like, a person data type using a separate typedef.
Dialogue: 0,0:08:06.96,0:08:13.10,中文,,0,0,0,,假设，就像上次我们已经用单独的 typedef 定义了一个 person 数据类型。
Dialogue: 0,0:08:13.10,0:08:15.90,英文,,0,0,0,,And every person has, like, a name and a number or whatever.
Dialogue: 0,0:08:13.10,0:08:15.90,中文,,0,0,0,,每个人都有姓名和号码之类的信息。
Dialogue: 0,0:08:15.90,0:08:18.55,英文,,0,0,0,,Let me just stipulate that person exists already.
Dialogue: 0,0:08:15.90,0:08:18.55,中文,,0,0,0,,我们假设 person 类型已经存在。
Dialogue: 0,0:08:18.55,0:08:23.27,英文,,0,0,0,,So here you might have, to implement a stack, an array called people.
Dialogue: 0,0:08:18.55,0:08:23.27,中文,,0,0,0,,为了实现一个栈，你可能需要一个名为 people 的数组。
Dialogue: 0,0:08:23.27,0:08:24.43,英文,,0,0,0,,of some capacity.
Dialogue: 0,0:08:23.27,0:08:24.43,中文,,0,0,0,,它有一定的容量。
Dialogue: 0,0:08:24.43,0:08:28.33,英文,,0,0,0,,Maybe it's an array of size 10, or 100, or whatever.
Dialogue: 0,0:08:24.43,0:08:28.33,中文,,0,0,0,,它的大小可能是 10，100 或者其他。
Dialogue: 0,0:08:28.33,0:08:30.97,英文,,0,0,0,,This is a constant here in this context, capacity.
Dialogue: 0,0:08:28.33,0:08:30.97,中文,,0,0,0,,在这个上下文中，capacity 是一个常量。
Dialogue: 0,0:08:30.97,0:08:34.55,英文,,0,0,0,,And every element in that array is a person structure.
Dialogue: 0,0:08:30.97,0:08:34.55,中文,,0,0,0,,数组中的每个元素都是一个 person 结构体。
Dialogue: 0,0:08:34.55,0:08:37.29,英文,,0,0,0,,And I now have this to size.
Dialogue: 0,0:08:34.55,0:08:37.29,中文,,0,0,0,,然后定义 size 变量。
Dialogue: 0,0:08:37.29,0:08:40.20,英文,,0,0,0,,Now, this almost seems like a synonym for capacity.
Dialogue: 0,0:08:37.29,0:08:40.20,中文,,0,0,0,,现在，这看起来像是 capacity 的同义词。
Dialogue: 0,0:08:40.20,0:08:49.64,英文,,0,0,0,,But maybe intuitively, anyone want to propose why I'm apparently maintaining separately the capacity of the stack, but also the size of the stack?
Dialogue: 0,0:08:40.20,0:08:49.64,中文,,0,0,0,,但凭直觉，谁能说说我为什么要分别维护栈的容量和大小？
Dialogue: 0,0:08:49.64,0:08:52.89,英文,,0,0,0,,Why these two distinctions here?
Dialogue: 0,0:08:49.64,0:08:52.89,中文,,0,0,0,,为什么要区分这两个概念？
Dialogue: 0,0:08:52.89,0:08:54.09,英文,,0,0,0,,Yeah.
Dialogue: 0,0:08:52.89,0:08:54.09,中文,,0,0,0,,好。
Dialogue: 0,0:09:02.26,0:09:14.45,英文,,0,0,0,,Perfect, the capacity is how high the stack could be, like how much room is there for those sweatshirts in my closet, for instance, whereas size is just literally, at this moment in time, how many sweatshirts are in the stack.
Dialogue: 0,0:09:02.26,0:09:14.45,中文,,0,0,0,,非常好，capacity 指的是栈的最大高度，比如我的衣柜里有多少空间可以放运动衫，而 size 指的是当前时刻栈里实际有多少件运动衫。
Dialogue: 0,0:09:14.45,0:09:18.33,英文,,0,0,0,,It's either capacity or fewer, presumably, in total there.
Dialogue: 0,0:09:14.45,0:09:18.33,中文,,0,0,0,,它应该小于或等于容量。
Dialogue: 0,0:09:18.33,0:09:19.43,英文,,0,0,0,,So what is capacity?
Dialogue: 0,0:09:18.33,0:09:19.43,中文,,0,0,0,,那么 capacity 是什么呢？
Dialogue: 0,0:09:19.43,0:09:22.38,英文,,0,0,0,,Well, we could implement this in perhaps a familiar way.
Dialogue: 0,0:09:19.43,0:09:22.38,中文,,0,0,0,,我们可以用一种熟悉的方式来实现它。
Dialogue: 0,0:09:22.38,0:09:28.46,英文,,0,0,0,,I might just define a const somewhere else in my code of type int that just defines it to be capacity 50.
Dialogue: 0,0:09:22.38,0:09:28.46,中文,,0,0,0,,我可以在代码的其他地方定义一个类型为 int 的常量 const，并将其赋值为 50。
Dialogue: 0,0:09:28.46,0:09:31.90,英文,,0,0,0,,But what perhaps is going to be the downside of implementing a stack
Dialogue: 0,0:09:28.46,0:09:32.24,中文,,0,0,0,,但这种使用数组实现堆栈的方式有什么缺点呢？
Dialogue: 0,0:09:32.24,0:09:37.11,英文,,0,0,0,,in this way of using an array inside here?
Dialogue: 0,0:09:32.24,0:09:37.11,中文,,0,0,0,,用数组和这个内部的 size 变量来实现堆栈有什么缺点呢？
Dialogue: 0,0:09:37.11,0:09:45.17,英文,,0,0,0,,What's a downside now of implementing a stack using an array and this size variable within?
Dialogue: 0,0:09:37.11,0:09:45.17,中文,,0,0,0,,这里有什么需要注意的地方吗？
Dialogue: 0,0:09:45.17,0:09:48.33,英文,,0,0,0,,What's a caveat here, perhaps?
Dialogue: 0,0:09:45.17,0:09:48.33,中文,,0,0,0,,有什么潜在的问题吗？
Dialogue: 0,0:09:48.33,0:09:48.91,英文,,0,0,0,,Any hands?
Dialogue: 0,0:09:48.33,0:09:48.91,中文,,0,0,0,,谁想回答？
Dialogue: 0,0:09:48.91,0:09:50.05,英文,,0,0,0,,Yeah.
Dialogue: 0,0:09:48.91,0:09:52.42,中文,,0,0,0,,好的。
Dialogue: 0,0:09:52.42,0:09:54.90,英文,,0,0,0,,OK, so it's going to be harder to reach elements that aren't the last one.
Dialogue: 0,0:09:52.42,0:09:54.90,中文,,0,0,0,,访问非最后一个元素会比较困难。
Dialogue: 0,0:09:54.90,0:09:56.74,英文,,0,0,0,,That is, the most recently added ones.
Dialogue: 0,0:09:54.90,0:09:56.74,中文,,0,0,0,,也就是最近添加的元素。
Dialogue: 0,0:09:56.74,0:09:59.60,英文,,0,0,0,,So there could be some sweatshirts, so to speak, way down below.
Dialogue: 0,0:09:56.74,0:09:59.60,中文,,0,0,0,,这么说吧，可能有一些运动衫在最下面。
Dialogue: 0,0:09:59.60,0:10:01.26,英文,,0,0,0,,So we've seen that before, too.
Dialogue: 0,0:09:59.60,0:10:01.26,中文,,0,0,0,,我们以前也见过这种情况。
Dialogue: 0,0:10:01.26,0:10:04.42,英文,,0,0,0,,But at some point, too, a limitation of this design is what?
Dialogue: 0,0:10:01.26,0:10:04.42,中文,,0,0,0,,但这设计的局限性是什么？
Dialogue: 0,0:10:04.42,0:10:05.74,英文,,0,0,0,,It's going to be finite, right?
Dialogue: 0,0:10:04.42,0:10:05.74,中文,,0,0,0,,它将是有限的，对吧？
Dialogue: 0,0:10:05.74,0:10:11.94,英文,,0,0,0,,I can maximally fit, in this example, 50 sweatshirts or 50 emails or 50 cafeteria trays, which is fine.
Dialogue: 0,0:10:05.74,0:10:11.94,中文,,0,0,0,,在这个例子中，我最多可以放 50 件运动衫或 50 封邮件或 50 个餐盘，这没问题。
Dialogue: 0,0:10:11.94,0:10:13.60,英文,,0,0,0,,But at least it's indeed finite.
Dialogue: 0,0:10:11.94,0:10:13.60,中文,,0,0,0,,但它确实是有限的。
Dialogue: 0,0:10:13.60,0:10:20.40,英文,,0,0,0,,And at least in the computer's memory, it might be nice to use more and more and more, maybe as more things are getting added to the computer.
Dialogue: 0,0:10:13.60,0:10:20.40,中文,,0,0,0,,至少在计算机内存中，随着越来越多东西被添加到计算机中，能够使用越来越多的内存可能会很好。
Dialogue: 0,0:10:20.40,0:10:25.13,英文,,0,0,0,,So maybe I make this 500. Or heck, why don't I make it 5,000 or 50,000?
Dialogue: 0,0:10:20.40,0:10:25.13,中文,,0,0,0,,也许我可以把它设为 500。或者，为什么不把它设为 5,000 或 50,000 呢？
Dialogue: 0,0:10:25.13,0:10:26.83,英文,,0,0,0,,Well, what's the trade-off there?
Dialogue: 0,0:10:25.13,0:10:26.83,中文,,0,0,0,,那么，这样做有什么代价呢？
Dialogue: 0,0:10:26.83,0:10:33.61,英文,,0,0,0,,If I want to have enough room to grow, it seems like I should just crank up the value of capacity endlessly.
Dialogue: 0,0:10:26.83,0:10:33.61,中文,,0,0,0,,如果我想要有足够的空间来增长，我应该无休止地增加 capacity 的值。
Dialogue: 0,0:10:33.61,0:10:39.64,英文,,0,0,0,,But why might I not want to change the 50 to 500 or 5,000 or 50,000?
Dialogue: 0,0:10:33.61,0:10:39.64,中文,,0,0,0,,但我为什么不想把 50 改成 500、5,000 或 50,000 呢？
Dialogue: 0,0:10:39.64,0:10:42.76,英文,,0,0,0,,What's the trade-off there, perhaps, just intuitively?
Dialogue: 0,0:10:39.64,0:10:42.76,中文,,0,0,0,,直观地说，这样做的代价是什么？
Dialogue: 0,0:10:42.76,0:10:43.88,英文,,0,0,0,,Yeah?
Dialogue: 0,0:10:42.76,0:10:47.01,中文,,0,0,0,,是吗？
Dialogue: 0,0:10:47.01,0:10:49.59,英文,,0,0,0,,OK, you don't want to touch memory that you're not supposed to be touching.
Dialogue: 0,0:10:47.01,0:10:49.59,中文,,0,0,0,,你不想碰你不应该碰的内存。
Dialogue: 0,0:10:49.59,0:10:54.64,英文,,0,0,0,,And in this case, that wouldn't be a risk, per se, unless you indeed overflow the stack.
Dialogue: 0,0:10:49.59,0:10:54.64,中文,,0,0,0,,在这种情况下，这本身不会有风险，除非你确实造成了堆栈溢出。
Dialogue: 0,0:10:54.64,0:10:58.19,英文,,0,0,0,,But there's a related issue in asking for that much memory.
Dialogue: 0,0:10:54.64,0:10:58.19,中文,,0,0,0,,但是请求这么多内存还有一个相关的问题。
Dialogue: 0,0:10:58.19,0:10:59.25,英文,,0,0,0,,What would another downside be?
Dialogue: 0,0:10:58.19,0:10:59.25,中文,,0,0,0,,另一个缺点是什么？
Dialogue: 0,0:11:06.43,0:11:07.91,英文,,0,0,0,,Yeah, OK, exactly.
Dialogue: 0,0:11:06.43,0:11:07.91,中文,,0,0,0,,对，没错。
Dialogue: 0,0:11:07.91,0:11:16.30,英文,,0,0,0,,So if you've got a capacity of 5,000, but you're only using one of those elements, it's awkward to say it non-technically, which is just to say very, very wasteful, right?
Dialogue: 0,0:11:07.91,0:11:16.30,中文,,0,0,0,,如果你有 5,000 的容量，但你只使用了其中一个元素，用非技术性的语言来描述会很尴尬，也就是说非常非常浪费，对吧？
Dialogue: 0,0:11:16.30,0:11:17.44,英文,,0,0,0,,That's just bad design.
Dialogue: 0,0:11:16.30,0:11:17.44,中文,,0,0,0,,这设计太糟糕了。
Dialogue: 0,0:11:17.44,0:11:23.46,英文,,0,0,0,,It's correct. It will work for up to 5,000 elements. But my gosh, you're wasting 4,999 extra spots.
Dialogue: 0,0:11:17.44,0:11:23.46,中文,,0,0,0,,这确实可以工作，最多可以容纳 5,000 个元素。但是，天哪，你浪费了 4,999 个额外的位置。
Dialogue: 0,0:11:23.46,0:11:31.35,英文,,0,0,0,,That's not going to end well, especially if you're using more data structures in memory, like your Mac, your PC, your phone is surely going to run out of memory if you ask for that much.
Dialogue: 0,0:11:23.46,0:11:31.35,中文,,0,0,0,,这样做不会有好结果的，特别是如果你在内存中使用更多的数据结构，比如你的 Mac、你的 PC，你的手机肯定会因为你请求这么多内存而耗尽内存。
Dialogue: 0,0:11:31.35,0:11:39.25,英文,,0,0,0,,So it'd be nice if there was a bit more dynamism there, whether it's a stack or a queue, both of which might be implemented a little similarly in spirit.
Dialogue: 0,0:11:31.35,0:11:39.25,中文,,0,0,0,,所以如果能有更多动态性就好了，无论是栈还是队列，两者在精神上都可能实现得有点相似。
Dialogue: 0,0:11:39.25,0:11:49.60,英文,,0,0,0,,But let's conclude this abstraction by comparing, thanks to a friend of ours, Professor Shannon Duvall of Elon University, who kindly put together this graphical animation that's just under two minutes long.
Dialogue: 0,0:11:39.25,0:11:49.60,中文,,0,0,0,,但是，让我们以比较来结束这个抽象概念，这要感谢我们的朋友，来自伊隆大学的 Shannon Duvall 教授，他 kindly 制作了这个不到两分钟的图形动画。
Dialogue: 0,0:11:49.60,0:11:52.61,英文,,0,0,0,,that paints a picture of these two types of abstract data structures.
Dialogue: 0,0:11:49.60,0:11:52.61,中文,,0,0,0,,它描绘了这两种抽象数据结构的图像。
Dialogue: 0,0:11:52.61,0:11:59.01,英文,,0,0,0,,And then we'll dive in underneath to how we might implement problems like these, if we could dim the lights dramatically.
Dialogue: 0,0:11:52.61,0:11:59.01,中文,,0,0,0,,然后我们将深入探讨如何实现这类问题，如果我们可以把灯调暗的话。
Dialogue: 0,0:12:04.19,0:12:07.01,英文,,0,0,0,,Once upon a time, there was a guy named Jack.
Dialogue: 0,0:12:04.19,0:12:07.01,中文,,0,0,0,,从前，有一个叫杰克的人。
Dialogue: 0,0:12:07.01,0:12:10.43,英文,,0,0,0,,When it came to making friends, Jack did not have the knack.
Dialogue: 0,0:12:07.01,0:12:10.43,中文,,0,0,0,,说到交朋友，杰克很不擅长。
Dialogue: 0,0:12:10.43,0:12:13.34,英文,,0,0,0,,So Jack went to talk to the most popular guy he knew.
Dialogue: 0,0:12:10.43,0:12:13.34,中文,,0,0,0,,于是杰克去找他认识的最受欢迎的人谈谈。
Dialogue: 0,0:12:13.34,0:12:16.02,英文,,0,0,0,,He went up to Lou and asked, what do I do?
Dialogue: 0,0:12:13.34,0:12:16.02,中文,,0,0,0,,他走到卢面前问，我该怎么办？
Dialogue: 0,0:12:16.02,0:12:18.58,英文,,0,0,0,,Lou saw that his friend was really distressed.
Dialogue: 0,0:12:16.02,0:12:18.58,中文,,0,0,0,,卢看到他的朋友真的很痛苦。
Dialogue: 0,0:12:18.58,0:12:21.04,英文,,0,0,0,,Well, Lou began, just look how you're dressed.
Dialogue: 0,0:12:18.58,0:12:21.04,中文,,0,0,0,,“嗯，”卢开始说，“看看你的穿着”。
Dialogue: 0,0:12:21.04,0:12:23.81,英文,,0,0,0,,Don't you have any clothes with a different look?
Dialogue: 0,0:12:21.04,0:12:23.81,中文,,0,0,0,,你就没有其他款式的衣服吗？
Dialogue: 0,0:12:23.81,0:12:24.89,英文,,0,0,0,,Yes, said Jack.
Dialogue: 0,0:12:23.81,0:12:24.89,中文,,0,0,0,,有啊，Jack 说。
Dialogue: 0,0:12:24.89,0:12:25.95,英文,,0,0,0,,I sure do.
Dialogue: 0,0:12:24.89,0:12:25.95,中文,,0,0,0,,当然有。
Dialogue: 0,0:12:25.95,0:12:28.43,英文,,0,0,0,,Come to my house and I'll show them to you.
Dialogue: 0,0:12:25.95,0:12:28.43,中文,,0,0,0,,去我家，我展示给你看。
Dialogue: 0,0:12:28.43,0:12:34.37,英文,,0,0,0,,So they went off to Jack's and Jack showed Lou the box, where he kept all his shirts and his pants and his socks.
Dialogue: 0,0:12:28.43,0:12:34.37,中文,,0,0,0,,于是他们去了 Jack 家，Jack 给 Lou 看了放着他所有衬衫、裤子和袜子的箱子。
Dialogue: 0,0:12:34.37,0:12:37.44,英文,,0,0,0,,Lou said, I see you have all your clothes in a pile.
Dialogue: 0,0:12:34.37,0:12:37.44,中文,,0,0,0,,Lou 说：我看到你把所有衣服都堆在一起。
Dialogue: 0,0:12:37.44,0:12:40.00,英文,,0,0,0,,Why don't you wear some others once in a while?
Dialogue: 0,0:12:37.44,0:12:40.00,中文,,0,0,0,,你怎么不偶尔穿穿别的衣服呢？
Dialogue: 0,0:12:40.00,0:12:45.88,英文,,0,0,0,,Jack said, well, when I remove clothes and socks, I wash them and put them away in the box.
Dialogue: 0,0:12:40.00,0:12:45.88,中文,,0,0,0,,Jack 说：当我脱掉衣服和袜子时，我会洗干净然后放回箱子里。
Dialogue: 0,0:12:45.88,0:12:48.38,英文,,0,0,0,,Then comes the next morning and up I hop.
Dialogue: 0,0:12:45.88,0:12:48.38,中文,,0,0,0,,然后第二天早上就来了，我起床。
Dialogue: 0,0:12:48.38,0:12:51.59,英文,,0,0,0,,I go to the box and get my clothes off the top.
Dialogue: 0,0:12:48.38,0:12:51.59,中文,,0,0,0,,我会去箱子里，然后从最上面拿衣服。
Dialogue: 0,0:12:51.59,0:12:54.19,英文,,0,0,0,,Lou quickly realized the problem with Jack.
Dialogue: 0,0:12:51.59,0:12:54.19,中文,,0,0,0,,Lou 很快意识到 Jack 的问题了。
Dialogue: 0,0:12:54.19,0:12:57.21,英文,,0,0,0,,He kept clothes, CDs, and books in a stack.
Dialogue: 0,0:12:54.19,0:12:57.21,中文,,0,0,0,,他把衣服、CD 和书都堆放在一起。
Dialogue: 0,0:12:57.21,0:13:02.21,英文,,0,0,0,,When he reached for something to read or to wear, he chose the top book or underwear.
Dialogue: 0,0:12:57.21,0:13:02.21,中文,,0,0,0,,当他想找东西读或穿的时候，他总是选择最上面的书或内衣。
Dialogue: 0,0:13:02.21,0:13:04.61,英文,,0,0,0,,Then when he was done, he would put it right back.
Dialogue: 0,0:13:02.21,0:13:04.61,中文,,0,0,0,,然后当他用完后，他会把它放回原处。
Dialogue: 0,0:13:04.61,0:13:07.15,英文,,0,0,0,,Back it would go, on top of the stack.
Dialogue: 0,0:13:04.61,0:13:07.15,中文,,0,0,0,,把它放回那一堆的最上面。
Dialogue: 0,0:13:07.15,0:13:09.64,英文,,0,0,0,,I know the solution, said a triumphant Lou.
Dialogue: 0,0:13:07.15,0:13:09.64,中文,,0,0,0,,我知道解决办法了，Lou  triumphantly 说。
Dialogue: 0,0:13:09.64,0:13:12.28,英文,,0,0,0,,You need to learn to start using a cue.
Dialogue: 0,0:13:09.64,0:13:12.28,中文,,0,0,0,,你需要学习使用队列。
Dialogue: 0,0:13:12.28,0:13:14.98,英文,,0,0,0,,Lou took Jack's clothes and hung them in the closet.
Dialogue: 0,0:13:12.28,0:13:14.98,中文,,0,0,0,,Lou 拿起 Jack 的衣服，把它们挂进衣橱。
Dialogue: 0,0:13:14.98,0:13:17.80,英文,,0,0,0,,And when he had emptied the box, he just tossed it.
Dialogue: 0,0:13:14.98,0:13:17.80,中文,,0,0,0,,当他清空箱子后，他直接把它扔了。
Dialogue: 0,0:13:17.80,0:13:23.05,英文,,0,0,0,,Then he said, now Jack, at the end of the day, put your clothes on the left when you put them away.
Dialogue: 0,0:13:17.80,0:13:23.05,中文,,0,0,0,,然后他说：现在 Jack，在一天结束的时候，当你把衣服脱下来的时候，把它们放在左边。
Dialogue: 0,0:13:23.05,0:13:28.53,英文,,0,0,0,,Then tomorrow morning when you see the sun shine, get your clothes from the right, from the end of the line.
Dialogue: 0,0:13:23.05,0:13:28.53,中文,,0,0,0,,第二天早上你看到阳光照耀的时候，就从右边，从排尾开始拿衣服。
Dialogue: 0,0:13:28.53,0:13:31.45,英文,,0,0,0,,Don't you see, said Lou, it will be so nice.
Dialogue: 0,0:13:28.53,0:13:31.45,中文,,0,0,0,,卢说，你看，这样多好。
Dialogue: 0,0:13:31.45,0:13:34.88,英文,,0,0,0,,You'll wear everything once before you wear something twice.
Dialogue: 0,0:13:31.45,0:13:34.88,中文,,0,0,0,,每件衣服你都会穿一次，然后再穿第二次。
Dialogue: 0,0:13:34.88,0:13:40.32,英文,,0,0,0,,And with everything in queues in his closet and shelf, Jack started to feel quite sure of himself.
Dialogue: 0,0:13:34.88,0:13:40.32,中文,,0,0,0,,杰克衣柜和架子上的所有东西都排好了队，他开始对自己感到相当自信。
Dialogue: 0,0:13:40.32,0:13:46.00,英文,,0,0,0,,All thanks to Lou and his wonderful queue.
Dialogue: 0,0:13:40.32,0:13:46.00,中文,,0,0,0,,这都要感谢卢和他奇妙的队列。
Dialogue: 0,0:13:46.00,0:13:50.07,英文,,0,0,0,,All right.
Dialogue: 0,0:13:46.00,0:13:50.07,中文,,0,0,0,,好的。
Dialogue: 0,0:13:50.07,0:13:52.85,英文,,0,0,0,,So that paints a picture of these two abstract data structures.
Dialogue: 0,0:13:50.07,0:13:52.85,中文,,0,0,0,,这就描绘了这两种抽象数据结构的图景。
Dialogue: 0,0:13:52.85,0:13:56.70,英文,,0,0,0,,But if we really were to dive underneath the hood, we could implement them in a number of different ways.
Dialogue: 0,0:13:52.85,0:13:56.70,中文,,0,0,0,,但如果我们真的要深入了解内部结构，我们可以用许多不同的方式来实现它们。
Dialogue: 0,0:13:56.70,0:14:01.14,英文,,0,0,0,,But we really, I think, need some building blocks via which we could solve problems like those.
Dialogue: 0,0:13:56.70,0:14:01.14,中文,,0,0,0,,但我认为我们确实需要一些构建块来解决这类问题。
Dialogue: 0,0:14:01.14,0:14:03.14,英文,,0,0,0,,And we'll see today, too, some others as well.
Dialogue: 0,0:14:01.14,0:14:03.14,中文,,0,0,0,,今天我们还会看到其他一些问题。
Dialogue: 0,0:14:03.14,0:14:08.39,英文,,0,0,0,,So let's rewind back to week two, where we introduced you to your very first data structure.
Dialogue: 0,0:14:03.14,0:14:08.39,中文,,0,0,0,,让我们回到第二周，我们向大家介绍了第一个数据结构。
Dialogue: 0,0:14:08.39,0:14:09.45,英文,,0,0,0,,That is an array.
Dialogue: 0,0:14:08.39,0:14:09.45,中文,,0,0,0,,那就是数组。
Dialogue: 0,0:14:09.45,0:14:16.51,英文,,0,0,0,,And an array, recall, was just a chunk of memory whereby elements were stored by design back to back to back.
Dialogue: 0,0:14:09.45,0:14:16.51,中文,,0,0,0,,回想一下，数组只是一块内存，其中的元素按照设计一个接一个地存储。
Dialogue: 0,0:14:16.51,0:14:19.97,英文,,0,0,0,,It's an array of contiguous memory, specifically.
Dialogue: 0,0:14:16.51,0:14:19.97,中文,,0,0,0,,确切地说，它是一块连续的内存。
Dialogue: 0,0:14:19.97,0:14:25.26,英文,,0,0,0,,So with an array, we could certainly store not just one thing, but two or three or even more.
Dialogue: 0,0:14:19.97,0:14:25.26,中文,,0,0,0,,所以使用数组，我们当然可以存储不止一个东西，而是两个、三个甚至更多。
Dialogue: 0,0:14:25.26,0:14:39.70,英文,,0,0,0,,And so for instance, if we treat my computer's memory as this sort of abstraction here, and pictured here are three bytes or some multiplication thereof, suppose we're storing in the computer's memory an array of size 3, storing the digits 1, 2, and 3.
Dialogue: 0,0:14:25.26,0:14:39.70,中文,,0,0,0,,例如，如果我们把我的计算机内存看作是一种抽象概念，\N这里画的是三个字节或其倍数，假设我们在计算机内存中存储一个大小为 3 的数组，存储数字 1、2 和 3。
Dialogue: 0,0:14:39.70,0:14:44.88,英文,,0,0,0,,Well, remember that if we zoom out per last week, there's other stuff going on in memory.
Dialogue: 0,0:14:39.70,0:14:44.88,中文,,0,0,0,,那么请记住，如果我们按照上周的内容放大来看，内存中还有其他东西在运行。
Dialogue: 0,0:14:44.88,0:14:54.25,英文,,0,0,0,,So even if we want to add another number to this array that we didn't think of when we first started the program, like the number 4, ideally, we would put it right here next to it.
Dialogue: 0,0:14:44.88,0:14:54.25,中文,,0,0,0,,因此，即使我们想在这个数组中添加另一个我们在程序开始时没有想到的数字，比如数字 4，理想情况下，我们应该把它放在数字 3 旁边的这里。
Dialogue: 0,0:14:54.25,0:14:55.85,英文,,0,0,0,,Otherwise, it's no longer an array.
Dialogue: 0,0:14:54.25,0:14:55.85,中文,,0,0,0,,否则，它就不再是一个数组了。
Dialogue: 0,0:14:55.85,0:15:00.09,英文,,0,0,0,,So by definition, if we're using an array, it's got to end up right there after the 3.
Dialogue: 0,0:14:55.85,0:15:00.09,中文,,0,0,0,,因此，根据定义，如果我们使用数组，它必须位于数字 3 之后。
Dialogue: 0,0:15:00.09,0:15:02.63,英文,,0,0,0,,But what else is going on inside of your computer's memory?
Dialogue: 0,0:15:00.09,0:15:02.63,中文,,0,0,0,,但是，在你的计算机内存中还发生了什么？
Dialogue: 0,0:15:02.63,0:15:11.40,英文,,0,0,0,,Well, assuming your program is of any length and you've got other variables, other functions, you've been running it for a while, there's a lot going on and your memory is being used and reused.
Dialogue: 0,0:15:02.63,0:15:11.40,中文,,0,0,0,,假设你的程序有一定的长度，并且你还有其他的变量、函数，并且你已经运行了一段时间，内存中会发生很多事情，你的内存正在被使用和重复使用。
Dialogue: 0,0:15:11.40,0:15:26.35,英文,,0,0,0,,So for instance, somewhere in memory might be immediately adjacent to this, like hello, world, backslash 0, the null character, just because maybe you have another variable somewhere in there that is storing that particular string alongside your existing array of size 3.
Dialogue: 0,0:15:11.40,0:15:26.35,中文,,0,0,0,,例如，在内存中的某个地方，可能紧挨着这个，比如 hello, world, \0（空字符），\N仅仅是因为你可能在其中的某个地方有另一个变量，它与你现有的长度为 3 的数组一起存储着特定的字符串。
Dialogue: 0,0:15:26.35,0:15:30.87,英文,,0,0,0,,And all of these Oscar the Grouches here really just represent what we called last week garbage values.
Dialogue: 0,0:15:26.35,0:15:30.87,中文,,0,0,0,,所有这些奥斯卡（Oscar the Grouches）实际上代表了我们上周所说的垃圾值。
Dialogue: 0,0:15:30.87,0:15:33.61,英文,,0,0,0,,Like, there's obviously bits there, because they don't disappear.
Dialogue: 0,0:15:30.87,0:15:33.61,中文,,0,0,0,,就像，那里显然有比特位，因为它们没有消失。
Dialogue: 0,0:15:33.61,0:15:36.74,英文,,0,0,0,,They're always going to be inside of the computer somehow implemented.
Dialogue: 0,0:15:33.61,0:15:36.74,中文,,0,0,0,,它们总是以某种方式在计算机内部实现。
Dialogue: 0,0:15:36.74,0:15:38.66,英文,,0,0,0,,But we don't really know or care what they are.
Dialogue: 0,0:15:36.74,0:15:38.66,中文,,0,0,0,,但我们真的不知道也不关心它们是什么。
Dialogue: 0,0:15:38.66,0:15:44.54,英文,,0,0,0,,They're the remnants of those bytes having been used for other older variables, previous function calls, or the like.
Dialogue: 0,0:15:38.66,0:15:44.54,中文,,0,0,0,,它们是那些字节被用于其他旧变量、以前的函数调用等的残余。
Dialogue: 0,0:15:44.54,0:15:48.89,英文,,0,0,0,,But the problem clearly here is that, OK, 1, 2, 3 is there, but the h is here.
Dialogue: 0,0:15:44.54,0:15:48.89,中文,,0,0,0,,但这里的问题很明显，1、2、3 在那里，但 h 在这里。
Dialogue: 0,0:15:48.89,0:15:57.27,英文,,0,0,0,,And unless I want to start taking a byte out of my string by overriding the h with a 4, like, we just can't fit it right there.
Dialogue: 0,0:15:48.89,0:15:57.27,中文,,0,0,0,,除非我想从我的字符串中取出一个字节，用 4 覆盖 h，就像，我们不能把它放在那里。
Dialogue: 0,0:15:57.27,0:16:00.51,英文,,0,0,0,,And yet, even though there's Oscars all over the place, those are indeed garbage values.
Dialogue: 0,0:15:57.27,0:16:00.51,中文,,0,0,0,,然而，即使到处都是奥斯卡，那些确实是垃圾值。
Dialogue: 0,0:16:00.51,0:16:04.23,英文,,0,0,0,,And therefore, we could use that space, because it's technically unused.
Dialogue: 0,0:16:00.51,0:16:04.23,中文,,0,0,0,,因此，我们可以使用那个空间，因为它在技术上是未使用的。
Dialogue: 0,0:16:04.23,0:16:06.27,英文,,0,0,0,,We just don't know or care what the values are.
Dialogue: 0,0:16:04.23,0:16:06.27,中文,,0,0,0,,我们只是不知道也不关心这些值是什么。
Dialogue: 0,0:16:06.27,0:16:09.02,英文,,0,0,0,,So where could I put 1, 2, 3, 4?
Dialogue: 0,0:16:06.27,0:16:09.02,中文,,0,0,0,,那么，我可以把 1、2、3、4 放在哪里呢？
Dialogue: 0,0:16:09.02,0:16:12.42,英文,,0,0,0,,Well, my gosh, I have all this memory down here that's unused.
Dialogue: 0,0:16:09.02,0:16:12.42,中文,,0,0,0,,我的天哪，我在下面有这么多未使用的内存。
Dialogue: 0,0:16:12.42,0:16:15.48,英文,,0,0,0,,I could certainly change those garbage values to be 1, 2, 3, 4.
Dialogue: 0,0:16:12.42,0:16:15.48,中文,,0,0,0,,我当然可以把这些垃圾值改为 1、2、3、4。
Dialogue: 0,0:16:15.48,0:16:21.70,英文,,0,0,0,,But to do that, I might need to do a bit of work here, right?
Dialogue: 0,0:16:15.48,0:16:21.70,中文,,0,0,0,,但要做到这一点，我可能需要在这里做一些工作，对吧？
Dialogue: 0,0:16:21.70,0:16:25.40,英文,,0,0,0,,It's not just a matter of just saying, boom, and it happens.
Dialogue: 0,0:16:21.70,0:16:25.40,中文,,0,0,0,,这不仅仅是说一声“砰”就能解决的问题。
Dialogue: 0,0:16:25.40,0:16:28.69,英文,,0,0,0,,Now with C and with code, I'd have to do this a little more methodically.
Dialogue: 0,0:16:25.40,0:16:28.69,中文,,0,0,0,,现在使用 C 和代码，我必须更有条理地进行操作。
Dialogue: 0,0:16:28.69,0:16:31.53,英文,,0,0,0,,So let me abstract away everything else that's a distraction.
Dialogue: 0,0:16:28.69,0:16:31.53,中文,,0,0,0,,因此，让我把所有其他的干扰因素都抽象出来。
Dialogue: 0,0:16:31.53,0:16:38.51,英文,,0,0,0,,Let me assume that there is indeed at least four bytes available for four numbers just down here, though we could have put them in a bunch of different spots.
Dialogue: 0,0:16:31.53,0:16:38.51,中文,,0,0,0,,假设在这里确实至少有四个字节可用于存储四个数字，尽管我们可以把它们放在很多不同的位置。
Dialogue: 0,0:16:38.51,0:16:45.62,英文,,0,0,0,,What's involved now in moving the 1, 2, 3 to this new chunk of memory so we can add the 4?
Dialogue: 0,0:16:38.51,0:16:45.62,中文,,0,0,0,,要把 1、2、3 移到这块新的内存区域以便添加 4，需要做什么？
Dialogue: 0,0:16:45.62,0:16:48.54,英文,,0,0,0,,Well, I think conceptually we're going to have to copy the 1.
Dialogue: 0,0:16:45.62,0:16:48.54,中文,,0,0,0,,我认为从概念上讲，我们必须复制数字 1。
Dialogue: 0,0:16:48.54,0:16:49.70,英文,,0,0,0,,From old to new.
Dialogue: 0,0:16:48.54,0:16:49.70,中文,,0,0,0,,从旧位置复制到新位置。
Dialogue: 0,0:16:49.70,0:16:51.22,英文,,0,0,0,,Copy the 2 from old to new.
Dialogue: 0,0:16:49.70,0:16:51.22,中文,,0,0,0,,复制数字 2。
Dialogue: 0,0:16:51.22,0:16:53.14,英文,,0,0,0,,Copy the 3 from old to new.
Dialogue: 0,0:16:51.22,0:16:53.14,中文,,0,0,0,,复制数字 3。
Dialogue: 0,0:16:53.14,0:16:56.08,英文,,0,0,0,,And then ultimately, we can get rid of the old memory.
Dialogue: 0,0:16:53.14,0:16:56.08,中文,,0,0,0,,最终，我们可以释放旧的内存空间。
Dialogue: 0,0:16:56.08,0:17:01.91,英文,,0,0,0,,Those three original bytes could now look like Oscar the Grouch and just be garbage values for all intents and purposes.
Dialogue: 0,0:16:56.08,0:17:01.91,中文,,0,0,0,,这三个原始字节现在可能就像 Oscar the Grouch 一样，变成了毫无意义的垃圾值。
Dialogue: 0,0:17:01.91,0:17:06.83,英文,,0,0,0,,But now I have room for a fourth byte wherein I can put the number 4.
Dialogue: 0,0:17:01.91,0:17:06.83,中文,,0,0,0,,但现在我有空间存储第四个字节，可以把数字 4 放进去。
Dialogue: 0,0:17:06.83,0:17:08.58,英文,,0,0,0,,So this is nice.
Dialogue: 0,0:17:06.83,0:17:08.58,中文,,0,0,0,,这很好。
Dialogue: 0,0:17:08.58,0:17:12.58,英文,,0,0,0,,But what's a downside of this approach?
Dialogue: 0,0:17:08.58,0:17:12.58,中文,,0,0,0,,但这种方法有什么缺点？
Dialogue: 0,0:17:12.58,0:17:23.83,英文,,0,0,0,,What's a downside of solving the problem in this way, where the problem at hand is just to grow the array, so to speak, to increase its size, to fit one or more numbers?
Dialogue: 0,0:17:12.58,0:17:23.83,中文,,0,0,0,,用这种方式解决问题有什么缺点？ 这里的问题仅仅是扩大数组的大小，以便容纳一个或多个数字。
Dialogue: 0,0:17:23.83,0:17:26.93,英文,,0,0,0,,Seems pretty straightforward, but yeah.
Dialogue: 0,0:17:23.83,0:17:26.93,中文,,0,0,0,,看起来很简单，但是...
Dialogue: 0,0:17:32.04,0:17:36.19,英文,,0,0,0,,OK, maybe it's out of order, but I think that's OK, because the order just matters that it's relative.
Dialogue: 0,0:17:32.04,0:17:36.19,中文,,0,0,0,,也许顺序不对，但这没关系，因为顺序只在它们是相对的时候才有意义。
Dialogue: 0,0:17:36.19,0:17:41.17,英文,,0,0,0,,So so long as it's still contiguous, back to back to back in a different chunk of memory, I think we're OK there.
Dialogue: 0,0:17:36.19,0:17:41.17,中文,,0,0,0,,所以只要它们仍然是连续的，在一个不同的内存块中一个接一个，我认为就没问题。
Dialogue: 0,0:17:41.17,0:17:49.11,英文,,0,0,0,,It's not like I changed it for 4, 3, 2, 1, but a reasonable hunch, yeah.
Dialogue: 0,0:17:41.17,0:17:49.11,中文,,0,0,0,,我并没有把它改成 4、3、2、1，但这确实是一个合理的猜测。
Dialogue: 0,0:17:49.11,0:17:51.31,英文,,0,0,0,,Yeah, like, I didn't really plan ahead here.
Dialogue: 0,0:17:49.11,0:17:51.31,中文,,0,0,0,,是的，我没有提前计划。
Dialogue: 0,0:17:51.31,0:17:56.14,英文,,0,0,0,,Like, if I have to add another number, like 5 or anything else, well, I might have to jump through these hoops again.
Dialogue: 0,0:17:51.31,0:17:56.14,中文,,0,0,0,,如果我必须再添加一个数字，比如 5 或其他任何数字，我可能不得不再次重复这些步骤。
Dialogue: 0,0:17:56.14,0:17:58.38,英文,,0,0,0,,Maybe I get lucky, and maybe there's space there.
Dialogue: 0,0:17:56.14,0:17:58.38,中文,,0,0,0,,也许我很幸运，那里正好有空间。
Dialogue: 0,0:17:58.38,0:18:00.83,英文,,0,0,0,,But not if I have other variables and other things going on.
Dialogue: 0,0:17:58.38,0:18:00.83,中文,,0,0,0,,但如果我有其他变量和其他事情要做，就不会这样了。
Dialogue: 0,0:18:00.83,0:18:03.49,英文,,0,0,0,,That, too, might be used at some point.
Dialogue: 0,0:18:00.83,0:18:03.49,中文,,0,0,0,,那一点以后也可能会用到。
Dialogue: 0,0:18:03.49,0:18:04.61,英文,,0,0,0,,Other thoughts?
Dialogue: 0,0:18:03.49,0:18:04.61,中文,,0,0,0,,还有其他想法吗？
Dialogue: 0,0:18:04.61,0:18:06.45,英文,,0,0,0,,Yeah?
Dialogue: 0,0:18:04.61,0:18:06.45,中文,,0,0,0,,有吗？
Dialogue: 0,0:18:06.45,0:18:07.31,英文,,0,0,0,,Slow efficiency.
Dialogue: 0,0:18:06.45,0:18:07.31,中文,,0,0,0,,效率低。
Dialogue: 0,0:18:07.31,0:18:11.34,英文,,0,0,0,,Why?
Dialogue: 0,0:18:07.31,0:18:11.34,中文,,0,0,0,,为什么？
Dialogue: 0,0:18:11.34,0:18:13.82,英文,,0,0,0,,Yeah, I mean, it's just inefficient.
Dialogue: 0,0:18:11.34,0:18:13.82,中文,,0,0,0,,我的意思是，效率很低。
Dialogue: 0,0:18:13.82,0:18:16.42,英文,,0,0,0,,It's sort of bad design, arguably.
Dialogue: 0,0:18:13.82,0:18:16.42,中文,,0,0,0,,可以说，这设计很糟糕。
Dialogue: 0,0:18:16.42,0:18:17.16,英文,,0,0,0,,Why?
Dialogue: 0,0:18:16.42,0:18:17.16,中文,,0,0,0,,为什么？
Dialogue: 0,0:18:17.16,0:18:20.38,英文,,0,0,0,,Because I had to copy all of my original work down here.
Dialogue: 0,0:18:17.16,0:18:20.38,中文,,0,0,0,,因为我必须把之前所有的内容都复制到这里。
Dialogue: 0,0:18:20.38,0:18:27.91,英文,,0,0,0,,And as you note, if I want to add a fifth number, I'm going to have to copy it again and again and again and do things n times again and again.
Dialogue: 0,0:18:20.38,0:18:27.91,中文,,0,0,0,,正如你注意到的，如果我想添加第五个数字，我将不得不一遍又一遍地复制它，并将所有事情重复 n 遍。
Dialogue: 0,0:18:27.91,0:18:29.55,英文,,0,0,0,,Now, maybe that's necessary.
Dialogue: 0,0:18:27.91,0:18:29.55,中文,,0,0,0,,也许这是必要的。
Dialogue: 0,0:18:29.55,0:18:31.21,英文,,0,0,0,,We'll soon see for sure.
Dialogue: 0,0:18:29.55,0:18:31.21,中文,,0,0,0,,我们很快就会知道了。
Dialogue: 0,0:18:31.21,0:18:34.99,英文,,0,0,0,,But it feels like this is not going to end well, especially if the array isn't of size 3 or 4.
Dialogue: 0,0:18:31.21,0:18:34.99,中文,,0,0,0,,但这感觉不太妙，尤其是当数组的大小不是 3 或 4 的时候。
Dialogue: 0,0:18:34.99,0:18:40.47,英文,,0,0,0,,But 300, 400, your computer ends up spending so much time just spinning its wheels.
Dialogue: 0,0:18:34.99,0:18:40.47,中文,,0,0,0,,而是 300、400，你的计算机最终会花费大量时间在原地打转。
Dialogue: 0,0:18:40.47,0:18:48.02,英文,,0,0,0,,I mean, honestly, better might be this. Like, if this is my same array, physically incarnated now, 1, 2, 3, it's literally on the edge of the shelf.
Dialogue: 0,0:18:40.47,0:18:48.02,中文,,0,0,0,,我的意思是，说实话，这样可能会更好。就像，如果这是我的同一个数组，现在以实体形式出现，1、2、3，它实际上就在架子的边缘。
Dialogue: 0,0:18:48.02,0:18:50.92,英文,,0,0,0,,So there's no room for the number 4.
Dialogue: 0,0:18:48.02,0:18:50.92,中文,,0,0,0,,所以没有地方放数字 4 了。
Dialogue: 0,0:18:50.92,0:18:53.12,英文,,0,0,0,,Maybe where we could take this story is,
Dialogue: 0,0:18:50.92,0:18:53.12,中文,,0,0,0,,也许我们可以这样想，
Dialogue: 0,0:18:53.12,0:18:55.30,英文,,0,0,0,,Well, let's just find room for the 4.
Dialogue: 0,0:18:53.12,0:18:55.30,中文,,0,0,0,,让我们为 4 腾出空间。
Dialogue: 0,0:18:55.30,0:19:01.95,英文,,0,0,0,,Let's just put the 4, for instance, over here, replacing some available garbage value, some spare byte over here.
Dialogue: 0,0:18:55.30,0:19:01.95,中文,,0,0,0,,例如，让我们把 4 放在这里，替换掉一些可用的垃圾值，这里的一些空闲字节。
Dialogue: 0,0:19:01.95,0:19:03.27,英文,,0,0,0,,But now, wait a minute.
Dialogue: 0,0:19:01.95,0:19:03.27,中文,,0,0,0,,但是现在，等等。
Dialogue: 0,0:19:03.27,0:19:06.13,英文,,0,0,0,,I've broken the definition of an array, right?
Dialogue: 0,0:19:03.27,0:19:06.13,中文,,0,0,0,,我打破了数组的定义，对吧？
Dialogue: 0,0:19:06.13,0:19:08.65,英文,,0,0,0,,I can't have 1, 2, 3, and then 4 over here.
Dialogue: 0,0:19:06.13,0:19:08.65,中文,,0,0,0,,我不能有 1、2、3，然后这边是 4。
Dialogue: 0,0:19:08.65,0:19:15.87,英文,,0,0,0,,So maybe there could be a mechanism, if I put this thing on again, where when you get to the end of the existing elements, maybe I just sum it up.
Dialogue: 0,0:19:08.65,0:19:15.87,中文,,0,0,0,,所以也许可以有一种机制，如果我再把这个东西放上去，当你到达现有元素的末尾时，也许我只是把它加起来。
Dialogue: 0,0:19:15.87,0:19:19.12,英文,,0,0,0,,Somehow, digitally, point to the fourth array.
Dialogue: 0,0:19:15.87,0:19:19.12,中文,,0,0,0,,以某种方式，以数字方式指向第四个数组。
Dialogue: 0,0:19:19.12,0:19:33.90,英文,,0,0,0,,And maybe we can kind of stitch together all of these different values in memory so that if you follow the arrows, so to speak, we can reconstruct exactly what the order is, even without having to find or make room here or pick up all of these numbers and move all of them over there.
Dialogue: 0,0:19:19.12,0:19:33.90,中文,,0,0,0,,也许我们可以把内存中所有这些不同的值拼接在一起，这样，如果你顺着箭头走，\N可以说，我们可以准确地重建顺序，即使不必在这里查找或腾出空间，也不必把所有这些数字都搬到那里。
Dialogue: 0,0:19:33.90,0:19:36.55,英文,,0,0,0,,So that's perhaps the direction in which we'll go here.
Dialogue: 0,0:19:33.90,0:19:36.55,中文,,0,0,0,,所以这也许就是我们将在这里前进的方向。
Dialogue: 0,0:19:36.55,0:19:41.15,英文,,0,0,0,,So let's see how we might get to that spot as follows.
Dialogue: 0,0:19:36.55,0:19:41.15,中文,,0,0,0,,那么，让我们看看如何到达那个位置。
Dialogue: 0,0:19:41.15,0:19:43.85,英文,,0,0,0,,Let me go ahead and open up, say, VS Code here.
Dialogue: 0,0:19:41.15,0:19:43.85,中文,,0,0,0,,让我继续打开 VS Code。
Dialogue: 0,0:19:43.85,0:19:48.21,英文,,0,0,0,,Let me open up a program called list.c in my terminal.
Dialogue: 0,0:19:43.85,0:19:48.21,中文,,0,0,0,,让我在我的终端中打开一个名为 list.c 的程序。
Dialogue: 0,0:19:48.21,0:19:56.40,英文,,0,0,0,,And let me go ahead and whip up a relatively simple program that just demonstrates what we did back in week two when we introduced arrays as follows.
Dialogue: 0,0:19:48.21,0:19:56.40,中文,,0,0,0,,让我快速完成一个相对简单的程序，它演示了我们在第二周引入数组时所做的事情。
Dialogue: 0,0:19:56.40,0:20:00.74,英文,,0,0,0,,Let me include standard io.h so we can print stuff out.
Dialogue: 0,0:19:56.40,0:20:00.74,中文,,0,0,0,,让我包含 standard io.h，这样我们就可以打印出东西了。
Dialogue: 0,0:20:00.74,0:20:04.46,英文,,0,0,0,,Let me do int main void, no command line arguments for now.
Dialogue: 0,0:20:00.74,0:20:04.46,中文,,0,0,0,,让我做 int main void，现在没有命令行参数。
Dialogue: 0,0:20:04.46,0:20:07.52,英文,,0,0,0,,Let me give myself an array.
Dialogue: 0,0:20:04.46,0:20:07.52,中文,,0,0,0,,让我给自己一个数组。
Dialogue: 0,0:20:07.52,0:20:10.13,英文,,0,0,0,,It's called list of size 3.
Dialogue: 0,0:20:07.52,0:20:10.13,中文,,0,0,0,,它叫做 list，大小为 3。
Dialogue: 0,0:20:10.13,0:20:14.61,英文,,0,0,0,,And I'll just hard code it to keep it simple for lecture's sake, each of which is going to be an integer.
Dialogue: 0,0:20:10.13,0:20:14.61,中文,,0,0,0,,为了便于讲解，我将对它进行硬编码，每个都是一个整数。
Dialogue: 0,0:20:14.61,0:20:23.62,英文,,0,0,0,,And now, just so we have some specifics to talk about, let me put it list bracket 0, the number 1, list bracket 1, the number 2, and list bracket 2, the number 3.
Dialogue: 0,0:20:14.61,0:20:23.62,中文,,0,0,0,,现在，为了让我们有一些具体的例子来讨论，让我把它放在 list[0]，数字 1，list[1]，数字 2，和 list[2]，数字 3。
Dialogue: 0,0:20:23.62,0:20:30.88,英文,,0,0,0,,So I'm just translating into code what we just had pictorially on the screen and also physically here with these numbers on the desk.
Dialogue: 0,0:20:23.62,0:20:30.88,中文,,0,0,0,,所以我只是将我们在屏幕上和桌子上用这些数字描绘的内容翻译成代码。
Dialogue: 0,0:20:30.88,0:20:33.46,英文,,0,0,0,,Now, let's just do something mildly useful for this.
Dialogue: 0,0:20:30.88,0:20:33.46,中文,,0,0,0,,现在，让我们为它做一些稍微有用的事情。
Dialogue: 0,0:20:33.46,0:20:38.87,英文,,0,0,0,,How about we do for int i gets 0, i is less than 3, i plus plus.
Dialogue: 0,0:20:33.46,0:20:38.87,中文,,0,0,0,,我们来做 int i = 0，i < 3，i++。
Dialogue: 0,0:20:38.87,0:20:43.11,英文,,0,0,0,,Let's just print each of these numbers out just to make sure they're indeed in memory as I intended.
Dialogue: 0,0:20:38.87,0:20:43.11,中文,,0,0,0,,让我们把这些数字都打印出来，以确保它们确实按照我的意图存储在内存中。
Dialogue: 0,0:20:43.11,0:20:47.37,英文,,0,0,0,,So %i backslash n comma i and then a semicolon.
Dialogue: 0,0:20:43.11,0:20:47.37,中文,,0,0,0,,%i 反斜杠 n 逗号 i 然后一个分号。
Dialogue: 0,0:20:47.37,0:20:48.67,英文,,0,0,0,,And I think that's it for now.
Dialogue: 0,0:20:47.37,0:20:48.67,中文,,0,0,0,,我认为现在就这些了。
Dialogue: 0,0:20:48.67,0:20:53.30,英文,,0,0,0,,So nothing interesting, no problem solved just yet, just a proof of concept so that now,
Dialogue: 0,0:20:48.67,0:20:53.30,中文,,0,0,0,,所以没什么有趣的，目前还没有解决任何问题，只是一个概念证明，所以现在，
Dialogue: 0,0:20:53.30,0:20:59.08,英文,,0,0,0,,When I clear my terminal and run make list, no apparent errors at the terminal.
Dialogue: 0,0:20:53.30,0:20:59.08,中文,,0,0,0,,当我清空终端并运行 make list 时，终端上没有明显的错误。
Dialogue: 0,0:20:59.08,0:21:04.43,英文,,0,0,0,,And so when I now do dot slash list, I should see, hopefully, from left to right, 1, 2, 3.
Dialogue: 0,0:20:59.08,0:21:04.43,中文,,0,0,0,,当我执行 ./list 时，我应该会看到，希望从左到右，1、2、3。
Dialogue: 0,0:21:04.43,0:21:10.97,英文,,0,0,0,,But of course, if I want to add a fourth number now, there's no mechanism for such, certainly in the code that I just wrote.
Dialogue: 0,0:21:04.43,0:21:10.97,中文,,0,0,0,,但是，当然，如果我现在想添加第四个数字，在我的代码中肯定没有这样的机制。
Dialogue: 0,0:21:10.97,0:21:14.22,英文,,0,0,0,,I could go back in here and change this to a 4.
Dialogue: 0,0:21:10.97,0:21:14.22,中文,,0,0,0,,我可以回到这里，把它改成 4。
Dialogue: 0,0:21:14.22,0:21:17.78,英文,,0,0,0,,I could go down here and change lists, bracket 3 equals 4.
Dialogue: 0,0:21:14.22,0:21:17.78,中文,,0,0,0,,我可以往下走，把 lists 改成 bracket 3 等于 4。
Dialogue: 0,0:21:17.78,0:21:21.29,英文,,0,0,0,,I could just manually change the code, recompile the code.
Dialogue: 0,0:21:17.78,0:21:21.29,中文,,0,0,0,,我可以手动更改代码，重新编译代码。
Dialogue: 0,0:21:21.29,0:21:24.97,英文,,0,0,0,,But of course, that doesn't give me any additional runway for the fifth or sixth number.
Dialogue: 0,0:21:21.29,0:21:24.97,中文,,0,0,0,,但是，当然，这并不能为我提供添加第五个或第六个数的任何额外空间。
Dialogue: 0,0:21:24.97,0:21:29.56,英文,,0,0,0,,So let me try to take a different approach, drawing some inspiration from last week.
Dialogue: 0,0:21:24.97,0:21:29.56,中文,,0,0,0,,让我试着从上周的课程中汲取灵感，采取不同的方法。
Dialogue: 0,0:21:29.56,0:21:42.61,英文,,0,0,0,,If I want to allocate memory dynamically, maybe because I don't know when I wrote the program how many bytes I want, we have another function as of last week that does not require that you commit in advance to a certain number of bytes.
Dialogue: 0,0:21:29.56,0:21:42.61,中文,,0,0,0,,如果我想动态分配内存，可能是因为我在编写程序时\N不知道我想要多少字节，从上周开始，我们就有另一个函数，它不需要你预先确定一定数量的字节。
Dialogue: 0,0:21:42.61,0:21:46.87,英文,,0,0,0,,Via what function can you just ask the operating system for a chunk of memory?
Dialogue: 0,0:21:42.61,0:21:46.87,中文,,0,0,0,,通过哪个函数，你可以直接向操作系统请求一块内存？
Dialogue: 0,0:21:46.87,0:21:49.15,英文,,0,0,0,,OK, so malloc, to allocate memory.
Dialogue: 0,0:21:46.87,0:21:49.15,中文,,0,0,0,,所以是 malloc，用来分配内存。
Dialogue: 0,0:21:49.15,0:21:51.29,英文,,0,0,0,,Now, an array is just a chunk of memory.
Dialogue: 0,0:21:49.15,0:21:51.29,中文,,0,0,0,,现在，数组只是一块内存。
Dialogue: 0,0:21:51.29,0:22:04.96,英文,,0,0,0,,And even though, since week two, we've been using this syntactic sugar, this convenience of just using square brackets and indexing into it, it's just making it easier to manipulate a chunk of memory that's contiguous, all together, back to back to back.
Dialogue: 0,0:21:51.29,0:22:04.96,中文,,0,0,0,,尽管从第二周开始，我们就一直在使用这种语法糖，\N这种使用方括号和索引的便利性，但这只是为了更容易地操作一块连续的内存，所有的内存都连在一起，一个接一个。
Dialogue: 0,0:22:04.96,0:22:11.70,英文,,0,0,0,,So today, just like last week, we can take those sort of training wheels off and maybe be a little more deliberate in how we allocate memory.
Dialogue: 0,0:22:04.96,0:22:11.70,中文,,0,0,0,,今天，就像上周一样，我们可以把这些辅助轮拆掉，也许在我们如何分配内存方面更加谨慎一些。
Dialogue: 0,0:22:11.70,0:22:14.14,英文,,0,0,0,,Let me go, for instance, and do this.
Dialogue: 0,0:22:11.70,0:22:14.14,中文,,0,0,0,,例如，让我去这样做。
Dialogue: 0,0:22:14.14,0:22:26.73,英文,,0,0,0,,Let me delete my contents of my main function here, go back into main, and let me propose now that I declare, for instance, how about my list no longer as an array, but as a pointer?
Dialogue: 0,0:22:14.14,0:22:26.73,中文,,0,0,0,,让我删除 main 函数的内容，回到 main 函数，现在我建议将 my list 声明为一个指针，而不是数组。
Dialogue: 0,0:22:26.73,0:22:31.83,英文,,0,0,0,,So int star list, and I'm going to go ahead and initialize this.
Dialogue: 0,0:22:26.73,0:22:31.83,中文,,0,0,0,,所以是 int 星号 list，我要继续初始化它。
Dialogue: 0,0:22:31.83,0:22:34.75,英文,,0,0,0,,to be, how about a chunk of three integers for now?
Dialogue: 0,0:22:31.83,0:22:34.75,中文,,0,0,0,,先来分配三个整数的空间怎么样？
Dialogue: 0,0:22:34.75,0:22:38.91,英文,,0,0,0,,So I'm still going to hard code it, but I'm taking a step toward more dynamism for now.
Dialogue: 0,0:22:34.75,0:22:38.91,中文,,0,0,0,,我还是会硬编码，但现在朝着更有动态性的方向迈进了一步。
Dialogue: 0,0:22:38.91,0:22:45.23,英文,,0,0,0,,So let me allocate 3 times whatever the size is of an int, but it's usually going to be 4 bytes, as we know.
Dialogue: 0,0:22:38.91,0:22:45.23,中文,,0,0,0,,让我分配三倍于 int 大小的空间，我们知道它通常是 4 个字节。
Dialogue: 0,0:22:45.23,0:22:49.61,英文,,0,0,0,,So this is really going to be 3 times 4 equals 12, but it's a little more dynamic.
Dialogue: 0,0:22:45.23,0:22:49.61,中文,,0,0,0,,所以这实际上是 3 乘以 4 等于 12，但它更有动态性。
Dialogue: 0,0:22:49.61,0:22:51.59,英文,,0,0,0,,And now, what can I do down here?
Dialogue: 0,0:22:49.61,0:22:51.59,中文,,0,0,0,,现在，我可以做什么？
Dialogue: 0,0:22:51.59,0:22:53.35,英文,,0,0,0,,Well, this is just a chunk of memory.
Dialogue: 0,0:22:51.59,0:22:53.35,中文,,0,0,0,,这只是一块内存。
Dialogue: 0,0:22:53.35,0:23:07.27,英文,,0,0,0,,So I can do literally list bracket 0 equals 1, list bracket 1 equals 2, list bracket 2 equals 3, and voila, achieve the exact same effect.
Dialogue: 0,0:22:53.35,0:23:07.27,中文,,0,0,0,,所以我可以直接写 `list[0] = 1`，`list[1] = 2`，`list[2] = 3`，瞧，实现了完全相同的效果。
Dialogue: 0,0:23:07.27,0:23:17.00,英文,,0,0,0,,Because again, an array is just a chunk of contiguous memory, but Matlock gives you Any old chunk of contiguous memory, so you can rather treat one like the other here.
Dialogue: 0,0:23:07.27,0:23:17.00,中文,,0,0,0,,因为数组只是一块连续的内存，而 malloc 给了你任意一块连续的内存，所以你可以把它们视为一体。
Dialogue: 0,0:23:17.00,0:23:20.44,英文,,0,0,0,,Now, if you really want to be cool, you could do something like this instead.
Dialogue: 0,0:23:17.00,0:23:20.44,中文,,0,0,0,,现在，如果你真的想炫酷一点，你可以这样做。
Dialogue: 0,0:23:20.44,0:23:24.51,英文,,0,0,0,,You could dereference the address in list and go there.
Dialogue: 0,0:23:20.44,0:23:24.51,中文,,0,0,0,,你可以解引用 list 中的地址并访问它。
Dialogue: 0,0:23:24.51,0:23:29.11,英文,,0,0,0,,You could go down here and dereference list plus 1 and go there.
Dialogue: 0,0:23:24.51,0:23:29.11,中文,,0,0,0,,你可以解引用 `list + 1` 并访问它。
Dialogue: 0,0:23:29.11,0:23:31.23,英文,,0,0,0,,But honestly, no one really writes code like this.
Dialogue: 0,0:23:29.11,0:23:31.23,中文,,0,0,0,,但老实说，没有人真的这样写代码。
Dialogue: 0,0:23:31.23,0:23:32.39,英文,,0,0,0,,It's just too cryptic.
Dialogue: 0,0:23:31.23,0:23:32.39,中文,,0,0,0,,这太难懂了。
Dialogue: 0,0:23:32.39,0:23:35.07,英文,,0,0,0,,It's a little too far over the line, at least for most people.
Dialogue: 0,0:23:32.39,0:23:35.07,中文,,0,0,0,,至少对大多数人来说有点过分了。
Dialogue: 0,0:23:35.07,0:23:46.94,英文,,0,0,0,,And so I think the syntactic sugar, as I keep describing it, just the more user-friendly square bracket notation does the exact same thing, figures out the pointer arithmetic, and puts each of these integers in the right chunks therein.
Dialogue: 0,0:23:35.07,0:23:46.94,中文,,0,0,0,,我认为这种语法糖，就像我一直描述的那样，只是更用户友好的方括号表示法，它完成了指针运算，并将每个整数放入其中正确的块中。
Dialogue: 0,0:23:46.94,0:23:50.86,英文,,0,0,0,,Now, just to be super pedantic, let me make sure if something went wrong.
Dialogue: 0,0:23:46.94,0:23:50.86,中文,,0,0,0,,现在，为了严谨起见，让我确保没有出错。
Dialogue: 0,0:23:50.86,0:23:58.33,英文,,0,0,0,,So if list equals equals null, that means that something went wrong, like my computer is out of memory, which we should check for, typically.
Dialogue: 0,0:23:50.86,0:23:58.33,中文,,0,0,0,,如果 `list == NULL`，这意味着出现了问题，比如我的电脑内存不足，我们通常应该检查一下。
Dialogue: 0,0:23:58.33,0:24:06.57,英文,,0,0,0,,So let me just immediately return 1, signaling anything other than 0, which means success, typically, just to get out of this program because something's wrong.
Dialogue: 0,0:23:58.33,0:24:06.57,中文,,0,0,0,,让我直接返回 1，表示除了 0 以外的任何值，0 通常表示成功，只是为了退出这个程序，因为出现了错误。
Dialogue: 0,0:24:06.57,0:24:08.45,英文,,0,0,0,,But now let me propose.
Dialogue: 0,0:24:06.57,0:24:08.45,中文,,0,0,0,,现在让我假设。
Dialogue: 0,0:24:08.45,0:24:10.73,英文,,0,0,0,,That I've had a, well, let's do this.
Dialogue: 0,0:24:08.45,0:24:10.73,中文,,0,0,0,,我已经有了一个，我们这样做吧。
Dialogue: 0,0:24:10.73,0:24:19.54,英文,,0,0,0,,For int i gets 0, i less than 3, i plus plus, though a better design would always be to use a const, but I'm just doing this for demonstration's sake.
Dialogue: 0,0:24:10.73,0:24:19.54,中文,,0,0,0,,对于 int i = 0, i < 3, i++，虽然更好的设计总是使用 const，但我这样做只是为了演示。
Dialogue: 0,0:24:19.54,0:24:23.74,英文,,0,0,0,,Let's print out each of these ints, too, and just make sure I didn't mess anything up.
Dialogue: 0,0:24:19.54,0:24:23.74,中文,,0,0,0,,我们也打印出每个 int，确保我没有搞砸。
Dialogue: 0,0:24:23.74,0:24:26.22,英文,,0,0,0,,And let me open my terminal window again.
Dialogue: 0,0:24:23.74,0:24:26.22,中文,,0,0,0,,让我再次打开终端窗口。
Dialogue: 0,0:24:26.22,0:24:28.82,英文,,0,0,0,,Let me do make list again.
Dialogue: 0,0:24:26.22,0:24:28.82,中文,,0,0,0,,让我再做一次 make list。
Dialogue: 0,0:24:28.82,0:24:29.54,英文,,0,0,0,,OK.
Dialogue: 0,0:24:28.82,0:24:29.54,中文,,0,0,0,,好的。
Dialogue: 0,0:24:29.54,0:24:30.44,英文,,0,0,0,,Huh.
Dialogue: 0,0:24:29.54,0:24:30.44,中文,,0,0,0,,嗯。
Dialogue: 0,0:24:30.44,0:24:39.75,英文,,0,0,0,,Implicitly declaring library function malloc with type void star something something implicitly declaring is the operative words there.
Dialogue: 0,0:24:30.44,0:24:39.75,中文,,0,0,0,,隐式声明库函数 malloc，类型为 void * 等等，隐式声明是这里的关键词。
Dialogue: 0,0:24:39.75,0:24:44.05,英文,,0,0,0,,What did I mess up?
Dialogue: 0,0:24:39.75,0:24:44.05,中文,,0,0,0,,我搞砸了什么？
Dialogue: 0,0:24:44.05,0:24:47.06,英文,,0,0,0,,Yeah, I forgot the header file in which malloc is declared.
Dialogue: 0,0:24:44.05,0:24:47.06,中文,,0,0,0,,是的，我忘了 malloc 声明所在的头文件。
Dialogue: 0,0:24:47.06,0:24:50.10,英文,,0,0,0,,I remember now, OK, that's in standard lib.h.
Dialogue: 0,0:24:47.06,0:24:50.10,中文,,0,0,0,,我现在想起来了，在 stdlib.h 中。
Dialogue: 0,0:24:50.10,0:24:52.54,英文,,0,0,0,,And it's fine to look stuff like that up if you forget.
Dialogue: 0,0:24:50.10,0:24:52.54,中文,,0,0,0,,如果你忘了，可以查阅这类资料。
Dialogue: 0,0:24:52.54,0:24:55.26,英文,,0,0,0,,So let me include standard lib.h.
Dialogue: 0,0:24:52.54,0:24:55.26,中文,,0,0,0,,让我包含 stdlib.h。
Dialogue: 0,0:24:55.26,0:24:58.84,英文,,0,0,0,,Now, let me clear my terminal, run make list again.
Dialogue: 0,0:24:55.26,0:24:58.84,中文,,0,0,0,,现在，让我清除终端，再次运行 make list。
Dialogue: 0,0:24:58.84,0:25:01.07,英文,,0,0,0,,OK, now we're good, .slash list.
Dialogue: 0,0:24:58.84,0:25:01.07,中文,,0,0,0,,现在可以了，./list。
Dialogue: 0,0:25:01.07,0:25:07.85,英文,,0,0,0,,And now, what did I do wrong?
Dialogue: 0,0:25:01.07,0:25:07.85,中文,,0,0,0,,现在，我做错了什么？
Dialogue: 0,0:25:07.85,0:25:10.83,英文,,0,0,0,,Oh, OK, not intended, but teachable moment.
Dialogue: 0,0:25:07.85,0:25:10.83,中文,,0,0,0,,不是故意的，但这是一个可教的时刻。
Dialogue: 0,0:25:10.83,0:25:15.30,英文,,0,0,0,,What did I do wrong?
Dialogue: 0,0:25:10.83,0:25:15.30,中文,,0,0,0,,我做错了什么？
Dialogue: 0,0:25:15.30,0:25:20.00,英文,,0,0,0,,Yeah, I'm printing the values of i instead of what is at location i in the array.
Dialogue: 0,0:25:15.30,0:25:20.00,中文,,0,0,0,,是的，我在打印 i 的值，而不是数组中位置 i 的值。
Dialogue: 0,0:25:20.00,0:25:22.44,英文,,0,0,0,,So what I actually meant to do was print this out.
Dialogue: 0,0:25:20.00,0:25:22.44,中文,,0,0,0,,所以我实际想做的是打印出来。
Dialogue: 0,0:25:22.44,0:25:22.90,英文,,0,0,0,,Thank you.
Dialogue: 0,0:25:22.44,0:25:22.90,中文,,0,0,0,,谢谢。
Dialogue: 0,0:25:22.90,0:25:26.31,英文,,0,0,0,,So now let me recompile, make list, dot slash list.
Dialogue: 0,0:25:22.90,0:25:26.31,中文,,0,0,0,,现在我重新编译，make list，./list
Dialogue: 0,0:25:26.31,0:25:30.75,英文,,0,0,0,,And now, OK, those are the three values I was expecting, not the indices thereof.
Dialogue: 0,0:25:26.31,0:25:30.75,中文,,0,0,0,,现在，这正是我预期的三个值，而不是它们的索引。
Dialogue: 0,0:25:30.75,0:25:38.20,英文,,0,0,0,,Now, let me propose that, for the sake of discussion, that I regret having only allocated space for three integers.
Dialogue: 0,0:25:30.75,0:25:38.20,中文,,0,0,0,,现在，为了讨论方便，我提出我后悔只分配了三个整数的空间。
Dialogue: 0,0:25:38.20,0:25:41.40,英文,,0,0,0,,And maybe I really should have allocated enough space for four.
Dialogue: 0,0:25:38.20,0:25:41.40,中文,,0,0,0,,也许我应该分配足够四个的空间。
Dialogue: 0,0:25:41.40,0:25:46.95,英文,,0,0,0,,Now, this is not how you would do this in practice, because presumably, if you have a change of thought, just go back in and correct the code.
Dialogue: 0,0:25:41.40,0:25:46.95,中文,,0,0,0,,实际上，你不会这样做的，因为如果你改变了想法，可以直接回去修改代码。
Dialogue: 0,0:25:46.95,0:25:52.09,英文,,0,0,0,,But let me propose that somewhere in here is a more complicated program and time passes, dot, dot, dot.
Dialogue: 0,0:25:46.95,0:25:52.09,中文,,0,0,0,,但假设这里有个更复杂的程序，时间流逝.....
Dialogue: 0,0:25:52.09,0:25:54.25,英文,,0,0,0,,There's a lot of other interesting code there.
Dialogue: 0,0:25:52.09,0:25:54.25,中文,,0,0,0,,那里还有很多其他有趣的代码。
Dialogue: 0,0:25:54.25,0:25:57.51,英文,,0,0,0,,But at some point, I might want to give myself more memory.
Dialogue: 0,0:25:54.25,0:25:57.51,中文,,0,0,0,,但有时，我可能想给自己更多内存。
Dialogue: 0,0:25:57.51,0:25:58.77,英文,,0,0,0,,So how can I do this?
Dialogue: 0,0:25:57.51,0:25:58.77,中文,,0,0,0,,那我该怎么做？
Dialogue: 0,0:25:58.77,0:26:10.46,英文,,0,0,0,,Well, let me just ask the operating system now for four new bytes of memory so that we can, at least in version 1, implement the idea on the board where I just copied the three bytes into the new four bytes and then added a fourth value.
Dialogue: 0,0:25:58.77,0:26:10.46,中文,,0,0,0,,让我现在就向操作系统请求四个新的字节内存，\N这样我们至少可以在版本 1 中实现黑板上的想法，将三个字节复制到新的四个字节中，然后添加第四个值。
Dialogue: 0,0:26:10.46,0:26:12.04,英文,,0,0,0,,So I'm going to use malloc again.
Dialogue: 0,0:26:10.46,0:26:12.04,中文,,0,0,0,,我会再次使用 malloc。
Dialogue: 0,0:26:12.04,0:26:14.98,英文,,0,0,0,,And I'm going to say, here's a new pointer. I'll call it temp.
Dialogue: 0,0:26:12.04,0:26:14.98,中文,,0,0,0,,我要说，这是一个新的指针。我叫它 temp。
Dialogue: 0,0:26:14.98,0:26:18.94,英文,,0,0,0,,TMP for short, which is quite common when you just need it briefly.
Dialogue: 0,0:26:14.98,0:26:18.94,中文,,0,0,0,,tmp 是简写，当你只需要它一小段时间时，这很常见。
Dialogue: 0,0:26:18.94,0:26:20.76,英文,,0,0,0,,I'm going to then call malloc again.
Dialogue: 0,0:26:18.94,0:26:20.76,中文,,0,0,0,,我要再次调用 malloc。
Dialogue: 0,0:26:20.76,0:26:24.94,英文,,0,0,0,,I'm going to say give me four integers using sizeof.
Dialogue: 0,0:26:20.76,0:26:24.94,中文,,0,0,0,,我要说用 sizeof 给我四个整数。
Dialogue: 0,0:26:24.94,0:26:26.10,英文,,0,0,0,,Let me again make sure.
Dialogue: 0,0:26:24.94,0:26:26.10,中文,,0,0,0,,让我再次确认一下。
Dialogue: 0,0:26:26.10,0:26:30.33,英文,,0,0,0,,So if temp equals equals null, something went wrong.
Dialogue: 0,0:26:26.10,0:26:30.33,中文,,0,0,0,,如果 tmp == NULL，那就是出错了。
Dialogue: 0,0:26:30.33,0:26:32.27,英文,,0,0,0,,So let me just immediately return 1.
Dialogue: 0,0:26:30.33,0:26:32.27,中文,,0,0,0,,我直接返回 1。
Dialogue: 0,0:26:32.27,0:26:35.69,英文,,0,0,0,,And for good measure, before I return 1,
Dialogue: 0,0:26:32.27,0:26:35.69,中文,,0,0,0,,为了稳妥起见，在我返回 1 之前，
Dialogue: 0,0:26:35.69,0:26:39.37,英文,,0,0,0,,Let me free the original list so that I don't leak memory.
Dialogue: 0,0:26:35.69,0:26:39.37,中文,,0,0,0,,让我释放原始列表，这样我就不会泄漏内存。
Dialogue: 0,0:26:39.37,0:26:41.31,英文,,0,0,0,,So I'm not just immediately returning one.
Dialogue: 0,0:26:39.37,0:26:41.31,中文,,0,0,0,,我没有直接返回 1。
Dialogue: 0,0:26:41.31,0:26:54.54,英文,,0,0,0,,I'm being a good citizen and remembering, well, if this malloc call did succeed, and indeed, I got as far as line 18, but then line 18 failed, I should free the memory that I previously malloc'd.
Dialogue: 0,0:26:41.31,0:26:54.54,中文,,0,0,0,,我做个好公民，记住如果 malloc 调用成功，并且我执行到第 18 行，但第 18 行失败了，我应该释放之前 malloc 的内存。
Dialogue: 0,0:26:54.54,0:27:00.04,英文,,0,0,0,,So again, that's the rule of thumb. If you allocate it, you should be the one to free it, even before you're about to quit.
Dialogue: 0,0:26:54.54,0:27:00.04,中文,,0,0,0,,同样，这是一个经验法则。如果你分配了内存，你就应该负责释放它，即使你马上要退出程序。
Dialogue: 0,0:27:00.04,0:27:08.95,英文,,0,0,0,,Now, once I've done that, I think I need to do what we did pictorially on the screen, where I need to copy the 1, the 2, the 3 from the old array into the new.
Dialogue: 0,0:27:00.04,0:27:08.95,中文,,0,0,0,,现在我完成了，我想我需要做我们在屏幕上用图片展示的操作：将旧数组中的 1、2、3 复制到新数组中。
Dialogue: 0,0:27:08.95,0:27:10.05,英文,,0,0,0,,So how might I do this?
Dialogue: 0,0:27:08.95,0:27:10.05,中文,,0,0,0,,我该怎么做呢？
Dialogue: 0,0:27:10.05,0:27:11.93,英文,,0,0,0,,Well, let me give myself a loop.
Dialogue: 0,0:27:10.05,0:27:11.93,中文,,0,0,0,,我先写一个循环。
Dialogue: 0,0:27:11.93,0:27:22.08,英文,,0,0,0,,So for int i gets 0, i less than 3, i plus plus, because the size of the original is still the same, let me go ahead and treat the new chunk of memory
Dialogue: 0,0:27:11.93,0:27:22.08,中文,,0,0,0,,`for (int i = 0; i < 3; i++)`，因为原始数组的大小仍然相同，让我继续将名为 tmp 的新内存块
Dialogue: 0,0:27:22.08,0:27:24.61,英文,,0,0,0,,called temp as an array itself.
Dialogue: 0,0:27:22.08,0:27:24.61,中文,,0,0,0,,视为一个数组。
Dialogue: 0,0:27:24.61,0:27:27.09,英文,,0,0,0,,And so I can absolutely use these square brackets just like before.
Dialogue: 0,0:27:24.61,0:27:27.09,中文,,0,0,0,,所以我完全可以使用方括号，就像之前一样。
Dialogue: 0,0:27:27.09,0:27:28.45,英文,,0,0,0,,It's just a chunk of memory.
Dialogue: 0,0:27:27.09,0:27:28.45,中文,,0,0,0,,它只是一块内存。
Dialogue: 0,0:27:28.45,0:27:29.87,英文,,0,0,0,,I'm treating it like an array.
Dialogue: 0,0:27:28.45,0:27:29.87,中文,,0,0,0,,我把它当作数组来处理。
Dialogue: 0,0:27:29.87,0:27:35.56,英文,,0,0,0,,And let me add to that value whatever is at the original list at location i as well.
Dialogue: 0,0:27:29.87,0:27:35.56,中文,,0,0,0,,然后我把原始列表中 i 位置的值加到 tmp 中。
Dialogue: 0,0:27:35.56,0:27:44.30,英文,,0,0,0,,So this, again, is just this exercise of copying from old to new, step by step, the 1, the 2, and the 3.
Dialogue: 0,0:27:35.56,0:27:44.30,中文,,0,0,0,,所以这还是一步一步地将 1、2、3 从旧数组复制到新数组。
Dialogue: 0,0:27:44.30,0:27:46.15,英文,,0,0,0,,But I still need one additional step.
Dialogue: 0,0:27:44.30,0:27:46.15,中文,,0,0,0,,但我还需要一个额外的步骤。
Dialogue: 0,0:27:46.15,0:27:53.58,英文,,0,0,0,,If my goal at hand now is to have ultimately a fourth value here, well, I'm just going to hard code this for demonstration's sake.
Dialogue: 0,0:27:46.15,0:27:53.58,中文,,0,0,0,,如果我现在目标是最终在这里得到第四个值，为了演示，我将硬编码这个值。
Dialogue: 0,0:27:53.58,0:28:07.58,英文,,0,0,0,,And I'm going to go to the very last location of temp, which is of size 4, which means the last element in temp is temp bracket 3, because it's 0 indexed, but there's four total spaces there.
Dialogue: 0,0:27:53.58,0:28:07.58,中文,,0,0,0,,我要找到 tmp 的最后一个位置，它的大小是 4，这意味着 tmp 中的最后一个元素是 `tmp[3]`，因为它是从 0 开始索引的，但是总共有四个空间。
Dialogue: 0,0:28:07.58,0:28:11.15,英文,,0,0,0,,And I'm just going to arbitrarily, for the sake of discussion, put the number 4 there.
Dialogue: 0,0:28:07.58,0:28:11.15,中文,,0,0,0,,为了讨论，我将任意地在那里放上数字 4。
Dialogue: 0,0:28:11.15,0:28:15.40,英文,,0,0,0,,And that is what happened when we proposed
Dialogue: 0,0:28:11.15,0:28:15.40,中文,,0,0,0,,这就是当我们建议将
Dialogue: 0,0:28:15.40,0:28:18.62,英文,,0,0,0,,Changing the final garbage value there to that 4.
Dialogue: 0,0:28:15.40,0:28:18.62,中文,,0,0,0,,最后一个垃圾值更改为 4 时发生的情况。
Dialogue: 0,0:28:18.62,0:28:22.41,英文,,0,0,0,,But now I need to do what the slide did for us sort of magically on the screen.
Dialogue: 0,0:28:18.62,0:28:22.41,中文,,0,0,0,,但现在我需要做幻灯片在屏幕上为我们神奇地完成的事情。
Dialogue: 0,0:28:22.41,0:28:24.69,英文,,0,0,0,,I should now do a couple of final things.
Dialogue: 0,0:28:22.41,0:28:24.69,中文,,0,0,0,,现在做最后几件事。
Dialogue: 0,0:28:24.69,0:28:30.48,英文,,0,0,0,,I should free the original list, which I've not done yet, because I only called free earlier in cases of error.
Dialogue: 0,0:28:24.69,0:28:30.48,中文,,0,0,0,,我应该释放原始列表，我还没有做，因为我之前只在出现错误时调用 free。
Dialogue: 0,0:28:30.48,0:28:32.30,英文,,0,0,0,,And that was just to be safe.
Dialogue: 0,0:28:30.48,0:28:32.30,中文,,0,0,0,,这只是为了安全起见。
Dialogue: 0,0:28:32.30,0:28:34.26,英文,,0,0,0,,I can now free the list.
Dialogue: 0,0:28:32.30,0:28:34.26,中文,,0,0,0,,我现在可以释放列表了。
Dialogue: 0,0:28:34.26,0:28:50.51,英文,,0,0,0,,And now, if I want to inform the computer that I want list, quote unquote, my variable called list, to point at not the old chunk like it originally did, but the new chunk, I think I can just do this, list equals tmp.
Dialogue: 0,0:28:34.26,0:28:50.51,中文,,0,0,0,,现在，如果我想通知计算机，我想让 list，我的变量 list，指向新的内存块，而不是像最初那样指向旧的内存块，我想我可以这样做，list = tmp。
Dialogue: 0,0:28:50.51,0:28:55.45,英文,,0,0,0,,And again, that's just saying that if list is a pointer, which it was, because look at the very top line here.
Dialogue: 0,0:28:50.51,0:28:55.45,中文,,0,0,0,,再说一次，这只是说，如果 list 是一个指针，它就是，因为看看最上面的一行。
Dialogue: 0,0:28:55.45,0:29:01.19,英文,,0,0,0,,On line 6, I declared list to be a pointer.
Dialogue: 0,0:28:55.45,0:29:01.19,中文,,0,0,0,,在第 6 行，我声明 list 是一个指针。
Dialogue: 0,0:29:01.19,0:29:02.93,英文,,0,0,0,,to a chunk of memory.
Dialogue: 0,0:29:01.19,0:29:02.93,中文,,0,0,0,,指向一块内存。
Dialogue: 0,0:29:02.93,0:29:06.43,英文,,0,0,0,,Temp, meanwhile, is a separate pointer to a chunk of memory.
Dialogue: 0,0:29:02.93,0:29:06.43,中文,,0,0,0,,同时，tmp 是指向另一块内存的指针。
Dialogue: 0,0:29:06.43,0:29:26.51,英文,,0,0,0,,So down here, this line 33 is just a matter of my saying, OK, now, henceforth, because I've already freed the old chunk of memory, my list variable should point not at this chunk of three bytes, but this chunk of four bytes, or really 12 in total now, or rather 16 now, because we have four such bytes.
Dialogue: 0,0:29:06.43,0:29:26.51,中文,,0,0,0,,所以在第 33 行，我只是想说，现在，从此以后，因为我已经释放了旧的内存块，我的 list 变量不应该指向这三个字节的块，\N而是指向这四个字节的块，或者现在总共是 12 个字节，或者更确切地说是 16 个字节，因为我们有四个这样的字节。
Dialogue: 0,0:29:26.51,0:29:44.69,英文,,0,0,0,,Questions now on this code, the point of which was quite simply to demonstrate how we could implement in code this idea of fairly correctly but inefficiently allocating a new array of sufficient size and then populating it with a new fourth value.
Dialogue: 0,0:29:26.51,0:29:44.69,中文,,0,0,0,,现在对这段代码有什么疑问吗？这段代码的重点很简单，\N就是演示我们如何在代码中实现这种想法：相当正确但效率低下地分配一个足够大小的新数组，然后用新的第四个值填充它。
Dialogue: 0,0:29:44.69,0:29:49.07,英文,,0,0,0,,Questions on what we've just done here?
Dialogue: 0,0:29:44.69,0:29:49.07,中文,,0,0,0,,对我们刚才所做的有什么疑问吗？
Dialogue: 0,0:29:49.07,0:29:55.78,英文,,0,0,0,,No? Yeah.
Dialogue: 0,0:29:49.07,0:29:55.78,中文,,0,0,0,,没有？好的。
Dialogue: 0,0:29:55.78,0:30:00.09,英文,,0,0,0,,Fine-tuning.
Dialogue: 0,0:29:55.78,0:30:00.09,中文,,0,0,0,,微调。
Dialogue: 0,0:30:00.09,0:30:00.63,英文,,0,0,0,,Good question.
Dialogue: 0,0:30:00.09,0:30:00.63,中文,,0,0,0,,好问题。
Dialogue: 0,0:30:00.63,0:30:07.56,英文,,0,0,0,,At this point in the story, with line 33, do I not have two different variables pointing at the same chunk of memory?
Dialogue: 0,0:30:00.63,0:30:07.56,中文,,0,0,0,,在这个时候，在第 33 行，我是不是有两个不同的变量指向同一块内存？
Dialogue: 0,0:30:07.56,0:30:08.66,英文,,0,0,0,,Short answer, yes.
Dialogue: 0,0:30:07.56,0:30:08.66,中文,,0,0,0,,简短的回答，是的。
Dialogue: 0,0:30:08.66,0:30:10.90,英文,,0,0,0,,But here's where the semantics are perhaps compelling.
Dialogue: 0,0:30:08.66,0:30:10.90,中文,,0,0,0,,但这就是语义也许令人信服的地方。
Dialogue: 0,0:30:10.90,0:30:15.20,英文,,0,0,0,,List is the variable that I intend to use longer term and keep around in memory.
Dialogue: 0,0:30:10.90,0:30:15.20,中文,,0,0,0,,List 是我打算长期使用并保存在内存中的变量。
Dialogue: 0,0:30:15.20,0:30:18.82,英文,,0,0,0,,And again, assume that there's even more code going on here that we just didn't write yet.
Dialogue: 0,0:30:15.20,0:30:18.82,中文,,0,0,0,,再次假设这里还有更多的代码，我们只是还没有写。
Dialogue: 0,0:30:18.82,0:30:20.90,英文,,0,0,0,,So it's useful to have that variable.
Dialogue: 0,0:30:18.82,0:30:20.90,中文,,0,0,0,,所以有个变量很有用。
Dialogue: 0,0:30:20.90,0:30:27.80,英文,,0,0,0,,Temp was just kind of a necessary evil, because up here, it would not have been correct to do this.
Dialogue: 0,0:30:20.90,0:30:27.80,中文,,0,0,0,,tmp 只是一个必要的麻烦，因为在上面，这样做是不对的。
Dialogue: 0,0:30:27.80,0:30:35.85,英文,,0,0,0,,It would not have been correct to say list on line 18 equals the new chunk of memory, because this would have represented a memory leak.
Dialogue: 0,0:30:27.80,0:30:35.85,中文,,0,0,0,,写成第 18 行的 list 等于新的内存块是不对的，因为这表示内存泄漏。
Dialogue: 0,0:30:35.85,0:30:44.38,英文,,0,0,0,,If I prematurely changed temp to point not at the old chunk, but the new chunk, at that point, no one's pointing at the old chunk.
Dialogue: 0,0:30:35.85,0:30:44.38,中文,,0,0,0,,如果我过早地将 tmp 从指向旧块改为指向新块，那么此时，就没有指针指向旧块了。
Dialogue: 0,0:30:44.38,0:30:46.30,英文,,0,0,0,,And so I've lost those three bytes.
Dialogue: 0,0:30:44.38,0:30:46.30,中文,,0,0,0,,这样我就丢失了这三个字节。
Dialogue: 0,0:30:46.30,0:30:51.18,英文,,0,0,0,,Valgrind, for instance, would yell at you for having lost as many bytes in memory.
Dialogue: 0,0:30:46.30,0:30:51.18,中文,,0,0,0,,例如，Valgrind 会对你丢失了这么多字节的内存发出警告。
Dialogue: 0,0:30:51.18,0:30:53.85,英文,,0,0,0,,So in this case here, I do leave this as temp.
Dialogue: 0,0:30:51.18,0:30:53.85,中文,,0,0,0,,所以在这种情况下，我把它保留为 tmp。
Dialogue: 0,0:30:53.85,0:30:59.75,英文,,0,0,0,,Yes, it's duplicative at this point, but it's not a huge deal if it was just meant semantically to be a temporary value.
Dialogue: 0,0:30:53.85,0:30:59.75,中文,,0,0,0,,是的，在这一点上它是重复的，但如果它只是语义上的一个临时值，那就没什么大不了的。
Dialogue: 0,0:30:59.75,0:31:09.83,英文,,0,0,0,,But down here, at the risk of one more line of code, I still want to, to be a good citizen, free list, and maybe just for good measure, return 0 explicitly.
Dialogue: 0,0:30:59.75,0:31:09.83,中文,,0,0,0,,但在下面，冒着再多写一行代码的风险，我还是想做一个好公民，释放 list，也许只是为了保险起见，显式地返回 0。
Dialogue: 0,0:31:09.83,0:31:14.33,英文,,0,0,0,,But notice, it's not doing it twice per se.
Dialogue: 0,0:31:09.83,0:31:14.33,中文,,0,0,0,,但请注意，它本身并没有做两次。
Dialogue: 0,0:31:14.33,0:31:17.15,英文,,0,0,0,,On line 31, what am I freeing?
Dialogue: 0,0:31:14.33,0:31:17.15,中文,,0,0,0,,在第 31 行，我要释放的是什么？
Dialogue: 0,0:31:17.15,0:31:19.68,英文,,0,0,0,,The original address of list.
Dialogue: 0,0:31:17.15,0:31:19.68,中文,,0,0,0,,list 的原始地址。
Dialogue: 0,0:31:19.68,0:31:22.06,英文,,0,0,0,,The three-integer version.
Dialogue: 0,0:31:19.68,0:31:22.06,中文,,0,0,0,,三个整数的版本。
Dialogue: 0,0:31:22.06,0:31:23.76,英文,,0,0,0,,Then I change what list points at.
Dialogue: 0,0:31:22.06,0:31:23.76,中文,,0,0,0,,然后我改变 list 指向的位置。
Dialogue: 0,0:31:23.76,0:31:27.56,英文,,0,0,0,,So it's pointing at a completely different chunk of memory, this one of size 4.
Dialogue: 0,0:31:23.76,0:31:27.56,中文,,0,0,0,,所以它指向了一个完全不同的内存块，这个内存块的大小为 4。
Dialogue: 0,0:31:27.56,0:31:32.37,英文,,0,0,0,,So eventually, when I'm all done using this memory for this demonstration, I still need to free list.
Dialogue: 0,0:31:27.56,0:31:32.37,中文,,0,0,0,,所以最终，当我用完这块内存进行演示后，我仍然需要释放 list。
Dialogue: 0,0:31:32.37,0:31:40.40,英文,,0,0,0,,But at this point in the storyline 40, it's pointing at the new chunk of memory, which I similarly need to hand back to the operating system by free.
Dialogue: 0,0:31:32.37,0:31:40.40,中文,,0,0,0,,但在第 40 行的故事情节中，它指向的是新的内存块，我同样需要通过 free 将其交还给操作系统。
Dialogue: 0,0:31:40.40,0:31:44.67,英文,,0,0,0,,Yeah.
Dialogue: 0,0:31:40.40,0:31:44.67,中文,,0,0,0,,是的。
Dialogue: 0,0:31:44.67,0:31:46.17,英文,,0,0,0,,When would temp equal null?
Dialogue: 0,0:31:44.67,0:31:46.17,中文,,0,0,0,,tmp 什么时候等于 NULL？
Dialogue: 0,0:31:46.17,0:31:48.27,英文,,0,0,0,,So let me scroll back up slightly.
Dialogue: 0,0:31:46.17,0:31:48.27,中文,,0,0,0,,让我向上滚动一点。
Dialogue: 0,0:31:48.27,0:31:50.85,英文,,0,0,0,,This is being a good citizen and a good programmer.
Dialogue: 0,0:31:48.27,0:31:50.85,中文,,0,0,0,,这是作为一名合格的公民和程序员应该做的。
Dialogue: 0,0:31:50.85,0:31:57.82,英文,,0,0,0,,Whenever it comes to using malloc, malloc can return null if the computer is out of memory.
Dialogue: 0,0:31:50.85,0:31:57.82,中文,,0,0,0,,每当使用 malloc 时，如果计算机内存不足，malloc 可能会返回 NULL。
Dialogue: 0,0:31:57.82,0:31:59.36,英文,,0,0,0,,So this is maybe a much bigger program.
Dialogue: 0,0:31:57.82,0:31:59.36,中文,,0,0,0,,所以这可能是一个更大的程序。
Dialogue: 0,0:31:59.36,0:32:01.14,英文,,0,0,0,,You've got other things going on in it.
Dialogue: 0,0:31:59.36,0:32:01.14,中文,,0,0,0,,里面还有其他东西在运行。
Dialogue: 0,0:32:01.14,0:32:04.60,英文,,0,0,0,,And so you just don't have enough memory available to be handed.
Dialogue: 0,0:32:01.14,0:32:04.60,中文,,0,0,0,,因此，没有足够的内存可供使用。
Dialogue: 0,0:32:04.60,0:32:07.14,英文,,0,0,0,,Malloc needs to signal to you that there's some error.
Dialogue: 0,0:32:04.60,0:32:07.14,中文,,0,0,0,,Malloc 需要向你发出错误信号。
Dialogue: 0,0:32:07.14,0:32:12.76,英文,,0,0,0,,And so it will, by convention, per the documentation, per the manual pages, return null.
Dialogue: 0,0:32:07.14,0:32:12.76,中文,,0,0,0,,按照惯例，根据文档，根据手册页，它将返回 NULL。
Dialogue: 0,0:32:12.76,0:32:14.34,英文,,0,0,0,,So this is just me being a good citizen.
Dialogue: 0,0:32:12.76,0:32:14.34,中文,,0,0,0,,所以这只是我作为一名合格的公民应该做的。
Dialogue: 0,0:32:14.34,0:32:24.86,英文,,0,0,0,,Otherwise, here's another error that might cause your program to crash with a segmentation fault if you get back null, but you assume that it's good memory going to address 0, a.k.a.
Dialogue: 0,0:32:14.34,0:32:24.86,中文,,0,0,0,,否则，如果返回 NULL，但假设它是指向地址 0 的有效内存，也就是 NULL，那么这里还有另一个错误可能会导致程序崩溃，并出现段错误。
Dialogue: 0,0:32:24.86,0:32:27.96,英文,,0,0,0,,null will crash your program intentionally.
Dialogue: 0,0:32:24.86,0:32:27.96,中文,,0,0,0,,Null 会故意使程序崩溃。
Dialogue: 0,0:32:27.96,0:32:29.10,英文,,0,0,0,,Yeah?
Dialogue: 0,0:32:27.96,0:32:29.10,中文,,0,0,0,,是吗？
Dialogue: 0,0:32:36.22,0:32:44.21,英文,,0,0,0,,Correct, if I were to change my final line 40 here to be free temp, this would also work as well.
Dialogue: 0,0:32:36.22,0:32:44.21,中文,,0,0,0,,是的，如果我将第 40 行的最后一行改为 free tmp，这也能正常工作。
Dialogue: 0,0:32:44.21,0:32:46.55,英文,,0,0,0,,And here, this is really a matter of design.
Dialogue: 0,0:32:44.21,0:32:46.55,中文,,0,0,0,,在这里，这实际上是一个设计问题。
Dialogue: 0,0:32:46.55,0:32:48.09,英文,,0,0,0,,It's a very nitpicky thing.
Dialogue: 0,0:32:46.55,0:32:48.09,中文,,0,0,0,,这是一个非常吹毛求疵的问题。
Dialogue: 0,0:32:48.09,0:32:49.55,英文,,0,0,0,,We could probably debate it.
Dialogue: 0,0:32:48.09,0:32:49.55,中文,,0,0,0,,我们可以讨论一下。
Dialogue: 0,0:32:49.55,0:33:05.28,英文,,0,0,0,,But because at this point in the story, my main variable for remembering where the list is is called list, this is sort of the more responsible way to do it, freeing the list, just so that my colleagues, my TA doesn't sort of wonder, why are you freeing temporary memory that you already freed?
Dialogue: 0,0:32:49.55,0:33:05.28,中文,,0,0,0,,但是因为在这个例子中，我用来记住列表位置的主要变量叫做 list，\N所以这种做法更负责任，释放 list，这样我的同事，我的助教就不会奇怪，为什么要释放已经释放的临时内存？
Dialogue: 0,0:33:05.28,0:33:09.84,英文,,0,0,0,,It just is a semantic thing at this point. But good instinct. It would also work, correct?
Dialogue: 0,0:33:05.28,0:33:09.84,中文,,0,0,0,,在这一点上，这只是一个语义问题。但直觉很好。它也能工作，对吧？
Dialogue: 0,0:33:09.84,0:33:11.94,英文,,0,0,0,,Maybe just not good design.
Dialogue: 0,0:33:09.84,0:33:11.94,中文,,0,0,0,,也许只是设计不好。
Dialogue: 0,0:33:11.94,0:33:17.12,英文,,0,0,0,,All right, so it turns out that this gets annoying quickly, as it did in the picture of doing all of this duplication.
Dialogue: 0,0:33:11.94,0:33:17.12,中文,,0,0,0,,事实证明，这很快就变得烦人了，就像在图片中进行所有复制一样。
Dialogue: 0,0:33:17.12,0:33:27.31,英文,,0,0,0,,And even though technically it's necessary to copy those values if you need a newer, bigger chunk of memory, there is at least a function in C that simplifies a lot of this for us.
Dialogue: 0,0:33:17.12,0:33:27.31,中文,,0,0,0,,尽管从技术上讲，如果需要更大的一块内存，就必须复制这些值，但在 C 语言中至少有一个函数可以为我们简化很多操作。
Dialogue: 0,0:33:27.31,0:33:29.49,英文,,0,0,0,,And in fact, let me go ahead and do this.
Dialogue: 0,0:33:27.31,0:33:29.49,中文,,0,0,0,,实际上，让我继续演示。
Dialogue: 0,0:33:29.49,0:33:41.12,英文,,0,0,0,,Instead of using malloc this second time on line 18, in addition to the first time I used it on line 6, I'm actually going to try and introduce another function called realloc.
Dialogue: 0,0:33:29.49,0:33:41.12,中文,,0,0,0,,与其在第 18 行再次使用 malloc，就像我在第 6 行那样，我将尝试引入另一个名为 realloc 的函数。
Dialogue: 0,0:33:41.12,0:33:44.88,英文,,0,0,0,,which, as the name suggests, tries to reallocate memory for you.
Dialogue: 0,0:33:41.12,0:33:44.88,中文,,0,0,0,,顾名思义，它会尝试为你重新分配内存。
Dialogue: 0,0:33:44.88,0:33:47.20,英文,,0,0,0,,And it works a little differently for malloc.
Dialogue: 0,0:33:44.88,0:33:47.20,中文,,0,0,0,,它的工作方式与 malloc 略有不同。
Dialogue: 0,0:33:47.20,0:33:49.36,英文,,0,0,0,,realloc expects two arguments.
Dialogue: 0,0:33:47.20,0:33:49.36,中文,,0,0,0,,realloc 需要两个参数。
Dialogue: 0,0:33:49.36,0:33:54.30,英文,,0,0,0,,The first one is, what is the chunk of memory that you want to try to grow or shrink?
Dialogue: 0,0:33:49.36,0:33:54.30,中文,,0,0,0,,第一个是：你想尝试扩大或缩小的内存块是什么？
Dialogue: 0,0:33:54.30,0:33:57.11,英文,,0,0,0,,That is, reallocate to be a different size.
Dialogue: 0,0:33:54.30,0:33:57.11,中文,,0,0,0,,也就是说，要重新分配成不同的大小。
Dialogue: 0,0:33:57.11,0:33:59.63,英文,,0,0,0,,And then you specify what size you would want.
Dialogue: 0,0:33:57.11,0:33:59.63,中文,,0,0,0,,然后指定你想要的大小。
Dialogue: 0,0:33:59.63,0:34:04.99,英文,,0,0,0,,And indeed, in this case, I want 4 times size of int.
Dialogue: 0,0:33:59.63,0:34:04.99,中文,,0,0,0,,实际上，在这种情况下，我想要 4 倍 int 的大小。
Dialogue: 0,0:34:04.99,0:34:12.97,英文,,0,0,0,,And that will now give me, hopefully, a new address of a chunk of memory that's big enough to fit all four numbers.
Dialogue: 0,0:34:04.99,0:34:12.97,中文,,0,0,0,,这将为我提供一个新的内存块地址，希望它足够大以容纳所有四个数字。
Dialogue: 0,0:34:12.97,0:34:19.95,英文,,0,0,0,,But what's wonderful about realloc is that it will handle all of the copying for me.
Dialogue: 0,0:34:12.97,0:34:19.95,中文,,0,0,0,,但 realloc 的妙处在于它将为我处理所有复制工作。
Dialogue: 0,0:34:19.95,0:34:21.98,英文,,0,0,0,,So in fact, I'm going to go down here.
Dialogue: 0,0:34:19.95,0:34:21.98,中文,,0,0,0,,所以实际上，我要往下看。
Dialogue: 0,0:34:21.98,0:34:26.00,英文,,0,0,0,,I'm going to get rid of all of this, this extra for loop.
Dialogue: 0,0:34:21.98,0:34:26.00,中文,,0,0,0,,我要去掉所有这些，这个额外的 for 循环。
Dialogue: 0,0:34:26.00,0:34:29.16,英文,,0,0,0,,And what I'm simply going to do instead is this.
Dialogue: 0,0:34:26.00,0:34:29.16,中文,,0,0,0,,我要做的是这样的。
Dialogue: 0,0:34:29.16,0:34:31.48,英文,,0,0,0,,Once I can trust.
Dialogue: 0,0:34:29.16,0:34:31.48,中文,,0,0,0,,一旦我能确定。
Dialogue: 0,0:34:31.48,0:34:44.41,英文,,0,0,0,,After lines 18 through 23 that realloc worked, and it didn't return null because I'm out of memory, I can just say, OK, just immediately remember that the new list points at this new chunk of memory instead.
Dialogue: 0,0:34:31.48,0:34:44.41,中文,,0,0,0,,在第 18 行到 23 行之后，realloc 成功了，并且它没有返回 NULL，因为我没有内存不足，我可以说，请立即记住，新列表指向这个新的内存块。
Dialogue: 0,0:34:44.41,0:34:54.72,英文,,0,0,0,,And then I can still now do this line, but I can tweak the semantics here and just say list bracket 3, the new final location
Dialogue: 0,0:34:44.41,0:34:54.72,中文,,0,0,0,,然后我仍然可以执行这一行，但我可以在这里调整语义，只需说 list[3]，新的最终位置
Dialogue: 0,0:34:54.72,0:34:58.18,英文,,0,0,0,,The new list is for, I don't need to free this here.
Dialogue: 0,0:34:54.72,0:34:58.18,中文,,0,0,0,,新的列表是for，我不需要在这里释放它。
Dialogue: 0,0:34:58.18,0:34:59.75,英文,,0,0,0,,I don't need to do this.
Dialogue: 0,0:34:58.18,0:34:59.75,中文,,0,0,0,,我不需要这样做。
Dialogue: 0,0:34:59.75,0:35:03.89,英文,,0,0,0,,All I need now at the bottom is the final for loop to just print out these values.
Dialogue: 0,0:34:59.75,0:35:03.89,中文,,0,0,0,,现在，我在底部只需要最后的 for 循环来打印出这些值。
Dialogue: 0,0:35:03.89,0:35:13.39,英文,,0,0,0,,So in short, even though that was somewhat quick, using realloc just moves the entire copying process that I implemented myself a moment ago using a for loop.
Dialogue: 0,0:35:03.89,0:35:13.39,中文,,0,0,0,,简而言之，即使刚才的操作有点快，使用 realloc 只是将我之前使用 for 循环实现的整个复制过程移动了位置。
Dialogue: 0,0:35:13.39,0:35:16.49,英文,,0,0,0,,It just moves it to realloc and lets it deal with the copying for me.
Dialogue: 0,0:35:13.39,0:35:16.49,中文,,0,0,0,,它只是将复制过程移交给了 realloc 来处理。
Dialogue: 0,0:35:16.49,0:35:17.66,英文,,0,0,0,,It's no more efficient.
Dialogue: 0,0:35:16.49,0:35:17.66,中文,,0,0,0,,效率并没有提高。
Dialogue: 0,0:35:17.66,0:35:20.42,英文,,0,0,0,,But it at least means I'm writing less code, which is more pleasant.
Dialogue: 0,0:35:17.66,0:35:20.42,中文,,0,0,0,,但这至少意味着我写的代码更少了，这更令人愉快。
Dialogue: 0,0:35:20.42,0:35:23.88,英文,,0,0,0,,And hopefully, the people who wrote malloc or realloc are smarter than me.
Dialogue: 0,0:35:20.42,0:35:23.88,中文,,0,0,0,,而且希望编写 malloc 或 realloc 的人比我聪明。
Dialogue: 0,0:35:23.88,0:35:27.39,英文,,0,0,0,,And they just will introduce bugs with lower probability, too.
Dialogue: 0,0:35:23.88,0:35:27.39,中文,,0,0,0,,并且他们引入错误的可能性也会更低。
Dialogue: 0,0:35:27.39,0:35:29.81,英文,,0,0,0,,All right, that was a lot.
Dialogue: 0,0:35:27.39,0:35:29.81,中文,,0,0,0,,内容很多。
Dialogue: 0,0:35:29.81,0:35:35.26,英文,,0,0,0,,Any questions?
Dialogue: 0,0:35:29.81,0:35:35.26,中文,,0,0,0,,有什么问题吗？
Dialogue: 0,0:35:35.26,0:35:40.97,英文,,0,0,0,,Good question, why do you still need to make list equal temp as I did on line 24?
Dialogue: 0,0:35:35.26,0:35:40.97,中文,,0,0,0,,问得好，为什么还需要像我在第 24 行那样将 list 赋值为 tmp？
Dialogue: 0,0:35:40.97,0:35:44.35,英文,,0,0,0,,So ideally, I would do this.
Dialogue: 0,0:35:40.97,0:35:44.35,中文,,0,0,0,,理想情况下，我会这样做。
Dialogue: 0,0:35:44.35,0:35:49.03,英文,,0,0,0,,Ideally, I would just change this line 18 to be list.
Dialogue: 0,0:35:44.35,0:35:49.03,中文,,0,0,0,,理想情况下，我只更改第 18 行为 list。
Dialogue: 0,0:35:49.03,0:35:55.34,英文,,0,0,0,,That is to say, call or actually even better, ideally, I would just say realloc this list to be of this new size.
Dialogue: 0,0:35:49.03,0:35:55.34,中文,,0,0,0,,也就是说，调用，或者更好的是，理想情况下，我会直接说将 list 的大小使用 realloc 调整为新的 size。
Dialogue: 0,0:35:55.34,0:35:57.78,英文,,0,0,0,,But again, things can go wrong when allocating memory.
Dialogue: 0,0:35:55.34,0:35:57.78,中文,,0,0,0,,但是，分配内存时可能会出现问题。
Dialogue: 0,0:35:57.78,0:36:01.90,英文,,0,0,0,,You need to check a return value to see if it was successful or not.
Dialogue: 0,0:35:57.78,0:36:01.90,中文,,0,0,0,,你需要检查返回值以查看它是否成功。
Dialogue: 0,0:36:01.90,0:36:03.80,英文,,0,0,0,,And so we need to use a return value.
Dialogue: 0,0:36:01.90,0:36:03.80,中文,,0,0,0,,因此我们需要使用返回值。
Dialogue: 0,0:36:03.80,0:36:05.82,英文,,0,0,0,,OK, so let's not introduce temp.
Dialogue: 0,0:36:03.80,0:36:05.82,中文,,0,0,0,,我们不要引入 tmp。
Dialogue: 0,0:36:05.82,0:36:07.29,英文,,0,0,0,,Let's just use list.
Dialogue: 0,0:36:05.82,0:36:07.29,中文,,0,0,0,,直接使用 list。
Dialogue: 0,0:36:07.29,0:36:09.71,英文,,0,0,0,,But here's where a memory leak might happen.
Dialogue: 0,0:36:07.29,0:36:09.71,中文,,0,0,0,,但这里可能会发生内存泄漏。
Dialogue: 0,0:36:09.71,0:36:15.73,英文,,0,0,0,,In the off chance, realloc fails and doesn't have enough memory for your four bytes.
Dialogue: 0,0:36:09.71,0:36:15.73,中文,,0,0,0,,万一 realloc 失败并且没有足够的内存用于你的 4 个字节。
Dialogue: 0,0:36:15.73,0:36:18.31,英文,,0,0,0,,Therefore, it returns, by definition, null.
Dialogue: 0,0:36:15.73,0:36:18.31,中文,,0,0,0,,根据定义，它会返回 NULL。
Dialogue: 0,0:36:18.31,0:36:23.10,英文,,0,0,0,,You can't overwrite the original value of list with null to then check it.
Dialogue: 0,0:36:18.31,0:36:23.10,中文,,0,0,0,,你不能用 NULL 覆盖 list 的原始值，然后再检查它。
Dialogue: 0,0:36:23.10,0:36:23.80,英文,,0,0,0,,Why?
Dialogue: 0,0:36:23.10,0:36:23.80,中文,,0,0,0,,为什么？
Dialogue: 0,0:36:23.80,0:36:27.32,英文,,0,0,0,,Because now who remembers where the original three bytes were?
Dialogue: 0,0:36:23.80,0:36:27.32,中文,,0,0,0,,因为现在谁记得原来那三个字节在哪儿？
Dialogue: 0,0:36:27.32,0:36:30.86,英文,,0,0,0,,If you prematurely change the value of list, you've lost.
Dialogue: 0,0:36:27.32,0:36:30.86,中文,,0,0,0,,如果你过早地改变了 list 的值，你就完蛋了。
Dialogue: 0,0:36:30.86,0:36:32.82,英文,,0,0,0,,You've leaked memory in that sense.
Dialogue: 0,0:36:30.86,0:36:32.82,中文,,0,0,0,,在某种意义上，你泄露了内存。
Dialogue: 0,0:36:32.82,0:36:37.22,英文,,0,0,0,,And so that's why, let me undo this change, I declare a temporary pointer
Dialogue: 0,0:36:32.82,0:36:37.22,中文,,0,0,0,,让我撤销这个更改，我声明了一个临时指针，
Dialogue: 0,0:36:37.22,0:36:40.95,英文,,0,0,0,,for the sole purpose of making sure I can check the return value.
Dialogue: 0,0:36:37.22,0:36:40.95,中文,,0,0,0,,其唯一目的是确保我能检查返回值。
Dialogue: 0,0:36:40.95,0:36:44.65,英文,,0,0,0,,And then once it's good, now I'll update the value of list.
Dialogue: 0,0:36:40.95,0:36:44.65,中文,,0,0,0,,一旦它没问题了，我就会更新 list 的值。
Dialogue: 0,0:36:44.65,0:36:51.17,英文,,0,0,0,,So it's sort of doing a switcheroo by making sure first that you have a new value to swap with the old.
Dialogue: 0,0:36:44.65,0:36:51.17,中文,,0,0,0,,所以它有点像是在进行交换，首先要确保你有一个新的值来与旧值交换。
Dialogue: 0,0:36:51.17,0:36:53.64,英文,,0,0,0,,Other questions on this code?
Dialogue: 0,0:36:51.17,0:36:53.64,中文,,0,0,0,,关于这段代码还有其他问题吗？
Dialogue: 0,0:36:53.64,0:36:53.80,英文,,0,0,0,,Yeah.
Dialogue: 0,0:36:53.64,0:36:53.80,中文,,0,0,0,,有。
Dialogue: 0,0:37:00.46,0:37:03.65,英文,,0,0,0,,Indeed, realloc automatically frees the previous memory for you.
Dialogue: 0,0:37:00.46,0:37:03.65,中文,,0,0,0,,的确，realloc 会自动帮你释放之前的内存。
Dialogue: 0,0:37:03.65,0:37:05.81,英文,,0,0,0,,And better yet, it's even smarter than that.
Dialogue: 0,0:37:03.65,0:37:05.81,中文,,0,0,0,,而且更好的是，它比那更聪明。
Dialogue: 0,0:37:05.81,0:37:15.54,英文,,0,0,0,,If you get lucky and there happens to be space right after your existing chunk of memory, so 1, 2, 3, garbage value, instead of 1, 2, 3, hello world,
Dialogue: 0,0:37:05.81,0:37:15.54,中文,,0,0,0,,如果你幸运的话，碰巧在你现有的内存块之后有空间，比如 1、2、3、垃圾值，而不是 1、2、3、“hello world”，
Dialogue: 0,0:37:15.54,0:37:19.12,英文,,0,0,0,,realloc won't even bother copying things from old to new.
Dialogue: 0,0:37:15.54,0:37:19.12,中文,,0,0,0,,realloc 甚至懒得把东西从旧的复制到新的。
Dialogue: 0,0:37:19.12,0:37:26.49,英文,,0,0,0,,It will just say, OK, I'm going to now reserve for you more bytes than you originally asked for so it doesn't have to waste time doing that copying.
Dialogue: 0,0:37:19.12,0:37:26.49,中文,,0,0,0,,它只会说，我现在要为你保留比你最初要求的更多的字节，这样它就不必浪费时间进行复制了。
Dialogue: 0,0:37:26.49,0:37:32.91,英文,,0,0,0,,And so in that sense, this version is now not only still correct, it's even better designed because we're not wasting time with that for loop.
Dialogue: 0,0:37:26.49,0:37:32.91,中文,,0,0,0,,所以在这个意义上，这个版本现在不仅仍然正确，而且设计得更好，因为我们没有在那个 for 循环上浪费时间。
Dialogue: 0,0:37:32.91,0:37:37.09,英文,,0,0,0,,We might have to resort to it if there is, in fact, hello world or something else in the way.
Dialogue: 0,0:37:32.91,0:37:37.09,中文,,0,0,0,,如果真的有“hello world”或其他东西挡路，我们可能不得不求助于它。
Dialogue: 0,0:37:37.09,0:37:40.13,英文,,0,0,0,,But hopefully, we'll get lucky and save those steps.
Dialogue: 0,0:37:37.09,0:37:40.13,中文,,0,0,0,,但希望我们能幸运地省去这些步骤。
Dialogue: 0,0:37:40.13,0:37:46.67,英文,,0,0,0,,Other questions on this manipulation of code here?
Dialogue: 0,0:37:40.13,0:37:46.67,中文,,0,0,0,,关于这段代码操作，还有其他问题吗？
Dialogue: 0,0:37:46.67,0:37:47.24,英文,,0,0,0,,Yeah, in the middle.
Dialogue: 0,0:37:46.67,0:37:47.24,中文,,0,0,0,,嗯，在中间。
Dialogue: 0,0:37:53.35,0:37:56.03,英文,,0,0,0,,What if you want to resize a two-dimensional array?
Dialogue: 0,0:37:53.35,0:37:56.03,中文,,0,0,0,,如果要调整二维数组的大小怎么办？
Dialogue: 0,0:37:56.03,0:38:00.55,英文,,0,0,0,,So very similar in spirit, whereby you can use the same trickery.
Dialogue: 0,0:37:56.03,0:38:00.55,中文,,0,0,0,,精神上非常相似，你也可以使用相同的技巧。
Dialogue: 0,0:38:00.55,0:38:07.47,英文,,0,0,0,,Let me wave my hand at that for now, just because I think that's going to sort of significantly increase the complexity, but very same primitives.
Dialogue: 0,0:38:00.55,0:38:07.47,中文,,0,0,0,,我现在先不细说，因为我认为这会在某种程度上显著增加复杂性，但基本原理是相同的。
Dialogue: 0,0:38:07.47,0:38:18.41,英文,,0,0,0,,Ultimately, a two-dimensional array is essentially just a doubly long or quadratically longer list of memory that, using square bracket notation, is doing some of that mental math for you.
Dialogue: 0,0:38:07.47,0:38:18.41,中文,,0,0,0,,最终，二维数组本质上只是一个双倍长或平方长的内存列表，使用方括号表示法为你做了一些心算。
Dialogue: 0,0:38:18.41,0:38:23.34,英文,,0,0,0,,But it's fundamentally no different of what's going on underneath the hood.
Dialogue: 0,0:38:18.41,0:38:21.83,中文,,0,0,0,,但它与底层发生的事情并没有本质区别。
Dialogue: 0,0:38:23.34,0:38:45.82,英文,,0,0,0,,All right, so with that said and that code under our belt, even though that's not going to be something you'll frequently need to code yourself, let's propose now how we might go about building some actual data structures ourselves, the new ingredient here being this reality that if you want to resize a chunk of memory so as to make room for things, we now have that ability.
Dialogue: 0,0:38:23.34,0:38:45.82,中文,,0,0,0,,好了，既然如此，而且我们已经掌握了代码，即使这不是你需要经常自己编写的代码，\N现在让我们提出如何构建一些实际的数据结构，新的要素是，如果你想调整一块内存的大小以便为事物腾出空间，我们现在有这种能力。
Dialogue: 0,0:38:45.82,0:38:51.72,英文,,0,0,0,,Memory addresses and pointers just give us the ability to, like, Point around at things and move things around in memory.
Dialogue: 0,0:38:45.82,0:38:51.72,中文,,0,0,0,,内存地址和指针让我们能够指向事物并在内存中移动事物。
Dialogue: 0,0:38:51.72,0:38:55.88,英文,,0,0,0,,But now that we have malloc and even realloc, you can imagine maybe rewinding.
Dialogue: 0,0:38:51.72,0:38:55.88,中文,,0,0,0,,但现在我们有了 malloc 甚至是 realloc，你可以想象也许可以回溯。
Dialogue: 0,0:38:55.88,0:39:02.93,英文,,0,0,0,,And you could implement that stack, that queue, using not an array, per se, because you have to commit to an array size in advance.
Dialogue: 0,0:38:55.88,0:39:02.93,中文,,0,0,0,,你可以用指针来实现堆栈或队列，而不是数组，因为数组需要提前确定大小。
Dialogue: 0,0:39:02.93,0:39:13.24,英文,,0,0,0,,But if you implement your stack or your queue using a pointer, and then malloc and realloc, and maybe someone else writes all that code for you, perhaps now you can imagine that, OK, now
Dialogue: 0,0:39:02.93,0:39:12.88,中文,,0,0,0,,但是如果你用指针，加上malloc和realloc来实现堆栈或队列，并且可能有人已经为你写好了这些代码，那么你可以想象，
Dialogue: 0,0:39:13.24,0:39:17.38,英文,,0,0,0,,The stack can grow or shrink by using realloc accordingly.
Dialogue: 0,0:39:13.24,0:39:17.38,中文,,0,0,0,,现在堆栈可以通过相应地使用 realloc 来增长或缩小。
Dialogue: 0,0:39:17.38,0:39:23.51,英文,,0,0,0,,You don't have to preemptively say, give me 5 bytes, or 50, or 500, or 5,000.
Dialogue: 0,0:39:17.38,0:39:23.51,中文,,0,0,0,,你不必预先说，给我 5 个字节，或 50 个，或 500 个，或 5,000 个。
Dialogue: 0,0:39:23.51,0:39:25.25,英文,,0,0,0,,You can say, just give me one initially.
Dialogue: 0,0:39:23.51,0:39:25.25,中文,,0,0,0,,你可以说，一开始只给我一个。
Dialogue: 0,0:39:25.25,0:39:27.93,英文,,0,0,0,,And if I need more, I'll realloc, realloc, realloc.
Dialogue: 0,0:39:25.25,0:39:27.93,中文,,0,0,0,,如果我需要更多，我会 realloc，realloc，realloc。
Dialogue: 0,0:39:27.93,0:39:33.79,英文,,0,0,0,,And if you keep popping things off the stack, you can realloc in the other direction and ask for fewer and fewer bytes.
Dialogue: 0,0:39:27.93,0:39:33.79,中文,,0,0,0,,如果你不断地从堆栈中弹出东西，你可以反向 realloc 并要求越来越少的字节。
Dialogue: 0,0:39:33.79,0:39:40.06,英文,,0,0,0,,And the operating system can take that memory back as well. So we now have this building block. Let's see what we can do with it.
Dialogue: 0,0:39:33.79,0:39:39.42,中文,,0,0,0,,操作系统也可以收回内存。所以我们现在有了这个构建块。让我们看看我们可以用它做什么。
Dialogue: 0,0:39:40.06,0:39:46.16,英文,,0,0,0,,So we've had a few pieces of syntax in recent weeks, all of which we're going to combine now in just a slightly more clever way.
Dialogue: 0,0:39:40.06,0:39:46.16,中文,,0,0,0,,最近几周我们已经学习了一些语法，现在我们将以一种稍微聪明一点的方式将所有这些语法结合起来。
Dialogue: 0,0:39:46.16,0:39:56.57,英文,,0,0,0,,So struct is this keyword in C that lets us build our own structure in memory, like a collection of two or three or more variables, like a person that we've seen before. The dot operator.
Dialogue: 0,0:39:46.16,0:39:55.99,中文,,0,0,0,,struct 是 C 语言中的关键字，它允许我们像之前见过的 person 一样，在内存中构建自己的结构，比如两个、三个或更多变量的集合。
Dialogue: 0,0:39:56.57,0:40:02.89,英文,,0,0,0,,Recall we've used when you do have a struct, like a person, and you want to go inside of it.
Dialogue: 0,0:39:56.57,0:40:02.89,中文,,0,0,0,,回想一下，当我们有一个结构体，比如一个人，你想访问它的内部。
Dialogue: 0,0:40:02.89,0:40:07.08,英文,,0,0,0,,So like person.name or person.number.
Dialogue: 0,0:40:02.89,0:40:07.08,中文,,0,0,0,,比如 person.name 或者 person.number。
Dialogue: 0,0:40:07.08,0:40:09.04,英文,,0,0,0,,And we did this a few weeks ago now.
Dialogue: 0,0:40:07.08,0:40:09.04,中文,,0,0,0,,几周前我们做过这个。
Dialogue: 0,0:40:09.04,0:40:14.34,英文,,0,0,0,,But the dot operator just allows you to go inside of a structure and get the individual variables within.
Dialogue: 0,0:40:09.04,0:40:14.34,中文,,0,0,0,,点运算符可以让你访问结构体内部，并获取其中的各个变量。
Dialogue: 0,0:40:14.34,0:40:17.58,英文,,0,0,0,,And then the star operator, unfortunately, has a lot of uses now.
Dialogue: 0,0:40:14.34,0:40:17.58,中文,,0,0,0,,星号运算符，很遗憾，现在有很多用途。
Dialogue: 0,0:40:17.58,0:40:18.86,英文,,0,0,0,,One was multiplication.
Dialogue: 0,0:40:17.58,0:40:18.86,中文,,0,0,0,,一个是乘法。
Dialogue: 0,0:40:18.86,0:40:21.08,英文,,0,0,0,,My god, that was easy back in the day.
Dialogue: 0,0:40:18.86,0:40:21.08,中文,,0,0,0,,天哪，这在过去很容易。
Dialogue: 0,0:40:21.08,0:40:23.72,英文,,0,0,0,,Now it's used to declare pointers.
Dialogue: 0,0:40:21.08,0:40:23.12,中文,,0,0,0,,现在用来声明指针。
Dialogue: 0,0:40:23.72,0:40:29.48,英文,,0,0,0,,It's also used to dereference pointers, so to make one exist and then go to that address.
Dialogue: 0,0:40:23.72,0:40:29.48,中文,,0,0,0,,它还用来解引用指针，即创建一个指针，然后访问该地址。
Dialogue: 0,0:40:29.48,0:40:33.27,英文,,0,0,0,,Unfortunately, it's the same symbol for all of those, but it's all related.
Dialogue: 0,0:40:29.48,0:40:33.27,中文,,0,0,0,,不幸的是，所有这些都使用相同的符号，但它们都是相关的。
Dialogue: 0,0:40:33.27,0:40:36.87,英文,,0,0,0,,But with these three symbols, it turns out you're going to get one last one today.
Dialogue: 0,0:40:33.27,0:40:36.87,中文,,0,0,0,,但是有了这三个符号，今天你将会看到最后一个。
Dialogue: 0,0:40:36.87,0:40:40.53,英文,,0,0,0,,And my god, it finally looks like the concept
Dialogue: 0,0:40:36.87,0:40:39.87,中文,,0,0,0,,天哪，它终于看起来像这个概念了。
Dialogue: 0,0:40:40.53,0:40:53.46,英文,,0,0,0,,It turns out there's a clever way, any time you want to use the dot and the star together, that is, to go somewhere and go to an address and then look inside of a structure, you can actually literally use an arrow symbol on your keyboard.
Dialogue: 0,0:40:40.53,0:40:53.46,中文,,0,0,0,,事实证明，有一个巧妙的方法，任何时候你想同时使用点和星号，\N即访问某个地方并找到一个地址，然后查看结构体的内部，你实际上可以在键盘上使用箭头符号。
Dialogue: 0,0:40:53.46,0:40:54.84,英文,,0,0,0,,It's not a single keystroke.
Dialogue: 0,0:40:53.46,0:40:54.84,中文,,0,0,0,,它不是一个单键操作。
Dialogue: 0,0:40:54.84,0:40:57.92,英文,,0,0,0,,It's a hyphen and then an open angle bracket.
Dialogue: 0,0:40:54.84,0:40:57.92,中文,,0,0,0,,它是一个连字符，然后是一个左尖括号。
Dialogue: 0,0:40:57.92,0:40:59.52,英文,,0,0,0,,But at least it looks like an arrow.
Dialogue: 0,0:40:57.92,0:40:59.52,中文,,0,0,0,,但至少它看起来像个箭头。
Dialogue: 0,0:40:59.52,0:41:09.53,英文,,0,0,0,,And we'll see, indeed, in code today, the things I was drawing pictorially on the screen last time with yellow arrows, you can actually now express as well in code.
Dialogue: 0,0:40:59.52,0:41:07.65,中文,,0,0,0,,我们将在今天的代码中看到，我上次在屏幕上用黄色箭头绘制的内容，现在也可以用代码表达出来。
Dialogue: 0,0:41:09.53,0:41:12.13,英文,,0,0,0,,And so here we have. Our next data structure, called a linked list.
Dialogue: 0,0:41:09.53,0:41:12.13,中文,,0,0,0,,这里我们有，我们的下一个数据结构，叫做链表。
Dialogue: 0,0:41:12.13,0:41:20.08,英文,,0,0,0,,And this is one of the most useful, powerful concepts in C. It's the kind of thing that you can take for granted in Java and Python and higher-level languages.
Dialogue: 0,0:41:12.13,0:41:20.08,中文,,0,0,0,,这是 C 语言中最有用、最强大的概念之一。在 Java、Python 和更高级的语言中，你可以认为这是理所当然的。
Dialogue: 0,0:41:20.08,0:41:26.00,英文,,0,0,0,,But today, we'll see how we or others can actually build these things just using these same primitives.
Dialogue: 0,0:41:20.08,0:41:26.00,中文,,0,0,0,,但今天，我们将看到我们或其他人如何使用这些相同的原语来构建这些东西。
Dialogue: 0,0:41:26.00,0:41:36.51,英文,,0,0,0,,So a linked list is going to allow us to actually do What we used a foam finger for last week allow us to link together, for instance, these three values maybe with that fourth value over there.
Dialogue: 0,0:41:26.00,0:41:36.51,中文,,0,0,0,,链表实际上可以做我们上周用手套做的事情，比如，把这三个值连起来，也许还有那边的第四个值。
Dialogue: 0,0:41:36.51,0:41:41.85,英文,,0,0,0,,And then if there's a fifth, maybe this other foam finger points even farther over way to that fifth value.
Dialogue: 0,0:41:36.51,0:41:41.85,中文,,0,0,0,,如果有第五个，也许这个手套指向更远的地方，指向第五个值。
Dialogue: 0,0:41:41.85,0:41:49.54,英文,,0,0,0,,The key being that you can stitch together fancier data structures without having to pick all of these up and find new space.
Dialogue: 0,0:41:41.85,0:41:49.54,中文,,0,0,0,,关键是你可以将更复杂的数据结构拼接在一起，而不必把所有这些都拿起来，然后再去寻找新的空间。
Dialogue: 0,0:41:49.54,0:41:51.74,英文,,0,0,0,,You just have to at least connect the dots somehow.
Dialogue: 0,0:41:49.54,0:41:51.74,中文,,0,0,0,,你只需要以某种方式连接这些点。
Dialogue: 0,0:41:51.74,0:41:53.48,英文,,0,0,0,,We just need to somehow point.
Dialogue: 0,0:41:51.74,0:41:53.10,中文,,0,0,0,,我们只需要想办法指向。
Dialogue: 0,0:41:53.48,0:41:54.60,英文,,0,0,0,,from one to the other.
Dialogue: 0,0:41:53.48,0:41:54.60,中文,,0,0,0,,从一个到另一个。
Dialogue: 0,0:41:54.60,0:41:58.80,英文,,0,0,0,,And that's going to make things much more efficient, it would seem. So how do we get there?
Dialogue: 0,0:41:54.60,0:41:58.80,中文,,0,0,0,,这会让事情变得更有效率。那我们该怎么做呢？
Dialogue: 0,0:41:58.80,0:42:00.64,英文,,0,0,0,,So here's my computer's memory, as always.
Dialogue: 0,0:41:58.80,0:42:00.64,中文,,0,0,0,,和往常一样，这是我电脑的内存。
Dialogue: 0,0:42:00.64,0:42:06.44,英文,,0,0,0,,Suppose that I'm storing the value 1 somewhere in there, and it's at 0x123 address, whatever.
Dialogue: 0,0:42:00.64,0:42:06.44,中文,,0,0,0,,假设我把值 1 存储在某个地方，它的地址是 0x123，随便什么地址。
Dialogue: 0,0:42:06.44,0:42:13.63,英文,,0,0,0,,And I'm storing the number 2 somewhere else in memory, 0x456, and number 3 at address 0x789.
Dialogue: 0,0:42:06.44,0:42:13.63,中文,,0,0,0,,我把数字 2 存储在内存的另一个地方，地址是 0x456，数字 3 的地址是 0x789。
Dialogue: 0,0:42:13.63,0:42:15.89,英文,,0,0,0,,This is not an array by definition.
Dialogue: 0,0:42:13.63,0:42:15.89,中文,,0,0,0,,根据定义，这不是数组。
Dialogue: 0,0:42:15.89,0:42:21.61,英文,,0,0,0,,Why? Even though it's the only three things on the screen, what makes this not an array?
Dialogue: 0,0:42:15.89,0:42:20.63,中文,,0,0,0,,为什么？即使屏幕上只有这三样东西，是什么让它不是数组？
Dialogue: 0,0:42:21.61,0:42:22.53,英文,,0,0,0,,It's not contiguous.
Dialogue: 0,0:42:21.61,0:42:22.53,中文,,0,0,0,,它不是连续的。
Dialogue: 0,0:42:22.53,0:42:25.54,英文,,0,0,0,,So this violates the definition of an array.
Dialogue: 0,0:42:22.53,0:42:25.54,中文,,0,0,0,,这违反了数组的定义。
Dialogue: 0,0:42:25.54,0:42:30.36,英文,,0,0,0,,But you know, especially since they're sequential, it kind of looks to a human like a list.
Dialogue: 0,0:42:25.54,0:42:30.36,中文,,0,0,0,,但你知道，特别是当它们是连续的时候，在人类看来，它就像一个列表。
Dialogue: 0,0:42:30.36,0:42:33.18,英文,,0,0,0,,So it would be nice if there were a data type called list.
Dialogue: 0,0:42:30.36,0:42:33.18,中文,,0,0,0,,所以如果有一种数据类型叫做列表就好了。
Dialogue: 0,0:42:33.18,0:42:36.02,英文,,0,0,0,,And there isn't in C. There will be in Python.
Dialogue: 0,0:42:33.18,0:42:36.02,中文,,0,0,0,,C 语言里没有。Python 里会有。
Dialogue: 0,0:42:36.02,0:42:37.08,英文,,0,0,0,,But you know what?
Dialogue: 0,0:42:36.02,0:42:37.08,中文,,0,0,0,,但你知道吗？
Dialogue: 0,0:42:37.08,0:42:51.05,英文,,0,0,0,,If I could somehow stitch together these three values so I can get from one to the next to the next, then I think we could achieve the idea, the concept of a list, without this really annoying constraint that they all be contiguous as in an array.
Dialogue: 0,0:42:37.08,0:42:50.23,中文,,0,0,0,,如果我能以某种方式将这三个值连接起来，以便我能从一个值到下一个值，\N再到下一个值，那么我认为我们就可以实现列表的概念，而不需要像数组那样，所有值都必须是连续的这种烦人的约束。
Dialogue: 0,0:42:51.05,0:42:52.11,英文,,0,0,0,,So how do I do that?
Dialogue: 0,0:42:51.05,0:42:52.11,中文,,0,0,0,,那我该怎么做呢？
Dialogue: 0,0:42:52.11,0:42:55.93,英文,,0,0,0,,Well, at the end of the day, I only have memory at my disposal, right?
Dialogue: 0,0:42:52.11,0:42:55.93,中文,,0,0,0,,最后，我手上有的只有内存，对吧？
Dialogue: 0,0:42:55.93,0:42:59.05,英文,,0,0,0,,There's no more training wheels to take off here.
Dialogue: 0,0:42:55.93,0:42:59.05,中文,,0,0,0,,没有其他的辅助轮可以拆掉了。
Dialogue: 0,0:42:59.05,0:43:01.74,英文,,0,0,0,,This is what we've got underneath the hood of a computer.
Dialogue: 0,0:42:59.05,0:43:01.74,中文,,0,0,0,,这就是电脑内部的样子。
Dialogue: 0,0:43:01.74,0:43:11.06,英文,,0,0,0,,So if all I have is memory, I think the solution to this problem of stitching together those values in a list must be to spend a bit more memory.
Dialogue: 0,0:43:01.74,0:43:11.06,中文,,0,0,0,,所以如果我只有内存，我认为解决这个问题的方法，就是把列表中的值拼接起来，必须多花点内存。
Dialogue: 0,0:43:11.06,0:43:13.84,英文,,0,0,0,,That's list. Literally the only resource we have right now.
Dialogue: 0,0:43:11.06,0:43:13.84,中文,,0,0,0,,那就是列表。实际上是我们现在拥有的唯一资源。
Dialogue: 0,0:43:13.84,0:43:25.29,英文,,0,0,0,,So let me propose that if we want to create a list conceptually out of three values that are in random, although pictorially pretty, positions in memory, let me just add a little bit more memory to the picture.
Dialogue: 0,0:43:13.84,0:43:25.29,中文,,0,0,0,,假设我们想用三个值创建一个列表，这三个值位于内存中随机的位置，虽然看起来很漂亮，让我在图中再添加一点内存。
Dialogue: 0,0:43:25.29,0:43:32.01,英文,,0,0,0,,So in addition to storing the 1, I'm going to leave myself some room, a little scratch pad, if you will, to use some other bits as well.
Dialogue: 0,0:43:25.29,0:43:32.01,中文,,0,0,0,,所以除了存储 1 之外，我还将给自己留出一些空间，一个便签本，如果你愿意的话，也可以使用其他一些位。
Dialogue: 0,0:43:32.01,0:43:34.53,英文,,0,0,0,,Same for the 2, same for the 3.
Dialogue: 0,0:43:32.01,0:43:34.53,中文,,0,0,0,,2 也是一样，3 也是一样。
Dialogue: 0,0:43:34.53,0:43:38.62,英文,,0,0,0,,And you can perhaps see where this is going based on last week.
Dialogue: 0,0:43:34.53,0:43:38.62,中文,,0,0,0,,根据上周的内容，你可能已经知道接下来要做什么了。
Dialogue: 0,0:43:38.62,0:43:41.06,英文,,0,0,0,,If I want to somehow connect.
Dialogue: 0,0:43:38.62,0:43:40.46,中文,,0,0,0,,如果我想以某种方式连接。
Dialogue: 0,0:43:41.06,0:43:50.52,英文,,0,0,0,,The 1 to the 2, any instincts as to what I should write in this box here that would lead me effectively from 1 to the 2?
Dialogue: 0,0:43:41.06,0:43:50.52,中文,,0,0,0,,1 到 2，对于我要在这个框里写什么，才能有效地从 1 走到 2，有什么想法吗？
Dialogue: 0,0:43:50.52,0:43:53.38,英文,,0,0,0,,What could go here?
Dialogue: 0,0:43:50.52,0:43:53.38,中文,,0,0,0,,这里可以放什么？
Dialogue: 0,0:43:53.38,0:43:57.95,英文,,0,0,0,,Yeah?
Dialogue: 0,0:43:53.38,0:43:57.95,中文,,0,0,0,,嗯？
Dialogue: 0,0:43:57.95,0:44:06.29,英文,,0,0,0,,We could store the address of 2. And so specifically, what would you have me write here? Perfect.
Dialogue: 0,0:43:57.95,0:44:06.29,中文,,0,0,0,,我们可以存储 2 的地址。具体来说，你要我在这里写什么？很好。
Dialogue: 0,0:44:06.29,0:44:12.92,英文,,0,0,0,,Ideally, I would just put in this box another integer, one that happens to be represented in hexadecimal, but that's just a base system.
Dialogue: 0,0:44:06.29,0:44:12.92,中文,,0,0,0,,理想情况下，我只想在这个框里放另一个整数，一个恰好是用十六进制表示的整数，但这只是一个进制系统。
Dialogue: 0,0:44:12.92,0:44:15.36,英文,,0,0,0,,It's just a human thing for us to look at.
Dialogue: 0,0:44:12.92,0:44:15.36,中文,,0,0,0,,这只是我们人类看待事物的方式。
Dialogue: 0,0:44:15.36,0:44:18.04,英文,,0,0,0,,I'm going to put the value 0x456 here.
Dialogue: 0,0:44:15.36,0:44:18.04,中文,,0,0,0,,我要把值 0x456 放在这里。
Dialogue: 0,0:44:18.04,0:44:21.56,英文,,0,0,0,,So let me go ahead and reveal that. 0x456 goes there.
Dialogue: 0,0:44:18.04,0:44:21.56,中文,,0,0,0,,让我继续揭晓答案。0x456 在这里。
Dialogue: 0,0:44:21.56,0:44:23.26,英文,,0,0,0,,You can perhaps see further where this is going.
Dialogue: 0,0:44:21.56,0:44:23.26,中文,,0,0,0,,你可能已经猜到接下来要做什么了。
Dialogue: 0,0:44:23.26,0:44:30.91,英文,,0,0,0,,Well, if I want to get from the 2 to the 3, I think I need to put below the 2 the address of the 3, which gives me 0x789.
Dialogue: 0,0:44:23.26,0:44:30.91,中文,,0,0,0,,如果我想从 2 到 3，我想我需要在 2 的下面放上 3 的地址，也就是 0x789。
Dialogue: 0,0:44:30.91,0:44:33.13,英文,,0,0,0,,Now, if 3 is the end of the list,
Dialogue: 0,0:44:30.91,0:44:32.91,中文,,0,0,0,,如果 3 是列表的结尾，
Dialogue: 0,0:44:33.13,0:44:38.15,英文,,0,0,0,,I don't want to let it be some garbage value, because that would imply that who knows where it's pointing.
Dialogue: 0,0:44:33.13,0:44:38.15,中文,,0,0,0,,我不想让它是一个垃圾值，因为那意味着它指向的地方是未知的。
Dialogue: 0,0:44:38.15,0:44:39.41,英文,,0,0,0,,I need some definitive value.
Dialogue: 0,0:44:38.15,0:44:39.41,中文,,0,0,0,,我需要一个确定的值。
Dialogue: 0,0:44:39.41,0:44:41.15,英文,,0,0,0,,And just what would your instincts be?
Dialogue: 0,0:44:39.41,0:44:41.15,中文,,0,0,0,,你的直觉是什么？
Dialogue: 0,0:44:41.15,0:44:47.40,英文,,0,0,0,,If I want to make clear with some special sentinel value that the buck stops here, what do I put?
Dialogue: 0,0:44:41.15,0:44:47.40,中文,,0,0,0,,如果我想用一个特殊的哨兵值来明确表示到此为止，我应该放什么？
Dialogue: 0,0:44:47.40,0:44:49.30,英文,,0,0,0,,What might my options be?
Dialogue: 0,0:44:47.40,0:44:48.38,中文,,0,0,0,,我有哪些选择？
Dialogue: 0,0:44:49.30,0:45:03.92,英文,,0,0,0,,Yeah, so null, not N-U-L per se, but N-U-L-L, which was the new keyword we introduced last week, which just represents an empty pointer, if you will, technically the address 0x0, so literally the 0 address.
Dialogue: 0,0:44:49.30,0:45:03.92,中文,,0,0,0,,可以使用 `NULL`，不是 N-U-L，而是 N-U-L-L，这是我们上周介绍的新关键字，它表示一个空指针，技术上是地址 0x0，也就是 0 地址。
Dialogue: 0,0:45:03.92,0:45:06.70,英文,,0,0,0,,And what humans did years ago, they just decided, you know what?
Dialogue: 0,0:45:03.92,0:45:06.24,中文,,0,0,0,,多年前，人们就决定，
Dialogue: 0,0:45:06.70,0:45:09.84,英文,,0,0,0,,Nothing should ever live at address 0 in memory.
Dialogue: 0,0:45:06.70,0:45:09.84,中文,,0,0,0,,内存地址 0 中不应该有任何东西。
Dialogue: 0,0:45:09.84,0:45:19.63,英文,,0,0,0,,We're just going to reserve that one special byte to be a special signal, a sentinel value, such that if you ever see a 0 address in a pointer, it just means it's invalid.
Dialogue: 0,0:45:09.84,0:45:19.63,中文,,0,0,0,,我们将保留这一个特殊的字节作为特殊的信号，一个哨兵值，这样当你看到指针中的 0 地址时，就意味着它是无效的。
Dialogue: 0,0:45:19.63,0:45:20.79,英文,,0,0,0,,It does not exist.
Dialogue: 0,0:45:19.63,0:45:20.79,中文,,0,0,0,,它不存在。
Dialogue: 0,0:45:20.79,0:45:25.78,英文,,0,0,0,,Now, we write that, though, a little more pleasantly for the eyes as just N-U-L-L in all caps.
Dialogue: 0,0:45:20.79,0:45:25.78,中文,,0,0,0,,不过，为了看起来更舒服，我们把它写成全部大写的 `NULL`。
Dialogue: 0,0:45:25.78,0:45:27.56,英文,,0,0,0,,And that's a keyword in C as well.
Dialogue: 0,0:45:25.78,0:45:27.56,中文,,0,0,0,,这也是 C 语言中的一个关键字。
Dialogue: 0,0:45:27.56,0:45:29.38,英文,,0,0,0,,But of course, last week, I claimed that,
Dialogue: 0,0:45:27.56,0:45:28.86,中文,,0,0,0,,但当然，上周我说过，
Dialogue: 0,0:45:29.38,0:45:31.14,英文,,0,0,0,,Who cares where things are in memory?
Dialogue: 0,0:45:29.38,0:45:31.14,中文,,0,0,0,,谁在乎东西在内存中的位置？
Dialogue: 0,0:45:31.14,0:45:34.79,英文,,0,0,0,,And honestly, this quickly gets tedious even worrying about these values.
Dialogue: 0,0:45:31.14,0:45:34.79,中文,,0,0,0,,老实说，即使是担心这些值也很快就会变得乏味。
Dialogue: 0,0:45:34.79,0:45:47.25,英文,,0,0,0,,So let me abstract this away and propose that if we want to remember where all of these numbers are in memory, let's give ourselves one final piece of memory that just allows us to start the whole process.
Dialogue: 0,0:45:34.79,0:45:47.25,中文,,0,0,0,,让我把这些抽象出来，并提出一个建议：如果我们想记住所有这些数字在内存中的位置，我们就给自己最后一块内存，让我们可以开始整个过程。
Dialogue: 0,0:45:47.25,0:45:54.04,英文,,0,0,0,,Let me allocate on the left-hand side here not room for a number, like 1, 2, 3, just room for a pointer.
Dialogue: 0,0:45:47.25,0:45:53.52,中文,,0,0,0,,让我在左侧这里分配空间，不是放数字 1、2、3，而是放指针。
Dialogue: 0,0:45:54.04,0:46:03.32,英文,,0,0,0,,that, henceforth, I think I'll call list by convention, and then store in that one additional pointer a value that just kickstarts the whole process.
Dialogue: 0,0:45:54.04,0:46:03.32,中文,,0,0,0,,我把它称为 `list`，然后在这个额外的指针中存储一个值，用来启动整个过程。
Dialogue: 0,0:46:03.32,0:46:06.50,英文,,0,0,0,,This is the sort of treasure map, if you will, that you get handed.
Dialogue: 0,0:46:03.32,0:46:06.50,中文,,0,0,0,,这就是你得到的藏宝图。
Dialogue: 0,0:46:06.50,0:46:11.96,英文,,0,0,0,,And this has the address of the very first actual node in memory.
Dialogue: 0,0:46:06.50,0:46:11.96,中文,,0,0,0,,这指向了内存中第一个实际节点的地址。
Dialogue: 0,0:46:11.96,0:46:13.63,英文,,0,0,0,,Now, technically, we could just start with this.
Dialogue: 0,0:46:11.96,0:46:13.63,中文,,0,0,0,,从技术上讲，我们可以从这里开始。
Dialogue: 0,0:46:13.63,0:46:18.25,英文,,0,0,0,,But it turns out, we'll see, it's just a little cleaner to use a simple single pointer.
Dialogue: 0,0:46:13.63,0:46:17.85,中文,,0,0,0,,但事实证明，我们会发现，使用一个简单的指针会更简洁一些。
Dialogue: 0,0:46:18.25,0:46:22.31,英文,,0,0,0,,That leads to the things you care about, as opposed to just starting with the first element.
Dialogue: 0,0:46:18.25,0:46:22.31,中文,,0,0,0,,它指向你关心的东西，而不是从第一个元素开始。
Dialogue: 0,0:46:22.31,0:46:22.93,英文,,0,0,0,,Why?
Dialogue: 0,0:46:22.31,0:46:22.93,中文,,0,0,0,,为什么？
Dialogue: 0,0:46:22.93,0:46:31.49,英文,,0,0,0,,Well, if you ever want to get rid of this element, it'd be nice if you could at least still hang on to an empty sheet of paper that indicates that the list is empty, would be one argument for that.
Dialogue: 0,0:46:22.93,0:46:31.49,中文,,0,0,0,,如果你想删除这个元素，最好还是保留一张空纸，表示列表为空，这就是其中一个理由。
Dialogue: 0,0:46:31.49,0:46:33.73,英文,,0,0,0,,So again, who cares about these addresses now?
Dialogue: 0,0:46:31.49,0:46:33.73,中文,,0,0,0,,再说一次，现在谁还在乎这些地址呢？
Dialogue: 0,0:46:33.73,0:46:36.95,英文,,0,0,0,,Now, with the wave of the hand, let's just abstract it away.
Dialogue: 0,0:46:33.73,0:46:36.95,中文,,0,0,0,,现在，挥挥手，让我们把它抽象出来。
Dialogue: 0,0:46:36.95,0:46:38.83,英文,,0,0,0,,And there are our pointers.
Dialogue: 0,0:46:36.95,0:46:38.57,中文,,0,0,0,,这就是我们的指针。
Dialogue: 0,0:46:38.83,0:46:46.48,英文,,0,0,0,,Each of those addresses in the squares at the bottom are simply pointing to the next element in the list.
Dialogue: 0,0:46:38.83,0:46:46.48,中文,,0,0,0,,底部方块中的每个地址都指向列表中的下一个元素。
Dialogue: 0,0:46:46.48,0:47:00.51,英文,,0,0,0,,The jargon to introduce here would be that now that we have these integers, 1, 2, 3, but they're in these wrappers, if you will, these structures that have metadata, that is additional data that is related to, but not the data you actually care about.
Dialogue: 0,0:46:46.48,0:47:00.51,中文,,0,0,0,,这里要介绍的行话是，现在我们有了这些整数，1、2、3，但它们在这些包装器中，\N你可以称之为结构体，它们包含元数据，这些元数据与数据相关，但不是你真正关心的数据。
Dialogue: 0,0:47:00.51,0:47:01.19,英文,,0,0,0,,This is data.
Dialogue: 0,0:47:00.51,0:47:01.19,中文,,0,0,0,,这是数据。
Dialogue: 0,0:47:01.19,0:47:02.43,英文,,0,0,0,,This is metadata.
Dialogue: 0,0:47:01.19,0:47:01.95,中文,,0,0,0,,这是元数据。
Dialogue: 0,0:47:02.43,0:47:06.28,英文,,0,0,0,,This thing here, rectangularly, we'll call a node, N-O-D-E.
Dialogue: 0,0:47:02.43,0:47:06.28,中文,,0,0,0,,我们将这个矩形的东西称为节点，N-O-D-E。
Dialogue: 0,0:47:06.28,0:47:12.31,英文,,0,0,0,,And it's just a term of art that means it's like a container in code for storing some values.
Dialogue: 0,0:47:06.28,0:47:11.10,中文,,0,0,0,,它只是一个艺术术语，意思是它就像代码中的一个容器，用于存储一些值。
Dialogue: 0,0:47:12.31,0:47:14.24,英文,,0,0,0,,This, then, is a linked list.
Dialogue: 0,0:47:12.31,0:47:14.24,中文,,0,0,0,,这就是链表。
Dialogue: 0,0:47:14.24,0:47:20.30,英文,,0,0,0,,And this, then, is the graphical incarnation of one node pointing to the other.
Dialogue: 0,0:47:14.24,0:47:20.30,中文,,0,0,0,,这就是一个节点指向另一个节点的图形化表示。
Dialogue: 0,0:47:20.30,0:47:25.63,英文,,0,0,0,,In this case, they happen to be, by chance and by design of this desk, contiguous initially.
Dialogue: 0,0:47:20.30,0:47:25.63,中文,,0,0,0,,在这种情况下，它们碰巧是连续的，这既是偶然的，也是这块桌面的设计使然。
Dialogue: 0,0:47:25.63,0:47:27.47,英文,,0,0,0,,But there's no requirement that they be such.
Dialogue: 0,0:47:25.63,0:47:27.47,中文,,0,0,0,,但这并没有要求它们必须如此。
Dialogue: 0,0:47:27.47,0:47:29.79,英文,,0,0,0,,The 1 could be over there, the 2 over there, the 3 over there.
Dialogue: 0,0:47:27.47,0:47:29.79,中文,,0,0,0,,1 可以在那里，2 在那里，3 在那里。
Dialogue: 0,0:47:29.79,0:47:33.59,英文,,0,0,0,,I would just need more foam fingers to point at one to the next.
Dialogue: 0,0:47:29.79,0:47:33.59,中文,,0,0,0,,我只需要更多泡沫手指来依次指向它们。
Dialogue: 0,0:47:33.59,0:47:38.14,英文,,0,0,0,,Questions on this concept of a linked list?
Dialogue: 0,0:47:33.59,0:47:38.14,中文,,0,0,0,,关于链表的概念，大家有什么问题吗？
Dialogue: 0,0:47:38.14,0:47:45.31,英文,,0,0,0,,Yeah, in back. Can you say that again?
Dialogue: 0,0:47:38.14,0:47:45.31,中文,,0,0,0,,有的，后面那位同学，你能再说一遍吗？
Dialogue: 0,0:47:51.03,0:47:55.36,英文,,0,0,0,,A good question, do traditional arrays start with a pointer that's outside of the structure?
Dialogue: 0,0:47:51.03,0:47:55.36,中文,,0,0,0,,问得好，传统的数组是否以一个结构外部的指针开头？
Dialogue: 0,0:47:55.36,0:47:56.54,英文,,0,0,0,,Short answer, no.
Dialogue: 0,0:47:55.36,0:47:56.54,中文,,0,0,0,,简短的回答，不是。
Dialogue: 0,0:47:56.54,0:48:00.40,英文,,0,0,0,,Arrays are special in C and certain other languages.
Dialogue: 0,0:47:56.54,0:48:00.40,中文,,0,0,0,,数组在 C 和其他某些语言中比较特殊。
Dialogue: 0,0:48:00.40,0:48:08.70,英文,,0,0,0,,And the name of an array is technically a symbol, if you will, that the program knows maps to a specific location in memory.
Dialogue: 0,0:48:00.40,0:48:08.70,中文,,0,0,0,,数组的名称实际上是一个符号，如果你愿意，程序知道它映射到内存中的特定位置。
Dialogue: 0,0:48:08.70,0:48:12.66,英文,,0,0,0,,It's just a label, a synonym for a memory address.
Dialogue: 0,0:48:08.70,0:48:12.66,中文,,0,0,0,,它只是一个标签，一个内存地址的同义词。
Dialogue: 0,0:48:12.66,0:48:14.32,英文,,0,0,0,,It does not take up space.
Dialogue: 0,0:48:12.66,0:48:14.32,中文,,0,0,0,,它不占用空间。
Dialogue: 0,0:48:14.32,0:48:19.69,英文,,0,0,0,,So to be clear, the name of an array does not take up space like that extra square on the left.
Dialogue: 0,0:48:14.32,0:48:19.69,中文,,0,0,0,,明确地说，数组的名称不像左边那个额外的方块那样占用空间。
Dialogue: 0,0:48:19.69,0:48:29.61,英文,,0,0,0,,But you do need that extra square on the left when implementing a linked list so that you can determine if the list is of size 0, there's nothing being pointed at, or size 3 in this case.
Dialogue: 0,0:48:19.69,0:48:29.61,中文,,0,0,0,,但是在实现链表时，确实需要左边那个额外的方块，以便确定链表的大小是 0，也就是没有指向任何元素，或者像现在这样是 3。
Dialogue: 0,0:48:29.61,0:48:32.95,英文,,0,0,0,,We're sort of taking on more responsibility ourselves.
Dialogue: 0,0:48:29.61,0:48:32.95,中文,,0,0,0,,我们自己承担了更多责任。
Dialogue: 0,0:48:32.95,0:48:39.88,英文,,0,0,0,,Yeah?
Dialogue: 0,0:48:32.95,0:48:39.88,中文,,0,0,0,,是吗？
Dialogue: 0,0:48:39.88,0:48:42.00,英文,,0,0,0,,How do you point to the next element? Can you elaborate?
Dialogue: 0,0:48:39.88,0:48:42.00,中文,,0,0,0,,如何指向下一个元素？ 你能详细说明一下吗？
Dialogue: 0,0:48:47.98,0:48:48.54,英文,,0,0,0,,Good question.
Dialogue: 0,0:48:47.98,0:48:48.54,中文,,0,0,0,,问得好。
Dialogue: 0,0:48:48.54,0:48:52.54,英文,,0,0,0,,If each of these elements is pointing to the next, how does 3 point to the others?
Dialogue: 0,0:48:48.54,0:48:52.54,中文,,0,0,0,,如果这些元素中的每一个都指向下一个元素，那么 3 如何指向其他元素？
Dialogue: 0,0:48:52.54,0:48:53.84,英文,,0,0,0,,Short answer, it doesn't.
Dialogue: 0,0:48:52.54,0:48:53.84,中文,,0,0,0,,简单地说，它不指向。
Dialogue: 0,0:48:53.84,0:48:58.51,英文,,0,0,0,,At least in this design, we have more technically what's called a singly-linked list.
Dialogue: 0,0:48:53.84,0:48:58.51,中文,,0,0,0,,至少在这个设计中，我们更多的是技术上称为单向链表的东西。
Dialogue: 0,0:48:58.51,0:49:01.43,英文,,0,0,0,,And as the arrows imply, it only goes in one direction.
Dialogue: 0,0:48:58.51,0:49:01.43,中文,,0,0,0,,正如箭头所示，它只有一个方向。
Dialogue: 0,0:49:01.43,0:49:15.12,英文,,0,0,0,,So if you somehow find in code maybe a for loop, maybe a while loop, somehow you're sort of in code over here, you have no way in code to go backwards unless we change this to a doubly-linked list where I add another box.
Dialogue: 0,0:49:01.43,0:49:15.12,中文,,0,0,0,,如果你在代码中找到了一个 for 循环，也许是一个 while 循环，\N不知何故你在代码中到了这里，你无法在代码中往回走，除非我们把它改成双向链表，我再加一个框。
Dialogue: 0,0:49:15.12,0:49:17.64,英文,,0,0,0,,That lets me have arrows in both directions.
Dialogue: 0,0:49:15.12,0:49:17.64,中文,,0,0,0,,这让我可以双向使用箭头。
Dialogue: 0,0:49:17.64,0:49:25.06,英文,,0,0,0,,Or maybe I just kind of make it circular, and I connect the 3 back to the 1, which you can totally do.
Dialogue: 0,0:49:17.64,0:49:25.06,中文,,0,0,0,,或者我可以把它弄成圆形，然后把 3 连接回 1，你完全可以这样做。
Dialogue: 0,0:49:25.06,0:49:30.06,英文,,0,0,0,,But that tends to make life harder, because now you have to figure out when you're stuck in a loop in your data structure.
Dialogue: 0,0:49:25.06,0:49:30.06,中文,,0,0,0,,但这往往会让事情变得更难，因为现在你必须弄清楚什么时候你的数据结构陷入了循环。
Dialogue: 0,0:49:30.06,0:49:31.27,英文,,0,0,0,,But it's doable as well.
Dialogue: 0,0:49:30.06,0:49:31.27,中文,,0,0,0,,但这也是可行的。
Dialogue: 0,0:49:31.27,0:49:34.57,英文,,0,0,0,,But as is, it's a dead end by design.
Dialogue: 0,0:49:31.27,0:49:34.57,中文,,0,0,0,,但照目前的情况来看，它在设计上就是一个死胡同。
Dialogue: 0,0:49:34.57,0:49:39.92,英文,,0,0,0,,Other questions on this design here?
Dialogue: 0,0:49:34.57,0:49:39.92,中文,,0,0,0,,关于这个设计还有其他问题吗？
Dialogue: 0,0:49:39.92,0:49:42.45,英文,,0,0,0,,All right, well, how might we implement this structure in code?
Dialogue: 0,0:49:39.92,0:49:42.45,中文,,0,0,0,,那么，我们如何用代码实现这个结构呢？
Dialogue: 0,0:49:42.45,0:49:46.15,英文,,0,0,0,,Well, let me just connect the dots to something like we've seen before here.
Dialogue: 0,0:49:42.45,0:49:46.15,中文,,0,0,0,,让我把它和我们以前见过的一些东西联系起来。
Dialogue: 0,0:49:46.15,0:49:50.77,英文,,0,0,0,,Like, this is how, a couple of weeks ago, we introduced the notion of a person.
Dialogue: 0,0:49:46.15,0:49:50.77,中文,,0,0,0,,就像几周前，我们介绍了 person 的概念。
Dialogue: 0,0:49:50.77,0:49:53.40,英文,,0,0,0,,And we claimed a person might have a name and a number.
Dialogue: 0,0:49:50.77,0:49:53.40,中文,,0,0,0,,我们声称一个人可能有一个名字和一个数字。
Dialogue: 0,0:49:53.40,0:49:55.54,英文,,0,0,0,,Last week, of course, we took off some of these training wheels.
Dialogue: 0,0:49:53.40,0:49:55.54,中文,,0,0,0,,当然，上周我们去掉了一些辅助轮。
Dialogue: 0,0:49:55.54,0:49:59.14,英文,,0,0,0,,And a string is really technically a char star in both cases.
Dialogue: 0,0:49:55.54,0:49:59.14,中文,,0,0,0,,从技术上讲，字符串实际上在两种情况下都是 `char *`。
Dialogue: 0,0:49:59.14,0:50:01.80,英文,,0,0,0,,But really, there's no conceptual difference beyond that.
Dialogue: 0,0:49:59.14,0:50:01.80,中文,,0,0,0,,但实际上，除此之外没有概念上的区别。
Dialogue: 0,0:50:01.80,0:50:03.37,英文,,0,0,0,,But let's use this same code.
Dialogue: 0,0:50:01.80,0:50:03.37,中文,,0,0,0,,但让我们使用相同的代码。
Dialogue: 0,0:50:03.37,0:50:07.93,英文,,0,0,0,,It's a paradigm to implement a node, as I described it in that picture.
Dialogue: 0,0:50:03.37,0:50:07.93,中文,,0,0,0,,正如我在那张图中描述的那样，这是一种实现节点的范式。
Dialogue: 0,0:50:07.93,0:50:11.51,英文,,0,0,0,,So let me get rid of the name and the number, because that's related only to a person.
Dialogue: 0,0:50:07.93,0:50:11.51,中文,,0,0,0,,所以让我去掉名字和数字，因为这仅与人相关。
Dialogue: 0,0:50:11.51,0:50:15.65,英文,,0,0,0,,And let me rename this structure, for discussion's sake, to node.
Dialogue: 0,0:50:11.51,0:50:15.65,中文,,0,0,0,,为了便于讨论，让我将此结构重命名为 node。
Dialogue: 0,0:50:15.65,0:50:20.17,英文,,0,0,0,,That then invites the question, well, what needs to go inside of a node?
Dialogue: 0,0:50:15.65,0:50:20.17,中文,,0,0,0,,这就引出了一个问题，根据我们绘制的这些矩形图片，节点内部至少需要包含什么？
Dialogue: 0,0:50:20.17,0:50:23.18,英文,,0,0,0,,Well, minimally, an integer.
Dialogue: 0,0:50:20.17,0:50:23.18,中文,,0,0,0,,至少是一个整数。
Dialogue: 0,0:50:23.18,0:50:36.59,英文,,0,0,0,,But this is now where we need to think a little harder, just conceptually, even if you have no idea how to type it at the keyboard, what else needs to be part of a node based on these rectangular pictures that we've drawn?
Dialogue: 0,0:50:23.18,0:50:36.59,中文,,0,0,0,,但这就是我们需要更加深入思考的地方，仅仅在概念上，\N即使你不知道如何在键盘上输入，根据我们绘制的这些矩形图片，还需要哪些东西成为节点的一部分？
Dialogue: 0,0:50:36.59,0:50:42.56,英文,,0,0,0,,What more do we need? Yeah, we need a pointer to another node.
Dialogue: 0,0:50:36.59,0:50:42.56,中文,,0,0,0,,还需要什么？需要一个指向另一个节点的指针。
Dialogue: 0,0:50:42.56,0:50:48.99,英文,,0,0,0,,So if I don't know how to implement this yet, it could be something like pointer to another node.
Dialogue: 0,0:50:42.56,0:50:48.99,中文,,0,0,0,,如果我还不知道如何实现它，它可能类似于指向另一个节点的指针。
Dialogue: 0,0:50:48.99,0:50:49.79,英文,,0,0,0,,How do I do that?
Dialogue: 0,0:50:48.99,0:50:49.79,中文,,0,0,0,,我该怎么做？
Dialogue: 0,0:50:49.79,0:50:50.79,英文,,0,0,0,,Well, you know what?
Dialogue: 0,0:50:49.79,0:50:50.79,中文,,0,0,0,,你知道吗？
Dialogue: 0,0:50:50.79,0:50:56.59,英文,,0,0,0,,It turns out you would ideally say this, if you know that the next node
Dialogue: 0,0:50:50.79,0:50:56.59,中文,,0,0,0,,理想情况下，如果你知道下一个节点，你会这样说
Dialogue: 0,0:50:56.59,0:50:58.93,英文,,0,0,0,,Is itself a node, by definition?
Dialogue: 0,0:50:56.59,0:50:58.93,中文,,0,0,0,,根据定义，它本身就是一个节点？
Dialogue: 0,0:50:58.93,0:51:02.95,英文,,0,0,0,,Well, any time we've needed a pointer, we just use the data type and a star.
Dialogue: 0,0:50:58.93,0:51:02.95,中文,,0,0,0,,每当我们需要一个指针时，我们只需使用数据类型和一个星号。
Dialogue: 0,0:51:02.95,0:51:11.94,英文,,0,0,0,,And I'm going to arbitrarily, but I think reasonably, call this second square at the bottom of those rectangles next, as the name of my attribute here.
Dialogue: 0,0:51:02.95,0:51:11.94,中文,,0,0,0,,我要随意地，但我认为合理地，将这些矩形底部第二个方块称为 next，作为我这里属性的名称。
Dialogue: 0,0:51:11.94,0:51:19.16,英文,,0,0,0,,But node star just connotes that the next variable is going to be not a node, per se, but the address of a node.
Dialogue: 0,0:51:11.94,0:51:19.16,中文,,0,0,0,,但是 node star 只是表示下一个变量本身不是一个节点，而是一个节点的地址。
Dialogue: 0,0:51:19.16,0:51:20.40,英文,,0,0,0,,And that's exactly what we did.
Dialogue: 0,0:51:19.16,0:51:20.40,中文,,0,0,0,,这正是我们所做的。
Dialogue: 0,0:51:20.40,0:51:26.31,英文,,0,0,0,,You had me put 0x456, 0x789 in that box, which is the address of another node.
Dialogue: 0,0:51:20.40,0:51:26.31,中文,,0,0,0,,你让我在那个方框中放入 0x456, 0x789，这是另一个节点的地址。
Dialogue: 0,0:51:26.31,0:51:30.85,英文,,0,0,0,,So the way we would express this in code would be node star next.
Dialogue: 0,0:51:26.31,0:51:30.85,中文,,0,0,0,,所以我们用代码表示这个的方式是 node *next。
Dialogue: 0,0:51:30.85,0:51:33.87,英文,,0,0,0,,But we could call the variable anything we want.
Dialogue: 0,0:51:30.85,0:51:33.87,中文,,0,0,0,,但是我们可以随意命名这个变量。
Dialogue: 0,0:51:33.87,0:51:36.05,英文,,0,0,0,,Now, this is a bit of a white lie.
Dialogue: 0,0:51:33.87,0:51:36.05,中文,,0,0,0,,现在，这有点谎言。
Dialogue: 0,0:51:36.05,0:51:39.47,英文,,0,0,0,,But we'll fix this right now. This code won't actually compile.
Dialogue: 0,0:51:36.05,0:51:39.47,中文,,0,0,0,,但我们现在就修复它。这段代码实际上无法编译。
Dialogue: 0,0:51:39.47,0:51:41.87,英文,,0,0,0,,C takes you pretty literally, recall.
Dialogue: 0,0:51:39.47,0:51:41.87,中文,,0,0,0,,回想一下，C 语言对你的要求非常严格。
Dialogue: 0,0:51:41.87,0:51:49.03,英文,,0,0,0,,And if you use some term at the top of your file that you don't define until later in your file, you're going to see some error message, right?
Dialogue: 0,0:51:41.87,0:51:49.03,中文,,0,0,0,,如果在文件的顶部使用了某个术语，而直到文件的后面才定义它，就会看到一些错误消息，对吧？
Dialogue: 0,0:51:49.03,0:51:53.60,英文,,0,0,0,,We've seen this when I've messed up and I forgot to include the function prototypes at the top of my code.
Dialogue: 0,0:51:49.03,0:51:53.60,中文,,0,0,0,,当我搞砸了，忘记在我的代码顶部包含函数原型时，我们就看到过这种情况。
Dialogue: 0,0:51:53.60,0:51:55.18,英文,,0,0,0,,This is related in spirit.
Dialogue: 0,0:51:53.60,0:51:55.18,中文,,0,0,0,,这在精神上是相关的。
Dialogue: 0,0:51:55.18,0:52:04.40,英文,,0,0,0,,I seem here on my 1, 2, 3, 4th line of code, I'm trying to use this new term of art that I invented here in my code called node, even though it's a CS term as well.
Dialogue: 0,0:51:55.18,0:52:04.40,中文,,0,0,0,,在我代码的第 1、2、3、4 行，我似乎试图使用我在代码中发明的这个新术语 node，尽管它也是一个计算机科学术语。
Dialogue: 0,0:52:04.40,0:52:08.42,英文,,0,0,0,,But nowhere above this, it would seem, did I even define what a node is.
Dialogue: 0,0:52:04.40,0:52:08.42,中文,,0,0,0,,但上面好像没有定义节点是什么。
Dialogue: 0,0:52:08.42,0:52:14.33,英文,,0,0,0,,It's not a data type in C. Every computer scientist knows what a node is, but it doesn't come for free with the language.
Dialogue: 0,0:52:08.42,0:52:14.33,中文,,0,0,0,,它不是 C 语言中的数据类型，每个计算机科学家都知道节点是什么，但它不是语言自带的。
Dialogue: 0,0:52:14.33,0:52:16.17,英文,,0,0,0,,So I need to do something else.
Dialogue: 0,0:52:14.33,0:52:16.17,中文,,0,0,0,,所以我需要做些别的事情。
Dialogue: 0,0:52:16.17,0:52:20.33,英文,,0,0,0,,Like, I need this word here to come first so that I can use it here.
Dialogue: 0,0:52:16.17,0:52:20.33,中文,,0,0,0,,比如，我需要先定义这个词，才能在这里使用它。
Dialogue: 0,0:52:20.33,0:52:22.01,英文,,0,0,0,,And so we have this sort of catch-22.
Dialogue: 0,0:52:20.33,0:52:22.01,中文,,0,0,0,,所以我们遇到了这种“第二十二条军规”。
Dialogue: 0,0:52:22.01,0:52:30.54,英文,,0,0,0,,Like, how can a structure be self-referential, that is, point to another version of itself, if the word doesn't yet exist?
Dialogue: 0,0:52:22.01,0:52:30.54,中文,,0,0,0,,就是说，如果这个词还不存在，一个结构体怎么能自引用，也就是指向另一个自身的版本呢？
Dialogue: 0,0:52:30.54,0:52:34.64,英文,,0,0,0,,So the solution to this in C, which we didn't need for a person,
Dialogue: 0,0:52:30.54,0:52:34.64,中文,,0,0,0,,所以在 C 语言中，这个问题的解决方案，我们不需要对一个人做，
Dialogue: 0,0:52:34.64,0:52:41.38,英文,,0,0,0,,Because there was no notion of connecting as a list, we need one more keyword here that we didn't need for a person.
Dialogue: 0,0:52:34.64,0:52:41.38,中文,,0,0,0,,因为没有连接成列表的概念，我们需要在这里多加一个对一个人来说不需要的关键字。
Dialogue: 0,0:52:41.38,0:52:43.56,英文,,0,0,0,,And we reuse that keyword here.
Dialogue: 0,0:52:41.38,0:52:43.56,中文,,0,0,0,,我们在这里重复使用这个关键字。
Dialogue: 0,0:52:43.56,0:52:45.45,英文,,0,0,0,,So kind of an annoying detail.
Dialogue: 0,0:52:43.56,0:52:45.45,中文,,0,0,0,,所以这有点烦人。
Dialogue: 0,0:52:45.45,0:52:54.51,英文,,0,0,0,,But if we preemptively call this whole thing struct node, you can now refer to the thing on the inside as a struct node star.
Dialogue: 0,0:52:45.45,0:52:54.51,中文,,0,0,0,,但如果我们预先把整个东西叫做 struct node，你现在就可以把里面的东西称为 struct node *。
Dialogue: 0,0:52:54.51,0:53:01.59,英文,,0,0,0,,But then you can shorten the name of the whole thing from struct node to just node, sort of an annoying sequence of steps.
Dialogue: 0,0:52:54.51,0:53:01.59,中文,,0,0,0,,但之后你可以把整个东西的名字从 struct node 缩短成 node，这一系列步骤有点烦人。
Dialogue: 0,0:53:01.59,0:53:06.31,英文,,0,0,0,,But in short, any time you're building a node, a linked list in memory, this is just the paradigm.
Dialogue: 0,0:53:01.59,0:53:06.31,中文,,0,0,0,,但简而言之，任何时候你在内存中构建一个节点，一个链表，这就是范式。
Dialogue: 0,0:53:06.31,0:53:10.22,英文,,0,0,0,,You use typedef, struct, the name of the thing you want to define, like node.
Dialogue: 0,0:53:06.31,0:53:10.22,中文,,0,0,0,,你使用 typedef，struct，你想定义的东西的名称，比如 node。
Dialogue: 0,0:53:10.22,0:53:14.20,英文,,0,0,0,,You use that name on the inside if you want to point from one to another.
Dialogue: 0,0:53:10.22,0:53:14.20,中文,,0,0,0,,如果你想从一个指向另一个，就在里面使用这个名字。
Dialogue: 0,0:53:14.20,0:53:18.92,英文,,0,0,0,,And then you can shorten it down here to just be called node.
Dialogue: 0,0:53:14.20,0:53:18.92,中文,,0,0,0,,然后你可以把它缩短为 node。
Dialogue: 0,0:53:18.92,0:53:23.72,英文,,0,0,0,,Questions, then, on this code here?
Dialogue: 0,0:53:18.92,0:53:23.72,中文,,0,0,0,,那么，关于这段代码，有问题吗？
Dialogue: 0,0:53:23.72,0:53:26.65,英文,,0,0,0,,Questions on what we just did?
Dialogue: 0,0:53:23.72,0:53:26.65,中文,,0,0,0,,对我们刚才做的事有问题吗？
Dialogue: 0,0:53:26.65,0:53:37.14,英文,,0,0,0,,Well, if I rewind just a moment to that final picture, what would be the upside, to be clear, of having jumped through these hoops and added this complexity, if you will?
Dialogue: 0,0:53:26.65,0:53:37.14,中文,,0,0,0,,如果我把时间倒回到最后一张图，很明显，如果我们费了这么大劲，增加了这种复杂性，好处是什么？
Dialogue: 0,0:53:37.14,0:53:42.06,英文,,0,0,0,,What problem did we just solve by linking together these three values, to be clear?
Dialogue: 0,0:53:37.14,0:53:42.06,中文,,0,0,0,,明确地说，我们把这三个值链接在一起解决了什么问题？
Dialogue: 0,0:53:42.06,0:53:50.06,英文,,0,0,0,,Yeah? Making lists that are? That are not contiguous, if you will.
Dialogue: 0,0:53:42.06,0:53:50.06,中文,,0,0,0,,嗯？创建了不连续的列表？
Dialogue: 0,0:53:50.06,0:54:00.67,英文,,0,0,0,,So making lists that are not contiguous in memory, the upside of which is that if I want to add the number 4 to this list, it looks like I can choose from any chunks of available memory on the screen.
Dialogue: 0,0:53:50.06,0:54:00.67,中文,,0,0,0,,创建了在内存中不连续的列表，这样做的好处是，如果我想在这个列表中添加数字 4，看起来我可以从屏幕上任何可用的内存块中选择。
Dialogue: 0,0:54:00.67,0:54:06.23,英文,,0,0,0,,I just need to sort of point from the end of the current list to wherever that other one is in memory.
Dialogue: 0,0:54:00.67,0:54:06.23,中文,,0,0,0,,我只需要从当前列表的末尾指向内存中另一个列表的位置。
Dialogue: 0,0:54:06.23,0:54:10.29,英文,,0,0,0,,What I don't need to do, to be clear, is copy the 1, the 2, or the 3.
Dialogue: 0,0:54:06.23,0:54:10.29,中文,,0,0,0,,需要明确的是，我不需要做的是， 复制数字 1、2 或 3。
Dialogue: 0,0:54:10.29,0:54:21.78,英文,,0,0,0,,Everything can just stay put, which means time-wise, I can do this much more quickly, it would seem, without copying things again and again, and even without using realloc to let it do all of the copying potentially for me.
Dialogue: 0,0:54:10.29,0:54:21.78,中文,,0,0,0,,所有内容都可以保持原样，这意味着在时间上，我可以更快地完成这个操作，\N似乎不需要一次又一次地复制内容，甚至不需要使用 realloc 来为我完成所有潜在的复制操作。
Dialogue: 0,0:54:21.78,0:54:28.56,英文,,0,0,0,,All right, but as we'll start seeing even more in the coming weeks, every time we benefit and solve some problem, we pay a price.
Dialogue: 0,0:54:21.78,0:54:28.56,中文,,0,0,0,,但正如我们在接下来的几周里将会看到的那样，每次我们受益并解决某个问题时，我们都要付出代价。
Dialogue: 0,0:54:28.56,0:54:29.92,英文,,0,0,0,,There's a trade-off.
Dialogue: 0,0:54:28.56,0:54:29.92,中文,,0,0,0,,这是一个权衡。
Dialogue: 0,0:54:29.92,0:54:38.05,英文,,0,0,0,,What is a downside, as you might perceive now, of using a linked list instead of an array?
Dialogue: 0,0:54:29.92,0:54:38.05,中文,,0,0,0,,你现在认为使用链表而不是数组的缺点是什么？
Dialogue: 0,0:54:38.05,0:54:45.19,英文,,0,0,0,,Yeah, I mean, we use twice as much memory because now, in addition to storing the integers 1, 2, 3, I also need to store a pointer for each of those.
Dialogue: 0,0:54:38.05,0:54:45.19,中文,,0,0,0,,是的，我的意思是，我们使用了兩倍的内存，因为现在除了存储整数 1、2、3 之外，我还需要为每个整数存储一个指针。
Dialogue: 0,0:54:45.19,0:54:48.59,英文,,0,0,0,,And honestly, even this picture is a bit of simplification.
Dialogue: 0,0:54:45.19,0:54:48.59,中文,,0,0,0,,老实说，即使这张图也经过了简化。
Dialogue: 0,0:54:48.59,0:54:52.07,英文,,0,0,0,,Technically, in most systems today, each int would be 4 bytes.
Dialogue: 0,0:54:48.59,0:54:52.07,中文,,0,0,0,,从技术上讲，在今天的大多数系统中，每个 int 都是 4 个字节。
Dialogue: 0,0:54:52.07,0:54:54.87,英文,,0,0,0,,Technically, today, most pointers, though, would be 8 bytes.
Dialogue: 0,0:54:52.07,0:54:54.87,中文,,0,0,0,,而技术上，今天大多数指针是 8 个字节。
Dialogue: 0,0:54:54.87,0:54:59.63,英文,,0,0,0,,I just didn't want to draw this weird shape on the board where the bottom square is even bigger than the top square.
Dialogue: 0,0:54:54.87,0:54:59.63,中文,,0,0,0,,我只是不想在黑板上画出这种奇怪的形状，底部方块比顶部方块还要大。
Dialogue: 0,0:54:59.63,0:55:03.66,英文,,0,0,0,,But technically, we're using even more than twice as much space for these pointers.
Dialogue: 0,0:54:59.63,0:55:03.66,中文,,0,0,0,,但从技术上讲，我们为这些指针使用的空间是实际的两倍多。
Dialogue: 0,0:55:03.66,0:55:09.54,英文,,0,0,0,,So there's that trade-off. Now, thankfully, decades after C was invented, memory is generally much cheaper nowadays.
Dialogue: 0,0:55:03.66,0:55:09.54,中文,,0,0,0,,所以这就是权衡。值得庆幸的是，在 C 语言发明几十年后，内存现在通常便宜得多。
Dialogue: 0,0:55:09.54,0:55:12.44,英文,,0,0,0,,And so it's OK to sort of spend more of it if you need to.
Dialogue: 0,0:55:09.54,0:55:12.44,中文,,0,0,0,,所以如果需要的话，多花点钱也是可以的。
Dialogue: 0,0:55:12.44,0:55:14.07,英文,,0,0,0,,And it depends on what you want to optimize for.
Dialogue: 0,0:55:12.44,0:55:14.07,中文,,0,0,0,,这取决于你想优化什么。
Dialogue: 0,0:55:14.07,0:55:16.61,英文,,0,0,0,,But that's absolutely here a downside.
Dialogue: 0,0:55:14.07,0:55:16.61,中文,,0,0,0,,但这绝对是一个缺点。
Dialogue: 0,0:55:16.61,0:55:22.11,英文,,0,0,0,,What's another downside of having transition to a linked list?
Dialogue: 0,0:55:16.61,0:55:22.11,中文,,0,0,0,,转换为链表的另一个缺点是什么？
Dialogue: 0,0:55:22.11,0:55:23.97,英文,,0,0,0,,You can't index into it.
Dialogue: 0,0:55:22.11,0:55:23.97,中文,,0,0,0,,你不能对其进行索引。
Dialogue: 0,0:55:23.97,0:55:26.39,英文,,0,0,0,,Now, I haven't even tried in code.
Dialogue: 0,0:55:23.97,0:55:26.39,中文,,0,0,0,,现在，我甚至还没有在代码中尝试过。
Dialogue: 0,0:55:26.39,0:55:31.82,英文,,0,0,0,,But when you have a linked list, you can no longer use square bracket notation.
Dialogue: 0,0:55:26.39,0:55:31.82,中文,,0,0,0,,但是当你有一个链表时，你不能再使用方括号了。
Dialogue: 0,0:55:31.82,0:55:32.84,英文,,0,0,0,,Because why?
Dialogue: 0,0:55:31.82,0:55:32.84,中文,,0,0,0,,为什么？
Dialogue: 0,0:55:32.84,0:55:36.50,英文,,0,0,0,,Well, square bracket notation just assumes the contiguousness of memory.
Dialogue: 0,0:55:32.84,0:55:36.50,中文,,0,0,0,,因为方括号表示内存是连续的。
Dialogue: 0,0:55:36.50,0:55:37.88,英文,,0,0,0,,Location 0 is here.
Dialogue: 0,0:55:36.50,0:55:37.88,中文,,0,0,0,,位置0在这里。
Dialogue: 0,0:55:37.88,0:55:39.96,英文,,0,0,0,,Location 1 is literally 1 to the right.
Dialogue: 0,0:55:37.88,0:55:39.96,中文,,0,0,0,,位置1就在右边1个位置。
Dialogue: 0,0:55:39.96,0:55:42.74,英文,,0,0,0,,Location 2 is literally 1 to the right, 1 to the right.
Dialogue: 0,0:55:39.96,0:55:42.74,中文,,0,0,0,,位置2就在右边1个位置，再往右1个位置。
Dialogue: 0,0:55:42.74,0:55:48.08,英文,,0,0,0,,These things, even though I've drawn it from right to left to just keep things pretty, there are gaps here.
Dialogue: 0,0:55:42.74,0:55:48.08,中文,,0,0,0,,这些东西，即使我把它们从右到左画只是为了美观，这里还是有间隙的。
Dialogue: 0,0:55:48.08,0:55:49.96,英文,,0,0,0,,And this is just my interpretation of this.
Dialogue: 0,0:55:48.08,0:55:49.96,中文,,0,0,0,,这只是我的理解。
Dialogue: 0,0:55:49.96,0:55:52.08,英文,,0,0,0,,These gaps could be big. They could be narrow.
Dialogue: 0,0:55:49.96,0:55:52.08,中文,,0,0,0,,这些间隙可能很大，也可能很小。
Dialogue: 0,0:55:52.08,0:55:53.78,英文,,0,0,0,,They could be down here, up here.
Dialogue: 0,0:55:52.08,0:55:53.78,中文,,0,0,0,,它们可能在这里，也可能在那里。
Dialogue: 0,0:55:53.78,0:55:57.50,英文,,0,0,0,,They could be anywhere so long as we're linking things together in this list.
Dialogue: 0,0:55:53.78,0:55:57.50,中文,,0,0,0,,只要我们把东西链接在这个链表中，它们可以在任何地方。
Dialogue: 0,0:55:57.50,0:56:04.70,英文,,0,0,0,,The computer can't just use bracket 0, bracket 1, bracket 2 anymore because it can't do simple arithmetic and jump to, like, the middle.
Dialogue: 0,0:55:57.50,0:56:04.70,中文,,0,0,0,,计算机不能再使用[0]、[1]、[2]，因为它不能进行简单的算术运算，并跳转到中间位置。
Dialogue: 0,0:56:04.70,0:56:07.07,英文,,0,0,0,,And now here's perhaps the worst price we've paid.
Dialogue: 0,0:56:04.70,0:56:07.07,中文,,0,0,0,,现在，这可能是我们付出的最糟糕的代价。
Dialogue: 0,0:56:07.07,0:56:16.53,英文,,0,0,0,,If you don't have square bracket notation, or really, you don't have contiguousness, what algorithm did we just sacrifice for this dynamism?
Dialogue: 0,0:56:07.07,0:56:16.53,中文,,0,0,0,,如果你没有方括号，或者实际上你没有连续性，那么为了这种动态性，我们牺牲了哪种算法？
Dialogue: 0,0:56:16.53,0:56:30.43,英文,,0,0,0,,If you rewind even back to week 0, and we gave it a name in week 3, what algorithm can we not use now if we can't assume that the memory is back to back to back to back?
Dialogue: 0,0:56:16.53,0:56:30.43,中文,,0,0,0,,如果你甚至倒回到第0周，我们在第3周给它起了一个名字，如果我们不能假设内存是挨着的，那么我们现在就不能使用什么算法？
Dialogue: 0,0:56:30.43,0:56:31.96,英文,,0,0,0,,Binary search.
Dialogue: 0,0:56:30.43,0:56:31.96,中文,,0,0,0,,二分查找。
Dialogue: 0,0:56:31.96,0:56:32.70,英文,,0,0,0,,Why?
Dialogue: 0,0:56:31.96,0:56:32.70,中文,,0,0,0,,为什么？
Dialogue: 0,0:56:32.70,0:56:39.94,英文,,0,0,0,,Because binary search, just like the phone book back in the first week, requires being able to arithmetically jump right to the middle.
Dialogue: 0,0:56:32.70,0:56:39.94,中文,,0,0,0,,因为二分查找就像第一周的电话簿例子一样，需要能够直接跳到中间。
Dialogue: 0,0:56:39.94,0:56:44.83,英文,,0,0,0,,Take the total length of it, divide by 2, and boom, you're right there in the middle with some simple arithmetic.
Dialogue: 0,0:56:39.94,0:56:44.83,中文,,0,0,0,,获取总长度，除以 2，就可以通过一些简单的算术运算直接找到中间位置。
Dialogue: 0,0:56:44.83,0:56:49.49,英文,,0,0,0,,Here. They might be laid out, again, with these big or small gaps.
Dialogue: 0,0:56:44.83,0:56:49.49,中文,,0,0,0,,这里，它们可能还是会有大大小小的间隔。
Dialogue: 0,0:56:49.49,0:56:53.09,英文,,0,0,0,,There's no simple math I can do to just jump immediately to the one in the middle.
Dialogue: 0,0:56:49.49,0:56:53.09,中文,,0,0,0,,没有简单的数学方法可以让我直接跳到中间那个。
Dialogue: 0,0:56:53.09,0:56:59.31,英文,,0,0,0,,And in fact, again, if this TV were bigger, the two could technically be in memory, be way down here or even way over here.
Dialogue: 0,0:56:53.09,0:56:59.31,中文,,0,0,0,,事实上，如果这台电视更大，这两个在内存中可能在这下面，甚至在这上面。
Dialogue: 0,0:56:59.31,0:57:03.49,英文,,0,0,0,,The foam finger could be pointing in any number of directions, depending on where malloc put the thing.
Dialogue: 0,0:56:59.31,0:57:03.49,中文,,0,0,0,,泡沫手指可以指向任何方向，这取决于 malloc 把它放在哪里。
Dialogue: 0,0:57:03.49,0:57:05.75,英文,,0,0,0,,There's just no way to do binary search.
Dialogue: 0,0:57:03.49,0:57:05.75,中文,,0,0,0,,没办法进行二分查找。
Dialogue: 0,0:57:05.75,0:57:10.09,英文,,0,0,0,,And so it would seem that we've paid another price, indeed, in terms of performance.
Dialogue: 0,0:57:05.75,0:57:10.09,中文,,0,0,0,,因此，在性能方面，我们似乎确实付出了另一个代价。
Dialogue: 0,0:57:10.09,0:57:13.20,英文,,0,0,0,,We're now talking about linear time again.
Dialogue: 0,0:57:10.09,0:57:13.20,中文,,0,0,0,,我们现在又在讨论线性时间了。
Dialogue: 0,0:57:13.20,0:57:14.64,英文,,0,0,0,,So that's a regression.
Dialogue: 0,0:57:13.20,0:57:14.64,中文,,0,0,0,,所以这是一种倒退。
Dialogue: 0,0:57:14.64,0:57:16.46,英文,,0,0,0,,Now, that's also a lot.
Dialogue: 0,0:57:14.64,0:57:16.46,中文,,0,0,0,,这也很多了。
Dialogue: 0,0:57:16.46,0:57:18.90,英文,,0,0,0,,Feels like a good time for some muffins and fruit out in the lobby.
Dialogue: 0,0:57:16.46,0:57:18.90,中文,,0,0,0,,现在是时候去大厅享用松饼和水果了。
Dialogue: 0,0:57:18.90,0:57:21.68,英文,,0,0,0,,And when we come back, we'll try to solve the problem we just created.
Dialogue: 0,0:57:18.90,0:57:21.68,中文,,0,0,0,,我们回来后，会尝试解决我们刚刚创建的问题。
Dialogue: 0,0:57:21.68,0:57:23.28,英文,,0,0,0,,So see you in 10.
Dialogue: 0,0:57:21.68,0:57:23.28,中文,,0,0,0,,10 分钟后见。
Dialogue: 0,0:57:23.28,0:57:24.30,英文,,0,0,0,,So we are back.
Dialogue: 0,0:57:23.28,0:57:24.30,中文,,0,0,0,,我们回来了。
Dialogue: 0,0:57:24.30,0:57:32.21,英文,,0,0,0,,And let's see if we can't now take some of these higher-level concepts of stitching together these nodes in memory and translate it to some actual code.
Dialogue: 0,0:57:24.30,0:57:32.21,中文,,0,0,0,,让我们看看是否可以把将这些节点连接在内存中的高级概念转换为实际的代码。
Dialogue: 0,0:57:32.21,0:57:35.37,英文,,0,0,0,,But we'll do it step-by-step first before I actually start writing it in VS Code.
Dialogue: 0,0:57:32.21,0:57:35.37,中文,,0,0,0,,在我开始在 VS Code 中实际编写之前，我们会逐步进行。
Dialogue: 0,0:57:35.37,0:57:44.68,英文,,0,0,0,,So if, Carter, you wouldn't mind helping me step through with some visuals, Let me propose that, line by line, we solve some of the problems that we've just created for ourselves in building this thing in memory.
Dialogue: 0,0:57:35.37,0:57:44.68,中文,,0,0,0,,Carter，如果你不介意用一些视觉效果帮助我逐步完成，我想逐行解决我们在内存中构建这个东西时为自己制造的一些问题。
Dialogue: 0,0:57:44.68,0:57:53.45,英文,,0,0,0,,So let's go ahead and, first, consider how we could build a linked list containing the numbers, indeed, 1, then 2, then 3.
Dialogue: 0,0:57:44.68,0:57:53.45,中文,,0,0,0,,让我们先考虑如何构建一个链表，其中包含数字 1、2、3。
Dialogue: 0,0:57:53.45,0:58:06.14,英文,,0,0,0,,And let's translate each of those steps to code, and then we'll put it all together into something that actually runs. So how about the first step here will just be this, to declare a pointer called list that initially has no value, at least at this point in the story.
Dialogue: 0,0:57:53.45,0:58:06.14,中文,,0,0,0,,让我们将每个步骤转换为代码，然后将它们组合成可以实际运行的东西。\N第一步是声明一个名为 list 的指针，它最初没有任何值，至少在故事的这一点上是这样。
Dialogue: 0,0:58:06.14,0:58:07.78,英文,,0,0,0,,List is the name of the variable.
Dialogue: 0,0:58:06.14,0:58:07.78,中文,,0,0,0,,List 是变量名。
Dialogue: 0,0:58:07.78,0:58:14.90,英文,,0,0,0,,Node star just means that this is essentially going to be our little square over here that points to the beginning of the list.
Dialogue: 0,0:58:07.78,0:58:14.90,中文,,0,0,0,,Node star 意味着这将是我们这里的小方块，指向列表的开头。
Dialogue: 0,0:58:14.90,0:58:24.16,英文,,0,0,0,,Of course, it's ideal if it ultimately has a value, because when we initially call this line of code, it just gives us, indeed, that square over here on the left.
Dialogue: 0,0:58:14.90,0:58:24.16,中文,,0,0,0,,当然，如果它最终有一个值是最好的，因为当我们最初调用这行代码时，它实际上给了我们左边这个方块。
Dialogue: 0,0:58:24.16,0:58:27.88,英文,,0,0,0,,But it's got a garbage value, because there's no equal sign on the other side there.
Dialogue: 0,0:58:24.16,0:58:27.88,中文,,0,0,0,,但它有一个垃圾值，因为另一边没有等号。
Dialogue: 0,0:58:27.88,0:58:37.57,英文,,0,0,0,,So let's propose that we do one more step here and actually initialize it to null so that if only we know that it's not garbage, it at least has some known value.
Dialogue: 0,0:58:27.88,0:58:37.57,中文,,0,0,0,,所以我们建议在这里再做一步，把它初始化为 NULL，这样我们至少知道它不是垃圾值，它至少有一些已知的值。
Dialogue: 0,0:58:37.57,0:58:41.33,英文,,0,0,0,,And null is a good way of signifying that at this point in the story, the list is empty.
Dialogue: 0,0:58:37.57,0:58:41.33,中文,,0,0,0,,Null 是表示列表当前为空的好方法。
Dialogue: 0,0:58:41.33,0:58:44.40,英文,,0,0,0,,Indeed, null indicates there's no nodes in the list.
Dialogue: 0,0:58:41.33,0:58:44.40,中文,,0,0,0,,实际上，NULL 表示列表中没有节点。
Dialogue: 0,0:58:44.40,0:58:51.60,英文,,0,0,0,,So that picture would now look like this, whereby let's just draw instead of writing null everywhere, I'll just leave the squares blank when it's not a garbage value per se.
Dialogue: 0,0:58:44.40,0:58:51.60,中文,,0,0,0,,所以现在图片看起来像这样，让我们画出来，而不是到处写 NULL，当它本身不是垃圾值时，我会把方块留空。
Dialogue: 0,0:58:51.60,0:58:54.04,英文,,0,0,0,,It's literally 0x0 or null.
Dialogue: 0,0:58:51.60,0:58:54.04,中文,,0,0,0,,它实际上是 0x0 或 NULL。
Dialogue: 0,0:58:54.04,0:58:57.45,英文,,0,0,0,,All right, so that's it for building a linked list of size 0.
Dialogue: 0,0:58:54.04,0:58:57.45,中文,,0,0,0,,好了，这就是构建大小为 0 的链表的过程。
Dialogue: 0,0:58:57.45,0:58:59.23,英文,,0,0,0,,Like, we're sort of done then.
Dialogue: 0,0:58:57.45,0:58:59.23,中文,,0,0,0,,就像，我们就这样完成了。
Dialogue: 0,0:58:59.23,0:59:01.43,英文,,0,0,0,,But we want to now add a 1, and then a 2, then a 3.
Dialogue: 0,0:58:59.23,0:59:01.43,中文,,0,0,0,,但我们现在想添加一个 1，然后是 2，然后是 3。
Dialogue: 0,0:59:01.43,0:59:03.47,英文,,0,0,0,,So next step here might be this.
Dialogue: 0,0:59:01.43,0:59:03.47,中文,,0,0,0,,所以下一步可能是这样的。
Dialogue: 0,0:59:03.47,0:59:09.35,英文,,0,0,0,,If I want to allocate the first of my rectangles on our previous picture, I'm going to call malloc.
Dialogue: 0,0:59:03.47,0:59:09.35,中文,,0,0,0,,如果我想在我们之前的图片上分配我的第一个矩形，我会调用 malloc。
Dialogue: 0,0:59:09.35,0:59:12.79,英文,,0,0,0,,And I'm going to ask for enough memory to fit a whole node.
Dialogue: 0,0:59:09.35,0:59:12.79,中文,,0,0,0,,我会请求足够的内存来容纳整个节点。
Dialogue: 0,0:59:12.79,0:59:19.70,英文,,0,0,0,,Now, technically, I think that's going to be like 4 bytes for the int and 8 bytes for the pointer, even though I did not draw it to scale on the board.
Dialogue: 0,0:59:12.79,0:59:19.70,中文,,0,0,0,,现在，从技术上讲，我认为这将是 int 的 4 个字节和指针的 8 个字节，即使我没有在黑板上按比例绘制。
Dialogue: 0,0:59:19.70,0:59:21.86,英文,,0,0,0,,So that's technically going to be, what, 12 bytes.
Dialogue: 0,0:59:19.70,0:59:21.86,中文,,0,0,0,,所以从技术上讲，这将是 12 个字节。
Dialogue: 0,0:59:21.86,0:59:26.52,英文,,0,0,0,,But again, size of node just figures out how many bytes I actually need dynamically.
Dialogue: 0,0:59:21.86,0:59:26.52,中文,,0,0,0,,但是，sizeof(node) 只是动态地计算出我实际需要多少字节。
Dialogue: 0,0:59:26.52,0:59:35.18,英文,,0,0,0,,That's going to return to me the address of that chunk of memory, which apparently I'm going to store inside of a temporary variable called n for short for node.
Dialogue: 0,0:59:26.52,0:59:35.18,中文,,0,0,0,,这将返回给我那块内存的地址，显然我将把它存储在一个名为 n 的临时变量中，它是 node 的缩写。
Dialogue: 0,0:59:35.18,0:59:42.14,英文,,0,0,0,,But let's see what this does pictorially. So when this line of code is executed, I first get on the left that variable n.
Dialogue: 0,0:59:35.18,0:59:42.14,中文,,0,0,0,,但是让我们看看这在图形上是怎么做的。所以当这行代码被执行时，我首先在左边得到变量 n。
Dialogue: 0,0:59:42.14,0:59:47.25,英文,,0,0,0,,It's got a garbage value by default, because I haven't executed the whole thing from right to left.
Dialogue: 0,0:59:42.14,0:59:47.25,中文,,0,0,0,,默认情况下它是一个垃圾值，因为我没有从右到左执行整个语句。
Dialogue: 0,0:59:47.25,0:59:51.33,英文,,0,0,0,,Meanwhile, on the right-hand side of the expression, I've got now a node somewhere in memory.
Dialogue: 0,0:59:47.25,0:59:51.33,中文,,0,0,0,,同时，表达式的右边现在在内存中的某个位置有一个节点。
Dialogue: 0,0:59:51.33,0:59:54.31,英文,,0,0,0,,It happened to be free here. This is where malloc put it for me.
Dialogue: 0,0:59:51.33,0:59:54.31,中文,,0,0,0,,它碰巧在这里是空闲的，这是 malloc 为我放置它的地方。
Dialogue: 0,0:59:54.31,0:59:57.68,英文,,0,0,0,,But it does have two garbage values initially, but because it's a node,
Dialogue: 0,0:59:54.31,0:59:57.68,中文,,0,0,0,,但是它最初确实有两个垃圾值，但是因为它是一个节点，
Dialogue: 0,0:59:57.68,1:00:04.06,英文,,0,0,0,,Per my typedef earlier, every node I proposed is going to have a number and a next pointer.
Dialogue: 0,0:59:57.68,1:00:04.06,中文,,0,0,0,,根据我之前定义的 typedef，我建议的每个节点都将有一个数字和一个 next 指针。
Dialogue: 0,1:00:04.06,1:00:05.76,英文,,0,0,0,,So we can see those labeled here.
Dialogue: 0,1:00:04.06,1:00:05.76,中文,,0,0,0,,所以我们可以在这里看到它们的标签。
Dialogue: 0,1:00:05.76,1:00:07.64,英文,,0,0,0,,But they've got two garbage values initially.
Dialogue: 0,1:00:05.76,1:00:07.64,中文,,0,0,0,,但是它们最初有两个垃圾值。
Dialogue: 0,1:00:07.64,1:00:13.59,英文,,0,0,0,,But all I care about initially is that, ultimately, n is pointing at that chunk of code.
Dialogue: 0,1:00:07.64,1:00:13.59,中文,,0,0,0,,但我最初只关心最终 n 指向那段代码。
Dialogue: 0,1:00:13.59,1:00:16.70,英文,,0,0,0,,So initially, if we could back up two steps.
Dialogue: 0,1:00:13.59,1:00:16.70,中文,,0,0,0,,所以最初，如果我们可以后退两步。
Dialogue: 0,1:00:16.70,1:00:18.64,英文,,0,0,0,,We have two steps.
Dialogue: 0,1:00:16.70,1:00:18.64,中文,,0,0,0,,我们有两步。
Dialogue: 0,1:00:18.64,1:00:20.84,英文,,0,0,0,,So we have initial, oop, one step forward.
Dialogue: 0,1:00:18.64,1:00:20.84,中文,,0,0,0,,我们有初始的，向前走一步。
Dialogue: 0,1:00:20.84,1:00:25.99,英文,,0,0,0,,We have this line of code gives us this variable here, which has garbage.
Dialogue: 0,1:00:20.84,1:00:25.99,中文,,0,0,0,,这行代码给了我们这里的变量，它包含垃圾值。
Dialogue: 0,1:00:25.99,1:00:29.81,英文,,0,0,0,,When this side of the expression is executed, that allocates the memory.
Dialogue: 0,1:00:25.99,1:00:29.81,中文,,0,0,0,,执行表达式的这一侧时，会分配内存。
Dialogue: 0,1:00:29.81,1:00:36.29,英文,,0,0,0,,And then when we copy from right to left the address of that chunk of memory, that's what gives us conceptually this arrow.
Dialogue: 0,1:00:29.81,1:00:36.29,中文,,0,0,0,,然后当我们从右到左复制那块内存的地址时，这就是从概念上给了我们这个箭头的原因。
Dialogue: 0,1:00:36.29,1:00:39.07,英文,,0,0,0,,And the garbage goes away because that's a valid pointer now.
Dialogue: 0,1:00:36.29,1:00:39.07,中文,,0,0,0,,垃圾值消失了，因为它现在是一个有效的指针。
Dialogue: 0,1:00:39.07,1:00:43.95,英文,,0,0,0,,Of course, there's still two garbage values there because we haven't set this node to store a number like the number 1.
Dialogue: 0,1:00:39.07,1:00:43.95,中文,,0,0,0,,当然，那里还有两个垃圾值，因为我们还没有设置这个节点来存储像数字 1 这样的数字。
Dialogue: 0,1:00:43.95,1:00:46.67,英文,,0,0,0,,So let's go ahead and execute one other line of code like this.
Dialogue: 0,1:00:43.95,1:00:46.67,中文,,0,0,0,,所以让我们继续执行另一行这样的代码。
Dialogue: 0,1:00:46.67,1:00:52.14,英文,,0,0,0,,Which, while cryptic looking, is just an application of ideas we've seen in week four and prior.
Dialogue: 0,1:00:46.67,1:00:52.14,中文,,0,0,0,,虽然看起来很神秘，但这只是我们在第四周及之前看到的概念的应用。
Dialogue: 0,1:00:52.14,1:00:56.16,英文,,0,0,0,,Star n means to start at this variable and go there.
Dialogue: 0,1:00:52.14,1:00:56.16,中文,,0,0,0,,星号 n 表示从这个变量开始，然后去那里。
Dialogue: 0,1:00:56.16,1:01:00.30,英文,,0,0,0,,Follow the arrow is what the star or the d reference operator does for us.
Dialogue: 0,1:00:56.16,1:01:00.30,中文,,0,0,0,,跟随箭头是星号或解引用运算符为我们所做的事情。
Dialogue: 0,1:01:00.30,1:01:08.11,英文,,0,0,0,,And then the dot operator, recall, when we first introduce structs, like for a person struct, allows us to go at the number field or the next field.
Dialogue: 0,1:01:00.30,1:01:08.11,中文,,0,0,0,,然后运算符，回想一下，当我们第一次介绍结构体时，比如 person 结构体，它允许我们访问 number 字段或 next 字段。
Dialogue: 0,1:01:08.11,1:01:18.16,英文,,0,0,0,,So if I do, Star n, and then in parentheses, to make sure order of operations is preserved, dot number, and then assign it the actual number 1, which puts the 1 in the top of that rectangle.
Dialogue: 0,1:01:08.11,1:01:18.16,中文,,0,0,0,,所以如果我写 *n，然后在括号里，确保运算顺序，.number，然后赋值为 1，这样就把 1 放到矩形的顶部。
Dialogue: 0,1:01:18.16,1:01:20.96,英文,,0,0,0,,Now, admittedly, this syntax is not very user-friendly.
Dialogue: 0,1:01:18.16,1:01:20.96,中文,,0,0,0,,现在，不得不承认，这种语法不是很友好。
Dialogue: 0,1:01:20.96,1:01:21.78,英文,,0,0,0,,It's annoying to remember.
Dialogue: 0,1:01:20.96,1:01:21.78,中文,,0,0,0,,很难记住。
Dialogue: 0,1:01:21.78,1:01:22.96,英文,,0,0,0,,You have to have the parentheses.
Dialogue: 0,1:01:21.78,1:01:22.96,中文,,0,0,0,,你必须加上括号。
Dialogue: 0,1:01:22.96,1:01:24.74,英文,,0,0,0,,So there's another syntax for this.
Dialogue: 0,1:01:22.96,1:01:24.74,中文,,0,0,0,,所以还有另一种语法。
Dialogue: 0,1:01:24.74,1:01:43.39,英文,,0,0,0,,Whenever you're doing two things like this in code, dereferencing a pointer that is going to an address and then further using the dot notation to go inside of the structure you find that, wonderfully C gives us this syntax whereby you can just change the star and the parentheses and the dot. to just be an arrow.
Dialogue: 0,1:01:24.74,1:01:43.39,中文,,0,0,0,,每当你在代码中做两件事，比如解引用一个指向某个地址的指针，\N然后进一步使用点符号进入你找到的结构体时，你会惊喜地发现 C 语言提供了这样一种语法，你可以直接把星号、括号和点号。 改成一个箭头。
Dialogue: 0,1:01:43.39,1:01:45.61,英文,,0,0,0,,And again, it's not a single character on your keyboard.
Dialogue: 0,1:01:43.39,1:01:45.61,中文,,0,0,0,,再说一次，它不是键盘上的单个字符。
Dialogue: 0,1:01:45.61,1:01:47.85,英文,,0,0,0,,It's a hyphen and then an open angle bracket.
Dialogue: 0,1:01:45.61,1:01:47.85,中文,,0,0,0,,它是一个连字符，然后是一个左尖括号。
Dialogue: 0,1:01:47.85,1:01:52.57,英文,,0,0,0,,But I kind of like the semantics of this, because this code now pretty much matches the picture.
Dialogue: 0,1:01:47.85,1:01:52.57,中文,,0,0,0,,但我有点喜欢这种语义，因为这段代码现在几乎和图片一致了。
Dialogue: 0,1:01:52.57,1:01:58.04,英文,,0,0,0,,n arrow leads you to the value that you want to access or ultimately change in this way.
Dialogue: 0,1:01:52.57,1:01:58.04,中文,,0,0,0,,箭头指向你想要访问的值，或者最终以这种方式改变的值。
Dialogue: 0,1:01:58.04,1:02:08.53,英文,,0,0,0,,There's one step, though, we've forgotten, of course, which is that we can't leave this garbage value here, because the garbage value is some unknown value that effectively is pointing who knows where.
Dialogue: 0,1:01:58.04,1:02:08.53,中文,,0,0,0,,当然，还有一步我们忘记了，那就是我们不能把这个垃圾值留在这里，因为垃圾值是一些未知的值，实际上它指向谁知道哪里。
Dialogue: 0,1:02:08.53,1:02:14.39,英文,,0,0,0,,And we don't want to accidentally misinterpret that garbage value as being a valid address and risk going there.
Dialogue: 0,1:02:08.53,1:02:14.39,中文,,0,0,0,,我们也不想意外地将垃圾值误认为是有效地址，并冒险访问它。
Dialogue: 0,1:02:14.39,1:02:17.81,英文,,0,0,0,,So of course, what value should we put here instead?
Dialogue: 0,1:02:14.39,1:02:17.81,中文,,0,0,0,,那么，我们应该在这里放什么值呢？
Dialogue: 0,1:02:17.81,1:02:21.70,英文,,0,0,0,,Our old friend null, just to signify that this is indeed the end of the list.
Dialogue: 0,1:02:17.81,1:02:21.70,中文,,0,0,0,,我们的老朋友 NULL，只是为了表示这确实是列表的结尾。
Dialogue: 0,1:02:21.70,1:02:27.40,英文,,0,0,0,,And we could do that with a line of code like this. And again, we'll connote as much by just leaving that empty box blank.
Dialogue: 0,1:02:21.70,1:02:27.40,中文,,0,0,0,,我们可以用这样一行代码来做到这一点。同样，我们将通过将空框留空来表示这一点。
Dialogue: 0,1:02:27.40,1:02:29.46,英文,,0,0,0,,So now we have a list of size 1.
Dialogue: 0,1:02:27.40,1:02:29.46,中文,,0,0,0,,所以现在我们有了一个大小为 1 的列表。
Dialogue: 0,1:02:29.46,1:02:33.33,英文,,0,0,0,,Let's go ahead and add the second number to it, as with these lines here.
Dialogue: 0,1:02:29.46,1:02:33.33,中文,,0,0,0,,让我们继续，像下面这几行代码那样，把第二个数字加进去。
Dialogue: 0,1:02:33.33,1:02:39.05,英文,,0,0,0,,List equals n allows us to remember that, indeed, we have this list here.
Dialogue: 0,1:02:33.33,1:02:39.05,中文,,0,0,0,,List = n 让我们记住，确实，我们这里有这个列表。
Dialogue: 0,1:02:39.05,1:02:43.21,英文,,0,0,0,,So if we can step one step forward, here's what the picture now looks like.
Dialogue: 0,1:02:39.05,1:02:43.21,中文,,0,0,0,,如果我们往前走一步，现在的情况就是这样。
Dialogue: 0,1:02:43.21,1:02:45.57,英文,,0,0,0,,And technically, let's go one step further here.
Dialogue: 0,1:02:43.21,1:02:45.57,中文,,0,0,0,,从技术上讲，让我们再往前走一步。
Dialogue: 0,1:02:45.57,1:02:50.30,英文,,0,0,0,,This is now really what's going on in memory once my list of size 1 exists.
Dialogue: 0,1:02:45.57,1:02:50.30,中文,,0,0,0,,这就是我的大小为 1 的列表存在时，内存中的实际情况。
Dialogue: 0,1:02:50.30,1:02:55.40,英文,,0,0,0,,My main variable called list is pointing at exactly that first node.
Dialogue: 0,1:02:50.30,1:02:55.40,中文,,0,0,0,,我的主变量 list 正好指向第一个节点。
Dialogue: 0,1:02:55.40,1:03:01.68,英文,,0,0,0,,At this point in the story, I don't need to know or care about the temporary variable that I called n, even though it might very well still be there.
Dialogue: 0,1:02:55.40,1:03:01.68,中文,,0,0,0,,目前，我不需要知道或关心我称为 n 的临时变量，尽管它很可能仍然存在。
Dialogue: 0,1:03:01.68,1:03:04.03,英文,,0,0,0,,But indeed, this now represents that linked list.
Dialogue: 0,1:03:01.68,1:03:04.03,中文,,0,0,0,,但这确实代表了链表。
Dialogue: 0,1:03:04.03,1:03:06.07,英文,,0,0,0,,Let's now, indeed, add the number 2.
Dialogue: 0,1:03:04.03,1:03:06.07,中文,,0,0,0,,现在，我们来添加数字 2。
Dialogue: 0,1:03:06.07,1:03:10.79,英文,,0,0,0,,So with the same line of code as before, I'm going to allocate another node, size of node.
Dialogue: 0,1:03:06.07,1:03:10.79,中文,,0,0,0,,使用与之前相同的代码行，我将分配另一个节点，节点大小。
Dialogue: 0,1:03:10.79,1:03:15.11,英文,,0,0,0,,Ideally, I would be checking for null here, but we're doing the juicy parts only on the slides.
Dialogue: 0,1:03:10.79,1:03:15.11,中文,,0,0,0,,理想情况下，我会在这里检查是否为空，但我们只在幻灯片上做重要的部分。
Dialogue: 0,1:03:15.11,1:03:16.65,英文,,0,0,0,,Let's now go ahead and depict that.
Dialogue: 0,1:03:15.11,1:03:16.65,中文,,0,0,0,,现在让我们继续描述它。
Dialogue: 0,1:03:16.65,1:03:17.99,英文,,0,0,0,,So what happens with this?
Dialogue: 0,1:03:16.65,1:03:17.99,中文,,0,0,0,,那么会发生什么呢？
Dialogue: 0,1:03:17.99,1:03:23.28,英文,,0,0,0,,This brings back our n pointer, which might have been there the whole time, but we're doing this step by step.
Dialogue: 0,1:03:17.99,1:03:23.28,中文,,0,0,0,,这将带回我们的 n 指针，它可能一直都在那里，但我们正在逐步进行。
Dialogue: 0,1:03:23.28,1:03:26.30,英文,,0,0,0,,It's a garbage value, though, because we haven't yet copied from right to left.
Dialogue: 0,1:03:23.28,1:03:26.30,中文,,0,0,0,,不过，它是一个垃圾值，因为我们还没有从右到左复制。
Dialogue: 0,1:03:26.30,1:03:30.06,英文,,0,0,0,,malloc, of course, gives us a second chunk of memory, which maybe ends up there.
Dialogue: 0,1:03:26.30,1:03:30.06,中文,,0,0,0,,当然，malloc 为我们提供了第二块内存，它可能最终会出现在那里。
Dialogue: 0,1:03:30.06,1:03:36.88,英文,,0,0,0,,With two garbage values by default, I've omitted the labels now just because they're still going to be number and next respectively.
Dialogue: 0,1:03:30.06,1:03:36.88,中文,,0,0,0,,默认情况下有两个垃圾值，我现在省略了标签，因为它们仍然分别是 number 和 next。
Dialogue: 0,1:03:36.88,1:03:40.69,英文,,0,0,0,,Once we copy from right to left, the garbage value indeed becomes an arrow.
Dialogue: 0,1:03:36.88,1:03:40.69,中文,,0,0,0,,一旦我们从右到左复制，垃圾值实际上就变成了一个箭头。
Dialogue: 0,1:03:40.69,1:03:44.99,英文,,0,0,0,,Oscar disappears because it's now indeed a valid pointer pointing here.
Dialogue: 0,1:03:40.69,1:03:44.99,中文,,0,0,0,,Oscar 消失了，因为它现在确实是一个指向这里的有效指针。
Dialogue: 0,1:03:44.99,1:03:49.07,英文,,0,0,0,,Now, the values themselves, number and next, are invalid garbage values.
Dialogue: 0,1:03:44.99,1:03:49.07,中文,,0,0,0,,现在，值本身，number 和 next，是无效的垃圾值。
Dialogue: 0,1:03:49.07,1:03:55.59,英文,,0,0,0,,So here is where we can now start using our new syntax, like the arrow notation, or the star and the dot if you prefer.
Dialogue: 0,1:03:49.07,1:03:55.59,中文,,0,0,0,,所以在这里，我们可以开始使用新的语法，比如箭头符号，或者如果你愿意，可以使用星号和点号。
Dialogue: 0,1:03:55.59,1:03:59.89,英文,,0,0,0,,And we can change the value of n, follow the arrow, to number.
Dialogue: 0,1:03:55.59,1:03:59.89,中文,,0,0,0,,我们可以改变 n 的值，跟随箭头，到 number。
Dialogue: 0,1:03:59.89,1:04:01.42,英文,,0,0,0,,And that becomes 2.
Dialogue: 0,1:03:59.89,1:04:01.42,中文,,0,0,0,,结果就是 2。
Dialogue: 0,1:04:01.42,1:04:04.38,英文,,0,0,0,,Similarly, we can do this again and set n,
Dialogue: 0,1:04:01.42,1:04:04.38,中文,,0,0,0,,类似地，我们可以再做一次，设置 n，
Dialogue: 0,1:04:04.38,1:04:10.84,英文,,0,0,0,,Arrow next, so start at n, follow the arrow, access the next field, and set that equal to null.
Dialogue: 0,1:04:04.38,1:04:10.84,中文,,0,0,0,,指向 next，所以从 n 开始，沿着箭头，访问 next 字段，并将其设置为 NULL。
Dialogue: 0,1:04:10.84,1:04:14.82,英文,,0,0,0,,Now, we're not quite done yet, because we haven't actually linked things together.
Dialogue: 0,1:04:10.84,1:04:14.82,中文,,0,0,0,,现在，我们还没有完全完成，因为我们还没有把它们连接在一起。
Dialogue: 0,1:04:14.82,1:04:16.80,英文,,0,0,0,,So here's now where things get interesting.
Dialogue: 0,1:04:14.82,1:04:16.80,中文,,0,0,0,,所以现在事情变得有趣了。
Dialogue: 0,1:04:16.80,1:04:18.49,英文,,0,0,0,,How do I combine these two?
Dialogue: 0,1:04:16.80,1:04:18.49,中文,,0,0,0,,我如何将这两个结合起来？
Dialogue: 0,1:04:18.49,1:04:20.07,英文,,0,0,0,,Well, let me propose this.
Dialogue: 0,1:04:18.49,1:04:20.07,中文,,0,0,0,,让我来提个建议。
Dialogue: 0,1:04:20.07,1:04:26.51,英文,,0,0,0,,Let me propose on our next line here, we actually update for now list equal to n.
Dialogue: 0,1:04:20.07,1:04:26.51,中文,,0,0,0,,我建议在下一行，我们将 list 更新为 n。
Dialogue: 0,1:04:26.51,1:04:31.85,英文,,0,0,0,,That is to say, whatever address this is, whatever it's pointing at, change list to be the same address.
Dialogue: 0,1:04:26.51,1:04:31.85,中文,,0,0,0,,也就是说，无论这个地址是什么，无论它指向哪里，都将 list 更改为相同的地址。
Dialogue: 0,1:04:31.85,1:04:33.23,英文,,0,0,0,,That is, point at the same thing.
Dialogue: 0,1:04:31.85,1:04:33.23,中文,,0,0,0,,也就是说，指向同一个东西。
Dialogue: 0,1:04:33.23,1:04:37.26,英文,,0,0,0,,So if n is pointing here, let's change list to point here.
Dialogue: 0,1:04:33.23,1:04:37.26,中文,,0,0,0,,所以如果 n 指向这里，让我们把 list 也改成指向这里。
Dialogue: 0,1:04:37.26,1:04:39.68,英文,,0,0,0,,And go ahead and do that, Carter, if you could.
Dialogue: 0,1:04:37.26,1:04:39.68,中文,,0,0,0,,Carter，如果你可以的话，请继续。
Dialogue: 0,1:04:39.68,1:04:40.94,英文,,0,0,0,,I don't like this.
Dialogue: 0,1:04:39.68,1:04:40.94,中文,,0,0,0,,我不喜欢这样。
Dialogue: 0,1:04:40.94,1:04:42.84,英文,,0,0,0,,Can you go one further step?
Dialogue: 0,1:04:40.94,1:04:42.84,中文,,0,0,0,,你能再走一步吗？
Dialogue: 0,1:04:42.84,1:04:44.44,英文,,0,0,0,,This is bad.
Dialogue: 0,1:04:42.84,1:04:44.44,中文,,0,0,0,,这很糟糕。
Dialogue: 0,1:04:44.44,1:04:53.62,英文,,0,0,0,,What is wrong about my sequence of operations here, where I updated list to point at my new node?
Dialogue: 0,1:04:44.44,1:04:53.62,中文,,0,0,0,,我的操作顺序有什么问题？我将 list 更新为指向我的新节点。
Dialogue: 0,1:04:53.62,1:04:56.00,英文,,0,0,0,,Yeah, we lost the pointer to the other node.
Dialogue: 0,1:04:53.62,1:04:56.00,中文,,0,0,0,,是的，我们丢失了指向另一个节点的指针。
Dialogue: 0,1:04:56.00,1:04:59.88,英文,,0,0,0,,So I don't even care about the ordering, 2, 1, or 1, 2.
Dialogue: 0,1:04:56.00,1:04:59.88,中文,,0,0,0,,我不在乎顺序，2，1 还是 1，2 都可以。
Dialogue: 0,1:04:59.88,1:05:05.32,英文,,0,0,0,,The bigger problem now, as the lack of arrows over there suggests, is that I have a memory leak.
Dialogue: 0,1:04:59.88,1:05:05.32,中文,,0,0,0,,更大的问题是，就像那边缺少箭头所暗示的那样，我遇到了内存泄漏。
Dialogue: 0,1:05:05.32,1:05:10.49,英文,,0,0,0,,I have orphaned my original node in the sense that nothing is pointing at it anymore.
Dialogue: 0,1:05:05.32,1:05:10.49,中文,,0,0,0,,我的原始节点变成了孤儿，因为没有任何东西指向它了。
Dialogue: 0,1:05:10.49,1:05:13.29,英文,,0,0,0,,Now, absolutely, I could fix this by adding some temporary variables.
Dialogue: 0,1:05:10.49,1:05:13.29,中文,,0,0,0,,当然，我可以通过添加一些临时变量来解决这个问题。
Dialogue: 0,1:05:13.29,1:05:18.43,英文,,0,0,0,,I could add it to the mix. But at this point in the story, I have not done any such recollection thereof.
Dialogue: 0,1:05:13.29,1:05:18.43,中文,,0,0,0,,我可以把它加进去，但目前我还没有做任何相关的回忆。
Dialogue: 0,1:05:18.43,1:05:19.44,英文,,0,0,0,,So let me back this up.
Dialogue: 0,1:05:18.43,1:05:19.44,中文,,0,0,0,,我们回过头来。
Dialogue: 0,1:05:19.44,1:05:20.92,英文,,0,0,0,,And let's go forward in the slides.
Dialogue: 0,1:05:19.44,1:05:20.92,中文,,0,0,0,,我们继续看幻灯片。
Dialogue: 0,1:05:20.92,1:05:22.84,英文,,0,0,0,,This is where we left off a moment ago.
Dialogue: 0,1:05:20.92,1:05:22.84,中文,,0,0,0,,这是我们刚才结束的地方。
Dialogue: 0,1:05:22.84,1:05:26.28,英文,,0,0,0,,I think I need to take into account order of operations.
Dialogue: 0,1:05:22.84,1:05:26.28,中文,,0,0,0,,我认为我需要考虑运算顺序。
Dialogue: 0,1:05:26.28,1:05:27.32,英文,,0,0,0,,And I'm going to keep this simple.
Dialogue: 0,1:05:26.28,1:05:27.32,中文,,0,0,0,,我会保持简单。
Dialogue: 0,1:05:27.32,1:05:30.30,英文,,0,0,0,,I'm not going to care about the order of the numbers for now.
Dialogue: 0,1:05:27.32,1:05:30.30,中文,,0,0,0,,现在我不关心数字的顺序。
Dialogue: 0,1:05:30.30,1:05:33.35,英文,,0,0,0,,I'm fine with a list that is 2 and then 1.
Dialogue: 0,1:05:30.30,1:05:33.35,中文,,0,0,0,,一个包含 2 和 1 的列表就可以了。
Dialogue: 0,1:05:33.35,1:05:39.71,英文,,0,0,0,,So with that said, let me go ahead and update, I think, this box here to point at my original node.
Dialogue: 0,1:05:33.35,1:05:39.71,中文,,0,0,0,,也就是说，让我们继续更新，我认为是这个框，让它指向我原来的节点。
Dialogue: 0,1:05:39.71,1:05:41.78,英文,,0,0,0,,So let's see how we can do this in code.
Dialogue: 0,1:05:39.71,1:05:41.78,中文,,0,0,0,,我们来看看如何在代码中实现。
Dialogue: 0,1:05:41.78,1:05:45.24,英文,,0,0,0,,OK, n arrow next, so n.
Dialogue: 0,1:05:41.78,1:05:45.24,中文,,0,0,0,,n 箭头指向 next，所以 n.
Dialogue: 0,1:05:45.24,1:05:49.14,英文,,0,0,0,,Arrow next should equal the current list.
Dialogue: 0,1:05:45.24,1:05:49.14,中文,,0,0,0,,箭头 next 应该指向当前列表。
Dialogue: 0,1:05:49.14,1:05:51.84,英文,,0,0,0,,And this is a little weird again, but recall what list is.
Dialogue: 0,1:05:49.14,1:05:51.84,中文,,0,0,0,,这又有点奇怪，但回想一下 list 是什么。
Dialogue: 0,1:05:51.84,1:05:58.00,英文,,0,0,0,,List is this pointer here that just contains the address of the original address of the list.
Dialogue: 0,1:05:51.84,1:05:58.00,中文,,0,0,0,,List 是这里的指针，它只包含列表原始地址的地址。
Dialogue: 0,1:05:58.00,1:06:01.49,英文,,0,0,0,,Or equivalently, it contains this arrow, whatever it's pointing at.
Dialogue: 0,1:05:58.00,1:06:01.49,中文,,0,0,0,,或者说，它包含这个箭头，无论它指向哪里。
Dialogue: 0,1:06:01.49,1:06:10.87,英文,,0,0,0,,So what this means in this line of code, n bracket next means start at n, follow the arrow, access the next pointer, and set it equal to whatever list equals.
Dialogue: 0,1:06:01.49,1:06:10.87,中文,,0,0,0,,所以这行代码的含义是，n[next] 表示从 n 开始，沿着箭头走，访问 next 指针，并将其设置为 list 的值。
Dialogue: 0,1:06:10.87,1:06:13.75,英文,,0,0,0,,So if list is pointing here, then this
Dialogue: 0,1:06:10.87,1:06:13.75,中文,,0,0,0,,所以如果 list 指向这里，那么这个
Dialogue: 0,1:06:13.75,1:06:16.21,英文,,0,0,0,,Next should point there as well.
Dialogue: 0,1:06:13.75,1:06:16.21,中文,,0,0,0,,Next 也应该指向那里。
Dialogue: 0,1:06:16.21,1:06:18.87,英文,,0,0,0,,This, I think, is safe because now we have redundancy.
Dialogue: 0,1:06:16.21,1:06:18.87,中文,,0,0,0,,我认为这样做是安全的，因为现在我们有了冗余。
Dialogue: 0,1:06:18.87,1:06:21.86,英文,,0,0,0,,Now we've got two pointers pointing at the original list.
Dialogue: 0,1:06:18.87,1:06:21.86,中文,,0,0,0,,现在我们有两个指针指向原始列表。
Dialogue: 0,1:06:21.86,1:06:31.32,英文,,0,0,0,,And now I think we can do another step whereby we update list to equal n. Same line of code before that got us into trouble, but I'm doing it second now instead of first.
Dialogue: 0,1:06:21.86,1:06:31.32,中文,,0,0,0,,我想现在我们可以进行下一步，更新 list 使其等于 n。这行代码之前给我们带来了麻烦，但现在我把它放在第二位而不是第一位。
Dialogue: 0,1:06:31.32,1:06:37.76,英文,,0,0,0,,When I execute list equals n, this now sets list equal to the same thing that n equals.
Dialogue: 0,1:06:31.32,1:06:37.76,中文,,0,0,0,,当我执行 list = n 时，这会将 list 设置为与 n 相同的值。
Dialogue: 0,1:06:37.76,1:06:44.45,英文,,0,0,0,,And so now I have successfully inserted my new node containing two into the list.
Dialogue: 0,1:06:37.76,1:06:44.45,中文,,0,0,0,,现在我已经成功地将包含 2 的新节点插入到列表中。
Dialogue: 0,1:06:44.45,1:06:50.25,英文,,0,0,0,,And in fact, if we advance one more, we can just clear up the clutter, assume that the temporary variable is gone from the story.
Dialogue: 0,1:06:44.45,1:06:50.25,中文,,0,0,0,,事实上，如果我们再进行一步，就可以清除杂乱，假设临时变量已经从场景中消失了。
Dialogue: 0,1:06:50.25,1:06:53.15,英文,,0,0,0,,Now we have a linked list where, admittedly, ordering is wrong.
Dialogue: 0,1:06:50.25,1:06:53.15,中文,,0,0,0,,现在我们有了一个链表，虽然顺序是错误的。
Dialogue: 0,1:06:53.15,1:06:54.37,英文,,0,0,0,,It's 2, 1 instead of 1, 2.
Dialogue: 0,1:06:53.15,1:06:54.37,中文,,0,0,0,,它是 2, 1 而不是 1, 2。
Dialogue: 0,1:06:54.37,1:06:56.40,英文,,0,0,0,,But at least it's linked correctly.
Dialogue: 0,1:06:54.37,1:06:56.40,中文,,0,0,0,,但至少它链接正确。
Dialogue: 0,1:06:56.40,1:07:00.72,英文,,0,0,0,,And I didn't orphan or leak any memory.
Dialogue: 0,1:06:56.40,1:07:00.72,中文,,0,0,0,,而且我没有孤立或泄漏任何内存。
Dialogue: 0,1:07:00.72,1:07:04.56,英文,,0,0,0,,Questions on this sequence of steps here?
Dialogue: 0,1:07:00.72,1:07:04.56,中文,,0,0,0,,对这里的步骤顺序有什么疑问吗？
Dialogue: 0,1:07:04.56,1:07:12.52,英文,,0,0,0,,Yeah, in back. So currently, this is only like stacking type, right?
Dialogue: 0,1:07:04.56,1:07:12.52,中文,,0,0,0,,后面那位同学。所以目前，这只是一个类似堆栈的类型，对吧？
Dialogue: 0,1:07:12.52,1:07:13.36,英文,,0,0,0,,Yeah, spot on.
Dialogue: 0,1:07:12.52,1:07:13.36,中文,,0,0,0,,是的，你说得对。
Dialogue: 0,1:07:13.36,1:07:22.91,英文,,0,0,0,,So this would fall under that category of a stack, if you will, although I've not called it that by name, because I just pushed the number 2 onto this data structure, if you will.
Dialogue: 0,1:07:13.36,1:07:22.91,中文,,0,0,0,,所以这将属于堆栈的范畴，如果你愿意这样称呼它的话，尽管我还没有给它起名字，因为我只是把数字 2 压入了这个数据结构中。
Dialogue: 0,1:07:22.91,1:07:26.47,英文,,0,0,0,,And indeed, it ended up at the beginning of the list instead of the end.
Dialogue: 0,1:07:22.91,1:07:26.47,中文,,0,0,0,,事实上，它最终出现在列表的开头而不是结尾。
Dialogue: 0,1:07:26.47,1:07:30.70,英文,,0,0,0,,And so here's where we see a distinction between an abstract data structure, which is where we began.
Dialogue: 0,1:07:26.47,1:07:30.70,中文,,0,0,0,,这就是我们看到抽象数据结构和具体实现之间区别的地方，抽象数据结构是我们开始的地方。
Dialogue: 0,1:07:30.70,1:07:39.28,英文,,0,0,0,,A stack is a thing like the pile of sweaters that just has push and pop properties and LIFO access, last in, first out.
Dialogue: 0,1:07:30.70,1:07:39.28,中文,,0,0,0,,堆栈就像一堆毛衣一样，只有压入和弹出的属性，以及后进先出（LIFO）的访问方式。
Dialogue: 0,1:07:39.28,1:07:41.30,英文,,0,0,0,,How do you implement something like that in memory?
Dialogue: 0,1:07:39.28,1:07:41.30,中文,,0,0,0,,如何在内存中实现这样的东西呢？
Dialogue: 0,1:07:41.30,1:07:56.27,英文,,0,0,0,,Well, it would seem that you could implement the notion of a stack here, not for sweaters but for numbers, using a linked list, so long as you implement insertion, a.k.a. pushing, by prepending new values to the list, by prepending again and again.
Dialogue: 0,1:07:41.30,1:07:56.27,中文,,0,0,0,,似乎你可以在这里实现堆栈的概念，不是针对毛衣而是针对数字，使用链表，\N只要你通过将新值添加到列表的开头来实现插入，也就是压入，一遍又一遍地添加到开头。
Dialogue: 0,1:07:56.27,1:08:03.63,英文,,0,0,0,,And if, Carter, you don't mind hitting the keyboard one more time, if I wanted to add the number 3 now, you could imagine prepending it to the list.
Dialogue: 0,1:07:56.27,1:08:03.63,中文,,0,0,0,,如果，Carter，你不介意再按一下键盘，如果我现在想添加数字 3，你可以想象把它添加到列表的开头。
Dialogue: 0,1:08:03.63,1:08:04.35,英文,,0,0,0,,Why?
Dialogue: 0,1:08:03.63,1:08:04.35,中文,,0,0,0,,为什么？
Dialogue: 0,1:08:04.35,1:08:07.59,英文,,0,0,0,,Well, honestly, especially as this list gets longer and longer,
Dialogue: 0,1:08:04.35,1:08:07.59,中文,,0,0,0,,老实说，特别是随着列表越来越长，
Dialogue: 0,1:08:07.59,1:08:10.78,英文,,0,0,0,,I kind of like the appeal of prepending these elements.
Dialogue: 0,1:08:07.59,1:08:10.78,中文,,0,0,0,,我更喜欢在前面插入元素。
Dialogue: 0,1:08:10.78,1:08:11.44,英文,,0,0,0,,Why?
Dialogue: 0,1:08:10.78,1:08:11.44,中文,,0,0,0,,为什么？
Dialogue: 0,1:08:11.44,1:08:19.15,英文,,0,0,0,,Because even if this list gets crazy long and way, way out here, you didn't notice me following all of the arrows earlier to do the insertions.
Dialogue: 0,1:08:11.44,1:08:19.15,中文,,0,0,0,,因为即使列表变得很长，你应该没注意到我之前为了插入元素而跟踪所有箭头。
Dialogue: 0,1:08:19.15,1:08:22.77,英文,,0,0,0,,If I want to insert a fourth number, a fifth number, a sixth number,
Dialogue: 0,1:08:19.15,1:08:22.77,中文,,0,0,0,,如果要插入第四、第五、第六个数字，
Dialogue: 0,1:08:22.77,1:08:30.22,英文,,0,0,0,,All I have to do is insert it here, if you will, point it at the original start of the list, then update this pointer, and done.
Dialogue: 0,1:08:22.77,1:08:30.22,中文,,0,0,0,,我只需要把它插入这里，让它指向列表的起始位置，然后更新这个指针，就完成了。
Dialogue: 0,1:08:30.22,1:08:32.94,英文,,0,0,0,,And I would say that's like two steps, give or take.
Dialogue: 0,1:08:30.22,1:08:32.94,中文,,0,0,0,,大概只需要两步。
Dialogue: 0,1:08:32.94,1:08:39.11,英文,,0,0,0,,It's not going to be n steps, as it would be if I had to append the new nodes to the end of the list.
Dialogue: 0,1:08:32.94,1:08:39.11,中文,,0,0,0,,不需要 n 步，不像之前那样必须将新节点追加到列表末尾。
Dialogue: 0,1:08:39.11,1:08:41.73,英文,,0,0,0,,Now, of course, we've sacrificed ordering of these numbers.
Dialogue: 0,1:08:39.11,1:08:41.73,中文,,0,0,0,,当然，我们牺牲了这些数字的顺序。
Dialogue: 0,1:08:41.73,1:08:45.22,英文,,0,0,0,,They're literally in the opposite order, or whatever order they were inserted in.
Dialogue: 0,1:08:41.73,1:08:45.22,中文,,0,0,0,,它们的顺序正好相反，或者按插入顺序排列。
Dialogue: 0,1:08:45.22,1:08:48.72,英文,,0,0,0,,But that might very well be OK, depending on the goal at hand.
Dialogue: 0,1:08:45.22,1:08:48.72,中文,,0,0,0,,但这可能没关系，具体取决于目标。
Dialogue: 0,1:08:48.72,1:08:50.68,英文,,0,0,0,,All right, thank you to Carter for stepping through this.
Dialogue: 0,1:08:48.72,1:08:50.68,中文,,0,0,0,,谢谢 Carter 的讲解。
Dialogue: 0,1:08:50.68,1:08:53.00,英文,,0,0,0,,What if now we wanted to translate this?
Dialogue: 0,1:08:50.68,1:08:53.00,中文,,0,0,0,,如果我们想把它转换成代码？
Dialogue: 0,1:08:53.00,1:08:56.90,英文,,0,0,0,,Oh, sure, thank you.
Dialogue: 0,1:08:53.00,1:08:56.90,中文,,0,0,0,,好的，谢谢。
Dialogue: 0,1:08:56.90,1:08:59.17,英文,,0,0,0,,It's all for you, none for me in this example.
Dialogue: 0,1:08:56.90,1:08:59.17,中文,,0,0,0,,这都是你的功劳，跟我没关系。
Dialogue: 0,1:08:59.17,1:09:03.43,英文,,0,0,0,,So here we have perhaps a way of translating this now to some actual code.
Dialogue: 0,1:08:59.17,1:09:03.43,中文,,0,0,0,,我们可以用某种方式把它转换成实际代码。
Dialogue: 0,1:09:03.43,1:09:10.49,英文,,0,0,0,,And this will be the last of the sort of intense code here, just to give you a sense of how we can translate this idea now to actual steps.
Dialogue: 0,1:09:03.43,1:09:10.49,中文,,0,0,0,,这将是最后一部分代码，只是为了让大家了解如何将这个想法转化为实际步骤。
Dialogue: 0,1:09:10.49,1:09:13.24,英文,,0,0,0,,So this is list.c in VS Code here.
Dialogue: 0,1:09:10.49,1:09:13.24,中文,,0,0,0,,这是 VS Code 中的 list.c 文件。
Dialogue: 0,1:09:13.24,1:09:15.52,英文,,0,0,0,,Let me go ahead and make a couple of changes up top.
Dialogue: 0,1:09:13.24,1:09:15.52,中文,,0,0,0,,我先在顶部做一些更改。
Dialogue: 0,1:09:15.52,1:09:25.18,英文,,0,0,0,,Let me go ahead and... How about declaring a node using typedef struct node using our new framing as before.
Dialogue: 0,1:09:15.52,1:09:25.18,中文,,0,0,0,,我先使用 typedef struct node 声明一个节点，就像之前用我们新的框架一样。
Dialogue: 0,1:09:25.18,1:09:33.85,英文,,0,0,0,,I'm going to give every node a number, as I proposed, and every node a pointer to the next element, which is going to be implemented just as before.
Dialogue: 0,1:09:25.18,1:09:33.85,中文,,0,0,0,,我将给每个节点一个编号，就像我建议的那样，并且每个节点都有一个指向下一个元素的指针，这将像以前一样实现。
Dialogue: 0,1:09:33.85,1:09:36.45,英文,,0,0,0,,And I'm going to simplify the whole name as just node.
Dialogue: 0,1:09:33.85,1:09:36.45,中文,,0,0,0,,我将把整个名称简化为 node。
Dialogue: 0,1:09:36.45,1:09:40.53,英文,,0,0,0,,So all that is is the exact same typedef that we proposed earlier.
Dialogue: 0,1:09:36.45,1:09:40.53,中文,,0,0,0,,所以这就是我们之前提出的完全相同的 typedef。
Dialogue: 0,1:09:40.53,1:09:44.99,英文,,0,0,0,,Now, let me go ahead and get rid of all of this code, which we wrote earlier.
Dialogue: 0,1:09:40.53,1:09:44.99,中文,,0,0,0,,现在，让我继续删除我们之前写的所有代码。
Dialogue: 0,1:09:44.99,1:09:48.33,英文,,0,0,0,,And recall that this was the most recent version that was not a linked list.
Dialogue: 0,1:09:44.99,1:09:48.33,中文,,0,0,0,,回想一下，这是最近的一个不是链表的版本。
Dialogue: 0,1:09:48.33,1:09:52.10,英文,,0,0,0,,This was just an array that we allocated and then reallocated.
Dialogue: 0,1:09:48.33,1:09:52.10,中文,,0,0,0,,这只是一个我们分配然后重新分配的数组。
Dialogue: 0,1:09:52.10,1:09:54.40,英文,,0,0,0,,So this is sort of the old way of doing things.
Dialogue: 0,1:09:52.10,1:09:54.40,中文,,0,0,0,,所以这有点像是旧的做事方式。
Dialogue: 0,1:09:54.40,1:10:00.90,英文,,0,0,0,,But it was inefficient, because we might have to lean on a for loop or lean on realloc to copy everything around.
Dialogue: 0,1:09:54.40,1:10:00.90,中文,,0,0,0,,但它效率很低，因为我们可能不得不依赖 for 循环或 realloc 来复制所有内容。
Dialogue: 0,1:10:00.90,1:10:07.76,英文,,0,0,0,,We're now going to reimplement the notion of a list as an actual linked list. Not as an array.
Dialogue: 0,1:10:00.90,1:10:07.76,中文,,0,0,0,,我们现在要将列表的概念重新实现为一个实际的链表。 不是数组。
Dialogue: 0,1:10:07.76,1:10:10.12,英文,,0,0,0,,So my main function now might do something like this.
Dialogue: 0,1:10:07.76,1:10:10.12,中文,,0,0,0,,所以我的 main 函数现在可能会执行这样的操作。
Dialogue: 0,1:10:10.12,1:10:14.29,英文,,0,0,0,,And I'm going to really just copy the lines of code that we just stepped through on the board.
Dialogue: 0,1:10:10.12,1:10:14.29,中文,,0,0,0,,我真的只是复制了我们刚才在黑板上逐步执行的代码行。
Dialogue: 0,1:10:14.29,1:10:19.39,英文,,0,0,0,,So let me give myself a special variable called list that's going to be initialized to null.
Dialogue: 0,1:10:14.29,1:10:19.39,中文,,0,0,0,,所以让我给自己一个名为 list 的特殊变量，它将被初始化为 NULL。
Dialogue: 0,1:10:19.39,1:10:24.25,英文,,0,0,0,,And this is just my pointer, the square on the left-hand side of the screen, that represents the start of the list.
Dialogue: 0,1:10:19.39,1:10:24.25,中文,,0,0,0,,这只是我的指针，屏幕左侧的方块，代表列表的开头。
Dialogue: 0,1:10:24.25,1:10:26.29,英文,,0,0,0,,And if it's null, it means the list is empty.
Dialogue: 0,1:10:24.25,1:10:26.29,中文,,0,0,0,,如果它是 NULL，则表示列表为空。
Dialogue: 0,1:10:26.29,1:10:26.89,英文,,0,0,0,,So done.
Dialogue: 0,1:10:26.29,1:10:26.89,中文,,0,0,0,,完成了。
Dialogue: 0,1:10:26.89,1:10:30.62,英文,,0,0,0,,I'm done implementing a linked list of size 0.
Dialogue: 0,1:10:26.89,1:10:30.62,中文,,0,0,0,,我已经完成了一个大小为 0 的链表的实现。
Dialogue: 0,1:10:30.62,1:10:32.54,英文,,0,0,0,,Well, now, how do I want to run this code?
Dialogue: 0,1:10:30.62,1:10:32.54,中文,,0,0,0,,那么，现在我想如何运行这段代码？
Dialogue: 0,1:10:32.54,1:10:37.70,英文,,0,0,0,,Well, let me propose, for the sake of discussion, that this version of the program will take command line arguments.
Dialogue: 0,1:10:32.54,1:10:37.70,中文,,0,0,0,,为了讨论，我建议这个版本的程序将接受命令行参数。
Dialogue: 0,1:10:37.70,1:10:39.36,英文,,0,0,0,,So I want to be able to do something like this.
Dialogue: 0,1:10:37.70,1:10:39.36,中文,,0,0,0,,我想这样操作。
Dialogue: 0,1:10:39.36,1:10:44.87,英文,,0,0,0,,I want to run this program, ultimately, and type in three command line arguments like this, 1, 2, 3.
Dialogue: 0,1:10:39.36,1:10:44.87,中文,,0,0,0,,我想运行这个程序，输入三个命令行参数，比如 1、2、3。
Dialogue: 0,1:10:44.87,1:10:54.17,英文,,0,0,0,,And I want my program, in a couple minutes, to allocate 1, 2, 3 nodes and stitch them together, just like the visualization on the board.
Dialogue: 0,1:10:44.87,1:10:54.17,中文,,0,0,0,,我希望几分钟后，我的程序就能分配 1、2、3 个节点，并将它们连接起来，就像黑板上的可视化效果一样。
Dialogue: 0,1:10:54.17,1:10:57.96,英文,,0,0,0,,I could use get int, but it's just going to be faster if we use command line arguments.
Dialogue: 0,1:10:54.17,1:10:57.96,中文,,0,0,0,,我可以用 get int，但如果使用命令行参数会更快。
Dialogue: 0,1:10:57.96,1:11:00.68,英文,,0,0,0,,So again, I'm just borrowing some concepts from week 2.
Dialogue: 0,1:10:57.96,1:11:00.68,中文,,0,0,0,,我再次借用了第二周的一些概念。
Dialogue: 0,1:11:00.68,1:11:03.30,英文,,0,0,0,,But none of that's possible yet until I change my code here.
Dialogue: 0,1:11:00.68,1:11:03.30,中文,,0,0,0,,但在修改代码之前，这些都还无法实现。
Dialogue: 0,1:11:03.30,1:11:09.25,英文,,0,0,0,,So let's do this, int argc string argv.
Dialogue: 0,1:11:03.30,1:11:09.25,中文,,0,0,0,,我们来试试 int argc, string argv。
Dialogue: 0,1:11:09.25,1:11:10.11,英文,,0,0,0,,But you know what?
Dialogue: 0,1:11:09.25,1:11:10.11,中文,,0,0,0,,但是你知道吗？
Dialogue: 0,1:11:10.11,1:11:12.71,英文,,0,0,0,,We know that strings are not actually a thing anymore.
Dialogue: 0,1:11:10.11,1:11:12.71,中文,,0,0,0,,我们知道字符串已经不存在了。
Dialogue: 0,1:11:12.71,1:11:16.73,英文,,0,0,0,,So I can change my command line argument definition to be what it really is.
Dialogue: 0,1:11:12.71,1:11:16.73,中文,,0,0,0,,所以我可以把我命令行参数的定义改成它本来的样子。
Dialogue: 0,1:11:16.73,1:11:18.17,英文,,0,0,0,,It's really char star.
Dialogue: 0,1:11:16.73,1:11:18.17,中文,,0,0,0,,它其实是 char *。
Dialogue: 0,1:11:18.17,1:11:25.56,英文,,0,0,0,,But it's the exact same thing as in week 2, just strings are no more, at least without the training wheels on, anymore like last week.
Dialogue: 0,1:11:18.17,1:11:25.56,中文,,0,0,0,,但这和第二周的内容完全一样，只是字符串已经不存在了，至少在没有辅助轮的情况下，不像上周那样了。
Dialogue: 0,1:11:25.56,1:11:33.26,英文,,0,0,0,,And now let me do this. For int i equals 1, i is less than argc, i plus plus.
Dialogue: 0,1:11:25.56,1:11:33.26,中文,,0,0,0,,现在让我这样做：for int i = 1，i < argc，i++。
Dialogue: 0,1:11:33.26,1:11:36.63,英文,,0,0,0,,So what I'm doing with this loop is I just want to iterate over the command line argument.
Dialogue: 0,1:11:33.26,1:11:36.63,中文,,0,0,0,,我用这个循环要做的就是遍历命令行参数。
Dialogue: 0,1:11:36.63,1:11:39.99,英文,,0,0,0,,So I have one number at a time from the prompt.
Dialogue: 0,1:11:36.63,1:11:39.99,中文,,0,0,0,,这样我就能从提示符中一次得到一个数字。
Dialogue: 0,1:11:39.99,1:11:42.91,英文,,0,0,0,,What else do I want to do here?
Dialogue: 0,1:11:39.99,1:11:42.91,中文,,0,0,0,,我还想在这里做什么呢？
Dialogue: 0,1:11:42.91,1:11:48.05,英文,,0,0,0,,Well, let's go ahead and how about do this.
Dialogue: 0,1:11:42.91,1:11:48.05,中文,,0,0,0,,我们继续，试试这个。
Dialogue: 0,1:11:48.05,1:11:49.62,英文,,0,0,0,,Let's get a number.
Dialogue: 0,1:11:48.05,1:11:49.62,中文,,0,0,0,,我们来获取一个数字。
Dialogue: 0,1:11:49.62,1:11:54.76,英文,,0,0,0,,So int number equals argv bracket i. So a couple of notes here.
Dialogue: 0,1:11:49.62,1:11:54.76,中文,,0,0,0,,int number = argv[i]。这里需要注意几点。
Dialogue: 0,1:11:54.76,1:11:58.50,英文,,0,0,0,,One, I'm starting my for loop at 1 instead of 0.
Dialogue: 0,1:11:54.76,1:11:58.50,中文,,0,0,0,,第一，我的 for 循环从 1 而不是 0 开始。
Dialogue: 0,1:11:58.50,1:11:59.94,英文,,0,0,0,,But I'm going up to argc.
Dialogue: 0,1:11:58.50,1:11:59.94,中文,,0,0,0,,但是我要遍历到 argc。
Dialogue: 0,1:11:59.94,1:12:02.68,英文,,0,0,0,,argc is argument count, how many words are at the prompt.
Dialogue: 0,1:11:59.94,1:12:02.68,中文,,0,0,0,,argc 是参数个数，也就是提示符后有多少个单词。
Dialogue: 0,1:12:02.68,1:12:08.02,英文,,0,0,0,,Why am I starting at 1 instead of 0, though, given my goal?
Dialogue: 0,1:12:02.68,1:12:08.02,中文,,0,0,0,,考虑到我的目标，为什么我要从 1 开始而不是 0？
Dialogue: 0,1:12:08.02,1:12:09.02,英文,,0,0,0,,Why am I starting at 1? Yeah.
Dialogue: 0,1:12:08.02,1:12:09.02,中文,,0,0,0,,我为什么要从 1 开始？ 是的。
Dialogue: 0,1:12:16.44,1:12:19.84,英文,,0,0,0,,Yeah, so the first value in argv is actually the name of the program.
Dialogue: 0,1:12:16.44,1:12:19.84,中文,,0,0,0,,是的，argv 中的第一个值实际上是程序的名称。
Dialogue: 0,1:12:19.84,1:12:21.03,英文,,0,0,0,,That's obviously not a number.
Dialogue: 0,1:12:19.84,1:12:21.03,中文,,0,0,0,,这显然不是一个数字。
Dialogue: 0,1:12:21.03,1:12:22.45,英文,,0,0,0,,So I want the second value.
Dialogue: 0,1:12:21.03,1:12:22.45,中文,,0,0,0,,所以我想要第二个值。
Dialogue: 0,1:12:22.45,1:12:25.99,英文,,0,0,0,,So I'm going to start iterating over those command line arguments at i equals 1.
Dialogue: 0,1:12:22.45,1:12:25.99,中文,,0,0,0,,所以我要从 i 等于 1 开始迭代这些命令行参数。
Dialogue: 0,1:12:25.99,1:12:26.51,英文,,0,0,0,,So that's all.
Dialogue: 0,1:12:25.99,1:12:26.51,中文,,0,0,0,,就这样。
Dialogue: 0,1:12:26.51,1:12:29.45,英文,,0,0,0,,I just want to get the actual numbers at the prompt.
Dialogue: 0,1:12:26.51,1:12:29.45,中文,,0,0,0,,我只想获取提示符后的实际数字。
Dialogue: 0,1:12:29.45,1:12:34.41,英文,,0,0,0,,Unfortunately, argv bracket i is a string, a.k.a. char star.
Dialogue: 0,1:12:29.45,1:12:34.41,中文,,0,0,0,,不幸的是，argv[i] 是一个字符串，也就是 char*。
Dialogue: 0,1:12:34.41,1:12:35.29,英文,,0,0,0,,That is not an int.
Dialogue: 0,1:12:34.41,1:12:35.29,中文,,0,0,0,,那不是一个 int。
Dialogue: 0,1:12:35.29,1:12:36.61,英文,,0,0,0,,So this line of code won't work.
Dialogue: 0,1:12:35.29,1:12:36.61,中文,,0,0,0,,所以这行代码无法工作。
Dialogue: 0,1:12:36.61,1:12:44.98,英文,,0,0,0,,But can anyone think back to, like, week 2, where we had a function for converting strings to integers?
Dialogue: 0,1:12:36.61,1:12:44.98,中文,,0,0,0,,但是，谁能回想一下，比如在第 2 周，我们学过一个将字符串转换为整数的函数吗？
Dialogue: 0,1:12:44.98,1:12:52.72,英文,,0,0,0,,Yeah, so a to i is a function that converts ASCII to an integer, assuming what you give it as an argument looks like a number like 1 or 2 or 3.
Dialogue: 0,1:12:44.98,1:12:52.72,中文,,0,0,0,,是的，atoi 是一个将 ASCII 转换为整数的函数，前提是你提供的参数看起来像数字，比如 1、2 或 3。
Dialogue: 0,1:12:52.72,1:12:55.35,英文,,0,0,0,,So let me fix this. Let me actually do the conversion.
Dialogue: 0,1:12:52.72,1:12:55.35,中文,,0,0,0,,让我修复一下。让我实际进行转换。
Dialogue: 0,1:12:55.35,1:13:01.39,英文,,0,0,0,,If I were really being careful, I would error check this, make sure that there's no digits, just like you might have in problem set 2.
Dialogue: 0,1:12:55.35,1:13:01.39,中文,,0,0,0,,如果我真的要小心谨慎，我会进行错误检查，确保没有数字，就像你在 problem set 2 中可能做的那样。
Dialogue: 0,1:13:01.39,1:13:07.46,英文,,0,0,0,,But for today's purposes, I'm just going to assume the honor system that the user, me, is going to run the program correctly.
Dialogue: 0,1:13:01.39,1:13:07.46,中文,,0,0,0,,但就今天而言，我将根据荣誉制度假设用户，也就是我，将正确运行程序。
Dialogue: 0,1:13:07.46,1:13:12.82,英文,,0,0,0,,All right, so now that I have a variable containing the number from the command line, let's just allocate a node for it.
Dialogue: 0,1:13:07.46,1:13:12.82,中文,,0,0,0,,好了，现在我 有了一个包含命令行中数字的变量，让我们为它分配一个节点。
Dialogue: 0,1:13:12.82,1:13:17.10,英文,,0,0,0,,So let me do node star n, just like we did in the visualization.
Dialogue: 0,1:13:12.82,1:13:17.10,中文,,0,0,0,,就像我们在可视化中所做的那样，让我定义  node *n。
Dialogue: 0,1:13:17.10,1:13:22.18,英文,,0,0,0,,And let's malloc enough space for the size of one such node here.
Dialogue: 0,1:13:17.10,1:13:22.18,中文,,0,0,0,,我们用 malloc 为一个这样的节点分配足够的内存空间。
Dialogue: 0,1:13:22.18,1:13:24.38,英文,,0,0,0,,I now need to just be super safe.
Dialogue: 0,1:13:22.18,1:13:24.38,中文,,0,0,0,,我需要非常小心。
Dialogue: 0,1:13:24.38,1:13:29.34,英文,,0,0,0,,So if n equals equals null, like if I'm out of memory, you know what?
Dialogue: 0,1:13:24.38,1:13:29.34,中文,,0,0,0,,所以如果 n = NULL，比如内存不足，怎么办？
Dialogue: 0,1:13:29.34,1:13:32.82,英文,,0,0,0,,Let me go ahead and just immediately return 1 here.
Dialogue: 0,1:13:29.34,1:13:32.82,中文,,0,0,0,,我会直接返回 1。
Dialogue: 0,1:13:32.82,1:13:44.09,英文,,0,0,0,,Otherwise, if that's not the case, let me go ahead and update the number field of this new node, which at line 24 does exist, because it did not return null.
Dialogue: 0,1:13:32.82,1:13:44.09,中文,,0,0,0,,否则，让我继续更新这个新节点的 number 字段，在第 24 行确实存在，因为它没有返回 NULL。
Dialogue: 0,1:13:44.09,1:13:46.28,英文,,0,0,0,,So I did not exit early with return.
Dialogue: 0,1:13:44.09,1:13:46.28,中文,,0,0,0,,所以我没有提前用 return 退出。
Dialogue: 0,1:13:46.28,1:13:49.70,英文,,0,0,0,,And let me just store whatever number the human typed in first.
Dialogue: 0,1:13:46.28,1:13:49.70,中文,,0,0,0,,让我存储用户首先输入的任何数字。
Dialogue: 0,1:13:49.70,1:13:55.00,英文,,0,0,0,,So the return value of a to i, which per line 17 is in my variable called number.
Dialogue: 0,1:13:49.70,1:13:55.00,中文,,0,0,0,,也就是 a 到 i 的返回值，根据第 17 行，它在我的变量 number 中。
Dialogue: 0,1:13:55.00,1:13:59.63,英文,,0,0,0,,And then let me go ahead and just prepend this
Dialogue: 0,1:13:55.00,1:13:59.63,中文,,0,0,0,,然后让我继续把它放在
Dialogue: 0,1:13:59.63,1:14:11.23,英文,,0,0,0,,To the list, let me go ahead and say that this next field first has a known value null, just so that we get rid of that second garbage value.
Dialogue: 0,1:13:59.63,1:14:11.23,中文,,0,0,0,,列表的开头，让我继续说这个 next 字段首先有一个已知的值 NULL，这样我们就摆脱了第二个垃圾值。
Dialogue: 0,1:14:11.23,1:14:13.99,英文,,0,0,0,,And let me go ahead and now prepend it to the list.
Dialogue: 0,1:14:11.23,1:14:13.99,中文,,0,0,0,,现在，让我们把它放在列表的开头。
Dialogue: 0,1:14:13.99,1:14:24.07,英文,,0,0,0,,So if I want to prepend it, that means this new node must have a next field that points to the current beginning of the list.
Dialogue: 0,1:14:13.99,1:14:24.07,中文,,0,0,0,,如果我想把它放在开头，这意味着这个新节点必须有一个 next 字段，指向列表的当前开头。
Dialogue: 0,1:14:24.07,1:14:26.71,英文,,0,0,0,,And again, the goal here is to prepend, prepend, prepend.
Dialogue: 0,1:14:24.07,1:14:26.71,中文,,0,0,0,,同样，这里的目标是放在开头，放在开头，放在开头。
Dialogue: 0,1:14:26.71,1:14:33.21,英文,,0,0,0,,So whatever the current list is, let's change it so that this new node points to that existing list.
Dialogue: 0,1:14:26.71,1:14:33.21,中文,,0,0,0,,所以无论当前列表是什么，让我们改变它，让这个新节点指向现有的列表。
Dialogue: 0,1:14:33.21,1:14:39.56,英文,,0,0,0,,And now, step two, as before, was to update the actual list to point at this node.
Dialogue: 0,1:14:33.21,1:14:39.56,中文,,0,0,0,,现在，第二步，和之前一样，是更新实际的列表以指向这个节点。
Dialogue: 0,1:14:39.56,1:14:42.78,英文,,0,0,0,,So recall, in red on the screen before, I screwed up originally.
Dialogue: 0,1:14:39.56,1:14:42.78,中文,,0,0,0,,回想一下，在屏幕上之前的红色部分，我最初搞砸了。
Dialogue: 0,1:14:42.78,1:14:46.80,英文,,0,0,0,,And I only did this line by moving the pointer too early, if you will.
Dialogue: 0,1:14:42.78,1:14:46.80,中文,,0,0,0,,我只是做了这一行，过早地移动了指针。
Dialogue: 0,1:14:46.80,1:14:49.34,英文,,0,0,0,,But I fixed that once Carter helped me rewind.
Dialogue: 0,1:14:46.80,1:14:49.34,中文,,0,0,0,,但当 Carter 帮我回溯后，我修正了这个问题。
Dialogue: 0,1:14:49.34,1:14:52.18,英文,,0,0,0,,And we got rid of the red line, which indicated error.
Dialogue: 0,1:14:49.34,1:14:52.18,中文,,0,0,0,,我们摆脱了表示错误的红线。
Dialogue: 0,1:14:52.18,1:14:58.22,英文,,0,0,0,,And I just do n arrow next to change the next field of this new node to point to the existing list.
Dialogue: 0,1:14:52.18,1:14:58.22,中文,,0,0,0,,我只是用 n 箭头 next 来改变这个新节点的 next 字段，使其指向现有的列表。
Dialogue: 0,1:14:58.22,1:15:00.24,英文,,0,0,0,,So I'm not orphaning anything.
Dialogue: 0,1:14:58.22,1:15:00.24,中文,,0,0,0,,我没有孤立任何东西。
Dialogue: 0,1:15:00.24,1:15:06.39,英文,,0,0,0,,All right, at this point in the story, I think my code is correct.
Dialogue: 0,1:15:00.24,1:15:06.39,中文,,0,0,0,,好了，现在我认为我的代码是正确的。
Dialogue: 0,1:15:06.39,1:15:07.91,英文,,0,0,0,,Not batting very well, though, today.
Dialogue: 0,1:15:06.39,1:15:07.91,中文,,0,0,0,,不过，今天状态不太好。
Dialogue: 0,1:15:07.91,1:15:11.07,英文,,0,0,0,,But I think my code is correct. But the program doesn't do anything interesting.
Dialogue: 0,1:15:07.91,1:15:11.07,中文,,0,0,0,,但我认为我的代码是正确的，只是程序没有做任何有趣的事情。
Dialogue: 0,1:15:11.07,1:15:16.98,英文,,0,0,0,,So it would be nice to kind of now iterate over this linked list in memory, whatever its order is, and print things out.
Dialogue: 0,1:15:11.07,1:15:16.98,中文,,0,0,0,,所以现在遍历内存中的这个链表，无论顺序如何，然后打印出来，应该会比较好。
Dialogue: 0,1:15:16.98,1:15:18.04,英文,,0,0,0,,Well, how do we do that?
Dialogue: 0,1:15:16.98,1:15:18.04,中文,,0,0,0,,那么，我们该怎么做呢？
Dialogue: 0,1:15:18.04,1:15:23.60,英文,,0,0,0,,Well, it turns out if you want to iterate over a linked list, the general paradigm is to do something like this.
Dialogue: 0,1:15:18.04,1:15:23.60,中文,,0,0,0,,事实证明，如果你想遍历链表，一般的范例是这样的。
Dialogue: 0,1:15:23.60,1:15:30.26,英文,,0,0,0,,To define a temporary variable, I could call it temp, but another convention that you might as well see is called pointer, PTR, for short.
Dialogue: 0,1:15:23.60,1:15:30.26,中文,,0,0,0,,定义一个临时变量，我可以称之为 tmp，但你可能还会看到另一种约定，称为 ptr，简称为 PTR。
Dialogue: 0,1:15:30.26,1:15:31.90,英文,,0,0,0,,But you can call it anything you want.
Dialogue: 0,1:15:30.26,1:15:31.90,中文,,0,0,0,,但你可以随意命名。
Dialogue: 0,1:15:31.90,1:15:35.87,英文,,0,0,0,,And you can have a temporary variable first point at the first node in the list.
Dialogue: 0,1:15:31.90,1:15:35.87,中文,,0,0,0,,你可以让一个临时变量首先指向链表中的第一个节点。
Dialogue: 0,1:15:35.87,1:15:39.75,英文,,0,0,0,,And then in some kind of loop, like a while loop, you point it at the second node in the list.
Dialogue: 0,1:15:35.87,1:15:39.75,中文,,0,0,0,,然后在某个循环中，比如 while 循环，你把它指向链表中的第二个节点。
Dialogue: 0,1:15:39.75,1:15:40.95,英文,,0,0,0,,And then you keep iterating.
Dialogue: 0,1:15:39.75,1:15:40.95,中文,,0,0,0,,然后你继续迭代。
Dialogue: 0,1:15:40.95,1:15:42.51,英文,,0,0,0,,You point it at the last node in the list.
Dialogue: 0,1:15:40.95,1:15:42.51,中文,,0,0,0,,你把它指向列表中的最后一个节点。
Dialogue: 0,1:15:42.51,1:15:49.07,英文,,0,0,0,,And then eventually, you iterate too far, effectively pointing at null, at which point your while loop can presumably terminate.
Dialogue: 0,1:15:42.51,1:15:49.07,中文,,0,0,0,,最终，你迭代得过远，实际上指向了空值，此时你的 while 循环可能会终止。
Dialogue: 0,1:15:49.07,1:15:57.09,英文,,0,0,0,,So how do I implement that idea of allocating a temporary pointer that just points at each node in the list and lets me print out, ultimately, each of those numbers?
Dialogue: 0,1:15:49.07,1:15:57.09,中文,,0,0,0,,那么，如何实现分配一个临时指针的想法，这个指针指向链表中的每个节点，并最终让我打印出每个数字呢？
Dialogue: 0,1:15:57.09,1:16:00.49,英文,,0,0,0,,Well, let's go back to my code here. And let me do this.
Dialogue: 0,1:15:57.09,1:16:00.49,中文,,0,0,0,,我们回到代码这里，让我来演示一下。
Dialogue: 0,1:16:00.49,1:16:05.93,英文,,0,0,0,,Let me go ahead and declare this temporary pointer, which is going to be a node star also.
Dialogue: 0,1:16:00.49,1:16:05.93,中文,,0,0,0,,让我继续声明这个临时指针，它也将是一个 node *ptr。
Dialogue: 0,1:16:05.93,1:16:08.96,英文,,0,0,0,,Why? Because it's the address of a node, the first, the second, the third.
Dialogue: 0,1:16:05.93,1:16:08.96,中文,,0,0,0,,为什么？因为它是一个节点的地址，第一个、第二个、第三个。
Dialogue: 0,1:16:08.96,1:16:11.92,英文,,0,0,0,,And I'm going to set that equal to whatever the beginning of the list is.
Dialogue: 0,1:16:08.96,1:16:11.92,中文,,0,0,0,,我要把它设置为列表开头的任何内容。
Dialogue: 0,1:16:11.92,1:16:19.44,英文,,0,0,0,,So that is going to be equivalent to this version of the picture here, where pointer is just temporarily pointing at the first node in the list.
Dialogue: 0,1:16:11.92,1:16:19.44,中文,,0,0,0,,所以这将等同于图中的这个版本，其中 ptr 只是暂时指向列表中的第一个节点。
Dialogue: 0,1:16:19.44,1:16:21.44,英文,,0,0,0,,It's not pointing at list, per se.
Dialogue: 0,1:16:19.44,1:16:21.44,中文,,0,0,0,,它本身不是指向列表。
Dialogue: 0,1:16:21.44,1:16:25.66,英文,,0,0,0,,It's pointing at the first node in the list, which list is also pointing at itself.
Dialogue: 0,1:16:21.44,1:16:25.66,中文,,0,0,0,,它指向列表中的第一个节点，而列表本身也指向它自己。
Dialogue: 0,1:16:25.66,1:16:36.86,英文,,0,0,0,,All right, once I've done this, I think I can translate this to code that's a little new, but it's conceptually familiar perhaps now, while that pointer does not equal null.
Dialogue: 0,1:16:25.66,1:16:36.86,中文,,0,0,0,,一旦我完成这个，我想我可以把它翻译成一些新的代码，但现在从概念上来说可能很熟悉，当指针不等于 NULL 时。
Dialogue: 0,1:16:36.86,1:16:44.44,英文,,0,0,0,,So while I have a valid pointer, like my finger or that arrow is pointing at an actual node in memory, well, let me go ahead and print it out.
Dialogue: 0,1:16:36.86,1:16:44.44,中文,,0,0,0,,当我们有一个有效的指针，就像我的手指或箭头指向内存中的一个实际节点，我可以继续打印它。
Dialogue: 0,1:16:44.44,1:16:50.20,英文,,0,0,0,,So let me print out with %i backslash n whatever is in the current node
Dialogue: 0,1:16:44.44,1:16:50.20,中文,,0,0,0,,让我用 %i 反斜杠 n 打印出当前节点中的任何内容
Dialogue: 0,1:16:50.20,1:16:53.49,英文,,0,0,0,,at the number field within.
Dialogue: 0,1:16:50.20,1:16:53.49,中文,,0,0,0,,在数字字段内。
Dialogue: 0,1:16:53.49,1:16:57.43,英文,,0,0,0,,And again, this is going to have the effect, hopefully, of first printing the 3.
Dialogue: 0,1:16:53.49,1:16:57.43,中文,,0,0,0,,同样，我希望这会起到首先打印 3 的效果。
Dialogue: 0,1:16:57.43,1:17:04.22,英文,,0,0,0,,And I think I just need to now update the pointer so that on the next iteration, it's pointing at the next value.
Dialogue: 0,1:16:57.43,1:17:04.22,中文,,0,0,0,,我认为我现在只需要更新指针，以便在下一次迭代中，它指向下一个值。
Dialogue: 0,1:17:04.22,1:17:06.24,英文,,0,0,0,,So if this is where the story is,
Dialogue: 0,1:17:04.22,1:17:06.24,中文,,0,0,0,,如果这就是故事的开头，
Dialogue: 0,1:17:06.24,1:17:10.02,英文,,0,0,0,,How do I update pointer to point at the second element of the list?
Dialogue: 0,1:17:06.24,1:17:10.02,中文,,0,0,0,,如何更新指针以指向列表的第二个元素？
Dialogue: 0,1:17:10.02,1:17:14.97,英文,,0,0,0,,Well, I want pointer to point at the 2, and I want pointer to eventually point at the 3.
Dialogue: 0,1:17:10.02,1:17:14.97,中文,,0,0,0,,我希望指针指向 2，并且我希望指针最终指向 3。
Dialogue: 0,1:17:14.97,1:17:15.93,英文,,0,0,0,,Well, how do I do that?
Dialogue: 0,1:17:14.97,1:17:15.93,中文,,0,0,0,,我该怎么做呢？
Dialogue: 0,1:17:15.93,1:17:19.29,英文,,0,0,0,,Well, the way in code I can follow these arrows is as follows.
Dialogue: 0,1:17:15.93,1:17:19.29,中文,,0,0,0,,在代码中，我可以按照以下方式来跟踪这些箭头。
Dialogue: 0,1:17:19.29,1:17:27.66,英文,,0,0,0,,If I currently have pointer pointing at this node, but I want to point it at the next node, I can borrow This pointer here.
Dialogue: 0,1:17:19.29,1:17:27.66,中文,,0,0,0,,如果我当前的指针指向这个节点，但我希望它指向下一个节点，我可以借用这个指针。
Dialogue: 0,1:17:27.66,1:17:33.87,英文,,0,0,0,,So whatever this address is in the first node, a.k.a. the next field, I can copy that into pointer.
Dialogue: 0,1:17:27.66,1:17:33.87,中文,,0,0,0,,第一个节点中的这个地址，也就是 next 字段，我可以把它复制到指针中。
Dialogue: 0,1:17:33.87,1:17:39.46,英文,,0,0,0,,Because then pointer will point at whatever this is pointing at by just setting one equal to the other.
Dialogue: 0,1:17:33.87,1:17:39.46,中文,,0,0,0,,因为这样指针就会指向这个指针所指向的任何东西，只需将一个设置为另一个即可。
Dialogue: 0,1:17:39.46,1:17:47.10,英文,,0,0,0,,So once I've done that, the picture will become This, and how do I translate that to code?
Dialogue: 0,1:17:39.46,1:17:47.10,中文,,0,0,0,,一旦我完成这些，图片就会变成这样，我该如何用代码翻译呢？
Dialogue: 0,1:17:47.10,1:17:50.35,英文,,0,0,0,,It, while new syntax, is surprisingly straightforward.
Dialogue: 0,1:17:47.10,1:17:50.35,中文,,0,0,0,,它虽然是新的语法，但非常简单。
Dialogue: 0,1:17:50.35,1:18:00.37,英文,,0,0,0,,All I need do is say pointer, after printing it, equals whatever pointer currently is, but grab its next field instead.
Dialogue: 0,1:17:50.35,1:18:00.37,中文,,0,0,0,,我只需要在打印后说指针等于当前的指针，但取它的 next 字段即可。
Dialogue: 0,1:18:00.37,1:18:02.05,英文,,0,0,0,,And this is a very common paradigm.
Dialogue: 0,1:18:00.37,1:18:02.05,中文,,0,0,0,,这是一个非常常见的范例。
Dialogue: 0,1:18:02.05,1:18:09.70,英文,,0,0,0,,When iterating over a linked list and you're using some temporary variable like pointer, you can simply set pointer equal to pointer next.
Dialogue: 0,1:18:02.05,1:18:09.70,中文,,0,0,0,,当迭代链表并且使用一些临时变量（如指针）时，可以直接将指针设置为等于指针的下一个节点。
Dialogue: 0,1:18:09.70,1:18:14.41,英文,,0,0,0,,And what that means here is as follows. If this is pointer.
Dialogue: 0,1:18:09.70,1:18:14.41,中文,,0,0,0,,这意味着： 如果这是指针。
Dialogue: 0,1:18:14.41,1:18:16.83,英文,,0,0,0,,Pointing from here down to here.
Dialogue: 0,1:18:14.41,1:18:16.83,中文,,0,0,0,,从这里指向这里。
Dialogue: 0,1:18:16.83,1:18:20.18,英文,,0,0,0,,Pointer next is follow the arrow, grab the next field.
Dialogue: 0,1:18:16.83,1:18:20.18,中文,,0,0,0,,指针的下一个节点是沿着箭头，抓住下一个字段。
Dialogue: 0,1:18:20.18,1:18:26.78,英文,,0,0,0,,So if you set pointer equal to this thing, that's the same thing as pointing this at this same box.
Dialogue: 0,1:18:20.18,1:18:26.78,中文,,0,0,0,,如果将指针设置为等于这个东西，那就相当于将指针指向同一个方框。
Dialogue: 0,1:18:26.78,1:18:34.91,英文,,0,0,0,,And indeed, if I advance to the next slide, even though the arrows are technically pointing at different parts of the rectangles, that's just for graphics sake.
Dialogue: 0,1:18:26.78,1:18:34.91,中文,,0,0,0,,事实上，如果我前进到下一张幻灯片，即使箭头在技术上指向矩形的不同部分，那也只是为了图形上的原因。
Dialogue: 0,1:18:34.91,1:18:36.63,英文,,0,0,0,,Pointer is now pointing at the second node.
Dialogue: 0,1:18:34.91,1:18:36.63,中文,,0,0,0,,指针现在指向第二个节点。
Dialogue: 0,1:18:36.63,1:18:39.67,英文,,0,0,0,,And when I do this again on my next iteration, it points at this.
Dialogue: 0,1:18:36.63,1:18:39.67,中文,,0,0,0,,当我在下一次迭代中再次这样做时，它指向这里。
Dialogue: 0,1:18:39.67,1:18:47.71,英文,,0,0,0,,And then this last step, notice, when I keep doing pointer equals pointer next, this will become eventually this value.
Dialogue: 0,1:18:39.67,1:18:47.71,中文,,0,0,0,,然后最后一步，注意，当我一直做指针等于指针的下一个节点时，这最终将变成这个值。
Dialogue: 0,1:18:47.71,1:18:50.75,英文,,0,0,0,,But what's this value in this linked list?
Dialogue: 0,1:18:47.71,1:18:50.75,中文,,0,0,0,,但是在这个链表中，这个值是什么？
Dialogue: 0,1:18:50.75,1:18:52.07,英文,,0,0,0,,It's null, technically.
Dialogue: 0,1:18:50.75,1:18:52.07,中文,,0,0,0,,从技术上讲，它是 NULL。
Dialogue: 0,1:18:52.07,1:18:57.65,英文,,0,0,0,,So this arrow will eventually take on this value when I set pointer equal to pointer next.
Dialogue: 0,1:18:52.07,1:18:57.65,中文,,0,0,0,,当我将指针设置为指针的下一个节点时，这个箭头最终将取这个值。
Dialogue: 0,1:18:57.65,1:19:02.65,英文,,0,0,0,,And at that point, PTR, my temporary pointer, is going to be null.
Dialogue: 0,1:18:57.65,1:19:02.65,中文,,0,0,0,,此时，我的临时指针 PTR 将为 NULL。
Dialogue: 0,1:19:02.65,1:19:04.99,英文,,0,0,0,,So it might as well look like this pictorially.
Dialogue: 0,1:19:02.65,1:19:04.99,中文,,0,0,0,,所以它看起来就像这幅图一样。
Dialogue: 0,1:19:04.99,1:19:07.93,英文,,0,0,0,,And what does that mean for my loop?
Dialogue: 0,1:19:04.99,1:19:07.93,中文,,0,0,0,,这对我的循环意味着什么？
Dialogue: 0,1:19:07.93,1:19:17.43,英文,,0,0,0,,Once pointer is null, because you've walked off the end of the linked list, what's going to be true of this loop here started in line 32?
Dialogue: 0,1:19:07.93,1:19:17.43,中文,,0,0,0,,一旦指针为 NULL，因为已经走到了链表的末尾，那么在第 32 行开始的这个循环会发生什么？
Dialogue: 0,1:19:17.43,1:19:21.01,英文,,0,0,0,,Any observations here?
Dialogue: 0,1:19:17.43,1:19:21.01,中文,,0,0,0,,有什么发现吗？
Dialogue: 0,1:19:21.01,1:19:21.97,英文,,0,0,0,,What's going to be true?
Dialogue: 0,1:19:21.01,1:19:21.97,中文,,0,0,0,,会发生什么？
Dialogue: 0,1:19:21.97,1:19:24.58,英文,,0,0,0,,What will happen now as soon as we hit the end of the list?
Dialogue: 0,1:19:21.97,1:19:24.58,中文,,0,0,0,,当我们到达列表末尾时会发生什么？
Dialogue: 0,1:19:24.58,1:19:26.84,英文,,0,0,0,,Yeah, sorry.
Dialogue: 0,1:19:24.58,1:19:26.84,中文,,0,0,0,,是的，抱歉。
Dialogue: 0,1:19:26.84,1:19:28.02,英文,,0,0,0,,The loop is going to break out.
Dialogue: 0,1:19:26.84,1:19:28.02,中文,,0,0,0,,循环会跳出。
Dialogue: 0,1:19:28.02,1:19:28.40,英文,,0,0,0,,Why?
Dialogue: 0,1:19:28.02,1:19:28.40,中文,,0,0,0,,为什么？
Dialogue: 0,1:19:28.40,1:19:38.55,英文,,0,0,0,,Because line 32, which is constantly asking, while pointer does not equal null, well, if pointer finally equals null three steps later, the while loop is now done.
Dialogue: 0,1:19:28.40,1:19:38.55,中文,,0,0,0,,因为第 32 行，它一直在询问，当指针不等于 NULL 时，如果指针在之后的三个步骤后最终等于 NULL，那么 while 循环就结束了。
Dialogue: 0,1:19:38.55,1:19:44.27,英文,,0,0,0,,And so what I can do at the end of this program once I've printed out those values, well, first, let's go ahead and open my terminal window.
Dialogue: 0,1:19:38.55,1:19:44.27,中文,,0,0,0,,所以在这个程序结束时，在我打印出这些值之后，我可以做的是，首先，让我们打开我的终端窗口。
Dialogue: 0,1:19:44.27,1:19:47.83,英文,,0,0,0,,Let's make list. OK, a compile dot slash list.
Dialogue: 0,1:19:44.27,1:19:47.83,中文,,0,0,0,,让我们创建链表。编译，./list。
Dialogue: 0,1:19:47.83,1:19:51.21,英文,,0,0,0,,And let me try the same values, 1 and 2 and 3.
Dialogue: 0,1:19:47.83,1:19:51.21,中文,,0,0,0,,让我尝试相同的值，1、2 和 3。
Dialogue: 0,1:19:51.21,1:19:57.42,英文,,0,0,0,,That's going to, again, allocate one node, two node, three nodes by prepending, prepending, prepending each of those values.
Dialogue: 0,1:19:51.21,1:19:57.42,中文,,0,0,0,,这将再次通过前置、前置、前置每个值来分配一个节点、两个节点、三个节点。
Dialogue: 0,1:19:57.42,1:20:00.12,英文,,0,0,0,,And it's then going to iterate over them from left to right.
Dialogue: 0,1:19:57.42,1:20:00.12,中文,,0,0,0,,然后它将从左到右迭代它们。
Dialogue: 0,1:20:00.12,1:20:07.14,英文,,0,0,0,,And so when I hit Enter now, what should I see on the screen if my code is correct?
Dialogue: 0,1:20:00.12,1:20:07.14,中文,,0,0,0,,所以当我按下回车键时，如果我的代码是正确的，我应该在屏幕上看到什么？
Dialogue: 0,1:20:07.14,1:20:12.11,英文,,0,0,0,,What will I see, if we were to just call it out?
Dialogue: 0,1:20:07.14,1:20:12.11,中文,,0,0,0,,如果我们直接说出来，我们会看到什么？
Dialogue: 0,1:20:12.11,1:20:14.53,英文,,0,0,0,,3, 2, 1, because I've prepended, presumably.
Dialogue: 0,1:20:12.11,1:20:14.53,中文,,0,0,0,,3、2、1，因为我可能已经前置了。
Dialogue: 0,1:20:14.53,1:20:17.23,英文,,0,0,0,,And here we go. I indeed see 3, 2, 1.
Dialogue: 0,1:20:14.53,1:20:17.23,中文,,0,0,0,,来了。 我确实看到了 3、2、1。
Dialogue: 0,1:20:17.23,1:20:20.19,英文,,0,0,0,,So the list is backwards, but all of the elements are there.
Dialogue: 0,1:20:17.23,1:20:20.19,中文,,0,0,0,,所以链表是反向的，但所有元素都在那里。
Dialogue: 0,1:20:20.19,1:20:25.66,英文,,0,0,0,,Now, technically, if I ran Valgrind on this, Valgrind would not be happy, because I have never freed any of my memory.
Dialogue: 0,1:20:20.19,1:20:25.66,中文,,0,0,0,,现在，从技术上讲，如果我在这上面运行 Valgrind，Valgrind 会不高兴，因为我从来没有释放过任何内存。
Dialogue: 0,1:20:25.66,1:20:29.40,英文,,0,0,0,,So I should probably now have a second loop here that does something like this.
Dialogue: 0,1:20:25.66,1:20:29.40,中文,,0,0,0,,所以我可能应该在这里再写一个循环，像这样。
Dialogue: 0,1:20:29.40,1:20:32.06,英文,,0,0,0,,Let me again set pointer equal to list.
Dialogue: 0,1:20:29.40,1:20:32.06,中文,,0,0,0,,让我再次将指针设置为链表。
Dialogue: 0,1:20:32.06,1:20:35.84,英文,,0,0,0,,I don't need to redeclare it, because I've already created this thing on line 31.
Dialogue: 0,1:20:32.06,1:20:35.84,中文,,0,0,0,,我不需要重新声明它，因为我已经在第 31 行创建了这个东西。
Dialogue: 0,1:20:35.84,1:20:38.72,英文,,0,0,0,,I just want to reset it to be the beginning of the list again.
Dialogue: 0,1:20:35.84,1:20:38.72,中文,,0,0,0,,我只是想把它重置为链表的开头。
Dialogue: 0,1:20:38.72,1:20:40.26,英文,,0,0,0,,And now I can do the same kind of thing.
Dialogue: 0,1:20:38.72,1:20:40.26,中文,,0,0,0,,现在我可以做同样的事情。
Dialogue: 0,1:20:40.26,1:20:45.73,英文,,0,0,0,,While PTR not equals null, go ahead and do this.
Dialogue: 0,1:20:40.26,1:20:45.73,中文,,0,0,0,,当 PTR 不等于 NULL 时，继续执行此操作。
Dialogue: 0,1:20:45.73,1:20:53.12,英文,,0,0,0,,Well, I don't want to just do free pointer and then do pointer gets pointer next.
Dialogue: 0,1:20:45.73,1:20:53.12,中文,,0,0,0,,但是，我不想只是执行 free ptr，然后执行 ptr gets ptr next。
Dialogue: 0,1:20:53.12,1:20:54.14,英文,,0,0,0,,Why?
Dialogue: 0,1:20:53.12,1:20:54.14,中文,,0,0,0,,为什么？
Dialogue: 0,1:20:54.14,1:20:58.26,英文,,0,0,0,,My goal is to free all of my memory, but I think this is going to get me in trouble.
Dialogue: 0,1:20:54.14,1:20:58.26,中文,,0,0,0,,我的目标是释放所有内存，但我认为这会给我带来麻烦。
Dialogue: 0,1:20:58.26,1:21:03.62,英文,,0,0,0,,Pointer equals list just gives me a temporary pointer that points at the 3, and then eventually the 2, and then the 1.
Dialogue: 0,1:20:58.26,1:21:03.62,中文,,0,0,0,,ptr = list 只是给了我一个指向 3 的临时指针，最终指向 2，然后指向 1。
Dialogue: 0,1:21:03.62,1:21:04.26,英文,,0,0,0,,How?
Dialogue: 0,1:21:03.62,1:21:04.26,中文,,0,0,0,,怎么做？
Dialogue: 0,1:21:04.26,1:21:06.97,英文,,0,0,0,,Well, while pointer not equal null, I'm freeing the pointer.
Dialogue: 0,1:21:04.26,1:21:06.97,中文,,0,0,0,,当 ptr 不等于 NULL 时，我释放 ptr。
Dialogue: 0,1:21:06.97,1:21:11.67,英文,,0,0,0,,So this is like saying to malloc, free that node, free that node, free that node.
Dialogue: 0,1:21:06.97,1:21:11.67,中文,,0,0,0,,所以这就像是对 malloc 说，释放那个节点，释放那个节点，释放那个节点。
Dialogue: 0,1:21:11.67,1:21:16.13,英文,,0,0,0,,But what's the problem with what I've just done here?
Dialogue: 0,1:21:11.67,1:21:16.13,中文,,0,0,0,,但是我在这里所做的有什么问题？
Dialogue: 0,1:21:16.13,1:21:18.03,英文,,0,0,0,,This code is technically buggy.
Dialogue: 0,1:21:16.13,1:21:18.03,中文,,0,0,0,,这段代码在技术上有 bug。
Dialogue: 0,1:21:18.03,1:21:22.39,英文,,0,0,0,,Yeah.
Dialogue: 0,1:21:18.03,1:21:22.39,中文,,0,0,0,,是的。
Dialogue: 0,1:21:22.39,1:21:30.23,英文,,0,0,0,,Exactly, after you call free on pointer, you are, by social contract with C, not allowed to touch pointer anymore.
Dialogue: 0,1:21:22.39,1:21:30.23,中文,,0,0,0,,没错，当你对 ptr 调用 free 后，根据与 C 的约定，你不能再碰 ptr 了。
Dialogue: 0,1:21:30.23,1:21:31.44,英文,,0,0,0,,It is invalid.
Dialogue: 0,1:21:30.23,1:21:31.44,中文,,0,0,0,,它是无效的。
Dialogue: 0,1:21:31.44,1:21:32.58,英文,,0,0,0,,Now, it's still going to be a number.
Dialogue: 0,1:21:31.44,1:21:32.58,中文,,0,0,0,,现在，它仍然是一个数字。
Dialogue: 0,1:21:32.58,1:21:35.28,英文,,0,0,0,,It's still going to be a pattern of bits. But it's invalid.
Dialogue: 0,1:21:32.58,1:21:35.28,中文,,0,0,0,,它仍然是一串比特序列。但它是无效的。
Dialogue: 0,1:21:35.28,1:21:40.32,英文,,0,0,0,,And you'll very often get a segmentation fault if you tempt fate in that way.
Dialogue: 0,1:21:35.28,1:21:40.32,中文,,0,0,0,,如果你那样冒险的话，你经常会遇到段错误。
Dialogue: 0,1:21:40.32,1:21:44.02,英文,,0,0,0,,So I can't free the pointer and then use it literally the next line.
Dialogue: 0,1:21:40.32,1:21:44.02,中文,,0,0,0,,所以我不能释放 ptr，然后在下一行就使用它。
Dialogue: 0,1:21:44.02,1:21:49.38,英文,,0,0,0,,The solution here, kind of like our swapping of the liquids last time, was to maybe just have a temporary variable.
Dialogue: 0,1:21:44.02,1:21:49.38,中文,,0,0,0,,这里的解决方案，有点像我们上次交换液体，可能是使用一个临时变量。
Dialogue: 0,1:21:49.38,1:21:55.90,英文,,0,0,0,,So I can do a switcheroo. And so a common way to solve this problem to get the order of operations right would be to do something like this.
Dialogue: 0,1:21:49.38,1:21:55.90,中文,,0,0,0,,所以我可以做一个交换。解决这个问题以获得正确的操作顺序的常见方法是执行以下操作。
Dialogue: 0,1:21:55.90,1:22:00.02,英文,,0,0,0,,Give yourself a temporary pointer, like node star next.
Dialogue: 0,1:21:55.90,1:22:00.02,中文,,0,0,0,,创建一个临时指针，比如 node * next。
Dialogue: 0,1:22:00.02,1:22:05.51,英文,,0,0,0,,Set it equal to the place you want to go next, so one step ahead.
Dialogue: 0,1:22:00.02,1:22:05.51,中文,,0,0,0,,将它设置为你要去的下一个位置，也就是前进一步。
Dialogue: 0,1:22:05.51,1:22:07.53,英文,,0,0,0,,Now you can free pointer.
Dialogue: 0,1:22:05.51,1:22:07.53,中文,,0,0,0,,现在你可以释放指针了。
Dialogue: 0,1:22:07.53,1:22:10.63,英文,,0,0,0,,And then you can update pointer to be that next value.
Dialogue: 0,1:22:07.53,1:22:10.63,中文,,0,0,0,,然后你可以更新指针为下一个值。
Dialogue: 0,1:22:10.63,1:22:12.97,英文,,0,0,0,,So essentially, you need two hands now.
Dialogue: 0,1:22:10.63,1:22:12.97,中文,,0,0,0,,所以本质上，你现在需要两只手。
Dialogue: 0,1:22:12.97,1:22:21.00,英文,,0,0,0,,You create on line 41 another pointer that, if this is pointing at the first node, the 3, your new pointer is pointing at the 2 temporarily.
Dialogue: 0,1:22:12.97,1:22:21.00,中文,,0,0,0,,你在第 41 行创建另一个指针，如果它指向第一个节点，也就是 3，你的新指针暂时指向 2。
Dialogue: 0,1:22:21.00,1:22:27.83,英文,,0,0,0,,So now you can tell malloc, via free, release this memory, but I haven't forgotten where I want to go next.
Dialogue: 0,1:22:21.00,1:22:27.83,中文,,0,0,0,,所以现在你可以通过 free 告诉 malloc 释放这块内存，但我没有忘记我下一步要去哪里。
Dialogue: 0,1:22:27.83,1:22:30.29,英文,,0,0,0,,And so I can now continue on.
Dialogue: 0,1:22:27.83,1:22:30.29,中文,,0,0,0,,所以现在我可以继续了。
Dialogue: 0,1:22:30.29,1:22:35.01,英文,,0,0,0,,So a common paradigm for just iterating over these nodes and then freeing them.
Dialogue: 0,1:22:30.29,1:22:35.01,中文,,0,0,0,,这是一个常见的范例，用于迭代这些节点并释放它们。
Dialogue: 0,1:22:35.01,1:22:36.59,英文,,0,0,0,,A couple of observations.
Dialogue: 0,1:22:35.01,1:22:36.59,中文,,0,0,0,,几点观察。
Dialogue: 0,1:22:36.59,1:22:38.90,英文,,0,0,0,,Strictly speaking, I could have consolidated this.
Dialogue: 0,1:22:36.59,1:22:38.90,中文,,0,0,0,,严格来说，我本来可以合并这个。
Dialogue: 0,1:22:38.90,1:22:43.88,英文,,0,0,0,,I don't need two loops to print the nodes and then free the nodes. I could do that all at once.
Dialogue: 0,1:22:38.90,1:22:43.88,中文,,0,0,0,,我不需要两个循环来打印节点，然后释放节点。我可以一次性完成。
Dialogue: 0,1:22:43.88,1:22:46.86,英文,,0,0,0,,But let's assume that there's other stuff of interest in my program.
Dialogue: 0,1:22:43.88,1:22:46.86,中文,,0,0,0,,但是假设我的程序中还有其他有趣的东西。
Dialogue: 0,1:22:46.86,1:22:48.58,英文,,0,0,0,,And I don't want to just immediately free it.
Dialogue: 0,1:22:46.86,1:22:48.58,中文,,0,0,0,,我不想马上释放它。
Dialogue: 0,1:22:48.58,1:22:51.54,英文,,0,0,0,,There's one other bug that I should probably address here.
Dialogue: 0,1:22:48.58,1:22:51.54,中文,,0,0,0,,还有一个 bug 我应该在这里解决。
Dialogue: 0,1:22:51.54,1:22:54.24,英文,,0,0,0,,There is still a potential memory leak up here.
Dialogue: 0,1:22:51.54,1:22:54.24,中文,,0,0,0,,这里仍然有一个潜在的内存泄漏。
Dialogue: 0,1:22:54.24,1:22:58.12,英文,,0,0,0,,And this one is super subtle, though Valgrind would help you find it.
Dialogue: 0,1:22:54.24,1:22:58.12,中文,,0,0,0,,这一个非常微妙，不过 Valgrind 会帮你找到它。
Dialogue: 0,1:22:58.12,1:23:08.57,英文,,0,0,0,,Notice that in this loop here, when I'm calling malloc, this line of code is fine if the first line of malloc fails and returns null, because I immediately return and I'm done.
Dialogue: 0,1:22:58.12,1:23:08.57,中文,,0,0,0,,注意，在这个循环中，当我调用 malloc 时，如果 malloc 的第一行失败并返回 NULL，这行代码是可以的，因为我会立即返回并完成。
Dialogue: 0,1:23:08.57,1:23:13.95,英文,,0,0,0,,But what if the second call, but not the first, or the third call, but not the first or second fail?
Dialogue: 0,1:23:08.57,1:23:13.95,中文,,0,0,0,,但是，如果第二次调用失败，而第一次没有，或者第三次调用失败，而第一次和第二次都没有，会发生什么？
Dialogue: 0,1:23:13.95,1:23:16.75,英文,,0,0,0,,This line of code has me returning immediately.
Dialogue: 0,1:23:13.95,1:23:16.75,中文,,0,0,0,,这行代码让我立即返回。
Dialogue: 0,1:23:16.75,1:23:25.12,英文,,0,0,0,,You really need to do some garbage collection, so to speak, whereby you really need to go in and free any nodes that you did allocate successfully earlier.
Dialogue: 0,1:23:16.75,1:23:25.12,中文,,0,0,0,,你需要进行一些垃圾回收，也就是说，你需要进入并释放之前成功分配的任何节点。
Dialogue: 0,1:23:25.12,1:23:26.34,英文,,0,0,0,,Honestly, that's going to be a pain in the neck.
Dialogue: 0,1:23:25.12,1:23:26.34,中文,,0,0,0,,老实说，这会很麻烦。
Dialogue: 0,1:23:26.34,1:23:27.62,英文,,0,0,0,,We won't do that here.
Dialogue: 0,1:23:26.34,1:23:27.62,中文,,0,0,0,,我们不会在这里做。
Dialogue: 0,1:23:27.62,1:23:35.92,英文,,0,0,0,,But probably what I'd want to do is write a function called freeList or something like that and call that function to free any nodes I had previously created.
Dialogue: 0,1:23:27.62,1:23:35.92,中文,,0,0,0,,但我可能会写一个叫做 freeList 或类似名字的函数，并调用该函数来释放我之前创建的任何节点。
Dialogue: 0,1:23:35.92,1:23:38.08,英文,,0,0,0,,So it's not quite at the finish line.
Dialogue: 0,1:23:35.92,1:23:38.08,中文,,0,0,0,,所以还没有完全完成。
Dialogue: 0,1:23:38.08,1:23:41.27,英文,,0,0,0,,But the building blocks are indeed here.
Dialogue: 0,1:23:38.08,1:23:41.27,中文,,0,0,0,,但构建块确实在这里。
Dialogue: 0,1:23:41.27,1:23:44.83,英文,,0,0,0,,Questions on this code?
Dialogue: 0,1:23:41.27,1:23:44.83,中文,,0,0,0,,这段代码有问题吗？
Dialogue: 0,1:23:44.83,1:23:50.94,英文,,0,0,0,,And I think it's safe for me to promise that it won't escalate further from that.
Dialogue: 0,1:23:44.83,1:23:50.94,中文,,0,0,0,,我可以保证它不会进一步升级。
Dialogue: 0,1:23:50.94,1:23:54.94,英文,,0,0,0,,Questions on this?
Dialogue: 0,1:23:50.94,1:23:54.94,中文,,0,0,0,,对此有问题吗？
Dialogue: 0,1:23:54.94,1:23:55.78,英文,,0,0,0,,No?
Dialogue: 0,1:23:54.94,1:23:55.78,中文,,0,0,0,,没有？
Dialogue: 0,1:23:55.78,1:23:58.28,英文,,0,0,0,,Well, let me show you one alternative that you might prefer.
Dialogue: 0,1:23:55.78,1:23:58.28,中文,,0,0,0,,让我告诉你一个你可能更喜欢的替代方案。
Dialogue: 0,1:23:58.28,1:23:59.86,英文,,0,0,0,,And I'm pretty sure this isn't an escalation.
Dialogue: 0,1:23:58.28,1:23:59.86,中文,,0,0,0,,我很确定这不是升级。
Dialogue: 0,1:23:59.86,1:24:01.73,英文,,0,0,0,,It's just an alternative formulation.
Dialogue: 0,1:23:59.86,1:24:01.73,中文,,0,0,0,,这只是一个替代方案。
Dialogue: 0,1:24:01.73,1:24:05.03,英文,,0,0,0,,Another way you can iterate over nodes in a list could be this.
Dialogue: 0,1:24:01.73,1:24:05.03,中文,,0,0,0,,迭代列表中节点的另一种方法可能是这样的。
Dialogue: 0,1:24:05.03,1:24:09.35,英文,,0,0,0,,Instead of a while loop, for instance, let me actually show you one other piece of syntax here.
Dialogue: 0,1:24:05.03,1:24:09.35,中文,,0,0,0,,例如，让我告诉你另一种语法，而不是 while 循环。
Dialogue: 0,1:24:09.35,1:24:15.69,英文,,0,0,0,,You could technically use a for loop. You could give yourself a node pointer here that is initialized to the list.
Dialogue: 0,1:24:09.35,1:24:15.69,中文,,0,0,0,,你可以用 for 循环。你可以在这里给自己一个初始化为列表的节点指针。
Dialogue: 0,1:24:15.69,1:24:18.45,英文,,0,0,0,,You can then check in your for loop that it's not equal to null.
Dialogue: 0,1:24:15.69,1:24:18.45,中文,,0,0,0,,然后你可以在 for 循环中检查它是否不等于 NULL。
Dialogue: 0,1:24:18.45,1:24:21.52,英文,,0,0,0,,And then you can do your update, as usual, like this.
Dialogue: 0,1:24:18.45,1:24:21.52,中文,,0,0,0,,然后你可以像往常一样进行更新，就像这样。
Dialogue: 0,1:24:21.52,1:24:25.56,英文,,0,0,0,,Either of these are equivalent, even though this one, I suspect, looks scarier.
Dialogue: 0,1:24:21.52,1:24:25.56,中文,,0,0,0,,这两种方法是等效的，尽管我怀疑这一个看起来更可怕。
Dialogue: 0,1:24:25.56,1:24:28.98,英文,,0,0,0,,It's doing the exact same thing in one line instead of two.
Dialogue: 0,1:24:25.56,1:24:28.98,中文,,0,0,0,,它在一行中完成了两行代码的工作。
Dialogue: 0,1:24:28.98,1:24:33.62,英文,,0,0,0,,But there's no reason we can't use for loops instead of while loops to achieve the same idea.
Dialogue: 0,1:24:28.98,1:24:33.62,中文,,0,0,0,,但我们同样可以使用 `for` 循环而不是 `while` 循环来实现相同的功能。
Dialogue: 0,1:24:33.62,1:24:36.59,英文,,0,0,0,,But I'll leave these two as demonstrations of one approach or the other.
Dialogue: 0,1:24:33.62,1:24:36.59,中文,,0,0,0,,我把这两种方式都留作演示。
Dialogue: 0,1:24:36.59,1:24:45.84,英文,,0,0,0,,But that's just like in week one, for loops, while loops, whatever looks simpler to you, even though admittedly, neither of these probably looks super clean.
Dialogue: 0,1:24:36.59,1:24:45.84,中文,,0,0,0,,就像我们在第一周学到的，`for` 循环，`while` 循环，选择对你来说更简单的，尽管，这两者看起来都不太简洁。
Dialogue: 0,1:24:45.84,1:24:49.78,英文,,0,0,0,,All right, so let's take things back to things more conceptual here.
Dialogue: 0,1:24:45.84,1:24:49.78,中文,,0,0,0,,好了，让我们回到更概念性的内容。
Dialogue: 0,1:24:49.78,1:24:54.70,英文,,0,0,0,,Up until now, we've been inserting elements into this linked list by prepending them.
Dialogue: 0,1:24:49.78,1:24:54.70,中文,,0,0,0,,到目前为止，我们一直通过前插的方式将元素插入到链表中。
Dialogue: 0,1:24:54.70,1:24:57.96,英文,,0,0,0,,Let's consider what the running time, then, is of these operations.
Dialogue: 0,1:24:54.70,1:24:57.96,中文,,0,0,0,,让我们考虑一下这些操作的运行时间。
Dialogue: 0,1:24:57.96,1:25:08.75,英文,,0,0,0,,So if I've got a linked list of size 3 or size n, more generally, time has passed and I've added a lot of things to it, what's going to be the running time, for instance, of searching a linked list for some value?
Dialogue: 0,1:24:57.96,1:25:08.75,中文,,0,0,0,,如果我有一个大小为 3 或 n 的链表，更一般地说，随着时间推移，我在其中添加了很多元素，那么搜索链表中某个值的运行时间是多少呢？
Dialogue: 0,1:25:08.75,1:25:15.34,英文,,0,0,0,,And I'll tell you already, it's not log n because, again, binary search is off the table as per before break.
Dialogue: 0,1:25:08.75,1:25:15.34,中文,,0,0,0,,我先告诉大家，它不是 log n，因为如之前所说，二分查找是不可能的。
Dialogue: 0,1:25:15.34,1:25:23.42,英文,,0,0,0,,So what might the running time be of searching a linked list for some value, like 2 or 3 or 1 or 50?
Dialogue: 0,1:25:15.34,1:25:23.42,中文,,0,0,0,,那么，在链表中搜索某个值（例如 2、3、1 或 50）的运行时间是多少？
Dialogue: 0,1:25:23.42,1:25:27.60,英文,,0,0,0,,What might the running time be?
Dialogue: 0,1:25:23.42,1:25:27.60,中文,,0,0,0,,运行时间是多少？
Dialogue: 0,1:25:27.60,1:25:31.02,英文,,0,0,0,,Oh, O of, I heard it over here, O of n and y. Who is that?
Dialogue: 0,1:25:27.60,1:25:31.02,中文,,0,0,0,,O(n)，我听到有人说了，为什么是 O(n)？
Dialogue: 0,1:25:31.02,1:25:37.91,英文,,0,0,0,,O in the middle here? Why O of n?
Dialogue: 0,1:25:31.02,1:25:37.91,中文,,0,0,0,,中间那位同学，为什么是 O(n)？
Dialogue: 0,1:25:37.91,1:25:44.46,英文,,0,0,0,,Exactly, you're going to have to go through every item in the list, starting from the left, from the beginning, which is how we've been drawing things and connecting the dots.
Dialogue: 0,1:25:37.91,1:25:44.46,中文,,0,0,0,,没错，你必须遍历列表中的每个元素，从左到右，从头开始，就像我们一直在画线连接点一样。
Dialogue: 0,1:25:44.46,1:25:47.00,英文,,0,0,0,,And in the worst case, the element might very well be at the very end.
Dialogue: 0,1:25:44.46,1:25:47.00,中文,,0,0,0,,在最坏的情况下，该元素可能位于最后。
Dialogue: 0,1:25:47.00,1:25:50.26,英文,,0,0,0,,So it's going to be big O of n. What about insertion?
Dialogue: 0,1:25:47.00,1:25:50.26,中文,,0,0,0,,所以它是 O(n) 的。那么插入呢？
Dialogue: 0,1:25:50.26,1:26:00.68,英文,,0,0,0,,How many steps, in terms of big O notation, has it been taking me to insert elements into the linked list using this prepend design?
Dialogue: 0,1:25:50.26,1:26:00.68,中文,,0,0,0,,使用这种前插设计，将元素插入链表需要多少步（用大 O 表示法）？
Dialogue: 0,1:26:00.68,1:26:03.98,英文,,0,0,0,,Yeah, so it's technically constant time, big O of 1.
Dialogue: 0,1:26:00.68,1:26:03.98,中文,,0,0,0,,是的，严格来说是常数时间，也就是 O(1)。
Dialogue: 0,1:26:03.98,1:26:06.28,英文,,0,0,0,,And again, 1 is just representative of any constant.
Dialogue: 0,1:26:03.98,1:26:06.28,中文,,0,0,0,,同样，1 只是表示任意常数。
Dialogue: 0,1:26:06.28,1:26:10.31,英文,,0,0,0,,It could technically be 2 steps or 3 steps or even 10 steps or 100 steps.
Dialogue: 0,1:26:06.28,1:26:10.31,中文,,0,0,0,,它可以是 2 步、3 步，甚至 10 步或 100 步。
Dialogue: 0,1:26:10.31,1:26:16.09,英文,,0,0,0,,But if it's always finite and fixed, then indeed, you can say it's in big O of 1.
Dialogue: 0,1:26:10.31,1:26:16.09,中文,,0,0,0,,但如果它是有限且固定的，那么它就是 O(1)。
Dialogue: 0,1:26:16.09,1:26:17.03,英文,,0,0,0,,Now, why is that?
Dialogue: 0,1:26:16.09,1:26:17.03,中文,,0,0,0,,为什么呢？
Dialogue: 0,1:26:17.03,1:26:23.11,英文,,0,0,0,,Well, again, no matter how long this list gets, so long as there's memory available for me, I can just kind of
Dialogue: 0,1:26:17.03,1:26:23.11,中文,,0,0,0,,同样，无论这个列表有多长，只要我有足够的内存，我就可以
Dialogue: 0,1:26:23.11,1:26:28.39,英文,,0,0,0,,Create a little splice at the beginning of the list to put in the new node, update the original list, and I'm on my way.
Dialogue: 0,1:26:23.11,1:26:28.39,中文,,0,0,0,,在列表的开头创建一个小的拼接来放入新的节点，更新原始列表，然后就完成了。
Dialogue: 0,1:26:28.39,1:26:31.45,英文,,0,0,0,,And it keeps getting longer, even though it might not be spread out in memory.
Dialogue: 0,1:26:28.39,1:26:31.45,中文,,0,0,0,,它会一直变长，即使它可能没有在内存中展开。
Dialogue: 0,1:26:31.45,1:26:36.69,英文,,0,0,0,,So big O of 1 is possible with these linked lists if I indeed prepend things.
Dialogue: 0,1:26:31.45,1:26:36.69,中文,,0,0,0,,所以如果我确实在前面添加元素，那么这些链表的复杂度可能是 O(1)。
Dialogue: 0,1:26:36.69,1:26:40.92,英文,,0,0,0,,Of course, if I prepend things, everything's going to get out of order, potentially.
Dialogue: 0,1:26:36.69,1:26:40.92,中文,,0,0,0,,当然，如果我在前面添加元素，所有元素的顺序都可能被打乱。
Dialogue: 0,1:26:40.92,1:26:43.58,英文,,0,0,0,,And we're going to have maybe the stack property instead of a queue property.
Dialogue: 0,1:26:40.92,1:26:43.58,中文,,0,0,0,,我们可能会有堆栈属性而不是队列属性。
Dialogue: 0,1:26:43.58,1:26:45.82,英文,,0,0,0,,So we might want to do things slightly differently.
Dialogue: 0,1:26:43.58,1:26:45.82,中文,,0,0,0,,所以我们可能想做一些稍微不同的事情。
Dialogue: 0,1:26:45.82,1:26:47.70,英文,,0,0,0,,So instead of doing this.
Dialogue: 0,1:26:45.82,1:26:47.70,中文,,0,0,0,,所以不要这样做。
Dialogue: 0,1:26:47.70,1:26:50.90,英文,,0,0,0,,whereby we kept prepending, prepending, prepending.
Dialogue: 0,1:26:47.70,1:26:50.90,中文,,0,0,0,,我们一直在前面添加，添加，添加。
Dialogue: 0,1:26:50.90,1:26:53.96,英文,,0,0,0,,Suppose we append to the end of the list instead.
Dialogue: 0,1:26:50.90,1:26:53.96,中文,,0,0,0,,假设我们改为在列表的末尾添加。
Dialogue: 0,1:26:53.96,1:27:01.41,英文,,0,0,0,,So if we now insert the 1, the 2, and the 3, as we might want to for a queue to maintain that fairness property, we might start with an empty list.
Dialogue: 0,1:26:53.96,1:27:01.41,中文,,0,0,0,,因此，如果我们现在插入 1、2 和 3，就像我们希望队列保持公平性一样，我们可以从一个空列表开始。
Dialogue: 0,1:27:01.41,1:27:02.77,英文,,0,0,0,,We might add the 1.
Dialogue: 0,1:27:01.41,1:27:02.77,中文,,0,0,0,,我们可以添加 1。
Dialogue: 0,1:27:02.77,1:27:06.03,英文,,0,0,0,,We might append the 2, append the 3.
Dialogue: 0,1:27:02.77,1:27:06.03,中文,,0,0,0,,我们可以追加 2，追加 3。
Dialogue: 0,1:27:06.03,1:27:08.68,英文,,0,0,0,,And so it just is sort of laid out differently in memory.
Dialogue: 0,1:27:06.03,1:27:08.68,中文,,0,0,0,,所以它在内存中的布局就不同了。
Dialogue: 0,1:27:08.68,1:27:16.96,英文,,0,0,0,,And again, if I can come to you in the middle, what's the running time of search, again, when the linked list uses this append implementation?
Dialogue: 0,1:27:08.68,1:27:16.96,中文,,0,0,0,,同样，如果我可以打断一下，当链表使用这种追加实现时，搜索的运行时间是多少？
Dialogue: 0,1:27:16.96,1:27:21.96,英文,,0,0,0,,Yeah, still big O of n, because in the worst case, you're going to have to go through the whole list just to find it.
Dialogue: 0,1:27:16.96,1:27:21.96,中文,,0,0,0,,是的，仍然是 O(n)，因为在最坏的情况下，你必须遍历整个列表才能找到它。
Dialogue: 0,1:27:21.96,1:27:27.52,英文,,0,0,0,,And notice, it doesn't matter if you have an intuition now that the bigger numbers might very well be at the end.
Dialogue: 0,1:27:21.96,1:27:27.52,中文,,0,0,0,,注意，即使你现在有了一种直觉，即较大的数字很可能在最后，这也没关系。
Dialogue: 0,1:27:27.52,1:27:29.50,英文,,0,0,0,,You have no way to jump to the end.
Dialogue: 0,1:27:27.52,1:27:29.50,中文,,0,0,0,,你没办法直接跳到最后。
Dialogue: 0,1:27:29.50,1:27:33.33,英文,,0,0,0,,You have no way to jump to the middle or do anything resembling binary search.
Dialogue: 0,1:27:29.50,1:27:33.33,中文,,0,0,0,,你没办法跳到中间或者做任何类似二分查找的事情。
Dialogue: 0,1:27:33.33,1:27:39.89,英文,,0,0,0,,Every search has to start from the left and follow the arrows again and again. All right, so I don't think we've done any better there.
Dialogue: 0,1:27:33.33,1:27:39.89,中文,,0,0,0,,每次搜索都得从左边开始，然后沿着箭头一次又一次地查找。所以我觉得我们在这方面并没有做得更好。
Dialogue: 0,1:27:39.89,1:27:49.35,英文,,0,0,0,,And in fact, what is insertion's running time now in big O when we're appending to the list in this way, as we might to implement a queue instead of a stack?
Dialogue: 0,1:27:39.89,1:27:49.35,中文,,0,0,0,,事实上，当我们以这种方式向列表末尾添加元素时，就像我们可能在实现队列而不是栈时那样，插入操作的大 O 运行时间是多少？
Dialogue: 0,1:27:49.35,1:27:53.66,英文,,0,0,0,,What's the running time of inserting a new value?
Dialogue: 0,1:27:49.35,1:27:53.66,中文,,0,0,0,,插入一个新值的运行时间是多少？
Dialogue: 0,1:27:53.66,1:27:56.18,英文,,0,0,0,,Big O of?
Dialogue: 0,1:27:53.66,1:27:56.18,中文,,0,0,0,,大 O 是多少？
Dialogue: 0,1:27:56.18,1:28:08.00,英文,,0,0,0,,So not big O of 1 in this case, but big O of n, because if I'm appending by definition, I have to start here and traverse the whole thing looking for the n. Now, this is a bit of an overstatement, right?
Dialogue: 0,1:27:56.18,1:28:08.00,中文,,0,0,0,,在这种情况下不是 O(1)，而是 O(n)，因为如果我要在末尾添加元素，\N根据定义，我必须从这里开始遍历整个列表，寻找第 n 个元素。当然，这有点夸张，对吧？
Dialogue: 0,1:28:08.00,1:28:17.59,英文,,0,0,0,,You could obviously optimize this slightly by maybe adding another variable that always points to the last element, sort of a cheat sheet, a shortcut that gets you all the way to the end.
Dialogue: 0,1:28:08.00,1:28:17.59,中文,,0,0,0,,你显然可以通过添加另一个始终指向最后一个元素的变量来稍微优化它，就像一个备忘录，一条捷径，可以让你直接到达末尾。
Dialogue: 0,1:28:17.59,1:28:18.83,英文,,0,0,0,,That's totally fine.
Dialogue: 0,1:28:17.59,1:28:18.83,中文,,0,0,0,,这完全没问题。
Dialogue: 0,1:28:18.83,1:28:26.27,英文,,0,0,0,,It doesn't really fit the traditional definition of a singly linked list, but there's absolutely smart engineering solutions to these kinds of problems, but as designed,
Dialogue: 0,1:28:18.83,1:28:26.27,中文,,0,0,0,,它并不完全符合单链表的传统定义，但对于这类问题，绝对有聪明的工程解决方案，但从设计上来说，
Dialogue: 0,1:28:26.27,1:28:34.40,英文,,0,0,0,,It would indeed be big O of n to insert to if you've got to go all the way to the end and you're not using a little extra memory to get yourself there quickly.
Dialogue: 0,1:28:26.27,1:28:34.40,中文,,0,0,0,,如果你必须一直走到末尾，并且没有使用一点额外的内存来快速到达那里，那么插入操作确实需要 O(n) 的时间。
Dialogue: 0,1:28:34.40,1:28:38.94,英文,,0,0,0,,Well, what if we want to take things one last step and not just append blindly?
Dialogue: 0,1:28:34.40,1:28:38.94,中文,,0,0,0,,那么，如果我们想更进一步，不只是盲目地追加元素呢？
Dialogue: 0,1:28:38.94,1:28:44.90,英文,,0,0,0,,Because even though I inserted 1, 2, 3, if I inserted them in random order, they would end up in random order.
Dialogue: 0,1:28:38.94,1:28:44.90,中文,,0,0,0,,因为即使我插入了 1、2、3，如果我以随机顺序插入它们，它们最终也会以随机顺序排列。
Dialogue: 0,1:28:44.90,1:28:48.80,英文,,0,0,0,,What if you want to maintain a sorted list from smallest to largest?
Dialogue: 0,1:28:44.90,1:28:48.80,中文,,0,0,0,,如果你想维护一个从最小到最大的排序列表呢？
Dialogue: 0,1:28:48.80,1:28:51.20,英文,,0,0,0,,Well, then you might want to insert numbers like this.
Dialogue: 0,1:28:48.80,1:28:51.20,中文,,0,0,0,,那么，你可能想这样插入数字。
Dialogue: 0,1:28:51.20,1:28:54.61,英文,,0,0,0,,Starting from an empty list, we might have a 2.
Dialogue: 0,1:28:51.20,1:28:54.61,中文,,0,0,0,,从一个空列表开始，我们可能有一个 2。
Dialogue: 0,1:28:54.61,1:28:57.97,英文,,0,0,0,,Then we might try inserting a 1, but we want to keep it sorted.
Dialogue: 0,1:28:54.61,1:28:57.97,中文,,0,0,0,,然后我们可能会尝试插入 1，但我们想保持排序。
Dialogue: 0,1:28:57.97,1:29:00.59,英文,,0,0,0,,So now we're going to prepend in our code.
Dialogue: 0,1:28:57.97,1:29:00.59,中文,,0,0,0,,所以现在我们要在代码中把它插到前面。
Dialogue: 0,1:29:00.59,1:29:02.87,英文,,0,0,0,,But then you might want to insert a 4.
Dialogue: 0,1:29:00.59,1:29:02.87,中文,,0,0,0,,但你可能想插入一个 4。
Dialogue: 0,1:29:02.87,1:29:07.61,英文,,0,0,0,,So you would append the 4, because you're probably going to look for the right spot to insert it.
Dialogue: 0,1:29:02.87,1:29:07.61,中文,,0,0,0,,所以你会在末尾追加 4，因为你可能会寻找合适的位置插入它。
Dialogue: 0,1:29:07.61,1:29:09.37,英文,,0,0,0,,Then we're going to insert a 3.
Dialogue: 0,1:29:07.61,1:29:09.37,中文,,0,0,0,,然后我们要插入一个 3。
Dialogue: 0,1:29:09.37,1:29:17.79,英文,,0,0,0,,And this one's getting a little annoying, because now you have to iterate over the list, look for the right spot, and then do a little smarter of a splice.
Dialogue: 0,1:29:09.37,1:29:17.79,中文,,0,0,0,,这一个就有点烦人了，因为现在你必须遍历列表，找到合适的位置，然后进行更巧妙的拼接。
Dialogue: 0,1:29:17.79,1:29:18.87,英文,,0,0,0,,But it's possible.
Dialogue: 0,1:29:17.79,1:29:18.87,中文,,0,0,0,,但这是有可能的。
Dialogue: 0,1:29:18.87,1:29:21.11,英文,,0,0,0,,But you don't want to orphan the 4, for instance.
Dialogue: 0,1:29:18.87,1:29:21.11,中文,,0,0,0,,但例如，你也不想把 4 孤立起来。
Dialogue: 0,1:29:21.11,1:29:24.25,英文,,0,0,0,,And then ultimately, we get back to this question.
Dialogue: 0,1:29:21.11,1:29:24.25,中文,,0,0,0,,最终，我们回到这个问题。
Dialogue: 0,1:29:24.25,1:29:30.19,英文,,0,0,0,,What would the performance be of your linked list if you're trying to maintain sorted order?
Dialogue: 0,1:29:24.25,1:29:30.19,中文,,0,0,0,,如果你试图维持排序顺序，那么链表的性能会是什么样的？
Dialogue: 0,1:29:30.19,1:29:34.58,英文,,0,0,0,,Well, search, I think, is going to be big O of n for the same reasons as before.
Dialogue: 0,1:29:30.19,1:29:34.58,中文,,0,0,0,,我认为，出于和之前相同的原因，搜索将会是 O(n) 的。
Dialogue: 0,1:29:34.58,1:29:37.20,英文,,0,0,0,,What about insertion?
Dialogue: 0,1:29:34.58,1:29:37.20,中文,,0,0,0,,插入呢？
Dialogue: 0,1:29:37.20,1:29:39.22,英文,,0,0,0,,Big O of what?
Dialogue: 0,1:29:37.20,1:29:39.22,中文,,0,0,0,,是多少？
Dialogue: 0,1:29:39.22,1:29:46.58,英文,,0,0,0,,For inserting into a sorted linked list. Yeah, in the worst case?
Dialogue: 0,1:29:39.22,1:29:46.58,中文,,0,0,0,,插入到已排序链表中。是的，在最坏的情况下？
Dialogue: 0,1:29:46.58,1:29:51.51,英文,,0,0,0,,Yeah, it's still big O of n. So it's no worse than, but it's not really any better than appending.
Dialogue: 0,1:29:46.58,1:29:51.51,中文,,0,0,0,,是的，它仍然是 O(n) 的。所以它并不比追加差，但实际上也没有比追加好多少。
Dialogue: 0,1:29:51.51,1:30:01.94,英文,,0,0,0,,But we gain the additional property of maintaining a sorted list, which might very well be useful if you're sorting your contacts in your phone or something like that, where it just makes sense to maintain sorted order.
Dialogue: 0,1:29:51.51,1:30:01.94,中文,,0,0,0,,但我们获得了维护排序列表的额外属性，这在你对手机中的联系人进行排序或类似情况下可能非常有用，在这种情况下，保持排序顺序是很有意义的。
Dialogue: 0,1:30:01.94,1:30:19.39,英文,,0,0,0,,Now, in the code for online today, if you take a look at some of the final versions of code, like list6.c and list5.c, as we'll post on the website, you can actually see code that will solve all three of these problems, the prepend version that we wrote live, the append version, which we talked through, as well as this sorted order one.
Dialogue: 0,1:30:01.94,1:30:19.39,中文,,0,0,0,,现在，在今天的在线代码中，如果你看一下一些最终版本的代码，比如 list6.c 和 list5.c，我们会在网站上发布，\N你可以看到代码可以解决所有这三个问题，我们现场写的 prepend 版本，我们讨论过的 append 版本，以及这个排序版本。
Dialogue: 0,1:30:19.39,1:30:23.87,英文,,0,0,0,,But I think I'll avoid showing it live, just because I do think that starts to escalate quickly.
Dialogue: 0,1:30:19.39,1:30:23.87,中文,,0,0,0,,但我认为我会避免现场展示它，因为我认为这会很快升级。
Dialogue: 0,1:30:23.87,1:30:32.21,英文,,0,0,0,,But I think we have enough of a building block, if we're comfortable with prepending, to at least solve some real-world problems with these linked lists.
Dialogue: 0,1:30:23.87,1:30:32.21,中文,,0,0,0,,但我认为，如果我们对 prepend 感到满意，我们就有足够的构建块，至少可以用这些链表解决一些现实世界的问题。
Dialogue: 0,1:30:32.21,1:30:44.70,英文,,0,0,0,,Questions, then, on linked lists, which we'll now leave behind on their own, but now use this technique to solve fancier problems, but much less code.
Dialogue: 0,1:30:32.21,1:30:44.70,中文,,0,0,0,,那么，关于链表的问题，我们现在将把它抛在脑后，现在使用这种技术来解决更复杂的问题，但代码要少得多。
Dialogue: 0,1:30:44.70,1:30:47.06,英文,,0,0,0,,Questions on linked lists.
Dialogue: 0,1:30:44.70,1:30:47.06,中文,,0,0,0,,关于链表的问题。
Dialogue: 0,1:30:47.06,1:30:52.23,英文,,0,0,0,,All right, so to recap, we've kind of taken a sidestep with linked list.
Dialogue: 0,1:30:47.06,1:30:52.23,中文,,0,0,0,,回顾一下，我们已经对链表进行了一些侧面的介绍。
Dialogue: 0,1:30:52.23,1:31:00.77,英文,,0,0,0,,We have this dynamism now where we can grow and shrink our chunks of memory without over-allocating or accidentally under-allocating, as in the world of an array.
Dialogue: 0,1:30:52.23,1:31:00.77,中文,,0,0,0,,我们现在有了这种动态性，我们可以增加和缩减内存块，而不会像数组那样过度分配或意外地分配不足。
Dialogue: 0,1:31:00.77,1:31:10.36,英文,,0,0,0,,We don't have to worry about copying values endlessly, because once you allocate the node, it can just stay wherever it is in memory, and you can just maintain You can just stitch it together somehow.
Dialogue: 0,1:31:00.77,1:31:10.36,中文,,0,0,0,,我们不必担心无休止地复制值，因为一旦分配了节点，它就可以一直停留在内存中的任何位置，你可以保持，你可以以某种方式将它们拼接在一起。
Dialogue: 0,1:31:10.36,1:31:24.13,英文,,0,0,0,,But unfortunately, we've sacrificed what we started the class with in week 0, which was binary search, divide and conquer, which gave us that log n running time, which was really compelling, if you think back to the demonstrations and the visuals.
Dialogue: 0,1:31:10.36,1:31:24.13,中文,,0,0,0,,但不幸的是，我们牺牲了我们在第 0 周开始上课时学到的东西，那就是二分查找、分治法，\N它给了我们 log n 的运行时间，如果你回想一下演示和视觉效果，就会发现它真的很有说服力。
Dialogue: 0,1:31:24.13,1:31:26.06,英文,,0,0,0,,Can we get the best of both worlds?
Dialogue: 0,1:31:24.13,1:31:26.06,中文,,0,0,0,,我们能两全其美吗？
Dialogue: 0,1:31:26.06,1:31:33.72,英文,,0,0,0,,Can we get the sort of speed of binary search, something logarithmic, but the dynamism of something like a linked list?
Dialogue: 0,1:31:26.06,1:31:33.72,中文,,0,0,0,,我们能否获得二分查找的速度，比如对数级别的速度，同时又能像链表那样动态变化呢？
Dialogue: 0,1:31:33.72,1:31:40.97,英文,,0,0,0,,Well, we can, actually, I think, if we start to think not in a single dimension, just the x-axis, if you will, but two dimensions.
Dialogue: 0,1:31:33.72,1:31:40.97,中文,,0,0,0,,实际上，我认为我们可以，如果我们不局限于一维思考，比如 x 轴，而是考虑二维空间。
Dialogue: 0,1:31:40.97,1:31:45.13,英文,,0,0,0,,Such that our data structures can maybe now have width and height, if you will.
Dialogue: 0,1:31:40.97,1:31:45.13,中文,,0,0,0,,这样，我们的数据结构就可以有宽度和高度了。
Dialogue: 0,1:31:45.13,1:31:47.67,英文,,0,0,0,,And so a tree is perhaps the right term here.
Dialogue: 0,1:31:45.13,1:31:47.67,中文,,0,0,0,,因此，树或许是这里合适的术语。
Dialogue: 0,1:31:47.67,1:31:58.12,英文,,0,0,0,,Much like a family tree, if you have sort of your elders up here in the tree and then the branches below them for their children and grandchildren and the like, that's actually what a computer scientist means when they talk about trees.
Dialogue: 0,1:31:47.67,1:31:58.12,中文,,0,0,0,,就像家谱一样，长辈在树的上方，然后是他们孩子和孙子的分支，这实际上就是计算机科学家谈论树时所指的。
Dialogue: 0,1:31:58.12,1:32:05.57,英文,,0,0,0,,Not a tree that grows up like this, but really one that typically is depicted growing down, although this is just an artist's depiction no matter what.
Dialogue: 0,1:31:58.12,1:32:05.57,中文,,0,0,0,,不是像这样向上生长的树，而是通常向下生长的树，尽管这只是艺术家的描绘方式。
Dialogue: 0,1:32:05.57,1:32:19.39,英文,,0,0,0,,But there are certain types of trees in the world called binary search trees that are structured on paper and visually like a family tree, but they have a special property that lends themselves to exactly that feature, binary search.
Dialogue: 0,1:32:05.57,1:32:19.39,中文,,0,0,0,,但是，世界上有一种叫做二叉搜索树的树，它们在纸上和视觉上都像家谱，但是它们有一个特殊的属性，可以实现二分搜索的功能。
Dialogue: 0,1:32:19.39,1:32:26.59,英文,,0,0,0,,So for instance, here is an array back from week 2, and I've sorted a whole bunch of numbers here in from 1 to 7.
Dialogue: 0,1:32:19.39,1:32:26.59,中文,,0,0,0,,例如，这是第二周的一个数组，我在这里对从 1 到 7 的一堆数字进行了排序。
Dialogue: 0,1:32:26.59,1:32:31.82,英文,,0,0,0,,We know we can do binary search on this structure if it's implemented as an array.
Dialogue: 0,1:32:26.59,1:32:31.82,中文,,0,0,0,,我们知道，如果将这种结构实现为数组，就可以对其进行二分搜索。
Dialogue: 0,1:32:31.82,1:32:37.54,英文,,0,0,0,,But what feature do arrays, to be clear, not have that linked lists do?
Dialogue: 0,1:32:31.82,1:32:37.54,中文,,0,0,0,,但是，需要明确的是，数组没有链表的什么特性呢？
Dialogue: 0,1:32:37.54,1:32:38.56,英文,,0,0,0,,Today's kind of a seesaw.
Dialogue: 0,1:32:37.54,1:32:38.56,中文,,0,0,0,,今天的内容就像是在跷跷板的两端。
Dialogue: 0,1:32:38.56,1:32:42.63,英文,,0,0,0,,Like, what did we just gain by adding linked lists that arrays do not allow?
Dialogue: 0,1:32:38.56,1:32:42.63,中文,,0,0,0,,比如，通过添加链表，我们获得了数组所不允许的什么？
Dialogue: 0,1:32:48.32,1:32:52.72,英文,,0,0,0,,Yeah, you can insert more elements without having to copy or moving everything else around.
Dialogue: 0,1:32:48.32,1:32:52.72,中文,,0,0,0,,是的，你可以插入更多元素，而无需复制或移动其他所有元素。
Dialogue: 0,1:32:52.72,1:32:59.99,英文,,0,0,0,,Like right now, in this single dimension, if these values to the left and or right are already used, then you have to move everything.
Dialogue: 0,1:32:52.72,1:32:59.99,中文,,0,0,0,,就像现在，在一维空间中，如果左边或右边的这些值已经被占用，那么你必须移动所有元素。
Dialogue: 0,1:32:59.99,1:33:01.57,英文,,0,0,0,,And that's where we started today's story.
Dialogue: 0,1:32:59.99,1:33:01.57,中文,,0,0,0,,这就是我们今天故事的开始。
Dialogue: 0,1:33:01.57,1:33:07.09,英文,,0,0,0,,So arrays kind of paint you into a corner, because you have to, by definition, decide in advance how big they are.
Dialogue: 0,1:33:01.57,1:33:07.09,中文,,0,0,0,,所以数组会把你限制住，因为你必须事先决定它们的大小。
Dialogue: 0,1:33:07.09,1:33:11.09,英文,,0,0,0,,Well, couldn't we have some kind of array that can still grow?
Dialogue: 0,1:33:07.09,1:33:11.09,中文,,0,0,0,,那么，我们能不能有一种数组可以增长呢？
Dialogue: 0,1:33:11.09,1:33:15.24,英文,,0,0,0,,but still is contiguous so we can do binary search in some way?
Dialogue: 0,1:33:11.09,1:33:15.24,中文,,0,0,0,,但仍然是连续的，以便我们能够以某种方式进行二分搜索？
Dialogue: 0,1:33:15.24,1:33:19.46,英文,,0,0,0,,Well, yes, if we sort of rethink how we implement binary search.
Dialogue: 0,1:33:15.24,1:33:19.46,中文,,0,0,0,,是的，如果我们重新思考如何实现二分搜索的话。
Dialogue: 0,1:33:19.46,1:33:27.51,英文,,0,0,0,,Let me propose that this, I've chosen these seven elements in the array, much like the lockers from week 2.
Dialogue: 0,1:33:19.46,1:33:27.51,中文,,0,0,0,,我建议，就像第二周的储物柜一样，我在数组中选择了这七个元素。
Dialogue: 0,1:33:27.51,1:33:29.91,英文,,0,0,0,,to be ordered from smallest to largest.
Dialogue: 0,1:33:27.51,1:33:29.91,中文,,0,0,0,,按从小到大的顺序排列。
Dialogue: 0,1:33:29.91,1:33:33.14,英文,,0,0,0,,I've highlighted now in yellow the middle elements here.
Dialogue: 0,1:33:29.91,1:33:33.14,中文,,0,0,0,,我现在用黄色突出显示了中间的元素。
Dialogue: 0,1:33:33.14,1:33:41.11,英文,,0,0,0,,And if we were telling the story of we two going left or going right, let me highlight in red the middle elements of the left half and the right half.
Dialogue: 0,1:33:33.14,1:33:41.11,中文,,0,0,0,,如果我们分别讲述向左或向右的故事，让我用红色突出显示左半部分和右半部分的中间元素。
Dialogue: 0,1:33:41.11,1:33:46.05,英文,,0,0,0,,And then let me further highlight in green the other elements in between those.
Dialogue: 0,1:33:41.11,1:33:46.05,中文,,0,0,0,,然后，让我用绿色进一步突出显示它们之间的其他元素。
Dialogue: 0,1:33:46.05,1:33:52.93,英文,,0,0,0,,And there's actually a pattern here, as you might notice, whereby there's one yellow in the middle, and then there's the two red and the four green.
Dialogue: 0,1:33:46.05,1:33:52.93,中文,,0,0,0,,你可能会注意到这里实际上有一个模式，中间有一个黄色，然后是两个红色和四个绿色。
Dialogue: 0,1:33:52.93,1:33:55.51,英文,,0,0,0,,There's kind of an implicit structure there, if you will.
Dialogue: 0,1:33:52.93,1:33:55.51,中文,,0,0,0,,如果你愿意，这里有一种隐含的结构。
Dialogue: 0,1:33:55.51,1:33:57.81,英文,,0,0,0,,And what if I do start to think in two dimensions?
Dialogue: 0,1:33:55.51,1:33:57.81,中文,,0,0,0,,如果我开始用二维思考呢？
Dialogue: 0,1:33:57.81,1:34:13.24,英文,,0,0,0,,And instead of laying out an array of lockers like this on the x-axis only, what if I kind of like slide the four up and pull the one, the three, the five down and kind of draw this in two dimensions instead?
Dialogue: 0,1:33:57.81,1:34:13.24,中文,,0,0,0,,如果不是只在 x 轴上布置这样一排储物柜，而是把这四个向上滑动，把一、三、五个向下滑动，然后用二维的方式来绘制它呢？
Dialogue: 0,1:34:13.24,1:34:15.02,英文,,0,0,0,,Well, let me do that.
Dialogue: 0,1:34:13.24,1:34:15.02,中文,,0,0,0,,我来演示一下。
Dialogue: 0,1:34:15.02,1:34:22.77,英文,,0,0,0,,As by separating these things like this, such that now, let me propose that each of these squares, maybe it doesn't have to be contiguous.
Dialogue: 0,1:34:15.02,1:34:22.77,中文,,0,0,0,,通过像这样把这些东西分开，现在，我假设每个正方形，也许它不必是连续的。
Dialogue: 0,1:34:22.77,1:34:25.17,英文,,0,0,0,,It can be anywhere in the computer's memory.
Dialogue: 0,1:34:22.77,1:34:25.17,中文,,0,0,0,,它可以在计算机内存中的任何位置。
Dialogue: 0,1:34:25.17,1:34:28.07,英文,,0,0,0,,But I can't have these crazy gaps among them.
Dialogue: 0,1:34:25.17,1:34:28.07,中文,,0,0,0,,但我不能在它们之间有这些疯狂的差距。
Dialogue: 0,1:34:28.07,1:34:32.24,英文,,0,0,0,,How could I perhaps keep these things connected conceptually?
Dialogue: 0,1:34:28.07,1:34:32.24,中文,,0,0,0,,如何在概念上保持这些东西的连接呢？
Dialogue: 0,1:34:32.24,1:34:36.94,英文,,0,0,0,,What should I add to the picture, if you will?
Dialogue: 0,1:34:32.24,1:34:36.94,中文,,0,0,0,,如果你愿意，我应该在这张图上添加什么？
Dialogue: 0,1:34:36.94,1:34:38.60,英文,,0,0,0,,Yeah?
Dialogue: 0,1:34:36.94,1:34:38.60,中文,,0,0,0,,嗯？
Dialogue: 0,1:34:38.60,1:34:39.48,英文,,0,0,0,,Say again?
Dialogue: 0,1:34:38.60,1:34:39.48,中文,,0,0,0,,再说一遍？
Dialogue: 0,1:34:39.48,1:34:46.61,英文,,0,0,0,,So branches, metaphorically here, and more technically, in the language of C, maybe just some arrows, some pointers.
Dialogue: 0,1:34:39.48,1:34:46.61,中文,,0,0,0,,比喻地说，是分支，更技术地说，用 C 语言来说，也许只是一些箭头，一些指针。
Dialogue: 0,1:34:46.61,1:34:49.09,英文,,0,0,0,,So I won't bother drawing things as rectangles constantly.
Dialogue: 0,1:34:46.61,1:34:49.09,中文,,0,0,0,,所以我不会总是费心把东西画成矩形。
Dialogue: 0,1:34:49.09,1:34:52.09,英文,,0,0,0,,Let me propose that we're now just abstracting away what a node is.
Dialogue: 0,1:34:49.09,1:34:52.09,中文,,0,0,0,,我假设我们现在只是在抽象出一个节点是什么。
Dialogue: 0,1:34:52.09,1:34:54.57,英文,,0,0,0,,But let me claim that each of these squares now is a node.
Dialogue: 0,1:34:52.09,1:34:54.57,中文,,0,0,0,,但我声明现在每个正方形都是一个节点。
Dialogue: 0,1:34:54.57,1:34:55.99,英文,,0,0,0,,And a node might have a number.
Dialogue: 0,1:34:54.57,1:34:55.99,中文,,0,0,0,,一个节点可能包含一个数字。
Dialogue: 0,1:34:55.99,1:34:59.96,英文,,0,0,0,,But it might also have a pointer, heck, maybe even two or more pointers.
Dialogue: 0,1:34:55.99,1:34:59.96,中文,,0,0,0,,但也可能包含一个指针，甚至两个或更多指针。
Dialogue: 0,1:34:59.96,1:35:01.34,英文,,0,0,0,,And let me draw those now.
Dialogue: 0,1:34:59.96,1:35:01.34,中文,,0,0,0,,让我现在就画出来。
Dialogue: 0,1:35:01.34,1:35:04.86,英文,,0,0,0,,I don't care about addresses like 0x123456789 anymore.
Dialogue: 0,1:35:01.34,1:35:04.86,中文,,0,0,0,,我不再关心 0x123456789 这样的地址了。
Dialogue: 0,1:35:04.86,1:35:07.42,英文,,0,0,0,,Let's just draw our pointers with arrows.
Dialogue: 0,1:35:04.86,1:35:07.42,中文,,0,0,0,,我们直接用箭头来表示指针。
Dialogue: 0,1:35:07.42,1:35:18.04,英文,,0,0,0,,But now, let me propose that we could very well think about this as a tree storing what was previously array data.
Dialogue: 0,1:35:07.42,1:35:18.04,中文,,0,0,0,,现在，我提议我们可以把这看作是一棵树，它存储了之前数组的数据。
Dialogue: 0,1:35:18.04,1:35:21.85,英文,,0,0,0,,But now, each of these nodes can be anywhere in memory.
Dialogue: 0,1:35:18.04,1:35:21.85,中文,,0,0,0,,但现在，每个节点都可以位于内存中的任何位置。
Dialogue: 0,1:35:21.85,1:35:30.57,英文,,0,0,0,,And moreover, even though I've kind of painted myself into a corner visually on the screen, so long as there's more memory in the computer, I could put the number 0 over here.
Dialogue: 0,1:35:21.85,1:35:30.57,中文,,0,0,0,,而且，即使我在屏幕上把自己逼到一个角落里，只要计算机中有更多的内存，我就可以把数字 0 放在这里。
Dialogue: 0,1:35:30.57,1:35:32.61,英文,,0,0,0,,I could put the number 8 over here.
Dialogue: 0,1:35:30.57,1:35:32.61,中文,,0,0,0,,我可以把数字 8 放在这里。
Dialogue: 0,1:35:32.61,1:35:47.44,英文,,0,0,0,,And if I'm smart, I could probably, if I want to insert other numbers like 2.5 or 1.5 or values in between, you know, I bet we could kind of make room by swiveling things around and just kind of hanging things off of these branches slightly differently.
Dialogue: 0,1:35:32.61,1:35:47.44,中文,,0,0,0,,如果我够聪明，如果我想插入其他数字，比如 2.5 或 1.5，或者中间的值，我想我们可以通过旋转和调整分支来腾出空间。
Dialogue: 0,1:35:47.44,1:35:49.16,英文,,0,0,0,,And so what does this gain me?
Dialogue: 0,1:35:47.44,1:35:49.16,中文,,0,0,0,,这样做有什么好处呢？
Dialogue: 0,1:35:49.16,1:35:57.99,英文,,0,0,0,,Well, if I instead start to model my data, not single dimensionally, but in two dimensions, and I connect those nodes with these pointers,
Dialogue: 0,1:35:49.16,1:35:57.99,中文,,0,0,0,,如果我不再用一维的方式，而是用二维的方式对数据进行建模，并用指针连接这些节点，
Dialogue: 0,1:35:57.99,1:35:59.05,英文,,0,0,0,,What can I now do?
Dialogue: 0,1:35:57.99,1:35:59.05,中文,,0,0,0,,我能做什么？
Dialogue: 0,1:35:59.05,1:36:01.37,英文,,0,0,0,,I think I just gave myself back binary search.
Dialogue: 0,1:35:59.05,1:36:01.37,中文,,0,0,0,,我想我又可以用二分查找了。
Dialogue: 0,1:36:01.37,1:36:01.91,英文,,0,0,0,,Why?
Dialogue: 0,1:36:01.37,1:36:01.91,中文,,0,0,0,,为什么？
Dialogue: 0,1:36:01.91,1:36:03.51,英文,,0,0,0,,Suppose I'm searching for the number 5.
Dialogue: 0,1:36:01.91,1:36:03.51,中文,,0,0,0,,假设我要查找数字 5。
Dialogue: 0,1:36:03.51,1:36:04.76,英文,,0,0,0,,How do I find it?
Dialogue: 0,1:36:03.51,1:36:04.76,中文,,0,0,0,,我该如何找到它？
Dialogue: 0,1:36:04.76,1:36:12.06,英文,,0,0,0,,Well, just like in a family tree where you might visually start reading from top to bottom, I'm always going to start from the so-called root of a binary search tree.
Dialogue: 0,1:36:04.76,1:36:12.06,中文,,0,0,0,,就像在家谱中，你可能会从上到下地阅读，我总是从二叉搜索树的所谓根节点开始。
Dialogue: 0,1:36:12.06,1:36:16.79,英文,,0,0,0,,This is just like the list pointer that kicks off the whole linked list process.
Dialogue: 0,1:36:12.06,1:36:16.79,中文,,0,0,0,,这就像链表指针一样，启动了整个链表的处理过程。
Dialogue: 0,1:36:16.79,1:36:18.25,英文,,0,0,0,,This is the so-called root.
Dialogue: 0,1:36:16.79,1:36:18.25,中文,,0,0,0,,这就是所谓的根节点。
Dialogue: 0,1:36:18.25,1:36:19.97,英文,,0,0,0,,All right, here I am at the number 4.
Dialogue: 0,1:36:18.25,1:36:19.97,中文,,0,0,0,,好了，我现在在数字 4。
Dialogue: 0,1:36:19.97,1:36:21.95,英文,,0,0,0,,I want to find the number 5.
Dialogue: 0,1:36:19.97,1:36:21.95,中文,,0,0,0,,我想找到数字 5。
Dialogue: 0,1:36:21.95,1:36:27.71,英文,,0,0,0,,What decision can I make when I see that I'm currently at the number 4, just like the phone book from week 0?
Dialogue: 0,1:36:21.95,1:36:27.71,中文,,0,0,0,,就像第 0 周的电话簿一样，当我看到我目前在数字 4 时，我可以做出什么决定？
Dialogue: 0,1:36:27.71,1:36:30.91,英文,,0,0,0,,Where is 5 not?
Dialogue: 0,1:36:27.71,1:36:30.91,中文,,0,0,0,,5 不在哪里？
Dialogue: 0,1:36:30.91,1:36:32.51,英文,,0,0,0,,It's not to the left.
Dialogue: 0,1:36:30.91,1:36:32.51,中文,,0,0,0,,它不在左边。
Dialogue: 0,1:36:32.51,1:36:38.17,英文,,0,0,0,,And if I had built a little mobile here or something, we could very dramatically snip off this branch.
Dialogue: 0,1:36:32.51,1:36:38.17,中文,,0,0,0,,如果我在这里建了一个小的移动装置什么的，我们可以非常戏剧性地剪掉这个分支。
Dialogue: 0,1:36:38.17,1:36:40.65,英文,,0,0,0,,This is very low-budget animation.
Dialogue: 0,1:36:38.17,1:36:40.65,中文,,0,0,0,,这是非常低成本的动画。
Dialogue: 0,1:36:40.65,1:36:45.99,英文,,0,0,0,,These nodes could fall to the ground, and we're left with half of, essentially, a tree.
Dialogue: 0,1:36:40.65,1:36:45.99,中文,,0,0,0,,这些节点可以掉到地上，我们只剩下了一半的树。
Dialogue: 0,1:36:45.99,1:36:48.61,英文,,0,0,0,,But what do I now know? It's obviously the 5 to the right.
Dialogue: 0,1:36:45.99,1:36:48.61,中文,,0,0,0,,但是我现在知道了什么？很明显，5 在右边。
Dialogue: 0,1:36:48.61,1:36:50.17,英文,,0,0,0,,So let me go to the right.
Dialogue: 0,1:36:48.61,1:36:50.17,中文,,0,0,0,,所以让我走到右边。
Dialogue: 0,1:36:50.17,1:36:51.97,英文,,0,0,0,,6 is obviously not the one I'm looking for.
Dialogue: 0,1:36:50.17,1:36:51.97,中文,,0,0,0,,6 显然不是我要找的。
Dialogue: 0,1:36:51.97,1:36:53.98,英文,,0,0,0,,But what do I now know about the 5?
Dialogue: 0,1:36:51.97,1:36:53.98,中文,,0,0,0,,但我现在对 5 了解多少？
Dialogue: 0,1:36:53.98,1:36:57.60,英文,,0,0,0,,Well, 5 is less than the 6, so I can sort of
Dialogue: 0,1:36:53.98,1:36:57.60,中文,,0,0,0,,5 小于 6，所以我可以
Dialogue: 0,1:36:57.60,1:37:00.96,英文,,0,0,0,,Snip this off here, because I know it's not going to be down there.
Dialogue: 0,1:36:57.60,1:37:00.96,中文,,0,0,0,,把这里剪掉，因为我知道它不会在那里。
Dialogue: 0,1:37:00.96,1:37:02.82,英文,,0,0,0,,And I can follow the remaining arrow here.
Dialogue: 0,1:37:00.96,1:37:02.82,中文,,0,0,0,,我可以沿着剩下的箭头走。
Dialogue: 0,1:37:02.82,1:37:04.78,英文,,0,0,0,,And voila, I just found it.
Dialogue: 0,1:37:02.82,1:37:04.78,中文,,0,0,0,,瞧，我找到了。
Dialogue: 0,1:37:04.78,1:37:08.76,英文,,0,0,0,,And now, without getting into the weeds of the math, I've got here, what, seven elements?
Dialogue: 0,1:37:04.78,1:37:08.76,中文,,0,0,0,,现在，不用深入到数学细节，我这里有多少个元素，7 个？
Dialogue: 0,1:37:08.76,1:37:10.51,英文,,0,0,0,,That's roughly eight if I round up.
Dialogue: 0,1:37:08.76,1:37:10.51,中文,,0,0,0,,如果我四舍五入的话，大概是 8 个。
Dialogue: 0,1:37:10.51,1:37:15.01,英文,,0,0,0,,And if I do some log base 2, I actually, 1, 2, 3 is the key detail here.
Dialogue: 0,1:37:10.51,1:37:15.01,中文,,0,0,0,,如果我取以 2 为底的对数，实际上，1，2，3 是这里的关键细节。
Dialogue: 0,1:37:15.01,1:37:26.12,英文,,0,0,0,,The height of this tree is 3, because I took a list of size 7, and I halved it, and I halved it in order to let it dangle in these two dimensions, plus or minus 1 for rounding's sake.
Dialogue: 0,1:37:15.01,1:37:26.12,中文,,0,0,0,,这棵树的高度是 3，因为我取了一个大小为 7 的列表，我把它减半，然后我又把它减半，以便让它在这两个维度上悬挂，为了四舍五入，加减 1。
Dialogue: 0,1:37:26.12,1:37:27.42,英文,,0,0,0,,So what do I get back?
Dialogue: 0,1:37:26.12,1:37:27.42,中文,,0,0,0,,我得到了什么？
Dialogue: 0,1:37:27.42,1:37:29.96,英文,,0,0,0,,I now have binary search.
Dialogue: 0,1:37:27.42,1:37:29.96,中文,,0,0,0,,我现在拥有了二分查找。
Dialogue: 0,1:37:29.96,1:37:32.82,英文,,0,0,0,,But it's not like the middle of the middle of the middle.
Dialogue: 0,1:37:29.96,1:37:32.82,中文,,0,0,0,,但它不像是在中间的中间的中间。
Dialogue: 0,1:37:32.82,1:37:35.62,英文,,0,0,0,,I now follow these arrows in one of two directions.
Dialogue: 0,1:37:32.82,1:37:35.62,中文,,0,0,0,,我现在沿着这些箭头朝两个方向中的一个前进。
Dialogue: 0,1:37:35.62,1:37:40.02,英文,,0,0,0,,So each of these nodes now has an int and maybe a left pointer and a right pointer.
Dialogue: 0,1:37:35.62,1:37:40.02,中文,,0,0,0,,所以现在每个节点都有一个 int 值，可能还有一个左指针和一个右指针。
Dialogue: 0,1:37:40.02,1:37:41.76,英文,,0,0,0,,But you can call them anything you want.
Dialogue: 0,1:37:40.02,1:37:41.76,中文,,0,0,0,,但你可以随意称呼它们。
Dialogue: 0,1:37:41.76,1:37:48.74,英文,,0,0,0,,And so I've gotten back binary search and dynamism. Because if you want to add 0 or 8 or 9 or 10,
Dialogue: 0,1:37:41.76,1:37:48.74,中文,,0,0,0,,我同时获得了二分查找和动态性。因为如果你想添加 0、8、9 或 10，
Dialogue: 0,1:37:48.74,1:37:52.46,英文,,0,0,0,,We can just dangle them at the bottom of the binary search tree.
Dialogue: 0,1:37:48.74,1:37:52.46,中文,,0,0,0,,我们可以把它们挂在二叉搜索树的底部。
Dialogue: 0,1:37:52.46,1:37:56.51,英文,,0,0,0,,So what would this look like in code, but we won't actually implement it line by line?
Dialogue: 0,1:37:52.46,1:37:56.51,中文,,0,0,0,,那么这在代码中是什么样的呢？但我们不会一行一行地实现它。
Dialogue: 0,1:37:56.51,1:38:05.03,英文,,0,0,0,,Well, here was previously our definition of a node for a linked list, which was one-dimensional, if you will, even though it might bounce up and down on the screen.
Dialogue: 0,1:37:56.51,1:38:05.03,中文,,0,0,0,,这是我们之前对链表节点的定义，它是链表的节点，你可以把它看作是一维的，即使它可能在屏幕上上下跳动。
Dialogue: 0,1:38:05.03,1:38:07.51,英文,,0,0,0,,It was still just a line, if you will.
Dialogue: 0,1:38:05.03,1:38:07.51,中文,,0,0,0,,如果你愿意，它仍然只是一条线。
Dialogue: 0,1:38:07.51,1:38:10.65,英文,,0,0,0,,Well, let me get rid of the single pointer in the linked list.
Dialogue: 0,1:38:07.51,1:38:10.65,中文,,0,0,0,,让我把链表中的单个指针去掉。
Dialogue: 0,1:38:10.65,1:38:18.43,英文,,0,0,0,,Let me make a little bit of room here in this typedef, and let me propose that we just add two pointers, each of which is a struct node star.
Dialogue: 0,1:38:10.65,1:38:18.43,中文,,0,0,0,,让我在这个 typedef 中腾出一点空间，我建议我们添加两个指针，每个指针都是一个 struct node *。
Dialogue: 0,1:38:18.43,1:38:20.48,英文,,0,0,0,,One will be called left by convention.
Dialogue: 0,1:38:18.43,1:38:20.48,中文,,0,0,0,,按照惯例，其中一个叫做 left。
Dialogue: 0,1:38:20.48,1:38:23.02,英文,,0,0,0,,One will be called right by convention.
Dialogue: 0,1:38:20.48,1:38:23.02,中文,,0,0,0,,按照惯例，另一个叫做 right。
Dialogue: 0,1:38:23.02,1:38:35.42,英文,,0,0,0,,And so long as someone, not me, not today, not in class, writes the code that stitches together this data structure too, handling both the left child and the right child, so to speak, I think we can indeed stitch together that
Dialogue: 0,1:38:23.02,1:38:35.42,中文,,0,0,0,,只要有人，不是我，不是今天，不是在课堂上，编写了将这个数据结构拼接在一起的代码，\N同时处理左孩子和右孩子，那么我认为我们确实可以将这个二维结构拼接在一起。
Dialogue: 0,1:38:35.42,1:38:37.10,英文,,0,0,0,,Two-dimensional structure.
Dialogue: 0,1:38:35.42,1:38:37.10,中文,,0,0,0,,二维结构。
Dialogue: 0,1:38:37.10,1:38:47.83,英文,,0,0,0,,And moreover, once you have this in memory, you can translate pretty elegantly to code binary search itself using a principle we talked about recently, too.
Dialogue: 0,1:38:37.10,1:38:47.83,中文,,0,0,0,,此外，一旦你在内存中拥有了这个结构，你就可以使用我们最近讨论过的一个原则，非常优雅地将代码转换为二分查找本身。
Dialogue: 0,1:38:47.83,1:38:59.81,英文,,0,0,0,,Here is, for instance, a function that I'll write by just clicking through steps called search, whose purpose in life is to return a Boolean, true or false, the number I'm looking for is in the tree.
Dialogue: 0,1:38:47.83,1:38:59.81,中文,,0,0,0,,例如，这里有一个我将通过点击步骤编写的函数，叫做 search，它的作用是返回一个布尔值，true 或 false，表示我要查找的数字是否在树中。
Dialogue: 0,1:38:59.81,1:39:08.10,英文,,0,0,0,,This search function, therefore, takes two arguments, the number I'm looking for, called number, and then a pointer to the tree, the so-called root of the tree.
Dialogue: 0,1:38:59.81,1:39:08.10,中文,,0,0,0,,因此，这个 search 函数接受两个参数，我要查找的数字，称为 number，以及指向树的指针，即所谓的树的根。
Dialogue: 0,1:39:08.10,1:39:10.76,英文,,0,0,0,,Now, how can I implement binary search in code?
Dialogue: 0,1:39:08.10,1:39:10.76,中文,,0,0,0,,现在，如何在代码中实现二分查找？
Dialogue: 0,1:39:10.76,1:39:13.53,英文,,0,0,0,,Well, recall our brief discussion of recursion.
Dialogue: 0,1:39:10.76,1:39:13.53,中文,,0,0,0,,回想一下我们刚才讨论的递归。
Dialogue: 0,1:39:13.53,1:39:16.23,英文,,0,0,0,,It turns out recursion is a beautiful technique.
Dialogue: 0,1:39:13.53,1:39:16.23,中文,,0,0,0,,结果是递归是一个很棒的技术。
Dialogue: 0,1:39:16.23,1:39:23.16,英文,,0,0,0,,And honestly, more obvious technique when you have two-dimensional structures, which finally, after five plus weeks, we now do.
Dialogue: 0,1:39:16.23,1:39:23.16,中文,,0,0,0,,老实说，当你面对二维结构的时候，它是一个更明显的技术，在五个多星期之后，我们终于接触到二维结构了。
Dialogue: 0,1:39:23.16,1:39:25.58,英文,,0,0,0,,Here's maybe my first line of code here.
Dialogue: 0,1:39:23.16,1:39:25.58,中文,,0,0,0,,这可能是我的第一行代码。
Dialogue: 0,1:39:25.58,1:39:27.84,英文,,0,0,0,,If the tree is null, then obviously return false.
Dialogue: 0,1:39:25.58,1:39:27.84,中文,,0,0,0,,如果树为空，显然返回 false。
Dialogue: 0,1:39:27.84,1:39:29.12,英文,,0,0,0,,You've handed me an empty tree.
Dialogue: 0,1:39:27.84,1:39:29.12,中文,,0,0,0,,你给我的是一棵空树。
Dialogue: 0,1:39:29.12,1:39:30.25,英文,,0,0,0,,There's nothing going on.
Dialogue: 0,1:39:29.12,1:39:30.25,中文,,0,0,0,,什么都没有。
Dialogue: 0,1:39:30.25,1:39:32.81,英文,,0,0,0,,Obviously, the number you're looking for is not going to be here.
Dialogue: 0,1:39:30.25,1:39:32.81,中文,,0,0,0,,显然，你要找的数字不在里面。
Dialogue: 0,1:39:32.81,1:39:37.61,英文,,0,0,0,,So that's my safe base case to make sure I don't screw up and recurse infinitely.
Dialogue: 0,1:39:32.81,1:39:37.61,中文,,0,0,0,,所以这是我的安全基本情况，确保我不会搞砸并无限递归下去。
Dialogue: 0,1:39:37.61,1:39:39.05,英文,,0,0,0,,Well, what else might be the case?
Dialogue: 0,1:39:37.61,1:39:39.05,中文,,0,0,0,,那么，还有什么可能呢？
Dialogue: 0,1:39:39.05,1:39:41.36,英文,,0,0,0,,Well, if the number I'm looking for
Dialogue: 0,1:39:39.05,1:39:41.36,中文,,0,0,0,,如果我要找的数字
Dialogue: 0,1:39:41.36,1:39:44.86,英文,,0,0,0,,is less than the tree's own number.
Dialogue: 0,1:39:41.36,1:39:44.86,中文,,0,0,0,,小于树本身的数字。
Dialogue: 0,1:39:44.86,1:39:46.78,英文,,0,0,0,,And now recall that tree is a node star.
Dialogue: 0,1:39:44.86,1:39:46.78,中文,,0,0,0,,现在回想一下，树是一个节点指针。
Dialogue: 0,1:39:46.78,1:39:51.42,英文,,0,0,0,,So even though I'm calling it a tree, it's really the current node that's been passed in.
Dialogue: 0,1:39:46.78,1:39:51.42,中文,,0,0,0,,所以即使我把它叫做树，它实际上是被传入的当前节点。
Dialogue: 0,1:39:51.42,1:40:01.56,英文,,0,0,0,,So if the number I'm looking for is less than the current node's number, then I must know that the number I'm looking for is to the left, so to speak. So how can I solve that?
Dialogue: 0,1:39:51.42,1:40:01.56,中文,,0,0,0,,所以如果我要找的数字小于当前节点的数字，那么我必须知道我要找的数字在左边，可以这么说。那么我该如何解决这个问题呢？
Dialogue: 0,1:40:01.56,1:40:03.76,英文,,0,0,0,,Well, this is where the magic of recursion.
Dialogue: 0,1:40:01.56,1:40:03.76,中文,,0,0,0,,这就是递归的神奇之处。
Dialogue: 0,1:40:03.76,1:40:08.32,英文,,0,0,0,,Just return whatever the answer is to calling search again
Dialogue: 0,1:40:03.76,1:40:08.32,中文,,0,0,0,,只需返回再次调用搜索的结果
Dialogue: 0,1:40:08.32,1:40:10.26,英文,,0,0,0,,but on a subtree, if you will.
Dialogue: 0,1:40:08.32,1:40:10.26,中文,,0,0,0,,但要在子树上调用。
Dialogue: 0,1:40:10.26,1:40:13.21,英文,,0,0,0,,This is the sort of equivalent of snipping off half of the tree.
Dialogue: 0,1:40:10.26,1:40:13.21,中文,,0,0,0,,这相当于剪掉了树的一半。
Dialogue: 0,1:40:13.21,1:40:17.63,英文,,0,0,0,,Pass in the left subtree, if you will, with the same number.
Dialogue: 0,1:40:13.21,1:40:17.63,中文,,0,0,0,,传入左子树，保持数字不变。
Dialogue: 0,1:40:17.63,1:40:29.89,英文,,0,0,0,,Else, if the number you're looking for isn't less than the current node's number but greater than, snip off the other subtree instead and just return whatever search says it finds in the right subtree here.
Dialogue: 0,1:40:17.63,1:40:29.89,中文,,0,0,0,,否则，如果你要找的数字不小于当前节点的数字，那就把另一棵子树剪掉，返回在右子树中找到的内容。
Dialogue: 0,1:40:29.89,1:40:31.47,英文,,0,0,0,,And then there's a fourth and final case.
Dialogue: 0,1:40:29.89,1:40:31.47,中文,,0,0,0,,然后是第四种也是最后一种情况。
Dialogue: 0,1:40:31.47,1:40:34.38,英文,,0,0,0,,What else could be true logically?
Dialogue: 0,1:40:31.47,1:40:34.38,中文,,0,0,0,,逻辑上还有什么可能是真的？
Dialogue: 0,1:40:34.38,1:40:38.25,英文,,0,0,0,,Yeah.
Dialogue: 0,1:40:34.38,1:40:38.25,中文,,0,0,0,,是的。
Dialogue: 0,1:40:38.25,1:40:45.46,英文,,0,0,0,,Perfect, if the number you're looking for equals equals the number in this node, then I'm just going to return true.
Dialogue: 0,1:40:38.25,1:40:45.46,中文,,0,0,0,,没错，如果你要找的数字等于这个节点中的数字，那我就返回 true。
Dialogue: 0,1:40:45.46,1:40:51.88,英文,,0,0,0,,And you might recall from our recurring discussions of design, I don't strictly need to ask that explicitly.
Dialogue: 0,1:40:45.46,1:40:51.88,中文,,0,0,0,,你可能还记得我们之前反复讨论过的设计，我不需要明确地问这个问题。
Dialogue: 0,1:40:51.88,1:40:55.65,英文,,0,0,0,,Either there's no node, it's to the left, it's to the right, or you found it.
Dialogue: 0,1:40:51.88,1:40:55.65,中文,,0,0,0,,要么没有节点，要么在左边，要么在右边，要么找到了。
Dialogue: 0,1:40:55.65,1:40:58.19,英文,,0,0,0,,So I can just whittle that down as usual.
Dialogue: 0,1:40:55.65,1:40:58.19,中文,,0,0,0,,所以我可以像往常一样把它精简掉。
Dialogue: 0,1:40:58.19,1:40:59.29,英文,,0,0,0,,To an else.
Dialogue: 0,1:40:58.19,1:40:59.29,中文,,0,0,0,,到一个 else 语句。
Dialogue: 0,1:40:59.29,1:41:01.17,英文,,0,0,0,,And this now returns my true.
Dialogue: 0,1:40:59.29,1:41:01.17,中文,,0,0,0,,现在它返回 true。
Dialogue: 0,1:41:01.17,1:41:11.60,英文,,0,0,0,,So here, too, this is where recursion, once you get comfy with it, sort of gets pretty elegant and cool in the sense that, wow, even though there's a lot of lines here, I mean, there's only a few interesting lines.
Dialogue: 0,1:41:01.17,1:41:11.60,中文,,0,0,0,,所以这里，一旦你熟悉了递归，它就会变得非常优雅和酷炫，尽管这里有很多行代码，但只有几行是关键的。
Dialogue: 0,1:41:11.60,1:41:15.12,英文,,0,0,0,,A lot of it's like curly braces at that, which, strictly speaking, I could get rid of.
Dialogue: 0,1:41:11.60,1:41:15.12,中文,,0,0,0,,很多都是花括号，严格来说，我可以把它们去掉。
Dialogue: 0,1:41:15.12,1:41:22.20,英文,,0,0,0,,And so recursion lends itself to elegance when it comes to traversing these two-dimensional data structures as well.
Dialogue: 0,1:41:15.12,1:41:22.20,中文,,0,0,0,,因此，递归在遍历这些二维数据结构时也更显优雅。
Dialogue: 0,1:41:22.20,1:41:28.03,英文,,0,0,0,,So that is, in code, how you might implement something like search.
Dialogue: 0,1:41:22.20,1:41:28.03,中文,,0,0,0,,这就是在代码中如何实现搜索功能。
Dialogue: 0,1:41:28.03,1:41:32.41,英文,,0,0,0,,Questions, then, on these trees.
Dialogue: 0,1:41:28.03,1:41:32.41,中文,,0,0,0,,关于这些树，大家还有什么问题吗？
Dialogue: 0,1:41:32.41,1:41:33.21,英文,,0,0,0,,We have dynamism.
Dialogue: 0,1:41:32.41,1:41:33.21,中文,,0,0,0,,它们是动态的。
Dialogue: 0,1:41:33.21,1:41:35.13,英文,,0,0,0,,We can insert more nodes to them.
Dialogue: 0,1:41:33.21,1:41:35.13,中文,,0,0,0,,我们可以向其中插入更多节点。
Dialogue: 0,1:41:35.13,1:41:37.13,英文,,0,0,0,,They're faster because we get binary search back.
Dialogue: 0,1:41:35.13,1:41:37.13,中文,,0,0,0,,因为我们回到了二分查找，所以它们更快。
Dialogue: 0,1:41:37.13,1:41:39.29,英文,,0,0,0,,But, but, but, there's got to be a price paid.
Dialogue: 0,1:41:37.13,1:41:39.29,中文,,0,0,0,,但是，但是，肯定要付出代价。
Dialogue: 0,1:41:39.29,1:41:42.33,英文,,0,0,0,,Any downsides or question or downside?
Dialogue: 0,1:41:39.29,1:41:42.33,中文,,0,0,0,,有什么缺点或问题吗？
Dialogue: 0,1:41:42.33,1:41:43.89,英文,,0,0,0,,OK, let me come back to that in just one sec.
Dialogue: 0,1:41:42.33,1:41:43.89,中文,,0,0,0,,我马上回来讨论这个问题。
Dialogue: 0,1:41:43.89,1:41:55.36,英文,,0,0,0,,Downside, though, what price have we paid for this dynamism and for this binary searchability, even though I've abstracted it away in the picture?
Dialogue: 0,1:41:43.89,1:41:55.36,中文,,0,0,0,,不过，缺点是，为了实现这种动态性和二分查找能力，我们付出了什么代价？即使我已经在图中将其抽象化了。
Dialogue: 0,1:41:55.36,1:41:57.13,英文,,0,0,0,,Say again?
Dialogue: 0,1:41:55.36,1:41:57.13,中文,,0,0,0,,再说一遍？
Dialogue: 0,1:41:57.13,1:41:58.87,英文,,0,0,0,,We're using a lot of memory, right?
Dialogue: 0,1:41:57.13,1:41:58.87,中文,,0,0,0,,我们使用了大量的内存，对吧？
Dialogue: 0,1:41:58.87,1:42:02.81,英文,,0,0,0,,I'm kind of misleading you now, because I'm just drawing these little squares with the simple numbers.
Dialogue: 0,1:41:58.87,1:42:02.81,中文,,0,0,0,,我现在有点误导你了，因为我只是画了这些带有简单数字的小方块。
Dialogue: 0,1:42:02.81,1:42:09.17,英文,,0,0,0,,But there's actually three things in there, a 4-byte integer, an 8-byte left pointer, a 8-byte right pointer.
Dialogue: 0,1:42:02.81,1:42:09.17,中文,,0,0,0,,但实际上里面有三样东西：一个 4 字节的整数、一个 8 字节的左指针和一个 8 字节的右指针。
Dialogue: 0,1:42:09.17,1:42:12.90,英文,,0,0,0,,So we're already up to 1620 bytes now to store individual ints.
Dialogue: 0,1:42:09.17,1:42:12.90,中文,,0,0,0,,所以我们现在已经需要 1620 个字节来存储单个整数了。
Dialogue: 0,1:42:12.90,1:42:18.10,英文,,0,0,0,,That's probably OK, though, if memory is relatively cheap and voluminous as it nowadays is.
Dialogue: 0,1:42:12.90,1:42:18.10,中文,,0,0,0,,不过，如果内存像现在这样相对便宜且容量大，这可能没什么问题。
Dialogue: 0,1:42:18.10,1:42:20.26,英文,,0,0,0,,But these are the kinds of trade-offs.
Dialogue: 0,1:42:18.10,1:42:20.26,中文,,0,0,0,,但这就是权衡利弊的地方。
Dialogue: 0,1:42:20.26,1:42:22.30,英文,,0,0,0,,And here, too, you see a hint of why.
Dialogue: 0,1:42:20.26,1:42:22.30,中文,,0,0,0,,在这里，你也能看出原因。
Dialogue: 0,1:42:22.30,1:42:30.54,英文,,0,0,0,,Some people still do like and use C. And in fact, it's so omnipresent because when you have C, you can really fine-tune how much memory is being used.
Dialogue: 0,1:42:22.30,1:42:30.54,中文,,0,0,0,,有些人仍然喜欢并使用 C 语言。事实上，它之所以如此普遍，是因为当你使用 C 语言时，你可以真正地微调内存的使用量。
Dialogue: 0,1:42:30.54,1:42:35.60,英文,,0,0,0,,For better or for worse, under the hood, as we transition soon to Python, these decisions get made for you.
Dialogue: 0,1:42:30.54,1:42:35.60,中文,,0,0,0,,不管怎样，在我们即将过渡到 Python 的过程中，这些决定都是为你做出的。
Dialogue: 0,1:42:35.60,1:42:43.49,英文,,0,0,0,,And you have much, much less control about how much memory is being used by your program because someone else made the design decisions for you.
Dialogue: 0,1:42:35.60,1:42:43.49,中文,,0,0,0,,你对程序使用多少内存的控制权要小得多，因为是其他人为你做了设计决定。
Dialogue: 0,1:42:43.49,1:42:47.06,英文,,0,0,0,,Question?
Dialogue: 0,1:42:43.49,1:42:47.06,中文,,0,0,0,,有什么问题吗？
Dialogue: 0,1:42:47.06,1:42:49.83,英文,,0,0,0,,Is it bad if we don't know the parent node?
Dialogue: 0,1:42:47.06,1:42:49.83,中文,,0,0,0,,如果我们不知道父节点会很糟糕吗？
Dialogue: 0,1:42:49.83,1:42:50.63,英文,,0,0,0,,Not necessarily.
Dialogue: 0,1:42:49.83,1:42:50.63,中文,,0,0,0,,不一定。
Dialogue: 0,1:42:50.63,1:42:54.69,英文,,0,0,0,,There's no reason why you need to have pointers in both directions.
Dialogue: 0,1:42:50.63,1:42:54.69,中文,,0,0,0,,没有理由必须在两个方向上都有指针。
Dialogue: 0,1:42:54.69,1:42:57.35,英文,,0,0,0,,However, that can lend itself to efficiency.
Dialogue: 0,1:42:54.69,1:42:57.35,中文,,0,0,0,,然而，这本身就可以提高效率。
Dialogue: 0,1:42:57.35,1:43:03.50,英文,,0,0,0,,By spending more space and having arrows go up, too, you can actually save more time when searching the tree in other contexts.
Dialogue: 0,1:42:57.35,1:43:03.50,中文,,0,0,0,,通过花费更多的空间并让箭头向上，实际上可以在其他情况下搜索树时节省更多时间。
Dialogue: 0,1:43:03.50,1:43:06.94,英文,,0,0,0,,This, though, would be the canonical way, the typical way to implement it.
Dialogue: 0,1:43:03.50,1:43:06.94,中文,,0,0,0,,不过，这是一种规范的、典型的实现方式。
Dialogue: 0,1:43:06.94,1:43:12.27,英文,,0,0,0,,But absolutely, just like a doubly linked list, that could help you solve other problems, too.
Dialogue: 0,1:43:06.94,1:43:12.27,中文,,0,0,0,,但它绝对可以像双向链表一样，帮助你解决其他问题。
Dialogue: 0,1:43:12.27,1:43:16.73,英文,,0,0,0,,All right, so turns out I'm kind of overselling binary search trees.
Dialogue: 0,1:43:12.27,1:43:16.73,中文,,0,0,0,,看来我有点过度吹捧二叉搜索树了。
Dialogue: 0,1:43:16.73,1:43:22.39,英文,,0,0,0,,There are perversions of them, so to speak, whereby they won't actually behave as advertised.
Dialogue: 0,1:43:16.73,1:43:22.39,中文,,0,0,0,,可以这么说，它们存在一些“变态”情况，不会像宣传的那样运作。
Dialogue: 0,1:43:22.39,1:43:24.59,英文,,0,0,0,,For instance, here's a good situation.
Dialogue: 0,1:43:22.39,1:43:24.59,中文,,0,0,0,,例如，假设有这样一种情况。
Dialogue: 0,1:43:24.59,1:43:28.65,英文,,0,0,0,,Suppose you've got an empty tree initially, and you insert the number 2.
Dialogue: 0,1:43:24.59,1:43:28.65,中文,,0,0,0,,假设你最初有一个空树，然后插入数字 2。
Dialogue: 0,1:43:28.65,1:43:32.50,英文,,0,0,0,,Well, it's got to go somewhere, so it might as well become the root of this binary search tree.
Dialogue: 0,1:43:28.65,1:43:32.50,中文,,0,0,0,,它总得有个位置，所以它不妨成为这棵二叉搜索树的根节点。
Dialogue: 0,1:43:32.50,1:43:34.90,英文,,0,0,0,,And let's assume that someone wrote the code to do this.
Dialogue: 0,1:43:32.50,1:43:34.90,中文,,0,0,0,,假设已经有人写好了代码来实现这个功能。
Dialogue: 0,1:43:34.90,1:43:39.53,英文,,0,0,0,,Now you want to insert the number 1, and you want to maintain the searchability of this tree.
Dialogue: 0,1:43:34.90,1:43:39.53,中文,,0,0,0,,现在你想插入数字 1，并且希望保持这棵树的可搜索性。
Dialogue: 0,1:43:39.53,1:43:44.54,英文,,0,0,0,,Well, it's important to note that binary search tree is different from tree.
Dialogue: 0,1:43:39.53,1:43:44.54,中文,,0,0,0,,需要注意的是，二叉搜索树不同于一般的树。
Dialogue: 0,1:43:44.54,1:43:49.46,英文,,0,0,0,,If you've just got a tree in memory, there is no social contract with where the numbers need to go.
Dialogue: 0,1:43:44.54,1:43:49.46,中文,,0,0,0,,如果内存中只有一个树结构，那么对数字存放的位置没有任何限制。
Dialogue: 0,1:43:49.46,1:43:51.96,英文,,0,0,0,,They can be completely random all over the place.
Dialogue: 0,1:43:49.46,1:43:51.96,中文,,0,0,0,,它们可以完全随机地分布在任何地方。
Dialogue: 0,1:43:51.96,1:44:01.94,英文,,0,0,0,,Binary search tree means that you can do binary search, means that any node here is going to be greater than every node here and less than every node here.
Dialogue: 0,1:43:51.96,1:44:01.94,中文,,0,0,0,,二叉搜索树意味着你可以进行二分查找，意味着这里的任何节点都大于它左边的所有节点，小于它右边的所有节点。
Dialogue: 0,1:44:01.94,1:44:03.18,英文,,0,0,0,,And that's a definition.
Dialogue: 0,1:44:01.94,1:44:03.18,中文,,0,0,0,,这就是定义。
Dialogue: 0,1:44:03.18,1:44:09.14,英文,,0,0,0,,It's a recursive structural definition that must be true to be a binary search tree or BST.
Dialogue: 0,1:44:03.18,1:44:09.14,中文,,0,0,0,,这是一个递归的结构定义，要成为二叉搜索树或 BST，就必须满足这个定义。
Dialogue: 0,1:44:09.14,1:44:12.16,英文,,0,0,0,,So if we maintain that property ourselves, let me insert 2.
Dialogue: 0,1:44:09.14,1:44:12.16,中文,,0,0,0,,所以如果我们自己维护这个属性，先插入 2。
Dialogue: 0,1:44:12.16,1:44:13.44,英文,,0,0,0,,Let me insert 1.
Dialogue: 0,1:44:12.16,1:44:13.44,中文,,0,0,0,,再插入 1。
Dialogue: 0,1:44:13.44,1:44:15.05,英文,,0,0,0,,1 belongs there by that definition.
Dialogue: 0,1:44:13.44,1:44:15.05,中文,,0,0,0,,根据定义，1 应该放在这里。
Dialogue: 0,1:44:15.05,1:44:15.87,英文,,0,0,0,,Let me insert 3.
Dialogue: 0,1:44:15.05,1:44:15.87,中文,,0,0,0,,再插入 3。
Dialogue: 0,1:44:15.87,1:44:18.73,英文,,0,0,0,,3 belongs there by that definition.
Dialogue: 0,1:44:15.87,1:44:18.73,中文,,0,0,0,,根据定义，3 应该放在这里。
Dialogue: 0,1:44:18.73,1:44:25.25,英文,,0,0,0,,But I kind of got lucky in that I, in the story, inserted 2, and then 1, and then 3.
Dialogue: 0,1:44:18.73,1:44:25.25,中文,,0,0,0,,但我刚才有点幸运，在例子中，我先插入了 2，然后是 1，然后是 3。
Dialogue: 0,1:44:25.25,1:44:29.56,英文,,0,0,0,,Let me propose a sort of perversion of the algorithm whereby we just get unlucky.
Dialogue: 0,1:44:25.25,1:44:29.56,中文,,0,0,0,,现在我们来故意“刁难”一下这个算法，假设我们不太走运。
Dialogue: 0,1:44:29.56,1:44:33.52,英文,,0,0,0,,Let me propose that we insert 1 first.
Dialogue: 0,1:44:29.56,1:44:33.52,中文,,0,0,0,,假设我们先插入 1。
Dialogue: 0,1:44:33.52,1:44:34.36,英文,,0,0,0,,And then we insert 2.
Dialogue: 0,1:44:33.52,1:44:34.36,中文,,0,0,0,,然后我们插入 2。
Dialogue: 0,1:44:34.36,1:44:35.86,英文,,0,0,0,,Well, where does 2 go?
Dialogue: 0,1:44:34.36,1:44:35.86,中文,,0,0,0,,那么，2 应该放在哪里？
Dialogue: 0,1:44:35.86,1:44:38.42,英文,,0,0,0,,Well, logically, it goes to the right, because it's larger.
Dialogue: 0,1:44:35.86,1:44:38.42,中文,,0,0,0,,从逻辑上讲，它应该放在右边，因为它比 1 大。
Dialogue: 0,1:44:38.42,1:44:40.80,英文,,0,0,0,,All right, now the user inserts 3.
Dialogue: 0,1:44:38.42,1:44:40.80,中文,,0,0,0,,好，现在用户插入 3。
Dialogue: 0,1:44:40.80,1:44:42.30,英文,,0,0,0,,Where does it go?
Dialogue: 0,1:44:40.80,1:44:42.30,中文,,0,0,0,,它应该放在哪里？
Dialogue: 0,1:44:42.30,1:44:44.34,英文,,0,0,0,,OK, it goes there, logically.
Dialogue: 0,1:44:42.30,1:44:44.34,中文,,0,0,0,,从逻辑上讲，它应该放在那里。
Dialogue: 0,1:44:44.34,1:44:46.17,英文,,0,0,0,,And how does this story unfold?
Dialogue: 0,1:44:44.34,1:44:46.17,中文,,0,0,0,,那么接下来会发生什么？
Dialogue: 0,1:44:46.17,1:44:48.27,英文,,0,0,0,,The user inserts 4, 5, 6.
Dialogue: 0,1:44:46.17,1:44:48.27,中文,,0,0,0,,用户插入 4、5、6。
Dialogue: 0,1:44:48.27,1:44:51.39,英文,,0,0,0,,It's wonderfully sorted in advance by luck.
Dialogue: 0,1:44:48.27,1:44:51.39,中文,,0,0,0,,很幸运，它们已经排好序了。
Dialogue: 0,1:44:51.39,1:44:56.21,英文,,0,0,0,,But this is a perversion of the structure in what sense?
Dialogue: 0,1:44:51.39,1:44:56.21,中文,,0,0,0,,但是，从什么意义上说，这扭曲了二叉搜索树的结构？
Dialogue: 0,1:44:56.21,1:44:59.15,英文,,0,0,0,,It's still technically a binary search tree.
Dialogue: 0,1:44:56.21,1:44:59.15,中文,,0,0,0,,从技术上讲，它仍然是一个二叉搜索树。
Dialogue: 0,1:44:59.15,1:45:03.01,英文,,0,0,0,,But what does it look more like?
Dialogue: 0,1:44:59.15,1:45:03.01,中文,,0,0,0,,但是它看起来更像什么？
Dialogue: 0,1:45:03.01,1:45:06.37,英文,,0,0,0,,It really is devolving, if you will, into a linked list.
Dialogue: 0,1:45:03.01,1:45:06.37,中文,,0,0,0,,它实际上是在退化，变成了一个链表。
Dialogue: 0,1:45:06.37,1:45:17.36,英文,,0,0,0,,And so if you, the programmer, don't implement a binary search tree with some kind of repairs going on, such that as soon as something gets, whoa, a little too long and stringy, I think I can fix this.
Dialogue: 0,1:45:06.37,1:45:17.36,中文,,0,0,0,,如果你作为程序员，没有在实现二叉搜索树时进行一些修复工作，比如当它变得太长太像字符串时，你就要考虑调整它。
Dialogue: 0,1:45:17.36,1:45:22.27,英文,,0,0,0,,It's going to be an annoying number of lines of code, which we're not going to write here or in a pset.
Dialogue: 0,1:45:17.36,1:45:22.27,中文,,0,0,0,,这将会需要写很多行代码，我们在这里或者在 pset 中都不会写。
Dialogue: 0,1:45:22.27,1:45:24.65,英文,,0,0,0,,But we could kind of pivot this thing, right?
Dialogue: 0,1:45:22.27,1:45:24.65,中文,,0,0,0,,但是我们可以稍微调整一下这个结构，对吧？
Dialogue: 0,1:45:24.65,1:45:31.61,英文,,0,0,0,,And we could just rejigger things so that the 2 becomes the new root, the 1 becomes the left child, the 3 becomes the right child.
Dialogue: 0,1:45:24.65,1:45:31.61,中文,,0,0,0,,我们可以重新调整，让 2 成为新的根节点，1 成为左子节点，3 成为右子节点。
Dialogue: 0,1:45:31.61,1:45:33.87,英文,,0,0,0,,But that's what? Like two, three plus lines of code.
Dialogue: 0,1:45:31.61,1:45:33.87,中文,,0,0,0,,但这意味着什么呢？大概两三行代码？
Dialogue: 0,1:45:33.87,1:45:34.57,英文,,0,0,0,,It's possible.
Dialogue: 0,1:45:33.87,1:45:34.57,中文,,0,0,0,,有可能。
Dialogue: 0,1:45:34.57,1:45:35.41,英文,,0,0,0,,It's doable.
Dialogue: 0,1:45:34.57,1:45:35.41,中文,,0,0,0,,可行的。
Dialogue: 0,1:45:35.41,1:45:36.67,英文,,0,0,0,,But it's extra work.
Dialogue: 0,1:45:35.41,1:45:36.67,中文,,0,0,0,,但这是额外的工作。
Dialogue: 0,1:45:36.67,1:45:37.79,英文,,0,0,0,,It's extra code.
Dialogue: 0,1:45:36.67,1:45:37.79,中文,,0,0,0,,是额外的代码。
Dialogue: 0,1:45:37.79,1:45:42.70,英文,,0,0,0,,So unless you write that code, though, and maintain balance of these trees,
Dialogue: 0,1:45:37.79,1:45:42.70,中文,,0,0,0,,除非你写了代码，并且维护了这些树的平衡，
Dialogue: 0,1:45:42.70,1:45:52.52,英文,,0,0,0,,Just because it's a binary search tree does not mean its height is going to be log base 2 of n. The height could be n, in which case you don't get those properties.
Dialogue: 0,1:45:42.70,1:45:52.52,中文,,0,0,0,,仅仅因为它是一个二叉搜索树，并不意味着它的高度就是 log₂n。高度可以是 n，在这种情况下，你就无法获得那些特性了。
Dialogue: 0,1:45:52.52,1:46:02.20,英文,,0,0,0,,So when it comes to looking up in a balanced binary search tree, yes, it's log n. But if it's unbalanced, if you don't add that additional logic and those repairs, so to speak,
Dialogue: 0,1:45:52.52,1:46:02.20,中文,,0,0,0,,所以在平衡二叉搜索树中查找时，是的，它是 log n。但如果它是不平衡的，如果你不添加额外的逻辑和修复，
Dialogue: 0,1:46:02.20,1:46:10.84,英文,,0,0,0,,It could devolve into big O of n. And this is a whole category of algorithms and fanciness that you would explore in a higher level course on algorithms and data structures.
Dialogue: 0,1:46:02.20,1:46:10.84,中文,,0,0,0,,它可能会退化成 O(n)。这整个算法类别和精妙之处，你会在更高阶的算法和数据结构课程中探索。
Dialogue: 0,1:46:10.84,1:46:17.20,英文,,0,0,0,,There's lots of way to do that sort of fixing that I'm alluding to in the picture there on the screen.
Dialogue: 0,1:46:10.84,1:46:17.20,中文,,0,0,0,,有很多方法可以进行我在屏幕上图片中提到的那种修复。
Dialogue: 0,1:46:17.20,1:46:23.15,英文,,0,0,0,,All right, a few other data structures, if you will, toward an end of a sort of computer science holy grail.
Dialogue: 0,1:46:17.20,1:46:23.15,中文,,0,0,0,,好了，还有一些其他的数据结构，朝着计算机科学的某种圣杯前进。
Dialogue: 0,1:46:23.15,1:46:27.99,英文,,0,0,0,,So log n is repeatedly a really good place to end up.
Dialogue: 0,1:46:23.15,1:46:27.99,中文,,0,0,0,,所以 log n 一直是一个非常好的结果。
Dialogue: 0,1:46:27.99,1:46:37.30,英文,,0,0,0,,We started in week 0 when we got log n. We lost it earlier today by introducing linked list, but we just got it back, albeit at the price of spending more space.
Dialogue: 0,1:46:27.99,1:46:37.30,中文,,0,0,0,,我们在第 0 周开始的时候得到了 log n。今天早些时候，我们引入了链表，失去了它，但我们又把它找回来了，尽管是以花费更多空间为代价。
Dialogue: 0,1:46:37.30,1:46:41.79,英文,,0,0,0,,But the holy grail, so to speak, when it comes to algorithms would not be big O of n, certainly.
Dialogue: 0,1:46:37.30,1:46:41.79,中文,,0,0,0,,但算法的圣杯，可以说，不是 O(n)。
Dialogue: 0,1:46:41.79,1:46:45.23,英文,,0,0,0,,Definitely not n squared, like our bubble sorts and selection sorts.
Dialogue: 0,1:46:41.79,1:46:45.23,中文,,0,0,0,,绝对不是 n²，就像我们的冒泡排序和选择排序。
Dialogue: 0,1:46:45.23,1:46:51.01,英文,,0,0,0,,And not even big O of log n. What's better than all of those?
Dialogue: 0,1:46:45.23,1:46:51.01,中文,,0,0,0,,甚至不是 O(log n)。还有什么比这些更好的？
Dialogue: 0,1:46:51.01,1:46:53.23,英文,,0,0,0,,Big O of 1, constant time, right?
Dialogue: 0,1:46:51.01,1:46:53.23,中文,,0,0,0,,O(1)，常数时间，对吧？
Dialogue: 0,1:46:53.23,1:47:05.16,英文,,0,0,0,,That's the holy grail, because if we could store huge amounts of data but find it instantly in one step, or two steps, or heck, even 10 or 20 steps, but independent of the size of the data structure, that's pretty powerful.
Dialogue: 0,1:46:53.23,1:47:05.16,中文,,0,0,0,,那是圣杯，因为如果我们可以存储大量数据，但可以在一步、两步，甚至 10 步或 20 步内找到它，而与数据结构的大小无关，那就非常强大了。
Dialogue: 0,1:47:05.16,1:47:11.28,英文,,0,0,0,,I mean, that's the secret sauce of the Googles and the Twitters of the world, trying to get back results really, really fast.
Dialogue: 0,1:47:05.16,1:47:11.28,中文,,0,0,0,,我的意思是，这就是谷歌和推特这些公司的秘诀，试图真正快速地获得结果。
Dialogue: 0,1:47:11.28,1:47:14.27,英文,,0,0,0,,Well, it turns out another abstract data type
Dialogue: 0,1:47:11.28,1:47:14.27,中文,,0,0,0,,事实证明，另一个抽象数据类型
Dialogue: 0,1:47:14.27,1:47:23.35,英文,,0,0,0,,Or abstract data structure might be something called a dictionary, just like the Merriam-Webster, Oxford English dictionaries that you might know, which associate, say, words with definitions.
Dialogue: 0,1:47:14.27,1:47:23.35,中文,,0,0,0,,抽象数据结构可以叫做字典，就像你可能知道的韦氏词典、牛津英语词典那样，把单词和定义联系起来。
Dialogue: 0,1:47:23.35,1:47:34.82,英文,,0,0,0,,Well, you can think of a dictionary really abstractly as this, like two columns, maybe on a spreadsheet of sorts, where the left column represents something and the right column represents something else, like the word is on the left and its definition is on the right.
Dialogue: 0,1:47:23.35,1:47:34.82,中文,,0,0,0,,可以把字典抽象地想象成这样，就像电子表格上的两列，左边一列代表某种东西，右边一列代表另一种东西，比如左边是单词，右边是它的定义。
Dialogue: 0,1:47:34.82,1:47:37.34,英文,,0,0,0,,And that's almost literally what a dictionary is on paper.
Dialogue: 0,1:47:34.82,1:47:37.34,中文,,0,0,0,,这几乎就是纸质字典的字面意思。
Dialogue: 0,1:47:37.34,1:47:40.56,英文,,0,0,0,,You've got all the words and all the definitions right next to it.
Dialogue: 0,1:47:37.34,1:47:40.56,中文,,0,0,0,,所有单词和定义都挨在一起。
Dialogue: 0,1:47:40.56,1:47:48.35,英文,,0,0,0,,But more generally, in computing, a dictionary really just has not words and definitions, per se, but key-value pairs.
Dialogue: 0,1:47:40.56,1:47:48.35,中文,,0,0,0,,但更笼统地说，在计算机领域，字典实际上并不只是单词和定义，而是键值对。
Dialogue: 0,1:47:48.35,1:47:49.25,英文,,0,0,0,,This is a term of art.
Dialogue: 0,1:47:48.35,1:47:49.25,中文,,0,0,0,,这是一个专业术语。
Dialogue: 0,1:47:49.25,1:47:54.35,英文,,0,0,0,,And we're going to see this again and again, especially as we transition to web programming, keys and values.
Dialogue: 0,1:47:49.25,1:47:54.35,中文,,0,0,0,,我们会一次又一次地看到这个词，尤其是在我们过渡到 Web 编程时，键和值。
Dialogue: 0,1:47:54.35,1:47:57.37,英文,,0,0,0,,Key is what you use to look for something.
Dialogue: 0,1:47:54.35,1:47:57.37,中文,,0,0,0,,键是你用来查找东西的东西。
Dialogue: 0,1:47:57.37,1:48:01.68,英文,,0,0,0,,The value is what you find, ultimately, via that key.
Dialogue: 0,1:47:57.37,1:48:01.68,中文,,0,0,0,,值是你最终通过键找到的东西。
Dialogue: 0,1:48:01.68,1:48:03.24,英文,,0,0,0,,So that's the generic term there.
Dialogue: 0,1:48:01.68,1:48:03.24,中文,,0,0,0,,这就是它的通用术语。
Dialogue: 0,1:48:03.24,1:48:05.62,英文,,0,0,0,,We've seen key value pairs really in the past.
Dialogue: 0,1:48:03.24,1:48:05.62,中文,,0,0,0,,我们以前见过键值对。
Dialogue: 0,1:48:05.62,1:48:14.74,英文,,0,0,0,,In week 0, we talked about your contacts in your iPhone or Android phone being an app that has a whole bunch of contacts, presumably alphabetized by first name or last name or the like.
Dialogue: 0,1:48:05.62,1:48:14.74,中文,,0,0,0,,在第 0 周，我们讨论了 iPhone 或 Android 手机中的联系人，它是一个应用程序，里面有一堆联系人，可能是按姓氏或名字的字母顺序排列的。
Dialogue: 0,1:48:14.74,1:48:20.82,英文,,0,0,0,,Well, one of those contact cards ultimately has someone's number, for instance, like John Harvard in this case.
Dialogue: 0,1:48:14.74,1:48:20.82,中文,,0,0,0,,其中一个联系人卡片最终会有某人的号码，例如，本例中的 John Harvard。
Dialogue: 0,1:48:20.82,1:48:26.95,英文,,0,0,0,,So in that type of application, the keys is the name, like John Harvard, that you use to find information.
Dialogue: 0,1:48:20.82,1:48:26.95,中文,,0,0,0,,所以在这种类型的应用程序中，键是名字，比如 John Harvard，你用它来查找信息。
Dialogue: 0,1:48:26.95,1:48:30.09,英文,,0,0,0,,And the value is the number that you find there.
Dialogue: 0,1:48:26.95,1:48:30.09,中文,,0,0,0,,值是你找到的号码。
Dialogue: 0,1:48:30.09,1:48:37.48,英文,,0,0,0,,Or if there's more information, like where he lives, and email address, and the like, the whole contact card could be the value thereof.
Dialogue: 0,1:48:30.09,1:48:37.48,中文,,0,0,0,,或者如果有更多信息，比如他住在哪里，电子邮件地址等等，整个联系人卡片都可以是它的值。
Dialogue: 0,1:48:37.48,1:48:41.86,英文,,0,0,0,,The key is what you use to look up John Harvard. Now, back in week 0.
Dialogue: 0,1:48:37.48,1:48:41.86,中文,,0,0,0,,键是你用来查找 John Harvard 的东西，回到第 0 周。
Dialogue: 0,1:48:41.86,1:48:47.77,英文,,0,0,0,,Oh, and rather, the corresponding table, then, if we draw this in two columns, wouldn't be word and definition or key value generically.
Dialogue: 0,1:48:41.86,1:48:47.77,中文,,0,0,0,,更确切地说，如果我们用两列来表示，对应的表格就不是单词和定义，或者一般的键值。
Dialogue: 0,1:48:47.77,1:48:50.01,英文,,0,0,0,,It would be name and number, for instance.
Dialogue: 0,1:48:47.77,1:48:50.01,中文,,0,0,0,,它可以是姓名和号码。
Dialogue: 0,1:48:50.01,1:48:53.81,英文,,0,0,0,,So we're just slapping some new terminology on this old contacts problem.
Dialogue: 0,1:48:50.01,1:48:53.81,中文,,0,0,0,,所以我们只是在这个旧的联系人问题上贴了一些新的术语。
Dialogue: 0,1:48:53.81,1:49:00.38,英文,,0,0,0,,Well, this is the picture we drew way back in week 0, whereby I claimed that log of n was really, really good.
Dialogue: 0,1:48:53.81,1:49:00.38,中文,,0,0,0,,这就是我们在第 0 周画的图，我之前说过 log(n) 非常好。
Dialogue: 0,1:49:00.38,1:49:02.58,英文,,0,0,0,,And indeed, it was and has been since.
Dialogue: 0,1:49:00.38,1:49:02.58,中文,,0,0,0,,事实上，它的确如此，而且一直如此。
Dialogue: 0,1:49:02.58,1:49:08.16,英文,,0,0,0,,But the holy grail would indeed be something more like this, in this dashed green line, constant time.
Dialogue: 0,1:49:02.58,1:49:08.16,中文,,0,0,0,,但真正的理想情况更像是这样，这条绿色的虚线，表示常数时间。
Dialogue: 0,1:49:08.16,1:49:20.95,英文,,0,0,0,,And maybe not literally one step, but a fixed number of steps that even as the problem gets huge and you go way, way out on the right of the x-axis, the problem does not depend on the size.
Dialogue: 0,1:49:08.16,1:49:20.95,中文,,0,0,0,,也许不只是一步，而是固定的步数，即使问题变得很大，你在 x 轴的右边越走越远，问题也不依赖于规模。
Dialogue: 0,1:49:20.95,1:49:29.47,英文,,0,0,0,,The time to solve the problem does not depend at all on the size of the problem itself. You can have 1,000 contacts or 100,000 contacts,
Dialogue: 0,1:49:20.95,1:49:29.47,中文,,0,0,0,,解决问题的时间完全不取决于问题本身的大小。你可以有 1000 个联系人，也可以有 100000 个联系人，
Dialogue: 0,1:49:29.47,1:49:33.14,英文,,0,0,0,,Constant time means it takes the same number of steps no matter what.
Dialogue: 0,1:49:29.47,1:49:33.14,中文,,0,0,0,,常数时间意味着无论如何都需要相同的步数。
Dialogue: 0,1:49:33.14,1:49:34.88,英文,,0,0,0,,Well, how can we get to that point?
Dialogue: 0,1:49:33.14,1:49:34.88,中文,,0,0,0,,那么，我们怎样才能达到这一点呢？
Dialogue: 0,1:49:34.88,1:49:37.28,英文,,0,0,0,,Well, there's a couple of final building blocks today.
Dialogue: 0,1:49:34.88,1:49:37.28,中文,,0,0,0,,今天还有几个最终的构建模块。
Dialogue: 0,1:49:37.28,1:49:38.64,英文,,0,0,0,,And there's one called hashing.
Dialogue: 0,1:49:37.28,1:49:38.64,中文,,0,0,0,,其中一个叫做哈希。
Dialogue: 0,1:49:38.64,1:49:40.62,英文,,0,0,0,,And this is something that will recur a few times.
Dialogue: 0,1:49:38.64,1:49:40.62,中文,,0,0,0,,这将是我们将多次讨论的内容。
Dialogue: 0,1:49:40.62,1:49:49.59,英文,,0,0,0,,But for now, hashing is all about taking as input some value and outputting a simpler version thereof.
Dialogue: 0,1:49:40.62,1:49:49.59,中文,,0,0,0,,但就目前而言，哈希就是输入某个值，并输出其简化版本。
Dialogue: 0,1:49:49.59,1:49:53.35,英文,,0,0,0,,So for instance, here's a gratuitously large deck of cards.
Dialogue: 0,1:49:49.59,1:49:53.35,中文,,0,0,0,,例如，这是一副故意放大的扑克牌。
Dialogue: 0,1:49:53.35,1:49:55.39,英文,,0,0,0,,which are all the more visible as a result.
Dialogue: 0,1:49:53.35,1:49:55.39,中文,,0,0,0,,这样一来，它们就更加显眼了。
Dialogue: 0,1:49:55.39,1:50:00.42,英文,,0,0,0,,And in a deck of cards, typically, you've got, like, what, 52 cards, plus maybe the jokers and whatnot.
Dialogue: 0,1:49:55.39,1:50:00.42,中文,,0,0,0,,在一副扑克牌中，通常有 52 张牌，再加上一些国王之类的。
Dialogue: 0,1:50:00.42,1:50:03.74,英文,,0,0,0,,And each of those cards has a number of sorts and a suit on it.
Dialogue: 0,1:50:00.42,1:50:03.74,中文,,0,0,0,,每张牌上都有一种数字和一种花色。
Dialogue: 0,1:50:03.74,1:50:06.46,英文,,0,0,0,,And here are literally four buckets on the stage.
Dialogue: 0,1:50:03.74,1:50:06.46,中文,,0,0,0,,舞台上有四个桶。
Dialogue: 0,1:50:06.46,1:50:10.83,英文,,0,0,0,,And how might I go about sorting these cards, not just by number, but also by suit?
Dialogue: 0,1:50:06.46,1:50:10.83,中文,,0,0,0,,我怎样才能把这些牌分类呢？不仅按数字分，还要按花色分？
Dialogue: 0,1:50:10.83,1:50:19.29,英文,,0,0,0,,Well, you could certainly, like, spread them all out and sort of make a mess of things and just kind of reason your way through it and get everything in order according to suit and according by number.
Dialogue: 0,1:50:10.83,1:50:19.29,中文,,0,0,0,,当然，你可以把它们都摊开，弄得一团糟，然后一路推理，根据花色和数字把所有东西都整理好。
Dialogue: 0,1:50:19.29,1:50:21.71,英文,,0,0,0,,But most of us, even if you don't have four buckets at home,
Dialogue: 0,1:50:19.29,1:50:21.71,中文,,0,0,0,,但我们大多数人，即使你家里没有四个桶，
Dialogue: 0,1:50:21.71,1:50:30.26,英文,,0,0,0,,Probably you're going to do something a little more intuitive, feels like an optimization, where if I find, like, the nine of hearts, I'm going to put that into the hearts bucket.
Dialogue: 0,1:50:21.71,1:50:30.26,中文,,0,0,0,,你可能会做一些更直观的事情，感觉像是优化，比如，如果我找到了红桃 9，我就会把它放到红桃桶里。
Dialogue: 0,1:50:30.26,1:50:32.70,英文,,0,0,0,,The king of spades, I'm going to put that into the spades bucket.
Dialogue: 0,1:50:30.26,1:50:32.70,中文,,0,0,0,,黑桃 K，我要把它放到黑桃桶里。
Dialogue: 0,1:50:32.70,1:50:35.02,英文,,0,0,0,,The jack of diamonds, over here.
Dialogue: 0,1:50:32.70,1:50:35.02,中文,,0,0,0,,方块 J，放这里。
Dialogue: 0,1:50:35.02,1:50:41.72,英文,,0,0,0,,And I'll do this with the queen of diamonds, and the ace of clubs here, and the three here, and the 10 here.
Dialogue: 0,1:50:35.02,1:50:41.72,中文,,0,0,0,,接着是方块 Q，梅花 A 放在这里，3 放在这里，10 放在这里。
Dialogue: 0,1:50:41.72,1:50:49.77,英文,,0,0,0,,And even though it's still going to be 52 steps, why am I, and maybe at home, like, why would you perhaps do this step first?
Dialogue: 0,1:50:41.72,1:50:49.77,中文,,0,0,0,,虽然这仍然需要 52 步，为什么我要先这样做呢？也许你在家也想问，为什么要先做这一步呢？
Dialogue: 0,1:50:49.77,1:50:52.93,英文,,0,0,0,,What's the value of bucketizing the values in this way?
Dialogue: 0,1:50:49.77,1:50:52.93,中文,,0,0,0,,以这种方式将数值分类有什么意义？
Dialogue: 0,1:50:52.93,1:50:55.76,英文,,0,0,0,,And that actually is kind of a term of art.
Dialogue: 0,1:50:52.93,1:50:55.76,中文,,0,0,0,,这实际上是一个专业术语。
Dialogue: 0,1:50:55.76,1:51:00.11,英文,,0,0,0,,What's the value of doing this first before you sift through and try to sort the numbers?
Dialogue: 0,1:50:55.76,1:51:00.11,中文,,0,0,0,,在筛选并尝试对数字进行排序之前，先这样做有什么意义？
Dialogue: 0,1:51:00.11,1:51:03.55,英文,,0,0,0,,Yeah?
Dialogue: 0,1:51:00.11,1:51:03.55,中文,,0,0,0,,对吧？
Dialogue: 0,1:51:03.55,1:51:06.29,英文,,0,0,0,,Yeah, it's easier to make sure you're not missing anything.
Dialogue: 0,1:51:03.55,1:51:06.29,中文,,0,0,0,,是的，这样更容易确保你没有遗漏任何东西。
Dialogue: 0,1:51:06.29,1:51:12.11,英文,,0,0,0,,And it's taking a problem of size 52 and shrinking it into four problems of size 13, if you will.
Dialogue: 0,1:51:06.29,1:51:12.11,中文,,0,0,0,,它把一个 52 个元素的问题缩减成了四个 13 个元素的问题。
Dialogue: 0,1:51:12.11,1:51:16.67,英文,,0,0,0,,And so that just kind of helps simplify things, maybe reduces the probability of errors or the like.
Dialogue: 0,1:51:12.11,1:51:16.67,中文,,0,0,0,,这有助于简化问题，也许可以降低出错的概率等等。
Dialogue: 0,1:51:16.67,1:51:20.61,英文,,0,0,0,,And what I'm doing here, to give it a technical term, is that I'm hashing the values.
Dialogue: 0,1:51:16.67,1:51:20.61,中文,,0,0,0,,我在这里所做的，用一个技术术语来说，就是对这些值进行哈希处理。
Dialogue: 0,1:51:20.61,1:51:22.76,英文,,0,0,0,,I'm taking as input a card like this.
Dialogue: 0,1:51:20.61,1:51:22.76,中文,,0,0,0,,我把像这样的卡片作为输入。
Dialogue: 0,1:51:22.76,1:51:29.54,英文,,0,0,0,,And I'm reducing it, more simply, from a larger domain to a much smaller range, if you will.
Dialogue: 0,1:51:22.76,1:51:29.54,中文,,0,0,0,,更简单地说，我把它从一个更大的域缩减到一个更小的范围。
Dialogue: 0,1:51:29.54,1:51:32.83,英文,,0,0,0,,So here's a domain of like 52 possibilities.
Dialogue: 0,1:51:29.54,1:51:32.83,中文,,0,0,0,,所以这里有一个 52 种可能性的域。
Dialogue: 0,1:51:32.83,1:51:38.63,英文,,0,0,0,,I want to map that to a range of four possible outcomes, the diamonds, the clubs, the carts.
Dialogue: 0,1:51:32.83,1:51:38.63,中文,,0,0,0,,我想把它映射到四个可能的输出范围：方块、梅花、红心或黑桃。
Dialogue: 0,1:51:38.63,1:51:39.73,英文,,0,0,0,,or the spades here.
Dialogue: 0,1:51:38.63,1:51:39.73,中文,,0,0,0,,或者这里的黑桃。
Dialogue: 0,1:51:39.73,1:51:42.58,英文,,0,0,0,,And by doing that, I'm just shrinking the size of the problem.
Dialogue: 0,1:51:39.73,1:51:42.58,中文,,0,0,0,,通过这样做，我就缩小了问题的规模。
Dialogue: 0,1:51:42.58,1:51:43.60,英文,,0,0,0,,So hashing does that.
Dialogue: 0,1:51:42.58,1:51:43.60,中文,,0,0,0,,哈希就是这么做的。
Dialogue: 0,1:51:43.60,1:51:50.32,英文,,0,0,0,,It's like literally an f of x type arrangement, whereby you pass something in and you get back a simpler known value.
Dialogue: 0,1:51:43.60,1:51:50.32,中文,,0,0,0,,它就像一个 f(x) 函数，你传入一个值，然后得到一个更简单的已知值。
Dialogue: 0,1:51:50.32,1:52:03.19,英文,,0,0,0,,Well, a hash function, more technically, is the algorithm or even the math or even the code that implements that idea, converting something bigger to something smaller to this, indeed, finite range of values.
Dialogue: 0,1:51:50.32,1:52:03.19,中文,,0,0,0,,从技术上讲，哈希函数是一种算法，甚至是一种数学运算，\N或者说是代码，它实现了将较大的数据转换成较小的数据，并将其转换为有限范围内的值的思想。
Dialogue: 0,1:52:03.19,1:52:14.07,英文,,0,0,0,,And it turns out that hash tables are a wonderful application of arrays and linked lists to try to leverage the best of both worlds.
Dialogue: 0,1:52:03.19,1:52:14.07,中文,,0,0,0,,事实证明，哈希表是数组和链表的一个很好的应用，它试图利用两者的优点。
Dialogue: 0,1:52:14.07,1:52:18.03,英文,,0,0,0,,The goal being, theoretically, to achieve that holy grail of
Dialogue: 0,1:52:14.07,1:52:18.03,中文,,0,0,0,,理论上，目标是实现这一圣杯：
Dialogue: 0,1:52:18.03,1:52:25.43,英文,,0,0,0,,Constant time, and that's going to be a bit of an overstatement because you're not always going to achieve it exactly, but at least we can get a little closer there, too.
Dialogue: 0,1:52:18.03,1:52:25.43,中文,,0,0,0,,恒定时间，这有点夸张，因为你不可能总是精确地实现它，但至少我们可以更接近它。
Dialogue: 0,1:52:25.43,1:52:28.65,英文,,0,0,0,,So with hash tables, you have something that looks like this.
Dialogue: 0,1:52:25.43,1:52:28.65,中文,,0,0,0,,所以使用哈希表，你会看到这样的东西。
Dialogue: 0,1:52:28.65,1:52:30.07,英文,,0,0,0,,This is just an array.
Dialogue: 0,1:52:28.65,1:52:30.07,中文,,0,0,0,,这只是一个数组。
Dialogue: 0,1:52:30.07,1:52:36.66,英文,,0,0,0,,This is an artist's rendition of drawing it vertically instead of horizontally, but that's just a detail graphically.
Dialogue: 0,1:52:30.07,1:52:36.66,中文,,0,0,0,,这是一个艺术家的渲染，把它画成垂直的而不是水平的，但这只是一个图形上的细节。
Dialogue: 0,1:52:36.66,1:52:41.12,英文,,0,0,0,,And this array, for instance, maybe is of size 26.
Dialogue: 0,1:52:36.66,1:52:41.12,中文,,0,0,0,,例如，这个数组的大小可能是 26。
Dialogue: 0,1:52:41.12,1:52:42.34,英文,,0,0,0,,And where am I going with this?
Dialogue: 0,1:52:41.12,1:52:42.34,中文,,0,0,0,,我要讲的是什么呢？
Dialogue: 0,1:52:42.34,1:52:49.68,英文,,0,0,0,,Well, how does Apple, how does Google store your context alphabetically in your phone and search for things quickly?
Dialogue: 0,1:52:42.34,1:52:49.68,中文,,0,0,0,,苹果和谷歌是如何在你的手机里按字母顺序存储你的联系人并快速搜索的呢？
Dialogue: 0,1:52:49.68,1:52:57.95,英文,,0,0,0,,Well, they probably alphabetize at least in English according to A through Z. Or if we convert that to numbers, it's like, what, 65 through whatever, or really,
Dialogue: 0,1:52:49.68,1:52:57.95,中文,,0,0,0,,它们可能至少在英语中是按照 A 到 Z 的字母顺序排列的。如果我们把它们转换成数字，就像 65 到什么，或者实际上是，
Dialogue: 0,1:52:57.95,1:52:59.35,英文,,0,0,0,,0 through 25 suffices.
Dialogue: 0,1:52:57.95,1:52:59.35,中文,,0,0,0,,0 到 25 就足够了。
Dialogue: 0,1:52:59.35,1:53:04.27,英文,,0,0,0,,If we're using an array of size 26, we start counting at 0, and we count up to 25.
Dialogue: 0,1:52:59.35,1:53:04.27,中文,,0,0,0,,如果我们使用大小为 26 的数组，我们从 0 开始计数，一直数到 25。
Dialogue: 0,1:53:04.27,1:53:06.95,英文,,0,0,0,,But let's abstract that away as just letters of the alphabet.
Dialogue: 0,1:53:04.27,1:53:06.95,中文,,0,0,0,,但让我们把它抽象为字母表中的字母。
Dialogue: 0,1:53:06.95,1:53:14.88,英文,,0,0,0,,So maybe what Google and Apple are doing in your phone is storing all of the A's up there, all of the Z's down there, and everything else in between.
Dialogue: 0,1:53:06.95,1:53:14.88,中文,,0,0,0,,所以也许谷歌和苹果在你的手机里做的是把所有的 A 存储在上面，所有的 Z 存储在下面，其他的存储在中间。
Dialogue: 0,1:53:14.88,1:53:18.02,英文,,0,0,0,,And so this works pretty well if you start adding your friends and your family.
Dialogue: 0,1:53:14.88,1:53:18.02,中文,,0,0,0,,所以如果你开始添加你的朋友和家人，这很有效。
Dialogue: 0,1:53:18.02,1:53:22.06,英文,,0,0,0,,So for instance, and I'll get rid of the letters so as to not distract,
Dialogue: 0,1:53:18.02,1:53:22.06,中文,,0,0,0,,例如，为了不分散注意力，我把字母去掉，
Dialogue: 0,1:53:22.06,1:53:26.53,英文,,0,0,0,,Albus might go in that first spot, because a, you subtract a 65, maps to 0.
Dialogue: 0,1:53:22.06,1:53:26.53,中文,,0,0,0,,Albus 可能会放在第一个位置，因为 a 减去 65，映射到 0。
Dialogue: 0,1:53:26.53,1:53:29.07,英文,,0,0,0,,So we put him in the first bucket, the a bucket.
Dialogue: 0,1:53:26.53,1:53:29.07,中文,,0,0,0,,所以我们把他放在第一个桶，a 桶里。
Dialogue: 0,1:53:29.07,1:53:31.55,英文,,0,0,0,,Maybe Zacharias ends up all the way at the end there.
Dialogue: 0,1:53:29.07,1:53:31.55,中文,,0,0,0,,也许 Zacharias 会一直排到最后。
Dialogue: 0,1:53:31.55,1:53:33.72,英文,,0,0,0,,And then in the middle might here be Hermione.
Dialogue: 0,1:53:31.55,1:53:33.72,中文,,0,0,0,,中间可能是赫敏。
Dialogue: 0,1:53:33.72,1:53:41.71,英文,,0,0,0,,And if we do this dot, dot, dot, you keep adding all of your classmates, you might get a contacts database that has all of this data here in.
Dialogue: 0,1:53:33.72,1:53:41.71,中文,,0,0,0,,如果我们像这样一直添加下去，把所有同学都加进去，就会得到一个包含所有数据的联系人数据库。
Dialogue: 0,1:53:41.71,1:53:46.55,英文,,0,0,0,,Now, each of these nodes, they're drawn differently because this is just another artist's rendition.
Dialogue: 0,1:53:41.71,1:53:46.55,中文,,0,0,0,,每个节点的绘制方式都不同，因为这只是另一个艺术家的诠释。
Dialogue: 0,1:53:46.55,1:53:55.39,英文,,0,0,0,,These rectangles, these long rectangles, represent a contact card, like John Harvard's that's got the name, maybe email, definitely phone number, and things like that.
Dialogue: 0,1:53:46.55,1:53:55.39,中文,,0,0,0,,这些长方形代表一个联系人卡片，比如约翰·哈佛的卡片，上面有姓名、可能还有电子邮件、电话号码等等。
Dialogue: 0,1:53:55.39,1:53:57.51,英文,,0,0,0,,So this seems great.
Dialogue: 0,1:53:55.39,1:53:57.51,中文,,0,0,0,,这看起来不错。
Dialogue: 0,1:53:57.51,1:53:58.35,英文,,0,0,0,,Why?
Dialogue: 0,1:53:57.51,1:53:58.35,中文,,0,0,0,,为什么？
Dialogue: 0,1:53:58.35,1:54:00.20,英文,,0,0,0,,How can I find Albus?
Dialogue: 0,1:53:58.35,1:54:00.20,中文,,0,0,0,,如何找到阿不思？
Dialogue: 0,1:54:00.20,1:54:01.32,英文,,0,0,0,,Well, I go to the A bucket.
Dialogue: 0,1:54:00.20,1:54:01.32,中文,,0,0,0,,去 A 桶。
Dialogue: 0,1:54:01.32,1:54:02.40,英文,,0,0,0,,How do I find Zacharias?
Dialogue: 0,1:54:01.32,1:54:02.40,中文,,0,0,0,,如何找到扎卡赖斯？
Dialogue: 0,1:54:02.40,1:54:03.60,英文,,0,0,0,,I go to the Z bucket.
Dialogue: 0,1:54:02.40,1:54:03.60,中文,,0,0,0,,去 Z 桶。
Dialogue: 0,1:54:03.60,1:54:04.54,英文,,0,0,0,,How do I find Hermione?
Dialogue: 0,1:54:03.60,1:54:04.54,中文,,0,0,0,,如何找到赫敏？
Dialogue: 0,1:54:04.54,1:54:06.26,英文,,0,0,0,,I go to the H bucket.
Dialogue: 0,1:54:04.54,1:54:06.26,中文,,0,0,0,,去 H 桶。
Dialogue: 0,1:54:06.26,1:54:08.06,英文,,0,0,0,,But, but, but.
Dialogue: 0,1:54:06.26,1:54:08.06,中文,,0,0,0,,但是。
Dialogue: 0,1:54:08.06,1:54:10.23,英文,,0,0,0,,I've done this very deliberately.
Dialogue: 0,1:54:08.06,1:54:10.23,中文,,0,0,0,,我这样做的原因是…
Dialogue: 0,1:54:10.23,1:54:12.98,英文,,0,0,0,,What problem will arise eventually?
Dialogue: 0,1:54:10.23,1:54:12.98,中文,,0,0,0,,最终会出现什么问题？
Dialogue: 0,1:54:12.98,1:54:18.36,英文,,0,0,0,,Assuming you have enough classmates.
Dialogue: 0,1:54:12.98,1:54:18.36,中文,,0,0,0,,假设你有足够多的同学。
Dialogue: 0,1:54:18.36,1:54:23.82,英文,,0,0,0,,Yeah, there'll be too many people, too many contacts for all of the available spaces in the array.
Dialogue: 0,1:54:18.36,1:54:23.82,中文,,0,0,0,,数组空间有限，但联系人会太多。
Dialogue: 0,1:54:23.82,1:54:36.59,英文,,0,0,0,,There's still some room here, but I'm pretty sure if I think back to this particular class, we've got not Hermione, but also Harry, who's also an H, Hagrid, who's also an H. So where do I put them?
Dialogue: 0,1:54:23.82,1:54:36.59,中文,,0,0,0,,这里还有一些空间，但我敢肯定，回想起这门课，不仅有赫敏，还有哈利，他也是 H 开头，还有海格，也是 H 开头，应该把他们放在哪里呢？
Dialogue: 0,1:54:36.59,1:54:47.76,英文,,0,0,0,,I could just put them arbitrarily in any of the open spots, but then you lose the immediacy of jumping right to the H, right to the A, right to the Z. But now that we have linked lists, we can kind of combine these ideas, right?
Dialogue: 0,1:54:36.59,1:54:47.76,中文,,0,0,0,,我可以把它们任意放在任何空位上，但这样就失去了直接跳转到 H、A、Z 的便利性。 现在我们有了链表，可以将这些想法结合起来。
Dialogue: 0,1:54:47.76,1:54:51.58,英文,,0,0,0,,Use an array to get to the first letter of the name you care about.
Dialogue: 0,1:54:47.76,1:54:51.58,中文,,0,0,0,,使用数组找到你想要的名字的首字母。
Dialogue: 0,1:54:51.58,1:55:05.01,英文,,0,0,0,,And then if you have a collision, so to speak, whereby someone's already there, you don't do something stupid like put Harry down here just because it's available, or maybe Hagrid down here just because it's available, because then you're losing the immediacy of the lookup.
Dialogue: 0,1:54:51.58,1:55:05.01,中文,,0,0,0,,如果发生了冲突，也就是说，已经有人在那里了，你不会做蠢事，比如把 Harry 放在这里，\N仅仅因为这里有空位，或者把 Hagrid 放在这里，仅仅因为这里有空位，因为那样你就失去了查找的即时性。
Dialogue: 0,1:55:05.01,1:55:09.13,英文,,0,0,0,,Why don't you just kind of stitch them together in a linked list?
Dialogue: 0,1:55:05.01,1:55:09.13,中文,,0,0,0,,为什么不把它们用链表连接起来呢？
Dialogue: 0,1:55:09.13,1:55:14.54,英文,,0,0,0,,Now, what does this mean? This means for most of the characters here, you have constant time lookup.
Dialogue: 0,1:55:09.13,1:55:14.54,中文,,0,0,0,,这意味着，对于这里的大多数字符，你都有常数时间的查找。
Dialogue: 0,1:55:14.54,1:55:15.94,英文,,0,0,0,,You look up Albus, boom, you're done.
Dialogue: 0,1:55:14.54,1:55:15.94,中文,,0,0,0,,你查找 Albus， boom，就找到了。
Dialogue: 0,1:55:15.94,1:55:17.32,英文,,0,0,0,,Zacharias, boom, you're done.
Dialogue: 0,1:55:15.94,1:55:17.32,中文,,0,0,0,,Zacharias， boom，就找到了。
Dialogue: 0,1:55:17.32,1:55:22.30,英文,,0,0,0,,OK, Harry, Hermione, Hagrid, it might be one, two, or three steps.
Dialogue: 0,1:55:17.32,1:55:22.30,中文,,0,0,0,,Harry、Hermione、Hagrid，可能需要一、二或三步。
Dialogue: 0,1:55:22.30,1:55:24.90,英文,,0,0,0,,So that's actually devolving into something linear.
Dialogue: 0,1:55:22.30,1:55:24.90,中文,,0,0,0,,所以这实际上变成了线性时间。
Dialogue: 0,1:55:24.90,1:55:29.28,英文,,0,0,0,,But here we make a distinction today between theoretical running times, which we keep talking about,
Dialogue: 0,1:55:24.90,1:55:29.28,中文,,0,0,0,,但今天我们要区分理论运行时间，也就是我们一直在讨论的，
Dialogue: 0,1:55:29.28,1:55:34.19,英文,,0,0,0,,And honestly, a clock on the wall running times that actual humans care about.
Dialogue: 0,1:55:29.28,1:55:34.19,中文,,0,0,0,,以及实际的人们关心的挂钟时间。
Dialogue: 0,1:55:34.19,1:55:40.33,英文,,0,0,0,,This is way faster than a linked list because you don't have to search every name.
Dialogue: 0,1:55:34.19,1:55:40.33,中文,,0,0,0,,这比链表快得多，因为你不需要搜索每个名字。
Dialogue: 0,1:55:40.33,1:55:45.05,英文,,0,0,0,,It's even faster than an array because you don't need to do binary search.
Dialogue: 0,1:55:40.33,1:55:45.05,中文,,0,0,0,,它甚至比数组还快，因为你不需要进行二分查找。
Dialogue: 0,1:55:45.05,1:55:50.74,英文,,0,0,0,,You can literally, for most of the names, find them in constant time, one step.
Dialogue: 0,1:55:45.05,1:55:50.74,中文,,0,0,0,,实际上，对于大多数名字，你可以在常数时间内找到它们，只需一步。
Dialogue: 0,1:55:50.74,1:55:53.04,英文,,0,0,0,,And again, it's not theoretically constant because these
Dialogue: 0,1:55:50.74,1:55:53.04,中文,,0,0,0,,再说一次，这在理论上不是常数时间，因为这些
Dialogue: 0,1:55:53.04,1:55:57.94,英文,,0,0,0,,If you only befriend people who have H names, it's going to be a crazy long linked list anyway.
Dialogue: 0,1:55:53.04,1:55:57.94,中文,,0,0,0,,如果你只和名字是 H 开头的人交朋友，那么这将是一个非常长的链表。
Dialogue: 0,1:55:57.94,1:56:01.98,英文,,0,0,0,,So again, it really kind of depends on what the nature of the data is here.
Dialogue: 0,1:55:57.94,1:56:01.98,中文,,0,0,0,,这真的取决于数据的性质。
Dialogue: 0,1:56:01.98,1:56:04.87,英文,,0,0,0,,But this is pretty close to constant time.
Dialogue: 0,1:56:01.98,1:56:04.87,中文,,0,0,0,,但这非常接近于常数时间。
Dialogue: 0,1:56:04.87,1:56:06.41,英文,,0,0,0,,And in fact, how could we get even closer?
Dialogue: 0,1:56:04.87,1:56:06.41,中文,,0,0,0,,事实上，我们怎样才能更接近常数时间呢？
Dialogue: 0,1:56:06.41,1:56:12.31,英文,,0,0,0,,How could we reduce the probability of collisions for the H's or any other letters?
Dialogue: 0,1:56:06.41,1:56:12.31,中文,,0,0,0,,我们怎样才能减少 H 或其他字母发生冲突的概率？
Dialogue: 0,1:56:12.31,1:56:23.12,英文,,0,0,0,,How could we avoid putting too many H names together? Say a little letter?
Dialogue: 0,1:56:12.31,1:56:23.12,中文,,0,0,0,,我们怎样才能避免把太多 H 开头的名字放在一起呢？比如小写字母？
Dialogue: 0,1:56:23.12,1:56:27.26,英文,,0,0,0,,OK, yeah, so we could add another dimension, if you will.
Dialogue: 0,1:56:23.12,1:56:27.26,中文,,0,0,0,,我们可以增加一个维度。
Dialogue: 0,1:56:27.26,1:56:29.04,英文,,0,0,0,,But let's not add a third dimension, per se.
Dialogue: 0,1:56:27.26,1:56:29.04,中文,,0,0,0,,但是我们先不增加第三个维度。
Dialogue: 0,1:56:29.04,1:56:33.63,英文,,0,0,0,,But let's indeed look at not just the first letter of everyone's name, but the first and the second.
Dialogue: 0,1:56:29.04,1:56:33.63,中文,,0,0,0,,但我们来看看，不只是每个名字的第一个字母，而是第一个和第二个字母。
Dialogue: 0,1:56:33.63,1:56:37.27,英文,,0,0,0,,And in fact, let's see if that gets us a little further along.
Dialogue: 0,1:56:33.63,1:56:37.27,中文,,0,0,0,,看看这样是否能让我们更进一步。
Dialogue: 0,1:56:37.27,1:56:43.01,英文,,0,0,0,,So let me go ahead and propose, if you go through the whole Harry Potter universe, there's actually a lot of collisions if we keep going.
Dialogue: 0,1:56:37.27,1:56:43.01,中文,,0,0,0,,如果遍历整个哈利波特宇宙，如果我们继续下去，实际上会有很多冲突。
Dialogue: 0,1:56:43.01,1:56:47.58,英文,,0,0,0,,And so we've got the L's here, the R's, the S's, and so forth. Well, let's clean this up here.
Dialogue: 0,1:56:43.01,1:56:47.58,中文,,0,0,0,,我们这里有 L 开头的名字，R 开头的名字，S 开头的名字，等等。让我们来整理一下。
Dialogue: 0,1:56:47.58,1:56:54.28,英文,,0,0,0,,Hermione originally went to the H location, but let's decrease the probability of collisions there and everywhere else.
Dialogue: 0,1:56:47.58,1:56:54.28,中文,,0,0,0,,赫敏最初被放在了 H 位置，但让我们降低那里以及其他所有地方发生冲突的可能性。
Dialogue: 0,1:56:54.28,1:56:59.90,英文,,0,0,0,,Instead of putting Hermione, Harry, and Hagrid all together, let's go ahead and do this instead.
Dialogue: 0,1:56:54.28,1:56:59.90,中文,,0,0,0,,与其把赫敏、哈利和海格放在一起，不如这样做。
Dialogue: 0,1:56:59.90,1:57:04.51,英文,,0,0,0,,Instead of labeling these buckets A through Z, let's just give ourselves more buckets.
Dialogue: 0,1:56:59.90,1:57:04.51,中文,,0,0,0,,与其用 A 到 Z 标记这些桶，不如给我们自己更多桶。
Dialogue: 0,1:57:04.51,1:57:08.61,英文,,0,0,0,,So in fact, this might be H. Well, instead of H, maybe this should be HA.
Dialogue: 0,1:57:04.51,1:57:08.61,中文,,0,0,0,,实际上，这可能是 H。不，与其是 H，不如把它设为 Ha。
Dialogue: 0,1:57:08.61,1:57:11.89,英文,,0,0,0,,And then this should be HB, HC, HD, HE, HF.
Dialogue: 0,1:57:08.61,1:57:11.89,中文,,0,0,0,,然后是 Hb、Hc、Hd、He、Hf。
Dialogue: 0,1:57:11.89,1:57:16.67,英文,,0,0,0,,Now, some of those are a little nonsensical, because I can't think of names that match most of those.
Dialogue: 0,1:57:11.89,1:57:16.67,中文,,0,0,0,,其中一些有点荒谬，因为我想不出与大多数这些相匹配的名字。
Dialogue: 0,1:57:16.67,1:57:18.17,英文,,0,0,0,,But it's deterministic.
Dialogue: 0,1:57:16.67,1:57:18.17,中文,,0,0,0,,但这是确定的。
Dialogue: 0,1:57:18.17,1:57:22.61,英文,,0,0,0,,At least we know the bucket will be there, which is important even if it's empty.
Dialogue: 0,1:57:18.17,1:57:22.61,中文,,0,0,0,,至少我们知道桶会在那里，这很重要，即使它是空的。
Dialogue: 0,1:57:22.61,1:57:24.65,英文,,0,0,0,,And now we can put Hermione here.
Dialogue: 0,1:57:22.61,1:57:24.65,中文,,0,0,0,,现在我们可以把赫敏放在这里。
Dialogue: 0,1:57:24.65,1:57:25.78,英文,,0,0,0,,We can put Harry here.
Dialogue: 0,1:57:24.65,1:57:25.78,中文,,0,0,0,,我们可以把哈利放在这里。
Dialogue: 0,1:57:25.78,1:57:28.16,英文,,0,0,0,,But uh-oh, we didn't do this perfectly well.
Dialogue: 0,1:57:25.78,1:57:28.16,中文,,0,0,0,,但是，我们做得还不够完美。
Dialogue: 0,1:57:28.16,1:57:29.44,英文,,0,0,0,,Hagrid still collides.
Dialogue: 0,1:57:28.16,1:57:29.44,中文,,0,0,0,,海格仍然冲突了。
Dialogue: 0,1:57:29.44,1:57:30.76,英文,,0,0,0,,So let me come back to you.
Dialogue: 0,1:57:29.44,1:57:30.76,中文,,0,0,0,,我再来问问你。
Dialogue: 0,1:57:30.76,1:57:35.42,英文,,0,0,0,,How can we reduce the probability of Harry and Hagrid colliding?
Dialogue: 0,1:57:30.76,1:57:35.42,中文,,0,0,0,,我们怎样才能降低哈利和海格发生冲突的可能性？
Dialogue: 0,1:57:35.42,1:57:36.98,英文,,0,0,0,,Yeah, so we could look at the third letter.
Dialogue: 0,1:57:35.42,1:57:36.98,中文,,0,0,0,,我们可以看第三个字母。
Dialogue: 0,1:57:36.98,1:57:38.38,英文,,0,0,0,,OK, so let me try that.
Dialogue: 0,1:57:36.98,1:57:38.38,中文,,0,0,0,,让我试试。
Dialogue: 0,1:57:38.38,1:57:47.67,英文,,0,0,0,,Instead of H-A, let's look at H-A-A, H-A-B, H-A-C, dot, dot, dot, H-A-Q, dot, dot, dot, H-E-Q, H-E-R, H-E-S, and so forth.
Dialogue: 0,1:57:38.38,1:57:47.67,中文,,0,0,0,,我们不看 H-a，而是看 H-a-a、H-a-b、H-a-c，等等，H-a-q，等等，H-e-q、H-e-r、H-e-s，等等。
Dialogue: 0,1:57:47.67,1:57:54.58,英文,,0,0,0,,And now I think those names, and probably all of the others we saw, are now much more cleanly distributed.
Dialogue: 0,1:57:47.67,1:57:54.58,中文,,0,0,0,,我认为这些名字，可能还有我们看到的所有其他名字，现在分布得更均匀了。
Dialogue: 0,1:57:54.58,1:58:02.58,英文,,0,0,0,,There is much lower probability of collisions, unless two people have almost the same names, or one is like a prefix of the other, but, but, but.
Dialogue: 0,1:57:54.58,1:58:02.58,中文,,0,0,0,,发生冲突的概率要低得多，除非两个人的名字几乎相同，或者一个人的名字是另一个人的前缀，但是，但是，但是。
Dialogue: 0,1:58:02.58,1:58:16.97,英文,,0,0,0,,Even though we're now closer than ever to constant time, because the odds that we hit a collision and have to devolve to a linked list are much lower, what's the downside that's not completely obvious from how I've depicted this on screen?
Dialogue: 0,1:58:02.58,1:58:16.97,中文,,0,0,0,,尽管我们现在比以往任何时候都更接近常数时间，因为我们遇到冲突\N并不得不退化到链表的可能性要低得多，但我现在在屏幕上展示的这种方法有什么不完全明显的缺点？
Dialogue: 0,1:58:16.97,1:58:18.39,英文,,0,0,0,,What's the price I'm paying here?
Dialogue: 0,1:58:16.97,1:58:18.39,中文,,0,0,0,,我要付出什么代价？
Dialogue: 0,1:58:18.39,1:58:20.04,英文,,0,0,0,,Yeah.
Dialogue: 0,1:58:18.39,1:58:20.04,中文,,0,0,0,,是的。
Dialogue: 0,1:58:20.04,1:58:22.32,英文,,0,0,0,,This is a huge amount of memory.
Dialogue: 0,1:58:20.04,1:58:22.32,中文,,0,0,0,,这需要大量的内存。
Dialogue: 0,1:58:22.32,1:58:32.59,英文,,0,0,0,,The number of cells here in the array is now, what, 26 times 26 times 26 for the first, the second, and the third possible characters, all combinatorically combined here.
Dialogue: 0,1:58:22.32,1:58:32.59,中文,,0,0,0,,现在数组中的单元格数量是多少，第一个、第二个和第三个可能字符分别是 26 乘以 26 乘以 26，所有这些字符都在这里组合起来了。
Dialogue: 0,1:58:32.59,1:58:36.77,英文,,0,0,0,,That's a lot. I didn't even draw them. I have the dot, dot, dot to evoke that instead.
Dialogue: 0,1:58:32.59,1:58:36.77,中文,,0,0,0,,太多了。我都没有把它们画出来。我用点，点，点来代替。
Dialogue: 0,1:58:36.77,1:58:38.25,英文,,0,0,0,,That's a huge amount of memory.
Dialogue: 0,1:58:36.77,1:58:38.25,中文,,0,0,0,,这需要大量的内存。
Dialogue: 0,1:58:38.25,1:58:40.51,英文,,0,0,0,,This is a very sparse data set now.
Dialogue: 0,1:58:38.25,1:58:40.51,中文,,0,0,0,,这是一个非常稀疏的数据集。
Dialogue: 0,1:58:40.51,1:58:47.61,英文,,0,0,0,,And odds are, you're going to waste so much memory, even for the names like H-A-E, H-A, like H-E-Q.
Dialogue: 0,1:58:40.51,1:58:47.61,中文,,0,0,0,,而且很有可能，你会浪费大量的内存，即使是像 H-a-e、H-a，像 H-e-q 这样的名字。
Dialogue: 0,1:58:47.61,1:58:48.83,英文,,0,0,0,,Like, I can't even think of names.
Dialogue: 0,1:58:47.61,1:58:48.83,中文,,0,0,0,,我想不出什么名字了。
Dialogue: 0,1:58:48.83,1:58:55.55,英文,,0,0,0,,So many of those buckets are going to be empty, not to mention the A-A-A and the Z-Z-Z and everything else in between.
Dialogue: 0,1:58:48.83,1:58:55.55,中文,,0,0,0,,很多桶都是空的，更不用说 A-A-A 和 Z-Z-Z 以及它们之间的所有东西了。
Dialogue: 0,1:58:55.55,1:58:56.51,英文,,0,0,0,,So it's a trade-off.
Dialogue: 0,1:58:55.55,1:58:56.51,中文,,0,0,0,,所以这是一个权衡。
Dialogue: 0,1:58:56.51,1:58:58.55,英文,,0,0,0,,And it might be too expensive a trade-off.
Dialogue: 0,1:58:56.51,1:58:58.55,中文,,0,0,0,,这可能是一个代价太高的权衡。
Dialogue: 0,1:58:58.55,1:59:04.64,英文,,0,0,0,,And so you might have to tolerate something like the collisions we had earlier, whereby even though they might very well happen,
Dialogue: 0,1:58:58.55,1:59:04.64,中文,,0,0,0,,所以你可能不得不容忍像我们之前遇到的冲突，尽管它们很可能会发生，
Dialogue: 0,1:59:04.64,1:59:10.84,英文,,0,0,0,,At least you are decreasing the probability by perhaps having more buckets like this.
Dialogue: 0,1:59:04.64,1:59:10.84,中文,,0,0,0,,至少你可以通过增加这样的桶来降低概率。
Dialogue: 0,1:59:10.84,1:59:17.64,英文,,0,0,0,,And in fact, if I rewind now to where we might have gone with this, here's how we might represent these nodes in the tree.
Dialogue: 0,1:59:10.84,1:59:17.64,中文,,0,0,0,,事实上，如果我现在倒回到我们可能采取这种做法的地方，我们可以用这种方式来表示树中的这些节点。
Dialogue: 0,1:59:17.64,1:59:23.47,英文,,0,0,0,,Previously, in the past, we've had a person who had a string name and a string number, a.k.a. now char star.
Dialogue: 0,1:59:17.64,1:59:23.47,中文,,0,0,0,,之前，我们见过一个人，他有一个字符串类型的名字和一个字符串类型的号码，也就是现在的 `char` 指针。
Dialogue: 0,1:59:23.47,1:59:33.59,英文,,0,0,0,,And so here now might be how, in this hash table, we represent someone's name and number, as well as a pointer to the next element in the list.
Dialogue: 0,1:59:23.47,1:59:33.59,中文,,0,0,0,,现在可能就是这样，在这个哈希表中，我们表示一个人的姓名和号码，以及一个指向列表中下一个元素的指针。
Dialogue: 0,1:59:33.59,1:59:35.50,英文,,0,0,0,,Let me rewind just to the picture here.
Dialogue: 0,1:59:33.59,1:59:35.50,中文,,0,0,0,,让我回到这张图。
Dialogue: 0,1:59:35.50,1:59:38.14,英文,,0,0,0,,We keep drawing different shapes because, again, these are abstractions.
Dialogue: 0,1:59:35.50,1:59:38.14,中文,,0,0,0,,我们一直在画不同的形状，因为，再说一次，这些都是抽象的。
Dialogue: 0,1:59:38.14,1:59:39.96,英文,,0,0,0,,Who really cares if they're to scale now?
Dialogue: 0,1:59:38.14,1:59:39.96,中文,,0,0,0,,谁在乎它们现在的比例？
Dialogue: 0,1:59:39.96,1:59:42.12,英文,,0,0,0,,We've got enough room for the person's name.
Dialogue: 0,1:59:39.96,1:59:42.12,中文,,0,0,0,,我们有足够的空间存放这个人的名字。
Dialogue: 0,1:59:42.12,1:59:46.05,英文,,0,0,0,,Not pictured on the screen is Hermione's number, but that's somewhere in this rectangle.
Dialogue: 0,1:59:42.12,1:59:46.05,中文,,0,0,0,,屏幕上没有显示赫敏的号码，但就在这个矩形的某个地方。
Dialogue: 0,1:59:46.05,1:59:51.08,英文,,0,0,0,,But yes pictured here in this little square is a pointer to the next node in the list.
Dialogue: 0,1:59:46.05,1:59:51.08,中文,,0,0,0,,但是，在这个小方块里确实显示的是一个指向列表中下一个节点的指针。
Dialogue: 0,1:59:51.08,2:00:01.80,英文,,0,0,0,,So by storing name and number, maybe her address, maybe her mailing address, whatever, in addition to a pointer, allows each of these nodes to be connectable, just like the nodes in a linked list.
Dialogue: 0,1:59:51.08,2:00:01.80,中文,,0,0,0,,通过存储姓名和号码，也许是她的地址，也许是她的邮寄地址，等等，除了指针之外，还可以让这些节点连接起来，就像链表中的节点一样。
Dialogue: 0,2:00:01.80,2:00:04.24,英文,,0,0,0,,But where they're starting is in an array.
Dialogue: 0,2:00:01.80,2:00:04.24,中文,,0,0,0,,但是，它们的起点是一个数组。
Dialogue: 0,2:00:04.24,2:00:12.62,英文,,0,0,0,,So the array narrows the problem from size 26 to 1, gets us to the linked list in question.
Dialogue: 0,2:00:04.24,2:00:12.62,中文,,0,0,0,,所以数组将问题的范围从 26 个缩小到 1 个，找到了我们想要的链表。
Dialogue: 0,2:00:12.62,2:00:16.62,英文,,0,0,0,,Hopefully, it's a single person, or perhaps it has more than that.
Dialogue: 0,2:00:12.62,2:00:16.62,中文,,0,0,0,,希望只有一个人，或者可能不止一个人。
Dialogue: 0,2:00:16.62,2:00:19.36,英文,,0,0,0,,Meanwhile, what is the hash table itself?
Dialogue: 0,2:00:16.62,2:00:19.36,中文,,0,0,0,,同时，哈希表本身是什么？
Dialogue: 0,2:00:19.36,2:00:23.05,英文,,0,0,0,,The hash table, the whole thing, is literally just an array.
Dialogue: 0,2:00:19.36,2:00:23.05,中文,,0,0,0,,哈希表，整个东西，实际上就是一个数组。
Dialogue: 0,2:00:23.05,2:00:26.17,英文,,0,0,0,,I've hardcoded the simplest version of size 26.
Dialogue: 0,2:00:23.05,2:00:26.17,中文,,0,0,0,,我已经硬编码了最简单的 26 个大小的版本。
Dialogue: 0,2:00:26.17,2:00:30.49,英文,,0,0,0,,But what do each of those boxes in the vertical array represent?
Dialogue: 0,2:00:26.17,2:00:30.49,中文,,0,0,0,,但是，垂直数组中的每个框代表什么？
Dialogue: 0,2:00:30.49,2:00:33.51,英文,,0,0,0,,Just a pointer to potentially a node, a node in the linked list.
Dialogue: 0,2:00:30.49,2:00:33.51,中文,,0,0,0,,只是一个指向潜在节点的指针，链表中的一个节点。
Dialogue: 0,2:00:33.51,2:00:41.91,英文,,0,0,0,,And if there's no one there, if there's no one in location y or x or the like in that universe, well, it's just a null pointer, signifying there's no one there.
Dialogue: 0,2:00:33.51,2:00:41.91,中文,,0,0,0,,如果没有人在那里，如果在那个宇宙中，y 或 x 或类似的位置上没有人，那么，它只是一个空指针，表示那里没有人。
Dialogue: 0,2:00:41.91,2:00:45.23,英文,,0,0,0,,But if there is, it's going to be a pointer to a valid node.
Dialogue: 0,2:00:41.91,2:00:45.23,中文,,0,0,0,,但如果有人，它将指向一个有效的节点。
Dialogue: 0,2:00:45.23,2:00:48.37,英文,,0,0,0,,From which we can get to any of the others as well.
Dialogue: 0,2:00:45.23,2:00:48.37,中文,,0,0,0,,从那里，我们也可以找到其他的节点。
Dialogue: 0,2:00:48.37,2:01:00.85,英文,,0,0,0,,And that so-called hash function, just like the one I did with the greeting cards, well, it's just a black box, if you will, but implemented somewhere in code, like in C. And so if you pass in Albus, what is the hash value of Albus?
Dialogue: 0,2:00:48.37,2:01:00.85,中文,,0,0,0,,这个所谓的哈希函数，就像我用贺卡演示的那样，它就像一个黑盒子，\N如果你愿意这样理解的话，但它是在代码中实现的，比如用 C 语言。如果你传入 Albus，Albus 的哈希值是多少？
Dialogue: 0,2:01:00.85,2:01:05.35,英文,,0,0,0,,Well, in the first version of the story with 26 buckets, it should be a 0.
Dialogue: 0,2:01:00.85,2:01:05.35,中文,,0,0,0,,在这个例子中，第一个版本有 26 个桶，它应该是 0。
Dialogue: 0,2:01:05.35,2:01:08.11,英文,,0,0,0,,If you pass in Zacharias, it should be 25.
Dialogue: 0,2:01:05.35,2:01:08.11,中文,,0,0,0,,如果你传入 Zacharias，它应该是 25。
Dialogue: 0,2:01:08.11,2:01:24.77,英文,,0,0,0,,And so just as my cards were being hashed to one of 1, 2, 3, 4 values, now these names are being hashed to one of 26 possibilities, or 26 times 26, or 26 to the third power, if you have more and more granularity than that.
Dialogue: 0,2:01:08.11,2:01:24.77,中文,,0,0,0,,就像我的卡片被散列到 1、2、3、4 这四个值之一一样，\N现在这些名字也被散列到 26 种可能性之一，或者 26 乘以 26，或者 26 的三次方，如果你需要越来越细的粒度。
Dialogue: 0,2:01:24.77,2:01:30.45,英文,,0,0,0,,Questions on this implementation now of this idea of a hash table?
Dialogue: 0,2:01:24.77,2:01:30.45,中文,,0,0,0,,关于哈希表的实现，大家还有什么问题吗？
Dialogue: 0,2:01:41.59,2:01:44.50,英文,,0,0,0,,If you say that again with the null.
Dialogue: 0,2:01:41.59,2:01:44.50,中文,,0,0,0,,能再说说空值的情况吗？
Dialogue: 0,2:01:55.81,2:01:56.57,英文,,0,0,0,,Oh, well, good question.
Dialogue: 0,2:01:55.81,2:01:56.57,中文,,0,0,0,,问得好。
Dialogue: 0,2:01:56.57,2:02:11.14,英文,,0,0,0,,So if there's so much sparseness, there's all of these empty cells in the array, couldn't you just go in and free them or delete them or just kind of shrink the array and not have AAA and AAB and AAC only have the prefixes, two or three characters that you need?
Dialogue: 0,2:01:56.57,2:02:11.14,中文,,0,0,0,,如果有这么多空位，数组中所有这些单元格都是空的，\N难道你不能直接释放它们或者删除它们，或者只是缩减数组，不要 AAA、AAB 和 AAC，只保留你需要的两三个字符的前缀吗？
Dialogue: 0,2:02:11.14,2:02:13.14,英文,,0,0,0,,You absolutely could do that.
Dialogue: 0,2:02:11.14,2:02:13.14,中文,,0,0,0,,你绝对可以这样做。
Dialogue: 0,2:02:13.14,2:02:19.12,英文,,0,0,0,,But now what you lose is the arithmetic benefit of being able to map each letter to a number.
Dialogue: 0,2:02:13.14,2:02:19.12,中文,,0,0,0,,但现在你失去了将每个字母映射到一个数字的算术优势。
Dialogue: 0,2:02:19.12,2:02:26.47,英文,,0,0,0,,If you start freeing up unused space, you don't know that Zacharias is necessarily at location 25.
Dialogue: 0,2:02:19.12,2:02:26.47,中文,,0,0,0,,如果你开始释放未使用的空间，你就不知道 Zacharias 一定在位置 25。
Dialogue: 0,2:02:26.47,2:02:28.31,英文,,0,0,0,,Albus is still going to be at location 0.
Dialogue: 0,2:02:26.47,2:02:28.31,中文,,0,0,0,,Albus 仍然会在位置 0。
Dialogue: 0,2:02:28.31,2:02:35.56,英文,,0,0,0,,But if you've deleted some of the elements in the middle, Zacharias could be at 24 if you've deleted one, 23 if you've deleted another.
Dialogue: 0,2:02:28.31,2:02:35.56,中文,,0,0,0,,但如果你删除了中间的一些元素，Zacharias 可能是 24，如果你删除了一个元素，23，如果你删除了另一个。
Dialogue: 0,2:02:35.56,2:02:41.62,英文,,0,0,0,,And so you don't have that arithmetic immediacy that you need in order to index into the array with constant time.
Dialogue: 0,2:02:35.56,2:02:41.62,中文,,0,0,0,,这样你就失去了以常数时间索引数组所需的算术直接性。
Dialogue: 0,2:02:41.62,2:02:45.64,英文,,0,0,0,,And the same is going to be true if it's two letters or three letters.
Dialogue: 0,2:02:41.62,2:02:45.64,中文,,0,0,0,,如果是两个字母或三个字母也是如此。
Dialogue: 0,2:02:45.64,2:02:50.90,英文,,0,0,0,,You need to be able to trust that you can do some quick math and jump to the right index in constant time.
Dialogue: 0,2:02:45.64,2:02:50.90,中文,,0,0,0,,你需要能够相信，你可以做一些快速的数学运算，并在常数时间内跳转到正确的索引。
Dialogue: 0,2:02:50.90,2:02:53.08,英文,,0,0,0,,And that's, again, the appeal of these arrays.
Dialogue: 0,2:02:50.90,2:02:53.08,中文,,0,0,0,,这也是这些数组的吸引力所在。
Dialogue: 0,2:02:53.08,2:02:59.39,英文,,0,0,0,,So when it comes to the running time of a hash table, inserting values into it, searching for values therein,
Dialogue: 0,2:02:53.08,2:02:59.39,中文,,0,0,0,,所以当谈到哈希表的运行时间时，向其中插入值，搜索其中的值，
Dialogue: 0,2:02:59.39,2:03:14.94,英文,,0,0,0,,At the end of the day, it technically is big O of n, because in the craziest case, you might have a huge, fancy hash table, but everyone in the universe has a name starting with H. And then it just evolves into a really long, length list, just like a binary search tree could do the same.
Dialogue: 0,2:02:59.39,2:03:14.94,中文,,0,0,0,,最终，它在技术上是 O(n) 的复杂度，因为在最糟糕的情况下，你可能有一个巨大而复杂的哈希表，\N但世界上每个人的名字都以 H 开头。然后它就会演变成一个非常长的列表，就像二叉搜索树一样。
Dialogue: 0,2:03:14.94,2:03:25.97,英文,,0,0,0,,But if you choose a smarter hash function, maybe you mitigate that and you don't rely only on the first letter, but on the second or the third as well or some other combination of that input and make your hash function smarter.
Dialogue: 0,2:03:14.94,2:03:25.97,中文,,0,0,0,,但是，如果你选择一个更智能的哈希函数，也许你可以缓解这种情况，\N你不只是依赖第一个字母，而是依赖第二个或第三个字母，或者输入的其他组合，使你的哈希函数更智能。
Dialogue: 0,2:03:25.97,2:03:33.68,英文,,0,0,0,,Odds are, if you get a good hash function, you want to get it to be more of like order of n divided by k, where k means constant mathematically.
Dialogue: 0,2:03:25.97,2:03:33.68,中文,,0,0,0,,如果你有一个好的哈希函数，你希望它更接近于 n / k 的数量级，其中 k 在数学上表示常数。
Dialogue: 0,2:03:33.68,2:03:35.58,英文,,0,0,0,,And so k is the number of buckets.
Dialogue: 0,2:03:33.68,2:03:35.58,中文,,0,0,0,,k 是桶的数量。
Dialogue: 0,2:03:35.58,2:03:38.18,英文,,0,0,0,,So ideally, you want like a uniform distribution.
Dialogue: 0,2:03:35.58,2:03:38.18,中文,,0,0,0,,理想情况下，你希望数据均匀分布。
Dialogue: 0,2:03:38.18,2:03:41.12,英文,,0,0,0,,You want like this many people here, this many people here.
Dialogue: 0,2:03:38.18,2:03:41.12,中文,,0,0,0,,你希望这里有这么多人，那里有那么多人。
Dialogue: 0,2:03:41.12,2:03:43.66,英文,,0,0,0,,You don't want there to be some or no people.
Dialogue: 0,2:03:41.12,2:03:43.66,中文,,0,0,0,,你不希望有些地方有人，有些地方没有人。
Dialogue: 0,2:03:43.66,2:03:46.17,英文,,0,0,0,,You want a uniform statistical distribution.
Dialogue: 0,2:03:43.66,2:03:46.17,中文,,0,0,0,,你希望有一个均匀的统计分布。
Dialogue: 0,2:03:46.17,2:03:47.77,英文,,0,0,0,,And maybe you get that from human names.
Dialogue: 0,2:03:46.17,2:03:47.77,中文,,0,0,0,,也许你能从人名中得到这种分布。
Dialogue: 0,2:03:47.77,2:03:48.35,英文,,0,0,0,,Maybe you don't.
Dialogue: 0,2:03:47.77,2:03:48.35,中文,,0,0,0,,也许你得不到。
Dialogue: 0,2:03:48.35,2:03:50.79,英文,,0,0,0,,But that's kind of the challenge of a hash function.
Dialogue: 0,2:03:48.35,2:03:50.79,中文,,0,0,0,,但这正是哈希函数的挑战所在。
Dialogue: 0,2:03:50.79,2:04:10.82,英文,,0,0,0,,Of course, big O of n over k is not a thing, because we always throw away constants like k. So it's still big O of n. But again, the distinction today is that, OK, yes, academically, you learned in CS50 that, sure, it's big O of n. But my god, it's 26 times faster if you do the hash function well and you spread everyone out over the hash table.
Dialogue: 0,2:03:50.79,2:04:10.82,中文,,0,0,0,,当然，O(n / k) 没什么意义，因为我们总是忽略像 k 这样的常数。所以它仍然是 O(n)。但同样，今天的区别在于，\N，从学术上讲，你在 CS50 中学到过，它是 O(n)。但天哪，如果你把哈希函数设计得好，把每个人都分散到哈希表中，速度就会快 26 倍。
Dialogue: 0,2:04:10.82,2:04:14.33,英文,,0,0,0,,And that's the appeal of these kinds of structures.
Dialogue: 0,2:04:10.82,2:04:14.33,中文,,0,0,0,,这就是这类结构的吸引力所在。
Dialogue: 0,2:04:14.33,2:04:20.29,英文,,0,0,0,,And we've got one more for you, if I may, something now known as a trie.
Dialogue: 0,2:04:14.33,2:04:20.29,中文,,0,0,0,,如果可以的话，我们还有一个要介绍，它叫做 tries。
Dialogue: 0,2:04:20.29,2:04:31.98,英文,,0,0,0,,So it turns out that a trie is even cooler, if you like this kind of thing, in that it does not devolve into big O of n. It is truly constant time.
Dialogue: 0,2:04:20.29,2:04:31.98,中文,,0,0,0,,事实证明，trie 甚至更酷，如果你喜欢这类东西的话，因为它不会退化成 O(n)。它确实是常数时间。
Dialogue: 0,2:04:31.98,2:04:33.02,英文,,0,0,0,,But there's going to be a price.
Dialogue: 0,2:04:31.98,2:04:33.02,中文,,0,0,0,,但这是有代价的。
Dialogue: 0,2:04:33.02,2:04:34.48,英文,,0,0,0,,There's going to be a gotcha.
Dialogue: 0,2:04:33.02,2:04:34.48,中文,,0,0,0,,会有一个陷阱。
Dialogue: 0,2:04:34.48,2:04:38.46,英文,,0,0,0,,A trie is sort of a fancier tree.
Dialogue: 0,2:04:34.48,2:04:38.46,中文,,0,0,0,,Trie 是一种更高级的树。
Dialogue: 0,2:04:38.46,2:04:42.81,英文,,0,0,0,,And it's short for retrieval, but pronounced tri for weird historical reasons.
Dialogue: 0,2:04:38.46,2:04:42.81,中文,,0,0,0,,它是 retrieval（检索）的缩写，但由于奇怪的历史原因，发音是 tri。
Dialogue: 0,2:04:42.81,2:04:48.01,英文,,0,0,0,,But a tri is a tree, each of whose nodes is an array, right?
Dialogue: 0,2:04:42.81,2:04:48.01,中文,,0,0,0,,trie 是一棵树，它的每个节点都是一个数组。
Dialogue: 0,2:04:48.01,2:04:49.81,英文,,0,0,0,,So this is all like crazy mashups now.
Dialogue: 0,2:04:48.01,2:04:49.81,中文,,0,0,0,,所以现在都是疯狂的混搭。
Dialogue: 0,2:04:49.81,2:04:52.49,英文,,0,0,0,,People started inventing data structures just by combining different ones.
Dialogue: 0,2:04:49.81,2:04:52.49,中文,,0,0,0,,人们开始通过组合不同的数据结构来发明新的数据结构。
Dialogue: 0,2:04:52.49,2:05:02.86,英文,,0,0,0,,So unfortunately, a lot of the good ideas are taken, but you just have Benefits from certain aspects of those data structures and combining them ideally gives you the best of both worlds, so to speak.
Dialogue: 0,2:04:52.49,2:05:02.86,中文,,0,0,0,,不幸的是，很多好的想法已经被提出了，但是你可以从这些数据结构的某些方面获益，理想情况下，将它们结合起来可以给你两全其美的结果。
Dialogue: 0,2:05:02.86,2:05:04.94,英文,,0,0,0,,So here might be the root of a trie.
Dialogue: 0,2:05:02.86,2:05:04.94,中文,,0,0,0,,这可能是一个字典树的根节点。
Dialogue: 0,2:05:04.94,2:05:08.40,英文,,0,0,0,,It's literally a big node, a big rectangle, but it's actually an array.
Dialogue: 0,2:05:04.94,2:05:08.40,中文,,0,0,0,,它实际上是一个大节点，一个大矩形，但它实际上是一个数组。
Dialogue: 0,2:05:08.40,2:05:11.68,英文,,0,0,0,,So there's like 26 locations in this picture here.
Dialogue: 0,2:05:08.40,2:05:11.68,中文,,0,0,0,,所以在这张图中大约有26个位置。
Dialogue: 0,2:05:11.68,2:05:17.54,英文,,0,0,0,,And here's how you use a trie, for instance, to store names just like the hash table.
Dialogue: 0,2:05:11.68,2:05:17.54,中文,,0,0,0,,下面是如何使用字典树来存储名字，就像哈希表一样。
Dialogue: 0,2:05:17.54,2:05:24.73,英文,,0,0,0,,You treat each of the elements of that array in that node as like a letter of the alphabet, so A through Z, or 0 through 25.
Dialogue: 0,2:05:17.54,2:05:24.73,中文,,0,0,0,,将该节点中数组的每个元素都视为字母表中的一个字母，例如从 A 到 Z，或者从 0 到 25。
Dialogue: 0,2:05:24.73,2:05:28.81,英文,,0,0,0,,And if you want to store someone's name in here, you do so as follows.
Dialogue: 0,2:05:24.73,2:05:28.81,中文,,0,0,0,,如果你想在这里存储一个人的名字，你可以这样做。
Dialogue: 0,2:05:28.81,2:05:34.40,英文,,0,0,0,,If you want to store, like, an H, you index into the H location.
Dialogue: 0,2:05:28.81,2:05:34.40,中文,,0,0,0,,如果你想存储一个 H，你可以在 H 位置建立索引。
Dialogue: 0,2:05:34.40,2:05:40.38,英文,,0,0,0,,And if you want to store the second letter of someone's name, like an A, well, you add another node below it.
Dialogue: 0,2:05:34.40,2:05:40.38,中文,,0,0,0,,如果你想存储某人名字的第二个字母，比如 A，那么你可以在它下面添加另一个节点。
Dialogue: 0,2:05:40.38,2:05:42.38,英文,,0,0,0,,And such one is connected to the other.
Dialogue: 0,2:05:40.38,2:05:42.38,中文,,0,0,0,,一个节点连接到另一个节点。
Dialogue: 0,2:05:42.38,2:05:45.25,英文,,0,0,0,,And you then identify the A in that array.
Dialogue: 0,2:05:42.38,2:05:45.25,中文,,0,0,0,,然后你在该数组中标识 A。
Dialogue: 0,2:05:45.25,2:05:51.95,英文,,0,0,0,,And then you go on and maybe put a G, if the goal is to store, spoiler now, Hagrid in this data structure.
Dialogue: 0,2:05:45.25,2:05:51.95,中文,,0,0,0,,然后你继续，也许放一个 G，如果目标是在这个数据结构中存储，剧透一下，Hagrid。
Dialogue: 0,2:05:51.95,2:06:02.54,英文,,0,0,0,,And then the R, and the I, and then the D. But when you get to the D, the end of the name, you have to somehow flag that this is the end of a name that we've embedded into this data structure.
Dialogue: 0,2:05:51.95,2:06:02.54,中文,,0,0,0,,然后是 R，I，然后是 D。但是当你到达 D，名字的结尾时，你必须以某种方式标记这是一个嵌入到这个数据结构中的名字的结尾。
Dialogue: 0,2:06:02.54,2:06:11.51,英文,,0,0,0,,Whereas all of these are called out in white just to make obvious what we're connecting to what, green has to be like a bool that's true, that just indicates like the buck stops here.
Dialogue: 0,2:06:02.54,2:06:11.51,中文,,0,0,0,,为了清楚地表明我们正在连接什么，所有这些都用白色标出，而绿色必须像一个值为 true 的布尔值，它只是表明“到此为止”。
Dialogue: 0,2:06:11.51,2:06:15.41,英文,,0,0,0,,Like D is the last letter in someone's actual name.
Dialogue: 0,2:06:11.51,2:06:15.41,中文,,0,0,0,,比如 D 是某人真实姓名中的最后一个字母。
Dialogue: 0,2:06:15.41,2:06:21.19,英文,,0,0,0,,And what's kind of cool now about a try is that we can repeat this for other names as well.
Dialogue: 0,2:06:15.41,2:06:21.19,中文,,0,0,0,,字典树的妙处在于，我们也可以对其他名称重复此操作。
Dialogue: 0,2:06:21.19,2:06:24.84,英文,,0,0,0,,So for instance, here's where we might put Harry as well.
Dialogue: 0,2:06:21.19,2:06:24.84,中文,,0,0,0,,例如，这里是我们也可以放置 Harry 的位置。
Dialogue: 0,2:06:24.84,2:06:28.00,英文,,0,0,0,,And notice they share a common prefix, H-A.
Dialogue: 0,2:06:24.84,2:06:28.00,中文,,0,0,0,,注意，它们共享一个共同的前缀，H-A。
Dialogue: 0,2:06:28.00,2:06:30.36,英文,,0,0,0,,For Hagrid, HA for Harry.
Dialogue: 0,2:06:28.00,2:06:30.36,中文,,0,0,0,,是 HA，Harry 是 HA。
Dialogue: 0,2:06:30.36,2:06:33.56,英文,,0,0,0,,So we're reusing some of these nodes, some of these arrays.
Dialogue: 0,2:06:30.36,2:06:33.56,中文,,0,0,0,,所以我们正在重用其中的一些节点，一些数组。
Dialogue: 0,2:06:33.56,2:06:42.75,英文,,0,0,0,,We can even slip Hermione in here, too, borrowing only the H. But she gets the H, then the E, then R, M, I, O, N, E, and so forth.
Dialogue: 0,2:06:33.56,2:06:42.75,中文,,0,0,0,,我们甚至可以把赫敏也放进去，只借用首字母 H。但她的名字是按顺序排列的：H、E、R、M、I、O、N、E，以此类推。
Dialogue: 0,2:06:42.75,2:06:46.45,英文,,0,0,0,,And we mark at the end of her name, too, that she's in there.
Dialogue: 0,2:06:42.75,2:06:46.45,中文,,0,0,0,,我们也会在她的名字末尾标记，表示她在这里。
Dialogue: 0,2:06:46.45,2:06:48.55,英文,,0,0,0,,Now, what's the takeaway here?
Dialogue: 0,2:06:46.45,2:06:48.55,中文,,0,0,0,,现在，要点是什么？
Dialogue: 0,2:06:48.55,2:06:51.89,英文,,0,0,0,,Well, what is the running time of a try?
Dialogue: 0,2:06:48.55,2:06:51.89,中文,,0,0,0,,查找一次的运行时间是多少？
Dialogue: 0,2:06:51.89,2:06:55.82,英文,,0,0,0,,How many steps does it take to find someone in this data structure?
Dialogue: 0,2:06:51.89,2:06:55.82,中文,,0,0,0,,在这个数据结构中找到某个人需要多少步？
Dialogue: 0,2:06:55.82,2:07:01.16,英文,,0,0,0,,And let me zoom out so that it sort of suddenly becomes a massive data structure with even more in it.
Dialogue: 0,2:06:55.82,2:07:01.16,中文,,0,0,0,,让我缩小一下，这样它就突然变成了一个包含更多内容的海量数据结构。
Dialogue: 0,2:07:01.16,2:07:04.02,英文,,0,0,0,,Maybe it looks, sorry, no, I'll keep it on this one.
Dialogue: 0,2:07:01.16,2:07:04.02,中文,,0,0,0,,也许它看起来，抱歉，不，我会保持在这个例子上。
Dialogue: 0,2:07:04.02,2:07:06.68,英文,,0,0,0,,Maybe it looks a little something like this with just these three names.
Dialogue: 0,2:07:04.02,2:07:06.68,中文,,0,0,0,,也许它看起来像这样，只有这三个名字。
Dialogue: 0,2:07:06.68,2:07:10.52,英文,,0,0,0,,But how many steps does it take to find Hagrid?
Dialogue: 0,2:07:06.68,2:07:10.52,中文,,0,0,0,,但是找到海格需要多少步？
Dialogue: 0,2:07:10.52,2:07:15.22,英文,,0,0,0,,Or Harry, or Hermione, no matter how many names are in this data structure.
Dialogue: 0,2:07:10.52,2:07:15.22,中文,,0,0,0,,或者哈利，或者赫敏，无论这个数据结构中有多少个名字。
Dialogue: 0,2:07:15.22,2:07:18.51,英文,,0,0,0,,There's three at the moment, but it takes what?
Dialogue: 0,2:07:15.22,2:07:18.51,中文,,0,0,0,,目前有三个，但需要多少步？
Dialogue: 0,2:07:18.51,2:07:23.67,英文,,0,0,0,,H-A-G-R-I-D, so six steps to find Hagrid.
Dialogue: 0,2:07:18.51,2:07:23.67,中文,,0,0,0,,H-A-G-R-I-D，找到海格需要六步。
Dialogue: 0,2:07:23.67,2:07:26.88,英文,,0,0,0,,H-A-R-R-Y, five steps to find Harry.
Dialogue: 0,2:07:23.67,2:07:26.88,中文,,0,0,0,,H-A-R-R-Y，找到哈利需要五步。
Dialogue: 0,2:07:26.88,2:07:32.02,英文,,0,0,0,,H-E-R-M-I-O-N-E, eight steps to find Hermione.
Dialogue: 0,2:07:26.88,2:07:32.02,中文,,0,0,0,,H-E-R-M-I-O-N-E，找到赫敏需要八步。
Dialogue: 0,2:07:32.02,2:07:35.14,英文,,0,0,0,,But notice that those steps are only dependent on what?
Dialogue: 0,2:07:32.02,2:07:35.14,中文,,0,0,0,,但请注意，这些步骤只取决于什么？
Dialogue: 0,2:07:35.14,2:07:37.34,英文,,0,0,0,,The lengths of the humans' names.
Dialogue: 0,2:07:35.14,2:07:37.34,中文,,0,0,0,,人名的长度。
Dialogue: 0,2:07:37.34,2:07:41.14,英文,,0,0,0,,And let's assume that no one's going to have an infinitely long name.
Dialogue: 0,2:07:37.34,2:07:41.14,中文,,0,0,0,,我们假设没有人会有无限长的名字。
Dialogue: 0,2:07:41.14,2:07:42.84,英文,,0,0,0,,It's going to max out at, what, like 8?
Dialogue: 0,2:07:41.14,2:07:42.84,中文,,0,0,0,,它最多只能达到 8 个字母左右？
Dialogue: 0,2:07:42.84,2:07:44.50,英文,,0,0,0,,No, maybe 18, maybe 20, 30.
Dialogue: 0,2:07:42.84,2:07:44.50,中文,,0,0,0,,不，也许是 18、20、30。
Dialogue: 0,2:07:44.50,2:07:47.44,英文,,0,0,0,,There's actually some pretty long human names out there.
Dialogue: 0,2:07:44.50,2:07:47.44,中文,,0,0,0,,实际上，有些人的名字很长。
Dialogue: 0,2:07:47.44,2:07:49.05,英文,,0,0,0,,But it's going to be finite.
Dialogue: 0,2:07:47.44,2:07:49.05,中文,,0,0,0,,但它是有限的。
Dialogue: 0,2:07:49.05,2:07:54.51,英文,,0,0,0,,You know it's abounded, whereas most contexts, n could grow forever.
Dialogue: 0,2:07:49.05,2:07:54.51,中文,,0,0,0,,你知道它是有界的，而在大多数情况下，n 可以无限增长。
Dialogue: 0,2:07:54.51,2:08:05.61,英文,,0,0,0,,So what's compelling here is if you assume that the longest name is, I don't know, 50 for the sake of a theme here, then you know that finding anyone in this data structure will take you no more than 50 steps.
Dialogue: 0,2:07:54.51,2:08:05.61,中文,,0,0,0,,这里令人信服的是，如果你假设最长的名字是 50（这里只是举个例子），那么你知道在这个数据结构中找到任何人都只需要不超过 50 步。
Dialogue: 0,2:08:05.61,2:08:09.68,英文,,0,0,0,,50 is thus a constant, which means you have big O of 1,
Dialogue: 0,2:08:05.61,2:08:09.68,中文,,0,0,0,,因此，50 是一个常数，这意味着你得到的时间复杂度是 O(1)，
Dialogue: 0,2:08:09.68,2:08:10.62,英文,,0,0,0,,Running time.
Dialogue: 0,2:08:09.68,2:08:10.62,中文,,0,0,0,,运行时间。
Dialogue: 0,2:08:10.62,2:08:15.02,英文,,0,0,0,,It doesn't matter if there's a million people in this phone book or a billion people in this phone book.
Dialogue: 0,2:08:10.62,2:08:15.02,中文,,0,0,0,,无论这个电话簿里有一百万人还是十亿人，都没有关系。
Dialogue: 0,2:08:15.02,2:08:17.04,英文,,0,0,0,,That's going to definitely add more nodes to it.
Dialogue: 0,2:08:15.02,2:08:17.04,中文,,0,0,0,,那肯定会增加更多的节点。
Dialogue: 0,2:08:17.04,2:08:29.75,英文,,0,0,0,,But it's still going to take you H-A-R, I'm sorry, H-A-G-R-I-D, six steps to find Hagrid, H-A-R-R-Y, five steps to find Harry, even if there's a billion other people in that data structure.
Dialogue: 0,2:08:17.04,2:08:29.75,中文,,0,0,0,,但你仍然需要 H-A-R，抱歉，是 H-A-G-R-I-D，六步才能找到 Hagrid，H-A-R-R-Y，五步才能找到 Harry，即使这个数据结构中有十亿其他人。
Dialogue: 0,2:08:29.75,2:08:36.21,英文,,0,0,0,,So now we actually do seem to have constant time if you assume that there's going to be a bound on the length of the name.
Dialogue: 0,2:08:29.75,2:08:36.21,中文,,0,0,0,,如果假设名字的长度是有界的，那么我们现在确实可以实现常数时间。
Dialogue: 0,2:08:36.21,2:08:44.76,英文,,0,0,0,,Why don't we use tries for everything then? What's the price we're paying for this data structure, even though we've represented just three characters here?
Dialogue: 0,2:08:36.21,2:08:44.76,中文,,0,0,0,,那为什么我们不把字典树用于所有东西呢？即使我们这里只表示了三个字符，但使用这种数据结构我们要付出什么代价呢？
Dialogue: 0,2:08:44.76,2:08:47.03,英文,,0,0,0,,Yeah.
Dialogue: 0,2:08:44.76,2:08:47.03,中文,,0,0,0,,是的。
Dialogue: 0,2:08:47.03,2:08:48.77,英文,,0,0,0,,It's a lot of memory, yeah.
Dialogue: 0,2:08:47.03,2:08:48.77,中文,,0,0,0,,需要很多内存，是的。
Dialogue: 0,2:08:48.77,2:08:50.93,英文,,0,0,0,,And you can see it even with these three names.
Dialogue: 0,2:08:48.77,2:08:50.93,中文,,0,0,0,,即使是这三个名字，你也能看出来。
Dialogue: 0,2:08:50.93,2:08:56.46,英文,,0,0,0,,Most of the squares on the screen are empty, like bytes and bits that are there and are allocated.
Dialogue: 0,2:08:50.93,2:08:56.46,中文,,0,0,0,,屏幕上的大多数方块都是空的，就像字节和比特位在那里，被分配了空间。
Dialogue: 0,2:08:56.46,2:09:01.54,英文,,0,0,0,,And they need to be there because you need to be able to do that arithmetic thing of this being 0, this being 25.
Dialogue: 0,2:08:56.46,2:09:01.54,中文,,0,0,0,,它们必须在那里，因为你需要能够进行这种算术运算，这里是 0，这里是 25。
Dialogue: 0,2:09:01.54,2:09:04.58,英文,,0,0,0,,So you can jump from boom, boom, boom, boom based on each of the letters.
Dialogue: 0,2:09:01.54,2:09:04.58,中文,,0,0,0,,所以你可以根据每个字母，从一个位置跳到另一个位置。
Dialogue: 0,2:09:04.58,2:09:10.05,英文,,0,0,0,,But it's a hugely sparse data structure, which means it takes up a crazy amount of memory.
Dialogue: 0,2:09:04.58,2:09:10.05,中文,,0,0,0,,但这是一个非常稀疏的数据结构，这意味着它会占用大量的内存。
Dialogue: 0,2:09:10.05,2:09:13.11,英文,,0,0,0,,Now, maybe that's tolerable, especially for short names.
Dialogue: 0,2:09:10.05,2:09:13.11,中文,,0,0,0,,当然，这也许是可以忍受的，尤其是对于短名字来说。
Dialogue: 0,2:09:13.11,2:09:14.63,英文,,0,0,0,,But that's going to be the trade-off as well.
Dialogue: 0,2:09:13.11,2:09:14.63,中文,,0,0,0,,但这也是一种取舍。
Dialogue: 0,2:09:14.63,2:09:16.55,英文,,0,0,0,,And this is such a tension in computing.
Dialogue: 0,2:09:14.63,2:09:16.55,中文,,0,0,0,,在计算机科学中，这是一个非常常见的矛盾。
Dialogue: 0,2:09:16.55,2:09:23.93,英文,,0,0,0,,Almost any time you want to improve time, you want to speed up the efficiency, the speed of your algorithm, you're going to spend space.
Dialogue: 0,2:09:16.55,2:09:23.93,中文,,0,0,0,,几乎任何时候，当你想要提升时间效率，也就是提升算法速度时，你都需要花费空间。
Dialogue: 0,2:09:23.93,2:09:30.11,英文,,0,0,0,,If, by contrast, you want to decrease the amount of space, you might very well have to increase the running time.
Dialogue: 0,2:09:23.93,2:09:30.11,中文,,0,0,0,,相反，如果你想减少空间使用量，你很可能不得不增加运行时间。
Dialogue: 0,2:09:30.11,2:09:32.53,英文,,0,0,0,,It is indeed this seesaw back and forth.
Dialogue: 0,2:09:30.11,2:09:32.53,中文,,0,0,0,,这确实像是在跷跷板上反复权衡。
Dialogue: 0,2:09:32.53,2:09:36.97,英文,,0,0,0,,And you, your colleagues, your company need to decide what resource is the most precious.
Dialogue: 0,2:09:32.53,2:09:36.97,中文,,0,0,0,,你，你的同事，你的公司需要决定哪种资源最宝贵。
Dialogue: 0,2:09:36.97,2:09:41.28,英文,,0,0,0,,Heck, it might be much harder to code one of these data structures than another.
Dialogue: 0,2:09:36.97,2:09:41.28,中文,,0,0,0,,见鬼，编写其中一种数据结构可能比另一种要难得多。
Dialogue: 0,2:09:41.28,2:09:41.88,英文,,0,0,0,,You're a human.
Dialogue: 0,2:09:41.28,2:09:41.88,中文,,0,0,0,,你是一个人。
Dialogue: 0,2:09:41.88,2:09:43.06,英文,,0,0,0,,Your time is valuable.
Dialogue: 0,2:09:41.88,2:09:43.06,中文,,0,0,0,,你的时间很宝贵。
Dialogue: 0,2:09:43.06,2:09:45.92,英文,,0,0,0,,Do you really want to spend hours implementing a try when
Dialogue: 0,2:09:43.06,2:09:45.92,中文,,0,0,0,,你真的想花几个小时来实现一个 trie 吗？
Dialogue: 0,2:09:45.92,2:09:49.80,英文,,0,0,0,,You know, hey, in 30 minutes, I can bang out an array nowadays, or a linked list even.
Dialogue: 0,2:09:45.92,2:09:49.80,中文,,0,0,0,,要知道，嘿，现在我可以在 30 分钟内完成一个数组，甚至是一个链表。
Dialogue: 0,2:09:49.80,2:09:52.46,英文,,0,0,0,,There, too, development time is going to be yet another resource.
Dialogue: 0,2:09:49.80,2:09:52.46,中文,,0,0,0,,开发时间也将是另一种资源。
Dialogue: 0,2:09:52.46,2:09:57.12,英文,,0,0,0,,And why sometimes there's good code or bad code, it depends on what you're prioritizing.
Dialogue: 0,2:09:52.46,2:09:57.12,中文,,0,0,0,,为什么有时会有好代码或坏代码，这取决于你优先考虑什么。
Dialogue: 0,2:09:57.12,2:10:01.38,英文,,0,0,0,,So what do each of these nodes look like in a try? Well, we can keep calling it a node.
Dialogue: 0,2:09:57.12,2:10:01.38,中文,,0,0,0,,那么在 trie 中，每个节点是什么样的呢？我们可以继续称它为节点。
Dialogue: 0,2:10:01.38,2:10:04.91,英文,,0,0,0,,This is a very generic term for just a container in these data structures.
Dialogue: 0,2:10:01.38,2:10:04.91,中文,,0,0,0,,这是这些数据结构中容器的通用术语。
Dialogue: 0,2:10:04.91,2:10:13.02,英文,,0,0,0,,In this story, though, let me claim that everyone has a number, like a phone number, a string, a.k.a. char star.
Dialogue: 0,2:10:04.91,2:10:13.02,中文,,0,0,0,,在这个例子中，我们假设每个人都有一个号码，比如电话号码，一个字符串，也就是 char*。
Dialogue: 0,2:10:13.02,2:10:20.72,英文,,0,0,0,,Every node has 26 children, or technically an array of size 26, that can point to more of these nodes.
Dialogue: 0,2:10:13.02,2:10:20.72,中文,,0,0,0,,每个节点都有 26 个子节点，或者严格来说是一个大小为 26 的数组，可以指向更多这样的节点。
Dialogue: 0,2:10:20.72,2:10:28.22,英文,,0,0,0,,Notice that I don't need to store the name of someone in a try, because it's implicit in the path that you take to find them.
Dialogue: 0,2:10:20.72,2:10:28.22,中文,,0,0,0,,注意，我不需要在 trie 中存储一个人的名字，因为它隐含在你找到他们的路径中。
Dialogue: 0,2:10:28.22,2:10:31.44,英文,,0,0,0,,So that's a minor optimization, but it saves us some space.
Dialogue: 0,2:10:28.22,2:10:31.44,中文,,0,0,0,,这是一个小的优化，但它节省了一些空间。
Dialogue: 0,2:10:31.44,2:10:39.59,英文,,0,0,0,,But this would be just a different data structure we could use to actually solve this problem as well, albeit at a very expensive cost.
Dialogue: 0,2:10:31.44,2:10:39.59,中文,,0,0,0,,但这只是我们可以用来解决这个问题的另一种数据结构，尽管成本非常高昂。
Dialogue: 0,2:10:39.59,2:10:42.67,英文,,0,0,0,,And what do we need our variable to be that stores the try?
Dialogue: 0,2:10:39.59,2:10:42.67,中文,,0,0,0,,我们需要用什么变量来存储 trie？
Dialogue: 0,2:10:42.67,2:10:53.05,英文,,0,0,0,,Just like before, we just need a single pointer that hangs on to the root of this structure that's null if it's empty or non-null if it's actually pointing at something.
Dialogue: 0,2:10:42.67,2:10:53.05,中文,,0,0,0,,和之前一样，我们只需要一个指针来指向这个结构的根，如果它是空的，则指针为空，如果它实际指向某个东西，则指针不为空。
Dialogue: 0,2:10:53.05,2:10:56.39,英文,,0,0,0,,Any questions, then, on tries?
Dialogue: 0,2:10:53.05,2:10:56.39,中文,,0,0,0,,关于 Trie 树，大家还有什么问题吗？
Dialogue: 0,2:10:56.39,2:10:59.44,英文,,0,0,0,,And if it's feeling like a lot, the fire hydrant, it is.
Dialogue: 0,2:10:56.39,2:10:59.44,中文,,0,0,0,,如果觉得信息量很大，就像消防栓一样，那确实如此。
Dialogue: 0,2:10:59.44,2:11:03.48,英文,,0,0,0,,We started with arrays, then linked list, then tries.
Dialogue: 0,2:10:59.44,2:11:03.48,中文,,0,0,0,,我们从数组开始，然后是链表，现在是 Trie 树。
Dialogue: 0,2:11:03.48,2:11:06.49,英文,,0,0,0,,But questions on how we've just assembled from these basic building blocks.
Dialogue: 0,2:11:03.48,2:11:06.49,中文,,0,0,0,,关于如何用这些基本构建块构建数据结构，大家有什么问题吗？
Dialogue: 0,2:11:06.49,2:11:11.56,英文,,0,0,0,,Yeah?
Dialogue: 0,2:11:06.49,2:11:11.56,中文,,0,0,0,,有吗？
Dialogue: 0,2:11:11.56,2:11:14.97,英文,,0,0,0,,A good question, why is this not size 26?
Dialogue: 0,2:11:11.56,2:11:14.97,中文,,0,0,0,,问得好，为什么这里的大小不是 26？
Dialogue: 0,2:11:14.97,2:11:19.05,英文,,0,0,0,,It's just like with the linked list before.
Dialogue: 0,2:11:14.97,2:11:19.05,中文,,0,0,0,,这就像之前的链表一样。
Dialogue: 0,2:11:19.05,2:11:27.64,英文,,0,0,0,,It just tends to be in code convenient to have a separate additional pointer that's small that just points to the beginning of the data structure, because that way it can be null.
Dialogue: 0,2:11:19.05,2:11:27.64,中文,,0,0,0,,在代码中，通常会用一个单独的额外指针指向数据结构的开头，这样做很方便，因为它可以为空。
Dialogue: 0,2:11:27.64,2:11:30.00,英文,,0,0,0,,Thereby clearly indicating there are no nodes.
Dialogue: 0,2:11:27.64,2:11:30.00,中文,,0,0,0,,从而清楚地表明没有节点。
Dialogue: 0,2:11:30.00,2:11:31.54,英文,,0,0,0,,The whole structure is empty.
Dialogue: 0,2:11:30.00,2:11:31.54,中文,,0,0,0,,整个结构都是空的。
Dialogue: 0,2:11:31.54,2:11:35.28,英文,,0,0,0,,If you allocated one of those nodes, you absolutely could.
Dialogue: 0,2:11:31.54,2:11:35.28,中文,,0,0,0,,如果你分配了其中一个节点，你绝对可以这样做。
Dialogue: 0,2:11:35.28,2:11:38.94,英文,,0,0,0,,But then you'd be just wasting space, even if it's empty, and it creates an ambiguity.
Dialogue: 0,2:11:35.28,2:11:38.94,中文,,0,0,0,,但即使它是空的，你也会浪费空间，而且会造成歧义。
Dialogue: 0,2:11:38.94,2:11:44.37,英文,,0,0,0,,So just having a single pointer linked to the beginnings of all of these things is a good thing.
Dialogue: 0,2:11:38.94,2:11:44.37,中文,,0,0,0,,只需要一个指针指向所有这些东西的开头就可以了。
Dialogue: 0,2:11:44.37,2:11:53.00,英文,,0,0,0,,Other questions now on tries, or trees, or hash tables, or arrays?
Dialogue: 0,2:11:44.37,2:11:53.00,中文,,0,0,0,,关于 Trie 树、树、哈希表或数组，还有其他问题吗？
Dialogue: 0,2:11:53.00,2:11:55.44,英文,,0,0,0,,So what problems might arise?
Dialogue: 0,2:11:53.00,2:11:55.44,中文,,0,0,0,,那么会出现什么问题呢？
Dialogue: 0,2:11:55.44,2:11:57.66,英文,,0,0,0,,Well, here's a counterexample.
Dialogue: 0,2:11:55.44,2:11:57.66,中文,,0,0,0,,这里有一个反例。
Dialogue: 0,2:11:57.66,2:12:03.36,英文,,0,0,0,,What names are manifest in this try here?
Dialogue: 0,2:11:57.66,2:12:03.36,中文,,0,0,0,,这个 Trie 树中有哪些名字？
Dialogue: 0,2:12:03.36,2:12:08.36,英文,,0,0,0,,Feel free to just call it out.
Dialogue: 0,2:12:03.36,2:12:08.36,中文,,0,0,0,,请随意说出来。
Dialogue: 0,2:12:08.36,2:12:10.40,英文,,0,0,0,,What do you see?
Dialogue: 0,2:12:08.36,2:12:10.40,中文,,0,0,0,,你看到了什么？
Dialogue: 0,2:12:10.40,2:12:12.64,英文,,0,0,0,,Danielle and?
Dialogue: 0,2:12:10.40,2:12:12.64,中文,,0,0,0,,Danielle 和？
Dialogue: 0,2:12:12.64,2:12:13.26,英文,,0,0,0,,Danielle.
Dialogue: 0,2:12:12.64,2:12:13.26,中文,,0,0,0,,Danielle。
Dialogue: 0,2:12:13.26,2:12:19.67,英文,,0,0,0,,So presumably, if these are two names here, one of which is a prefix of another, notice that the data structure still works.
Dialogue: 0,2:12:13.26,2:12:19.67,中文,,0,0,0,,假设这里有两个名字，其中一个是另一个的前缀，注意数据结构仍然有效。
Dialogue: 0,2:12:19.67,2:12:27.95,英文,,0,0,0,,And I chose a friend's name and then appended a couple of more characters to it that's also a name, because we have here D-A-N-I-E-L and the green.
Dialogue: 0,2:12:19.67,2:12:27.95,中文,,0,0,0,,我选择了一个朋友的名字，然后在它后面追加了几个字符，这也是一个名字，因为这里有 D-A-N-I-E-L 和绿色的部分。
Dialogue: 0,2:12:27.95,2:12:32.05,英文,,0,0,0,,Technically, it's implemented as a bool or something like that that indicates a word stops here.
Dialogue: 0,2:12:27.95,2:12:32.05,中文,,0,0,0,,从技术上讲，它实现为一个布尔值或类似的东西，用来指示一个单词在这里停止。
Dialogue: 0,2:12:32.05,2:12:37.64,英文,,0,0,0,,But we don't want to preclude storing Daniel as well, who's a superstring, if you will, of Daniel.
Dialogue: 0,2:12:32.05,2:12:37.64,中文,,0,0,0,,但我们也不想排除存储 Daniel，你可以把它理解为 Daniel 的超字符串。
Dialogue: 0,2:12:37.64,2:12:41.76,英文,,0,0,0,,And so that's OK, too, so long as the structure allows for the pointers to keep going.
Dialogue: 0,2:12:37.64,2:12:41.76,中文,,0,0,0,,只要结构允许指针继续前进，这也是可以的。
Dialogue: 0,2:12:41.76,2:12:46.08,英文,,0,0,0,,So even that works out OK, whereas it might not have otherwise.
Dialogue: 0,2:12:41.76,2:12:46.08,中文,,0,0,0,,所以即使这样也可以，而在其他情况下可能不行。
Dialogue: 0,2:12:46.08,2:13:06.18,英文,,0,0,0,,And in terms of the running time, just to be clear, at the end of the day, tries do give you actual constant Time for insertions, lookups, deletions, and the like, because it's dependent only on the length of the input, the key, if you will, and not on how many other people are in your phone or address book.
Dialogue: 0,2:12:46.08,2:13:06.18,中文,,0,0,0,,从运行时间来看，需要明确的是，Trie 确实可以让你在插入、查找、删除等操作\N上获得真正的常数时间，因为它只取决于输入的长度，也就是键，而不取决于你手机或地址簿中有多少人。
Dialogue: 0,2:13:06.18,2:13:08.76,英文,,0,0,0,,And now I thought we'd conclude with a visual.
Dialogue: 0,2:13:06.18,2:13:08.76,中文,,0,0,0,,现在我想用一个直观的例子来结束。
Dialogue: 0,2:13:08.76,2:13:12.88,英文,,0,0,0,,If you've gotten out into the square, anyone recognize this?
Dialogue: 0,2:13:08.76,2:13:12.88,中文,,0,0,0,,如果你们去过广场，有人认出这是什么吗？
Dialogue: 0,2:13:12.88,2:13:16.36,英文,,0,0,0,,OK, Sweetgreen, a local salad place, what are we looking at here?
Dialogue: 0,2:13:12.88,2:13:16.36,中文,,0,0,0,,Sweetgreen，一家当地的沙拉店，我们在看什么？
Dialogue: 0,2:13:16.36,2:13:18.66,英文,,0,0,0,,And what's its connection to today?
Dialogue: 0,2:13:16.36,2:13:18.66,中文,,0,0,0,,它和今天的内容有什么联系？
Dialogue: 0,2:13:18.66,2:13:24.51,英文,,0,0,0,,You're about to become all the geekier in the real world, because you will start to see data structures everywhere.
Dialogue: 0,2:13:18.66,2:13:24.51,中文,,0,0,0,,你们将会在现实世界中变得更加 geek，因为你们将开始到处看到数据结构。
Dialogue: 0,2:13:24.51,2:13:25.85,英文,,0,0,0,,What is this?
Dialogue: 0,2:13:24.51,2:13:25.85,中文,,0,0,0,,这是什么？
Dialogue: 0,2:13:25.85,2:13:29.47,英文,,0,0,0,,Or how does this work, maybe, in salad form?
Dialogue: 0,2:13:25.85,2:13:29.47,中文,,0,0,0,,或者说，它是如何以沙拉的形式工作的？
Dialogue: 0,2:13:29.47,2:13:31.63,英文,,0,0,0,,Who's been to Sweetgreen?
Dialogue: 0,2:13:29.47,2:13:31.63,中文,,0,0,0,,谁去过 Sweetgreen？
Dialogue: 0,2:13:31.63,2:13:32.89,英文,,0,0,0,,OK, either of you.
Dialogue: 0,2:13:31.63,2:13:32.89,中文,,0,0,0,,你们两个谁去过？
Dialogue: 0,2:13:32.89,2:13:33.99,英文,,0,0,0,,So how does this work?
Dialogue: 0,2:13:32.89,2:13:33.99,中文,,0,0,0,,这是怎么运作的？
Dialogue: 0,2:13:43.15,2:13:48.90,英文,,0,0,0,,OK, good, so if you order a salad for someone named L, when it's ready, they put it in the L section here.
Dialogue: 0,2:13:43.15,2:13:48.90,中文,,0,0,0,,所以如果你为一个叫 L 的人点了一份沙拉，当沙拉准备好后，他们会把它放在 L 区。
Dialogue: 0,2:13:48.90,2:13:51.68,英文,,0,0,0,,And so this is kind of a set of key value pairs, right?
Dialogue: 0,2:13:48.90,2:13:51.68,中文,,0,0,0,,所以这就像一组键值对，对吧？
Dialogue: 0,2:13:51.68,2:13:55.73,英文,,0,0,0,,If L is the first letter of someone's name, the value hopefully is the salad.
Dialogue: 0,2:13:51.68,2:13:55.73,中文,,0,0,0,,如果 L 是某人名字的首字母，那么对应的值就是沙拉。
Dialogue: 0,2:13:55.73,2:13:58.09,英文,,0,0,0,,And so what you kind of have here is a dictionary, key
Dialogue: 0,2:13:55.73,2:13:58.09,中文,,0,0,0,,所以你在这里看到的是一个字典，键
Dialogue: 0,2:13:58.09,2:14:00.65,英文,,0,0,0,,We value pairs, where it's not words and definitions.
Dialogue: 0,2:13:58.09,2:14:00.65,中文,,0,0,0,,值对，它不是单词和定义。
Dialogue: 0,2:14:00.65,2:14:02.44,英文,,0,0,0,,It's names and salads.
Dialogue: 0,2:14:00.65,2:14:02.44,中文,,0,0,0,,而是名字和沙拉。
Dialogue: 0,2:14:02.44,2:14:04.54,英文,,0,0,0,,And you can think of this, too, as kind of a hash table.
Dialogue: 0,2:14:02.44,2:14:04.54,中文,,0,0,0,,你也可以把它看作是一种哈希表。
Dialogue: 0,2:14:04.54,2:14:05.10,英文,,0,0,0,,Why?
Dialogue: 0,2:14:04.54,2:14:05.10,中文,,0,0,0,,为什么？
Dialogue: 0,2:14:05.10,2:14:10.56,英文,,0,0,0,,Even though it actually doesn't fit on one long shelf, because the store is only so big, this is really an array.
Dialogue: 0,2:14:05.10,2:14:10.56,中文,,0,0,0,,尽管它实际上并不适合放在一个长架子上，因为商店只有这么大，但这实际上是一个数组。
Dialogue: 0,2:14:10.56,2:14:12.40,英文,,0,0,0,,And apparently, A is missing.
Dialogue: 0,2:14:10.56,2:14:12.40,中文,,0,0,0,,显然，A 不见了。
Dialogue: 0,2:14:12.40,2:14:13.72,英文,,0,0,0,,Or maybe it's around the corner.
Dialogue: 0,2:14:12.40,2:14:13.72,中文,,0,0,0,,或者可能在角落里。
Dialogue: 0,2:14:13.72,2:14:16.33,英文,,0,0,0,,But this array just happens to wrap onto multiple lines.
Dialogue: 0,2:14:13.72,2:14:16.33,中文,,0,0,0,,但是这个数组恰好换行到多行了。
Dialogue: 0,2:14:16.33,2:14:18.89,英文,,0,0,0,,But it's still conceptually a single dimension.
Dialogue: 0,2:14:16.33,2:14:18.89,中文,,0,0,0,,但它在概念上仍然是单一维度的。
Dialogue: 0,2:14:18.89,2:14:26.45,英文,,0,0,0,,But suppose two people have the name L. What do they do typically?
Dialogue: 0,2:14:18.89,2:14:26.45,中文,,0,0,0,,但是假设两个人都叫 L，他们通常怎么做？
Dialogue: 0,2:14:26.45,2:14:31.89,英文,,0,0,0,,Yeah, so maybe they, well, if they, one, put that much effort into it, they might look at the second letter and then the third letter.
Dialogue: 0,2:14:26.45,2:14:31.89,中文,,0,0,0,,是的，也许他们，如果他们真的花那么多心思去做的话，他们可能会看第二个字母，然后是第三个字母。
Dialogue: 0,2:14:31.89,2:14:35.39,英文,,0,0,0,,Odds are this is not that interesting a problem to solve optimally in that way.
Dialogue: 0,2:14:31.89,2:14:35.39,中文,,0,0,0,,但这种问题不太可能以这种方式得到最佳解决。
Dialogue: 0,2:14:35.39,2:14:41.05,英文,,0,0,0,,But they probably do start stacking the salads on top of each other, maybe scooching it over just a little bit.
Dialogue: 0,2:14:35.39,2:14:41.05,中文,,0,0,0,,但他们可能会开始把沙拉堆放在一起，也许稍微挪动一下。
Dialogue: 0,2:14:41.05,2:14:42.31,英文,,0,0,0,,And so what do you have there?
Dialogue: 0,2:14:41.05,2:14:42.31,中文,,0,0,0,,那你得到了什么？
Dialogue: 0,2:14:42.31,2:14:46.82,英文,,0,0,0,,Well, now, if you start to view the lens through, like, CS50 glasses, like, OK, you have an array.
Dialogue: 0,2:14:42.31,2:14:46.82,中文,,0,0,0,,现在，如果你从 CS50 的角度来看待这个问题，就像，你有一个数组。
Dialogue: 0,2:14:46.82,2:14:50.38,英文,,0,0,0,,And then you have, like, these linked lists that are sort of growing here. But even then, you run into a problem.
Dialogue: 0,2:14:46.82,2:14:50.38,中文,,0,0,0,,然后你就有了一些链表，它们在这里不断增长。但即使这样，你也会遇到问题。
Dialogue: 0,2:14:50.38,2:14:50.82,英文,,0,0,0,,Why?
Dialogue: 0,2:14:50.38,2:14:50.82,中文,,0,0,0,,为什么？
Dialogue: 0,2:14:50.82,2:14:52.08,英文,,0,0,0,,Because it's not really a linked list.
Dialogue: 0,2:14:50.82,2:14:52.08,中文,,0,0,0,,因为它不是真正的链表。
Dialogue: 0,2:14:52.08,2:14:54.70,英文,,0,0,0,,Because at some point, you're going to hit the boundary here.
Dialogue: 0,2:14:52.08,2:14:54.70,中文,,0,0,0,,因为在某个时候，你会碰到这里的边界。
Dialogue: 0,2:14:54.70,2:14:59.30,英文,,0,0,0,,So it's kind of like an array of arrays, because you can only fit, what, like three or four salads here?
Dialogue: 0,2:14:54.70,2:14:59.30,中文,,0,0,0,,这有点像数组的数组，因为你只能在这里放三四个沙拉吧？
Dialogue: 0,2:14:59.30,2:15:04.60,英文,,0,0,0,,And so long story short, we started today deliberately talking about real-world things, like stacks and queues.
Dialogue: 0,2:14:59.30,2:15:04.60,中文,,0,0,0,,长话短说，我们今天特意从现实世界的东西开始讲，比如栈和队列。
Dialogue: 0,2:15:04.60,2:15:11.48,英文,,0,0,0,,And even though it did escalate quickly into binary search trees and hash tables and tries, even those things are everywhere.
Dialogue: 0,2:15:04.60,2:15:11.48,中文,,0,0,0,,尽管很快就升级到了二叉搜索树、哈希表和 Trie 树，但这些东西仍然无处不在。
Dialogue: 0,2:15:11.48,2:15:14.58,英文,,0,0,0,,Even though they don't call them as such, these are just solutions to problems.
Dialogue: 0,2:15:11.48,2:15:14.58,中文,,0,0,0,,即使人们不这么称呼它们，它们也只是问题的解决方案。
Dialogue: 0,2:15:14.58,2:15:21.82,英文,,0,0,0,,And now, with this final week of C under your belt, you have all the more of a technical toolkit by which to implement these things in code.
Dialogue: 0,2:15:14.58,2:15:21.82,中文,,0,0,0,,现在，随着最后一周 C 语言学习的结束，你们有了更多的技术工具包，可以用代码实现这些东西。
Dialogue: 0,2:15:21.82,2:15:25.29,英文,,0,0,0,,Next week, we'll be able to trust that someone else solved all these problems.
Dialogue: 0,2:15:21.82,2:15:25.29,中文,,0,0,0,,下周，我们将可以相信其他人已经解决了所有这些问题。
Dialogue: 0,2:15:25.29,2:15:26.61,英文,,0,0,0,,We'll introduce Python.
Dialogue: 0,2:15:25.29,2:15:26.61,中文,,0,0,0,,我们将介绍 Python。
Dialogue: 0,2:15:26.61,2:15:30.23,英文,,0,0,0,,And lines of code like this will finally become lines of code like that.
Dialogue: 0,2:15:26.61,2:15:30.23,中文,,0,0,0,,像这样的代码行最终将变成那样的代码行。
Dialogue: 0,2:15:30.23,2:15:31.25,英文,,0,0,0,,So that's the promise ahead.
Dialogue: 0,2:15:30.23,2:15:31.25,中文,,0,0,0,,这就是未来的承诺。
Dialogue: 0,2:15:31.25,2:15:32.41,英文,,0,0,0,,And we'll see you next time.
Dialogue: 0,2:15:31.25,2:15:32.41,中文,,0,0,0,,我们下次再见。
