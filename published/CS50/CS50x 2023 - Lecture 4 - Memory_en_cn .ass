[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1920
PlayResY: 1080

[Aegisub Project Garbage]
Audio File: D:/python_code/video_tool/result/CS50x 2023 - Lecture 4 - Memory.mp4
Video File: D:/python_code/video_tool/result/CS50x 2023 - Lecture 4 - Memory.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.500000
Scroll Position: 4145
Active Line: 4153
Video Position: 207330

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.99999,1.99999,2,11,11,11,1
Style: 英文,Arial,29,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1.33333,1.33333,2,11,11,11,1
Style: 中文,微软雅黑,38,&H0029EEF1,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1.99999,1.99999,2,11,11,45,1
Style: 中文大字幕,Arial,38,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.99999,1.99999,2,11,11,11,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,
Dialogue: 0,0:01:13.00,0:01:17.31,英文,,0,0,0,,All right, this is CS50, and this is week four.
Dialogue: 0,0:01:13.00,0:01:17.31,中文,,0,0,0,,大家好，欢迎来到 cs50，这是第四周的课程。
Dialogue: 0,0:01:17.31,0:01:21.56,英文,,0,0,0,,And if you think back a few weeks ago already, in week zero, we started talking about what images are.
Dialogue: 0,0:01:17.31,0:01:21.56,中文,,0,0,0,,回想几周前的第零周，我们开始讨论图像是什么。
Dialogue: 0,0:01:21.56,0:01:29.02,英文,,0,0,0,,And we talked about representation of images as this grid of pixels, and each pixel has some pattern of bits that defines its color.
Dialogue: 0,0:01:21.56,0:01:29.02,中文,,0,0,0,,我们谈到将图像表示为像素网格，每个像素都有一组定义其颜色的比特位。
Dialogue: 0,0:01:29.02,0:01:42.13,英文,,0,0,0,,Well, it turns out today, we'll take a deeper look underneath the hood at how things like images and so much more is actually implemented using just these zeros and ones, and how now, as a programmer, you can actually harness that, for better or for worse,
Dialogue: 0,0:01:29.02,0:01:42.13,中文,,0,0,0,,今天，我们将深入了解图像以及更多事物是如何使用 0 和 1 实现的，\N以及作为一名程序员，如何利用这一点更好地理解和操作计算机内存中发生的事情，使用像 C 这样的语言。
Dialogue: 0,0:01:42.13,0:01:51.78,英文,,0,0,0,,to better understand and better manipulate what's going on inside of a computer's memory using a language like C. In fact, even this bowl of stress balls that we keep happening is just a photograph, of course.
Dialogue: 0,0:01:42.13,0:01:51.78,中文,,0,0,0,,事实上，即使是我们一直在传递的这个减压球，当然，也只是一张照片。
Dialogue: 0,0:01:51.78,0:02:00.31,英文,,0,0,0,,But if you think back to week 0, if you sort of enhance, enhance, enhance this image like they do in the movies, it actually doesn't work out the way you would think from Hollywood.
Dialogue: 0,0:01:51.78,0:02:00.31,中文,,0,0,0,,但如果你回想一下第 0 周，如果你像电影里那样不断增强、增强、增强这张图片，它实际上并不像你从好莱坞电影中看到的那样。
Dialogue: 0,0:02:00.31,0:02:06.45,英文,,0,0,0,,As I continue to zoom in and zoom in, And zoom in on a screen like this, you'll see that, yes, it gets bigger.
Dialogue: 0,0:02:00.31,0:02:06.45,中文,,0,0,0,,当我继续放大、放大， 并在像这样的屏幕上放大，你会看到，是的，它变大了。
Dialogue: 0,0:02:06.45,0:02:09.23,英文,,0,0,0,,But if it gets too big, what do you start to notice?
Dialogue: 0,0:02:06.45,0:02:09.23,中文,,0,0,0,,但如果它变得太大，你会开始注意到什么？
Dialogue: 0,0:02:09.23,0:02:10.51,英文,,0,0,0,,The so-called pixelation.
Dialogue: 0,0:02:09.23,0:02:10.51,中文,,0,0,0,,所谓的像素化。
Dialogue: 0,0:02:10.51,0:02:12.55,英文,,0,0,0,,And indeed, you can see the individual dots.
Dialogue: 0,0:02:10.51,0:02:12.55,中文,,0,0,0,,事实上，你可以看到一个个的像素点。
Dialogue: 0,0:02:12.55,0:02:19.25,英文,,0,0,0,,So next time you watch some show or movie on TV that has this sort of notion of enhancing
Dialogue: 0,0:02:12.55,0:02:19.25,中文,,0,0,0,,所以下次当你观看一些有这种增强概念的电视剧或电影时
Dialogue: 0,0:02:19.25,0:02:20.67,英文,,0,0,0,,There's actually a finite limit there.
Dialogue: 0,0:02:19.25,0:02:20.67,中文,,0,0,0,,实际上是有一个有限的限制的。
Dialogue: 0,0:02:20.67,0:02:23.80,英文,,0,0,0,,You can only enhance so far as there's actually information there.
Dialogue: 0,0:02:20.67,0:02:23.80,中文,,0,0,0,,你只能增强到实际信息存在的程度。
Dialogue: 0,0:02:23.80,0:02:27.52,英文,,0,0,0,,But once you zoom into a certain level like this, that's all that's there.
Dialogue: 0,0:02:23.80,0:02:27.52,中文,,0,0,0,,但一旦你放大到像这样的程度，那就是所有存在的信息。
Dialogue: 0,0:02:27.52,0:02:33.12,英文,,0,0,0,,You're not going to see the glint of the suspect in some crime drama in their eye just because you've enhanced the image.
Dialogue: 0,0:02:27.52,0:02:33.12,中文,,0,0,0,,你不会仅仅因为增强了图像就看到犯罪剧中嫌疑人眼中的光芒。
Dialogue: 0,0:02:33.12,0:02:36.28,英文,,0,0,0,,There's only a finite amount of information actually there.
Dialogue: 0,0:02:33.12,0:02:36.28,中文,,0,0,0,,实际上只有有限的信息量。
Dialogue: 0,0:02:36.28,0:02:44.10,英文,,0,0,0,,But we'll see today, too, that by understanding what's going on inside of a computer's memory, we can start to represent and even create and code more interesting things.
Dialogue: 0,0:02:36.28,0:02:44.10,中文,,0,0,0,,但我们今天也会看到，通过理解计算机内存中发生的事情，我们可以开始表示、甚至创建和编码更有趣的东西。
Dialogue: 0,0:02:44.10,0:02:49.12,英文,,0,0,0,,So for instance, here is a bitmap, if you will, which is a term of art.
Dialogue: 0,0:02:44.10,0:02:49.12,中文,,0,0,0,,例如，这里是一个位图，如果你愿意这样称呼它，这是一个专业术语。
Dialogue: 0,0:02:49.12,0:02:51.14,英文,,0,0,0,,A bitmap is a type of image.
Dialogue: 0,0:02:49.12,0:02:51.14,中文,,0,0,0,,位图是一种图像类型。
Dialogue: 0,0:02:51.14,0:02:57.65,英文,,0,0,0,,And it's a map of bits in the sense that you have this coordinate system of top-down, left-right, at least in this artist representation here.
Dialogue: 0,0:02:51.14,0:02:57.65,中文,,0,0,0,,它其实是一个位图，因为你拥有这个自上而下、从左到右的坐标系，至少在这位艺术家的作品中是这样的。
Dialogue: 0,0:02:57.65,0:03:07.05,英文,,0,0,0,,And suppose that maybe we all decide as the world that 1 shall represent the color white and 0 shall represent the color black.
Dialogue: 0,0:02:57.65,0:03:07.05,中文,,0,0,0,,假设我们都决定用 1 来表示白色，用 0 来表示黑色。
Dialogue: 0,0:03:07.05,0:03:12.24,英文,,0,0,0,,What might this map of bits, this bitmap, actually be?
Dialogue: 0,0:03:07.05,0:03:12.24,中文,,0,0,0,,那么这张位图，它实际上会是什么呢？
Dialogue: 0,0:03:12.24,0:03:13.34,英文,,0,0,0,,Can you see through it?
Dialogue: 0,0:03:12.24,0:03:13.34,中文,,0,0,0,,你能看出来吗？
Dialogue: 0,0:03:13.34,0:03:14.92,英文,,0,0,0,,Yeah.
Dialogue: 0,0:03:13.34,0:03:14.92,中文,,0,0,0,,可以。
Dialogue: 0,0:03:14.92,0:03:18.04,英文,,0,0,0,,It is, indeed, a smiley face, so an amazing eye.
Dialogue: 0,0:03:14.92,0:03:18.04,中文,,0,0,0,,它确实是一个笑脸，一双神奇的眼睛。
Dialogue: 0,0:03:18.04,0:03:23.60,英文,,0,0,0,,If I actually turn all of the ones to white just to visualize this, you'll see, indeed, this is what was embedded there.
Dialogue: 0,0:03:18.04,0:03:23.60,中文,,0,0,0,,如果我把所有的 1 都变成白色，你就会看到，这确实就是嵌入其中的图案。
Dialogue: 0,0:03:23.60,0:03:28.59,英文,,0,0,0,,But of course, on our computer monitors and phones, we have this grid of squares, this grid of pixels.
Dialogue: 0,0:03:23.60,0:03:28.59,中文,,0,0,0,,当然，在我们的电脑显示器和手机上，我们看到的其实是像素网格。
Dialogue: 0,0:03:28.59,0:03:43.22,英文,,0,0,0,,So indeed, if you were to actually see on your screen a smiley face, like a black and white one at that, what's probably going on underneath the hood is just some pattern of 0's and 1's and maybe single bits, one-bit color, if you will, where 1 here Represents white, and 0 represents black.
Dialogue: 0,0:03:28.59,0:03:43.22,中文,,0,0,0,,所以实际上，如果你在屏幕上看到一张笑脸，比如一张黑白的笑脸，\N那么在底层很可能只是一些 0 和 1 的模式，也许是单个比特，也就是一位颜色，其中 1 代表白色，0 代表黑色。
Dialogue: 0,0:03:43.22,0:03:50.10,英文,,0,0,0,,So if you kind of like this thing, it turns out you can do pretty beautiful, pretty interesting, pretty artistically inclined things.
Dialogue: 0,0:03:43.22,0:03:50.10,中文,,0,0,0,,如果你喜欢这种东西，你会发现你可以用它来做一些非常漂亮、非常有趣、非常有艺术感的事情。
Dialogue: 0,0:03:50.10,0:03:56.96,英文,,0,0,0,,If you go to this URL at your leisure, cs50.ly slash art, it'll actually redirect you to a Google spreadsheet that we've made in advance.
Dialogue: 0,0:03:50.10,0:03:56.96,中文,,0,0,0,,如果你有空的话，可以访问这个 URL，cs50.ly 斜杠 art，它会将你重定向到我们预先制作好的 Google 电子表格。
Dialogue: 0,0:03:56.96,0:04:01.27,英文,,0,0,0,,And we've kind of shrunk the rows and columns to resemble a grid of pixels, tiny pixels.
Dialogue: 0,0:03:56.96,0:04:01.27,中文,,0,0,0,,我们已经将行和列缩小，使其类似于像素网格，非常小的像素。
Dialogue: 0,0:04:01.27,0:04:08.45,英文,,0,0,0,,Any little squares, all of which are white by default, not unlike this easel here that we have a couple of volunteers working away at.
Dialogue: 0,0:04:01.27,0:04:08.45,中文,,0,0,0,,所有的小方块默认都是白色的，就像我们这里有几位志愿者正在使用的画架一样。
Dialogue: 0,0:04:08.45,0:04:13.15,英文,,0,0,0,,In fact, would you guys like to come forward for a moment and say a quick hello before we come back to you?
Dialogue: 0,0:04:08.45,0:04:13.15,中文,,0,0,0,,事实上，你们想不想上来打个招呼？
Dialogue: 0,0:04:13.15,0:04:13.73,英文,,0,0,0,,Hello.
Dialogue: 0,0:04:13.15,0:04:13.73,中文,,0,0,0,,大家好。
Dialogue: 0,0:04:13.73,0:04:14.55,英文,,0,0,0,,My name is Daniel.
Dialogue: 0,0:04:13.73,0:04:14.55,中文,,0,0,0,,我叫 Daniel。
Dialogue: 0,0:04:14.55,0:04:16.13,英文,,0,0,0,,I'm from Chicago.
Dialogue: 0,0:04:14.55,0:04:16.13,中文,,0,0,0,,我来自芝加哥。
Dialogue: 0,0:04:16.13,0:04:17.31,英文,,0,0,0,,Welcome to Daniel. And?
Dialogue: 0,0:04:16.13,0:04:17.31,中文,,0,0,0,,欢迎 Daniel。还有？
Dialogue: 0,0:04:17.31,0:04:18.19,英文,,0,0,0,,Hi, everyone.
Dialogue: 0,0:04:17.31,0:04:18.19,中文,,0,0,0,,大家好。
Dialogue: 0,0:04:18.19,0:04:20.98,英文,,0,0,0,,I'm Adam, and I'm from Trinidad and Tobago.
Dialogue: 0,0:04:18.19,0:04:20.98,中文,,0,0,0,,我是 Adam，我来自特立尼达和多巴哥。
Dialogue: 0,0:04:20.98,0:04:22.24,英文,,0,0,0,,Nice, well, welcome to you both.
Dialogue: 0,0:04:20.98,0:04:22.24,中文,,0,0,0,,欢迎两位。
Dialogue: 0,0:04:22.24,0:04:23.20,英文,,0,0,0,,Thank you.
Dialogue: 0,0:04:22.24,0:04:23.20,中文,,0,0,0,,谢谢。
Dialogue: 0,0:04:23.20,0:04:28.25,英文,,0,0,0,,You'll see that in their hands are actually a whole bunch of pixels, Post-it notes that we've handed them in advance.
Dialogue: 0,0:04:23.20,0:04:28.25,中文,,0,0,0,,大家可以看到他们手中有很多便利贴像素，我们提前发给他们的。
Dialogue: 0,0:04:28.25,0:04:35.87,英文,,0,0,0,,So if you don't mind, we'll come back to you in a couple of minutes and see what they've created, if you will, on this grid of white paper, much like you could create on this Google spreadsheet.
Dialogue: 0,0:04:28.25,0:04:35.87,中文,,0,0,0,,我们过几分钟再来看看他们用这些便利贴在白纸上创作了什么，就像你在 Google 表格上创作一样。
Dialogue: 0,0:04:35.87,0:04:42.57,英文,,0,0,0,,In fact, feel free to send us your creations, if so inclined, via the URL you'll get at cs50.ly slash art.
Dialogue: 0,0:04:35.87,0:04:42.57,中文,,0,0,0,,如果你愿意，可以通过 cs50.ly/art 把你的作品发给我们。
Dialogue: 0,0:04:42.57,0:04:46.46,英文,,0,0,0,,Now, let's come back to week 0, where we defined some of the building blocks for images.
Dialogue: 0,0:04:42.57,0:04:46.46,中文,,0,0,0,,让我们回到第 0 周，我们定义了一些图像的基本元素。
Dialogue: 0,0:04:46.46,0:04:49.30,英文,,0,0,0,,We talked about RGB, which is just red, green, blue.
Dialogue: 0,0:04:46.46,0:04:49.30,中文,,0,0,0,,我们讲了 RGB，也就是红、绿、蓝。
Dialogue: 0,0:04:49.30,0:04:57.88,英文,,0,0,0,,And it's just one of the systems, a popular system via which you can represent any color of the rainbow using some combination of red and green and blue.
Dialogue: 0,0:04:49.30,0:04:57.88,中文,,0,0,0,,这只是一个系统，一个流行的系统，通过它你可以用红色、绿色和蓝色的组合来表示彩虹的任何颜色。
Dialogue: 0,0:04:57.88,0:05:07.52,英文,,0,0,0,,And if any of you are artistically inclined or have used Photoshop or similar programs, you might typically have some means of selecting a color via some grid like this.
Dialogue: 0,0:04:57.88,0:05:07.52,中文,,0,0,0,,如果你们中有人有艺术倾向，或者使用过 Photoshop 或类似的程序，你可能通常会通过像这样的网格来选择颜色。
Dialogue: 0,0:05:07.52,0:05:13.19,英文,,0,0,0,,But down here, notice, there's explicit mentions of the types of color systems in use.
Dialogue: 0,0:05:07.52,0:05:13.19,中文,,0,0,0,,但请注意，这里明确提到了正在使用的颜色系统的类型。
Dialogue: 0,0:05:13.19,0:05:15.97,英文,,0,0,0,,And in fact, here you see 000.
Dialogue: 0,0:05:13.19,0:05:15.97,中文,,0,0,0,,事实上，这里你看到了 000。
Dialogue: 0,0:05:15.97,0:05:18.47,英文,,0,0,0,,And up here, under New, you see the color black.
Dialogue: 0,0:05:15.97,0:05:18.47,中文,,0,0,0,,在上面的“新建”下，你看到了黑色。
Dialogue: 0,0:05:18.47,0:05:24.37,英文,,0,0,0,,And that implies that if you have no red, no green, no blue, well, that indeed would represent, by convention, the color black.
Dialogue: 0,0:05:18.47,0:05:24.37,中文,,0,0,0,,这意味着，如果没有红色、没有绿色、没有蓝色，按照惯例，这的确代表黑色。
Dialogue: 0,0:05:24.37,0:05:33.00,英文,,0,0,0,,By contrast, if we play around with Photoshop or any similar program, if you have a lot of red, a lot of green, and a lot of blue, for instance,
Dialogue: 0,0:05:24.37,0:05:33.00,中文,,0,0,0,,相比之下，如果我们使用 Photoshop 或任何类似的程序，如果你有很多红色、很多绿色和很多蓝色，
Dialogue: 0,0:05:33.00,0:05:42.55,英文,,0,0,0,,255, 255, 255, like really crank it up to the max value you can represent with 8 bits per week 0, well, then it turns out you get the color white here.
Dialogue: 0,0:05:33.00,0:05:42.55,中文,,0,0,0,,例如，255，255，255，像第 0 周那样，把它调到 8 位可以表示的最大值，那么结果是，你在这里得到了白色。
Dialogue: 0,0:05:42.55,0:05:44.83,英文,,0,0,0,,And we can play with these numbers endlessly.
Dialogue: 0,0:05:42.55,0:05:44.83,中文,,0,0,0,,我们可以无休止地玩弄这些数字。
Dialogue: 0,0:05:44.83,0:05:50.45,英文,,0,0,0,,For instance, if we use 255 of red, but 0 green and 0 blue,
Dialogue: 0,0:05:44.83,0:05:50.45,中文,,0,0,0,,例如，如果我们使用 255 的红色，但 0 绿色和 0 蓝色，
Dialogue: 0,0:05:50.45,0:05:57.08,英文,,0,0,0,,Not surprisingly, the square at the top of the screen becomes, of course, red entirely, because it's all red and no green, no blue.
Dialogue: 0,0:05:50.45,0:05:57.08,中文,,0,0,0,,毫不奇怪，屏幕顶部的方块完全变成了红色，因为它是全红色，没有绿色，没有蓝色。
Dialogue: 0,0:05:57.08,0:06:02.60,英文,,0,0,0,,If we change it instead to 255 for green but 0 for red and blue, of course, we get green.
Dialogue: 0,0:05:57.08,0:06:02.60,中文,,0,0,0,,如果我们把它改成 255 的绿色，但红色和蓝色是 0，我们当然会得到绿色。
Dialogue: 0,0:06:02.60,0:06:07.53,英文,,0,0,0,,And then lastly, if we crank up the blue but leave red and green as 0, we, of course, get blue.
Dialogue: 0,0:06:02.60,0:06:07.53,中文,,0,0,0,,最后，如果我们把蓝色调高，但红色和绿色保持为 0，我们当然会得到蓝色。
Dialogue: 0,0:06:07.53,0:06:14.23,英文,,0,0,0,,But all this while, down here highlighted, is something that maybe some of you have seen before, like some combination of numbers and letters.
Dialogue: 0,0:06:07.53,0:06:14.23,中文,,0,0,0,,但一直以来，下面高亮显示的内容，你们中的一些人可能以前见过，就像数字和字母的某种组合。
Dialogue: 0,0:06:14.23,0:06:20.18,英文,,0,0,0,,If any of you have made personal web pages or used programs like Photoshop, you might have used these so-called color codes.
Dialogue: 0,0:06:14.23,0:06:20.18,中文,,0,0,0,,如果你们中有人制作过个人网页或使用过 Photoshop 之类的程序，那么你可能使用过这些所谓的颜色代码。
Dialogue: 0,0:06:20.18,0:06:31.79,英文,,0,0,0,,So indeed, the world has this convention whereby using six digits, or sometimes three, you can represent a little more succinctly some amount of red, green, blue. And you'll see here.
Dialogue: 0,0:06:20.18,0:06:31.79,中文,,0,0,0,,所以事实上，世界已经达成了这样一种惯例，即使用六位数字，有时是三位数字，你可以更简洁地表示一定量的红色、绿色、蓝色。你会在这里看到。
Dialogue: 0,0:06:31.79,0:06:44.27,英文,,0,0,0,,Maybe by inference that if RGB is 0, 0, 255, respectively, perhaps where we're going with this is that 0000FF is just an alternative way of expressing the exact same idea.
Dialogue: 0,0:06:31.79,0:06:44.27,中文,,0,0,0,,也许通过推断，如果 RGB 分别是 0、0、255，我们接下来要讲的是，0000FF 只是表达完全相同想法的另一种方式。
Dialogue: 0,0:06:44.27,0:06:46.89,英文,,0,0,0,,No red, no green, and a lot of blue.
Dialogue: 0,0:06:44.27,0:06:46.89,中文,,0,0,0,,没有红色，没有绿色，只有很多蓝色。
Dialogue: 0,0:06:46.89,0:06:48.19,英文,,0,0,0,,But why is that?
Dialogue: 0,0:06:46.89,0:06:48.19,中文,,0,0,0,,但为什么会这样呢？
Dialogue: 0,0:06:48.19,0:06:51.09,英文,,0,0,0,,And in fact, we'll come full circle here to introducing
Dialogue: 0,0:06:48.19,0:06:51.09,中文,,0,0,0,,事实上，我们将在这里回到原点，
Dialogue: 0,0:06:51.09,0:06:54.40,英文,,0,0,0,,Something that we could have done in week 0, but it doesn't really solve a problem then.
Dialogue: 0,0:06:51.09,0:06:54.40,中文,,0,0,0,,介绍一些我们本可以在第 0 周做的事情，但在那时并不能真正解决问题。
Dialogue: 0,0:06:54.40,0:07:00.46,英文,,0,0,0,,But today, as we focus more on images and on memory itself, turns out understanding these patterns is pretty useful.
Dialogue: 0,0:06:54.40,0:07:00.46,中文,,0,0,0,,但今天，当我们更加关注图像和内存本身时，事实证明，理解这些模式非常有用。
Dialogue: 0,0:07:00.46,0:07:03.49,英文,,0,0,0,,So back in week 0, we talked, of course, about binary.
Dialogue: 0,0:07:00.46,0:07:03.49,中文,,0,0,0,,回到第 0 周，我们当然谈到了二进制。
Dialogue: 0,0:07:03.49,0:07:07.73,英文,,0,0,0,,And binary by implying 2 only gives you two digits, 0 and 1.
Dialogue: 0,0:07:03.49,0:07:07.73,中文,,0,0,0,,二进制意味着 2，它只有两个数字，0 和 1。
Dialogue: 0,0:07:07.73,0:07:12.95,英文,,0,0,0,,You and I, as humans, almost always use the decimal system in normal conversation, dec meaning 10.
Dialogue: 0,0:07:07.73,0:07:12.95,中文,,0,0,0,,你和我在日常对话中几乎总是使用十进制，dec 表示 10。
Dialogue: 0,0:07:12.95,0:07:15.56,英文,,0,0,0,,So we have 0 through 9 instead.
Dialogue: 0,0:07:12.95,0:07:15.56,中文,,0,0,0,,所以我们有 0 到 9。
Dialogue: 0,0:07:15.56,0:07:22.94,英文,,0,0,0,,If a human like us wants to count up as high as 10 or 11 or 12, we don't have a digit, per se, for 10, 11, and 12.
Dialogue: 0,0:07:15.56,0:07:22.94,中文,,0,0,0,,如果像我们这样的人想要一直数到 10、11 或 12，我们本身并没有 10、11 和 12 的数字。
Dialogue: 0,0:07:22.94,0:07:24.74,英文,,0,0,0,,We start reusing digits.
Dialogue: 0,0:07:22.94,0:07:24.74,中文,,0,0,0,,我们开始重复使用数字。
Dialogue: 0,0:07:24.74,0:07:27.67,英文,,0,0,0,,So it's 1, 0, 1, 1, 1, 2, and so forth.
Dialogue: 0,0:07:24.74,0:07:27.67,中文,,0,0,0,,所以是 1、0、1、1、1、2，以此类推。
Dialogue: 0,0:07:27.67,0:07:39.31,英文,,0,0,0,,But in other systems, not binary, not decimal, but systems called hexadecimal, hex implying 16, there are actually more digits than these, which might come as a surprise.
Dialogue: 0,0:07:27.67,0:07:39.31,中文,,0,0,0,,但在其他进制中，不是二进制，不是十进制，而是称为十六进制的进制，hex 意味着 16，实际上有比这更多的数字，这可能会让人感到惊讶。
Dialogue: 0,0:07:39.31,0:07:42.48,英文,,0,0,0,,It's not pairs of digits, like in decimal, single digits.
Dialogue: 0,0:07:39.31,0:07:42.48,中文,,0,0,0,,它不是像十进制那样的两位数字，而是单个数字。
Dialogue: 0,0:07:42.48,0:07:54.58,英文,,0,0,0,,And frankly, it doesn't really matter what the digits are, because at the end of the day, these are just symbols that you and I immediately associate with some notion of math, but just strokes on the screen that represent some actual value.
Dialogue: 0,0:07:42.48,0:07:54.58,中文,,0,0,0,,坦率地说，数字是什么并不重要，因为说到底，这些只是你我立即与某种数学概念联系起来的符号，而只是屏幕上的笔画，代表着某个实际的值。
Dialogue: 0,0:07:54.58,0:08:06.21,英文,,0,0,0,,So it turns out that by convention, when you want more than 10 digits, 0 through 9, you start using letters of the English alphabet, A, B, C, D, E, and F.
Dialogue: 0,0:07:54.58,0:08:06.21,中文,,0,0,0,,所以事实证明，按照惯例，当你需要超过 10 个数字，0 到 9 时，你开始使用英文字母表中的字母，A、B、C、D、E 和 F。
Dialogue: 0,0:08:06.21,0:08:09.67,英文,,0,0,0,,And you can represent them in lowercase. It's case insensitive, so it doesn't really matter.
Dialogue: 0,0:08:06.21,0:08:09.67,中文,,0,0,0,,你可以用小写字母表示，它不区分大小写，所以没关系。
Dialogue: 0,0:08:09.67,0:08:17.45,英文,,0,0,0,,You might see it in uppercase or lowercase. But this is how you can count beyond 9, not using decimal, but using, indeed, something called hexadecimal.
Dialogue: 0,0:08:09.67,0:08:17.45,中文,,0,0,0,,你可能会看到大写或小写的。但这就是如何在不使用十进制的情况下计数超过 9 的方法，实际上使用的是十六进制。
Dialogue: 0,0:08:17.45,0:08:20.73,英文,,0,0,0,,If we get really technical, this is also known as base 16.
Dialogue: 0,0:08:17.45,0:08:20.73,中文,,0,0,0,,如果我们非要说的很专业的话，这也被称为基数 16。
Dialogue: 0,0:08:20.73,0:08:28.64,英文,,0,0,0,,And it's the same idea as week 0, where instead of using base 2 for binary, base 10 for decimal used 16 as the base for hexadecimal.
Dialogue: 0,0:08:20.73,0:08:28.64,中文,,0,0,0,,这和第 0 周的想法一样，我们没有使用以 2 为基数的二进制，以 10 为基数的十进制，而是使用 16 作为十六进制的基数。
Dialogue: 0,0:08:28.64,0:08:40.52,英文,,0,0,0,,And so if we run through just some simple examples here, in the world of hexadecimal, your columns are just powers of 16, 16 to the 0, 16 to the 1, 16 to the 2, and so forth.
Dialogue: 0,0:08:28.64,0:08:40.52,中文,,0,0,0,,因此，如果我们在这里运行一些简单的例子，在十六进制的世界中，你的列就是 16 的幂，16 的 0 次方，16 的 1 次方，16 的 2 次方，等等。
Dialogue: 0,0:08:40.52,0:08:45.86,英文,,0,0,0,,But in the world of hex, we usually, at least thus far and today, we'll see just pairs of digits like this.
Dialogue: 0,0:08:40.52,0:08:45.86,中文,,0,0,0,,但在十六进制的世界里，我们通常，至少到目前为止，今天，只会看到这样的两位数。
Dialogue: 0,0:08:45.86,0:08:50.61,英文,,0,0,0,,So here, for instance, is the 1's column and the 16's column, if we multiply that out.
Dialogue: 0,0:08:45.86,0:08:50.61,中文,,0,0,0,,例如，这里是个位列和十六位列，如果我们把它乘出来。
Dialogue: 0,0:08:50.61,0:08:55.67,英文,,0,0,0,,So if you wanted to represent the number you and I know in the real world as 0,
Dialogue: 0,0:08:50.61,0:08:55.67,中文,,0,0,0,,如果你想用十六进制表示现实世界中你和我都知道的数字 0，
Dialogue: 0,0:08:55.67,0:08:58.61,英文,,0,0,0,,In hexadecimal, it would just be 00.
Dialogue: 0,0:08:55.67,0:08:58.61,中文,,0,0,0,,用十六进制表示就是 00。
Dialogue: 0,0:08:58.61,0:09:01.21,英文,,0,0,0,,If you want to represent the number 1, it would be 01.
Dialogue: 0,0:08:58.61,0:09:01.21,中文,,0,0,0,,如果你想表示数字 1，那就是 01。
Dialogue: 0,0:09:01.21,0:09:07.96,英文,,0,0,0,,And from there, we get 02, 03, 04, 05, 06, 07, 08, 09.
Dialogue: 0,0:09:01.21,0:09:07.96,中文,,0,0,0,,以此类推，我们得到 02、03、04、05、06、07、08、09。
Dialogue: 0,0:09:07.96,0:09:10.24,英文,,0,0,0,,Now things get potentially interesting.
Dialogue: 0,0:09:07.96,0:09:10.24,中文,,0,0,0,,现在事情开始变得有趣了。
Dialogue: 0,0:09:10.24,0:09:12.52,英文,,0,0,0,,In decimal, it would obviously become 10.
Dialogue: 0,0:09:10.24,0:09:12.52,中文,,0,0,0,,用十进制表示，它显然会变成 10。
Dialogue: 0,0:09:12.52,0:09:16.26,英文,,0,0,0,,But in hexadecimal, it just becomes 0A.
Dialogue: 0,0:09:12.52,0:09:16.26,中文,,0,0,0,,但用十六进制表示，它就变成了 0A。
Dialogue: 0,0:09:16.26,0:09:25.05,英文,,0,0,0,,And then 0b, which is to say, if I rewind, after 9 comes in hexadecimal, if I pronounce it in decimal, this is how you'd represent 10.
Dialogue: 0,0:09:16.26,0:09:25.05,中文,,0,0,0,,然后是 0b，也就是说，如果我倒带，在十六进制的 9 之后，如果我用十进制来读，这就是你表示 10 的方式。
Dialogue: 0,0:09:25.05,0:09:28.77,英文,,0,0,0,,This is how you'd represent 11, 12, 13, 14.
Dialogue: 0,0:09:25.05,0:09:28.77,中文,,0,0,0,,这就是你表示 11、12、13、14 的方式。
Dialogue: 0,0:09:28.77,0:09:36.06,英文,,0,0,0,,And then lastly, in hexadecimal, the 16th value is f, which is just always going to represent 15.
Dialogue: 0,0:09:28.77,0:09:36.06,中文,,0,0,0,,最后，在十六进制中，第 16 个值是 F，它总是表示 15。
Dialogue: 0,0:09:36.06,0:09:39.20,英文,,0,0,0,,So how do we connect this to some of the past math?
Dialogue: 0,0:09:36.06,0:09:39.20,中文,,0,0,0,,那么我们如何将它与过去的一些数学联系起来呢？
Dialogue: 0,0:09:39.20,0:09:48.84,英文,,0,0,0,,Well, once you get to 0f in hexadecimal, if f is the highest you can count, just like in decimal, 9 is the highest you can count, what comes next?
Dialogue: 0,0:09:39.20,0:09:48.84,中文,,0,0,0,,一旦你在十六进制中达到 0F，如果 F 是你能数到的最大值，就像在十进制中，9 是你能数到的最大值一样，接下来是什么？
Dialogue: 0,0:09:48.84,0:09:53.24,英文,,0,0,0,,If this is 15, I claim, how do I represent 16 in hexadecimal?
Dialogue: 0,0:09:48.84,0:09:53.24,中文,,0,0,0,,如果这是 15，我认为，我如何用十六进制表示 16？
Dialogue: 0,0:09:53.24,0:09:56.62,英文,,0,0,0,,With what pattern of symbols?
Dialogue: 0,0:09:53.24,0:09:56.62,中文,,0,0,0,,用什么符号模式？
Dialogue: 0,0:09:56.62,0:09:59.79,英文,,0,0,0,,What pattern of symbols for hexadecimal?
Dialogue: 0,0:09:56.62,0:09:59.79,中文,,0,0,0,,十六进制用什么符号模式？
Dialogue: 0,0:09:59.79,0:10:05.40,英文,,0,0,0,,So 1, 0, not 10, even though you might read it like that as a typical human, but 1, 0.
Dialogue: 0,0:09:59.79,0:10:05.40,中文,,0,0,0,,所以是 1, 0，不是 10，即使你可能像普通人一样读作 10，但它是 1, 0。
Dialogue: 0,0:10:05.40,0:10:06.36,英文,,0,0,0,,Because why?
Dialogue: 0,0:10:05.40,0:10:06.36,中文,,0,0,0,,为什么？
Dialogue: 0,0:10:06.36,0:10:11.48,英文,,0,0,0,,Well, even if this is completely new to you, the whole column system, the places, are exactly the same intuitively.
Dialogue: 0,0:10:06.36,0:10:11.48,中文,,0,0,0,,即使你对整个列系统、位值完全陌生，但直观上它们是完全一样的。
Dialogue: 0,0:10:11.48,0:10:15.35,英文,,0,0,0,,So you need a 1 in the 16s place and a 0 in the 1s place.
Dialogue: 0,0:10:11.48,0:10:15.35,中文,,0,0,0,,所以你需要在 16 位上放个 1，在 1 位上放个 0。
Dialogue: 0,0:10:15.35,0:10:17.65,英文,,0,0,0,,And we won't count all the way up to 255.
Dialogue: 0,0:10:15.35,0:10:17.65,中文,,0,0,0,,我们不会一直数到 255。
Dialogue: 0,0:10:17.65,0:10:21.45,英文,,0,0,0,,But if we count a little higher, this would be 1, 0, a.k.a.
Dialogue: 0,0:10:17.65,0:10:21.45,中文,,0,0,0,,但如果我们再往上数一点，就会是 1, 0，也就是
Dialogue: 0,0:10:21.45,0:10:22.95,英文,,0,0,0,,16 in decimal.
Dialogue: 0,0:10:21.45,0:10:22.95,中文,,0,0,0,,十进制的 16。
Dialogue: 0,0:10:22.95,0:10:26.27,英文,,0,0,0,,This would be 1, 1, a.k.a. 17 in decimal.
Dialogue: 0,0:10:22.95,0:10:26.27,中文,,0,0,0,,这将是 1, 1，也就是十进制的 17。
Dialogue: 0,0:10:26.27,0:10:30.65,英文,,0,0,0,,And then 18, 19, 20, and so forth, dot, dot, dot.
Dialogue: 0,0:10:26.27,0:10:30.65,中文,,0,0,0,,然后是 18、19、20，以此类推，点点点。
Dialogue: 0,0:10:30.65,0:10:38.78,英文,,0,0,0,,And we can count all the way up to f, f. Because if f is the biggest digit in hexadecimal, f, f is indeed as high as we can count.
Dialogue: 0,0:10:30.65,0:10:38.78,中文,,0,0,0,,我们可以一直数到 F, F。因为如果 F 是十六进制中最大的数字，那么 F, F 就是我们可以数到的最大值。
Dialogue: 0,0:10:38.78,0:10:42.78,英文,,0,0,0,,And if each f represents 15, well, let's just do the math like in week 0.
Dialogue: 0,0:10:38.78,0:10:42.78,中文,,0,0,0,,如果每个 F 代表 15，那么，让我们像第 0 周那样进行计算。
Dialogue: 0,0:10:42.78,0:10:50.39,英文,,0,0,0,,So 16 times f plus 1 times f is how all of us learn to do math in grade school, even though not in hexadecimal.
Dialogue: 0,0:10:42.78,0:10:50.39,中文,,0,0,0,,所以 16 乘以 F + 1 乘以 F 就是我们所有人小学时学的数学算法，即使不是十六进制的。
Dialogue: 0,0:10:50.39,0:10:54.51,英文,,0,0,0,,That's, of course, 16 times 15 plus 1 times 15.
Dialogue: 0,0:10:50.39,0:10:54.51,中文,,0,0,0,,这当然是 16 乘以 15 + 1 乘以 15。
Dialogue: 0,0:10:54.51,0:10:58.03,英文,,0,0,0,,Multiply that out, you get 240 plus 15.
Dialogue: 0,0:10:54.51,0:10:58.03,中文,,0,0,0,,算出来就是 240 + 15。
Dialogue: 0,0:10:58.03,0:11:03.46,英文,,0,0,0,,And ergo, you can count as high as 255 using two
Dialogue: 0,0:10:58.03,0:11:03.46,中文,,0,0,0,,因此，你可以使用两个
Dialogue: 0,0:11:03.46,0:11:05.06,英文,,0,0,0,,Hexadecimal digits.
Dialogue: 0,0:11:03.46,0:11:05.06,中文,,0,0,0,,十六进制数字数到 255。
Dialogue: 0,0:11:05.06,0:11:10.04,英文,,0,0,0,,Now, this is not the kind of thing where this is going to be an interesting exercise mentally to ever convert in your head.
Dialogue: 0,0:11:05.06,0:11:10.04,中文,,0,0,0,,当然，这不是说在脑子里进行进制转换会是一件有趣的事情。
Dialogue: 0,0:11:10.04,0:11:19.67,英文,,0,0,0,,Generally, you'll get used to the fact that after 9 comes a, and the biggest digit is f. And you'll just start to see patterns like this in the worlds of Photoshop, web pages in a few weeks, and beyond.
Dialogue: 0,0:11:10.04,0:11:19.67,中文,,0,0,0,,通常，你会习惯 9 之后是 A，最大的数字是 F。在接下来的几周内，你会在 Photoshop、网页等领域中开始看到这样的规律。
Dialogue: 0,0:11:19.67,0:11:21.93,英文,,0,0,0,,But why is hexadecimal?
Dialogue: 0,0:11:19.67,0:11:21.93,中文,,0,0,0,,但为什么是十六进制呢？
Dialogue: 0,0:11:21.93,0:11:27.69,英文,,0,0,0,,Useful, like why are we complicating the world and adding on top of decimal something else?
Dialogue: 0,0:11:21.93,0:11:27.69,中文,,0,0,0,,有什么用？为什么要让世界变得更复杂，在十进制的基础上再加一个进制呢？
Dialogue: 0,0:11:27.69,0:11:33.16,英文,,0,0,0,,Well, it turns out that a single decimal digit, like F, the biggest one, for instance, is 15.
Dialogue: 0,0:11:27.69,0:11:33.16,中文,,0,0,0,,事实证明，一个十进制数字，比如最大的数字 F，是 15。
Dialogue: 0,0:11:33.16,0:11:35.56,英文,,0,0,0,,And here, let me just propose a bit of mental math.
Dialogue: 0,0:11:33.16,0:11:35.56,中文,,0,0,0,,这里，我建议大家做一道心算题。
Dialogue: 0,0:11:35.56,0:11:41.28,英文,,0,0,0,,How many bits do you need to represent the number 15 in binary?
Dialogue: 0,0:11:35.56,0:11:41.28,中文,,0,0,0,,你需要多少位才能用二进制表示数字 15？
Dialogue: 0,0:11:41.28,0:11:48.29,英文,,0,0,0,,If you've got the ones place, twos place, fours, and so forth, how many bits total?
Dialogue: 0,0:11:41.28,0:11:48.29,中文,,0,0,0,,如果你有个位、二位、四位等等，总共需要多少位？
Dialogue: 0,0:11:48.29,0:11:51.77,英文,,0,0,0,,So fewer than 5 to count as high as 15, I think.
Dialogue: 0,0:11:48.29,0:11:51.77,中文,,0,0,0,,要表示到 15，我认为不到 5 位。
Dialogue: 0,0:11:51.77,0:11:53.74,英文,,0,0,0,,But close.
Dialogue: 0,0:11:51.77,0:11:53.74,中文,,0,0,0,,但很接近了。
Dialogue: 0,0:11:53.74,0:11:57.86,英文,,0,0,0,,Someone else? Seeing a hand? Yeah.
Dialogue: 0,0:11:53.74,0:11:57.86,中文,,0,0,0,,还有其他人？看到有人举手了？好的。
Dialogue: 0,0:11:57.86,0:12:00.34,英文,,0,0,0,,So 4 bits, I think, suffice.
Dialogue: 0,0:11:57.86,0:12:00.34,中文,,0,0,0,,所以 4 位就足够了。
Dialogue: 0,0:12:00.34,0:12:06.90,英文,,0,0,0,,Because if you want to count as high as f, that is to say 15, I think if you have 4 bits, you can do that.
Dialogue: 0,0:12:00.34,0:12:06.90,中文,,0,0,0,,因为如果你想表示到 F，也就是 15，我认为如果你有 4 位，你就能做到。
Dialogue: 0,0:12:06.90,0:12:13.85,英文,,0,0,0,,Because if over here is the 1's place from week 0 for binary, this is the 2's place, this is the 4's place, this is the 8's place.
Dialogue: 0,0:12:06.90,0:12:13.85,中文,,0,0,0,,因为如果这边是第 0 周二进制的个位，这边是二位，这边是四位，这边是八位。
Dialogue: 0,0:12:13.85,0:12:14.71,英文,,0,0,0,,Do out some quick math.
Dialogue: 0,0:12:13.85,0:12:14.71,中文,,0,0,0,,快速计算一下。
Dialogue: 0,0:12:14.71,0:12:19.31,英文,,0,0,0,,So 8 plus 4 is 12, plus 2 is 14, plus 1 is 15.
Dialogue: 0,0:12:14.71,0:12:19.31,中文,,0,0,0,,8 + 4 = 12，+ 2 + 14，+1 = 15。
Dialogue: 0,0:12:19.31,0:12:27.37,英文,,0,0,0,,So it turns out that by convenience, hexadecimal digits can just be represented consistently with 4 bits, or fewer, but 4.
Dialogue: 0,0:12:19.31,0:12:27.37,中文,,0,0,0,,为了方便起见，十六进制数字可以用 4 位或更少的位数来表示，但至少是 4 位。
Dialogue: 0,0:12:27.37,0:12:29.11,英文,,0,0,0,,And 4, of course, is half of 8.
Dialogue: 0,0:12:27.37,0:12:29.11,中文,,0,0,0,,当然，4 是 8 的一半。
Dialogue: 0,0:12:29.11,0:12:30.37,英文,,0,0,0,,And 8 is, like, everywhere.
Dialogue: 0,0:12:29.11,0:12:30.37,中文,,0,0,0,,而 8 无处不在。
Dialogue: 0,0:12:30.37,0:12:33.66,英文,,0,0,0,,Like, 8 bits is a byte, which is, again, just a convention we've seen.
Dialogue: 0,0:12:30.37,0:12:33.66,中文,,0,0,0,,比如，8 位是一个字节，这也是我们已经看到的惯例。
Dialogue: 0,0:12:33.66,0:12:45.69,英文,,0,0,0,,And so the reason that you see hexadecimal in the world of Photoshop and eventually web pages is it actually just maps really nicely to expressing binary numbers more succinctly with a fixed number of digits.
Dialogue: 0,0:12:33.66,0:12:45.69,中文,,0,0,0,,你在 Photoshop 和网页中看到十六进制的原因是，它实际上可以很好地用固定位数更简洁地表示二进制数。
Dialogue: 0,0:12:45.69,0:12:50.59,英文,,0,0,0,,So for instance, any time you see 1, 1, 1, 1,
Dialogue: 0,0:12:45.69,0:12:50.59,中文,,0,0,0,,例如，任何时候你看到二进制的 1, 1, 1, 1，
Dialogue: 0,0:12:50.59,0:12:53.22,英文,,0,0,0,,1, 1, 1, 1 in the world as binary, you know what?
Dialogue: 0,0:12:50.59,0:12:53.22,中文,,0,0,0,,1, 1, 1, 1，你知道是什么吗？
Dialogue: 0,0:12:53.22,0:12:55.72,英文,,0,0,0,,That's a little tedious to both say and write.
Dialogue: 0,0:12:53.22,0:12:55.72,中文,,0,0,0,,说和写都太乏味了。
Dialogue: 0,0:12:55.72,0:12:59.89,英文,,0,0,0,,You can represent more succinctly any.
Dialogue: 0,0:12:55.72,0:12:59.89,中文,,0,0,0,,你可以更简洁地表示任何。
Dialogue: 0,0:12:59.89,0:13:14.94,英文,,0,0,0,,group of four 1 bits, more succinctly in hexadecimal, as just F. So 1, 1, 1, 1, 1, 1, 1, 1, 1 in binary, more succinctly, and more commonly now in the world of Photoshop, memory, images, and the like, is represented more succinctly as FF.
Dialogue: 0,0:12:59.89,0:13:14.94,中文,,0,0,0,,一组四个 1 比特，用十六进制可以更简洁地表示为 F。\N所以二进制的 1, 1, 1, 1, 1, 1, 1, 1, 1，在 Photoshop、内存、图像等领域，更简洁、更常见的表示方式是 FF。
Dialogue: 0,0:13:14.94,0:13:18.26,英文,,0,0,0,,And that's why, because it just maps really nicely to four bits.
Dialogue: 0,0:13:14.94,0:13:18.26,中文,,0,0,0,,原因是它正好映射到四个比特。
Dialogue: 0,0:13:18.26,0:13:20.73,英文,,0,0,0,,And so we can be a little more succinct.
Dialogue: 0,0:13:18.26,0:13:20.73,中文,,0,0,0,,这样我们可以更简洁一些。
Dialogue: 0,0:13:20.73,0:13:27.67,英文,,0,0,0,,So any questions on hexadecimal, which is just another way of representing information, but using the same grade school approach?
Dialogue: 0,0:13:20.73,0:13:27.67,中文,,0,0,0,,关于十六进制，还有什么问题吗？它只是另一种表示信息的方式，但使用了相同的进制方法。
Dialogue: 0,0:13:27.67,0:13:28.91,英文,,0,0,0,,Yeah?
Dialogue: 0,0:13:27.67,0:13:28.91,中文,,0,0,0,,有吗？
Dialogue: 0,0:13:28.91,0:13:29.43,英文,,0,0,0,,Good question.
Dialogue: 0,0:13:28.91,0:13:29.43,中文,,0,0,0,,好问题。
Dialogue: 0,0:13:29.43,0:13:33.30,英文,,0,0,0,,If you represent 15 with F, it would use four bits.
Dialogue: 0,0:13:29.43,0:13:33.30,中文,,0,0,0,,用 F 表示 15，会使用四个比特。
Dialogue: 0,0:13:33.30,0:13:38.84,英文,,0,0,0,,So base systems are really just a way for us humans on paper or on screens to represent information.
Dialogue: 0,0:13:33.30,0:13:38.84,中文,,0,0,0,,所以进制系统实际上只是我们人类在纸上或屏幕上表示信息的一种方式。
Dialogue: 0,0:13:38.84,0:13:45.80,英文,,0,0,0,,If F represents the decimal number 15, the computer underneath the hood has to use four bits to represent it.
Dialogue: 0,0:13:38.84,0:13:45.80,中文,,0,0,0,,如果 F 表示十进制数 15，底层的计算机必须使用四个比特来表示它。
Dialogue: 0,0:13:45.80,0:13:51.34,英文,,0,0,0,,So one hexadecimal digit, by convention, always implies four bits underneath the hood.
Dialogue: 0,0:13:45.80,0:13:51.34,中文,,0,0,0,,因此，按照惯例，一个十六进制数字总是意味着底层有四个比特。
Dialogue: 0,0:13:51.34,0:13:59.31,英文,,0,0,0,,So therefore, if you have two hexadecimal digits, like 00, that means eight zero bits underneath the hood, like for red. or for green.
Dialogue: 0,0:13:51.34,0:13:59.31,中文,,0,0,0,,因此，如果有两个十六进制数字，比如 00，那就意味着底层有八个 0 比特，比如红色或者绿色。
Dialogue: 0,0:13:59.31,0:14:03.43,英文,,0,0,0,,If you see FF, now we know that's 4 1 bits and another 4 1 bits.
Dialogue: 0,0:13:59.31,0:14:03.43,中文,,0,0,0,,如果你看到 FF，现在我们知道它是 4 个 1 比特和另外 4 个 1 比特。
Dialogue: 0,0:14:03.43,0:14:05.75,英文,,0,0,0,,And if we do out the math, that's 255.
Dialogue: 0,0:14:03.43,0:14:05.75,中文,,0,0,0,,如果我们计算一下，那就是 255。
Dialogue: 0,0:14:05.75,0:14:14.33,英文,,0,0,0,,That's why in Photoshop, 0000FF means no red, no green, and 255 of blue.
Dialogue: 0,0:14:05.75,0:14:14.33,中文,,0,0,0,,这就是为什么在 Photoshop 中，0000FF 表示没有红色，没有绿色，只有 255 的蓝色。
Dialogue: 0,0:14:14.33,0:14:19.30,英文,,0,0,0,,And it's just way more succinct than writing out, like, what, 8 plus 8 plus 8, 24 0's and 1's.
Dialogue: 0,0:14:14.33,0:14:19.30,中文,,0,0,0,,它比写出 8+8+8，24 个 0 和 1 要简洁得多。
Dialogue: 0,0:14:19.30,0:14:25.48,英文,,0,0,0,,And it's just cleaner than even using decimal when you're using units of 8, which, again, computers just use everywhere.
Dialogue: 0,0:14:19.30,0:14:25.48,中文,,0,0,0,,它比使用十进制更简洁，当你使用以 8 为单位的时候，电脑也是到处都用。
Dialogue: 0,0:14:25.48,0:14:28.30,英文,,0,0,0,,So it's just another system. It's not one you need to dwell on very much.
Dialogue: 0,0:14:25.48,0:14:28.30,中文,,0,0,0,,所以这只是另一种体系，你不需要过多纠结。
Dialogue: 0,0:14:28.30,0:14:32.09,英文,,0,0,0,,But again, it's fundamentally no different from binary or decimal.
Dialogue: 0,0:14:28.30,0:14:32.09,中文,,0,0,0,,但本质上，它与二进制或十进制没有什么不同。
Dialogue: 0,0:14:32.09,0:14:35.21,英文,,0,0,0,,We're just using a slightly different base.
Dialogue: 0,0:14:32.09,0:14:35.21,中文,,0,0,0,,我们只是用了一个稍微不同的进制。
Dialogue: 0,0:14:35.21,0:14:35.29,英文,,0,0,0,,No?
Dialogue: 0,0:14:35.21,0:14:35.29,中文,,0,0,0,,没有？
Dialogue: 0,0:14:35.29,0:14:35.53,英文,,0,0,0,,All right.
Dialogue: 0,0:14:35.29,0:14:35.53,中文,,0,0,0,,好的。
Dialogue: 0,0:14:35.53,0:14:37.77,英文,,0,0,0,,Well, we had this blank canvas here.
Dialogue: 0,0:14:35.53,0:14:37.77,中文,,0,0,0,,我们这里有一块空白的画布。
Dialogue: 0,0:14:37.77,0:14:41.75,英文,,0,0,0,,And I think, are you two perhaps ready to reveal for the world what you've created?
Dialogue: 0,0:14:37.77,0:14:41.75,中文,,0,0,0,,我想，你们两位是否准备好向世界展示你们的创作了？
Dialogue: 0,0:14:41.75,0:14:45.13,英文,,0,0,0,,Do you want to go ahead and I'll swivel it around for you?
Dialogue: 0,0:14:41.75,0:14:45.13,中文,,0,0,0,,你们想继续吗？我可以帮你们把它转过来。
Dialogue: 0,0:14:45.13,0:14:45.69,英文,,0,0,0,,All right.
Dialogue: 0,0:14:45.13,0:14:45.69,中文,,0,0,0,,好的。
Dialogue: 0,0:14:45.69,0:14:46.17,英文,,0,0,0,,Here we go.
Dialogue: 0,0:14:45.69,0:14:46.17,中文,,0,0,0,,我们开始吧。
Dialogue: 0,0:14:46.17,0:14:47.04,英文,,0,0,0,,Big reveal.
Dialogue: 0,0:14:46.17,0:14:47.04,中文,,0,0,0,,隆重揭晓。
Dialogue: 0,0:14:47.04,0:14:50.12,英文,,0,0,0,,And today's pixel art.
Dialogue: 0,0:14:47.04,0:14:50.12,中文,,0,0,0,,今天的像素画。
Dialogue: 0,0:14:50.12,0:14:54.31,英文,,0,0,0,,A round of applause, if we could.
Dialogue: 0,0:14:50.12,0:14:54.31,中文,,0,0,0,,让我们以热烈的掌声祝贺他们。
Dialogue: 0,0:14:54.31,0:14:55.33,英文,,0,0,0,,Very nicely done.
Dialogue: 0,0:14:54.31,0:14:55.33,中文,,0,0,0,,做得非常好。
Dialogue: 0,0:14:55.33,0:14:56.15,英文,,0,0,0,,Well, thank you both.
Dialogue: 0,0:14:55.33,0:14:56.15,中文,,0,0,0,,谢谢你们两位。
Dialogue: 0,0:14:56.15,0:14:59.23,英文,,0,0,0,,If you want to come up after and tear this off and bring it home, you're welcome to.
Dialogue: 0,0:14:56.15,0:14:59.23,中文,,0,0,0,,如果你们想之后上来把它撕下来带回家，请便。
Dialogue: 0,0:14:59.23,0:15:00.43,英文,,0,0,0,,And keep the post-it notes, too.
Dialogue: 0,0:14:59.23,0:15:00.43,中文,,0,0,0,,便利贴也可以带走。
Dialogue: 0,0:15:00.43,0:15:02.32,英文,,0,0,0,,Well, thank you to our volunteers there.
Dialogue: 0,0:15:00.43,0:15:02.32,中文,,0,0,0,,感谢我们的志愿者。
Dialogue: 0,0:15:02.32,0:15:07.96,英文,,0,0,0,,Let's now translate this to really more technical world, where we're going to see and consider it more often.
Dialogue: 0,0:15:02.32,0:15:07.96,中文,,0,0,0,,现在让我们把它转换到更技术的世界，在那里我们会更频繁地看到和考虑到它。
Dialogue: 0,0:15:07.96,0:15:15.49,英文,,0,0,0,,Because in fact, sometimes when you've had error messages over the past few weeks from Clang, the compiler, You might have even seen evidence of hexadecimal.
Dialogue: 0,0:15:07.96,0:15:15.49,中文,,0,0,0,,因为实际上，过去几周你可能在 Clang 编译器中看到过错误信息， 你甚至可能见过十六进制。
Dialogue: 0,0:15:15.49,0:15:18.11,英文,,0,0,0,,We didn't call it out. It wasn't useful to know at the time.
Dialogue: 0,0:15:15.49,0:15:18.11,中文,,0,0,0,,我们当时没有说出来。 当时知道它并没有什么用。
Dialogue: 0,0:15:18.11,0:15:26.86,英文,,0,0,0,,But it turns out a lot of programs use, and a lot of code uses, hexadecimal for those reasons of more succinct representation.
Dialogue: 0,0:15:18.11,0:15:26.86,中文,,0,0,0,,但事实证明，很多程序和代码都使用十六进制，因为它表示起来更简洁。
Dialogue: 0,0:15:26.86,0:15:32.02,英文,,0,0,0,,So for instance, where else might we see it? Well, here's that picture we keep pulling up. of our computer's memory.
Dialogue: 0,0:15:26.86,0:15:32.02,中文,,0,0,0,,例如，我们还能在哪里看到它？ 这就是我们一直提到的计算机内存图片。
Dialogue: 0,0:15:32.02,0:15:37.19,英文,,0,0,0,,And each of these squares in this grid represents a byte, sort of top left to bottom right in the computer's memory.
Dialogue: 0,0:15:32.02,0:15:37.19,中文,,0,0,0,,网格中的每一个方块都代表一个字节，从计算机内存的左上角到右下角。
Dialogue: 0,0:15:37.19,0:15:39.81,英文,,0,0,0,,But again, just an artist's representation.
Dialogue: 0,0:15:37.19,0:15:39.81,中文,,0,0,0,,但这又只是艺术家的表现手法。
Dialogue: 0,0:15:39.81,0:15:43.64,英文,,0,0,0,,A few weeks ago, I claimed that each of these bytes can be numbered, of course.
Dialogue: 0,0:15:39.81,0:15:43.64,中文,,0,0,0,,几周前，我曾说过，这些字节中的每一个字节当然都可以被编号。
Dialogue: 0,0:15:43.64,0:15:49.88,英文,,0,0,0,,Like this is byte 0 at top left, then byte 1, then byte 2, then byte 2 billion if you have 2 gigabytes of memory.
Dialogue: 0,0:15:43.64,0:15:49.88,中文,,0,0,0,,比如左上角是字节 0，然后是字节 1，然后是字节 2，如果你的内存有 2 GB，那就是字节 20 亿。
Dialogue: 0,0:15:49.88,0:15:55.11,英文,,0,0,0,,And so we could just number them like this, 0 through 15 on up.
Dialogue: 0,0:15:49.88,0:15:55.11,中文,,0,0,0,,所以我们可以像这样对它们进行编号，从 0 到 15。
Dialogue: 0,0:15:55.11,0:15:56.55,英文,,0,0,0,,16, 17, 18, and so forth.
Dialogue: 0,0:15:55.11,0:15:56.55,中文,,0,0,0,,16、17、18，以此类推。
Dialogue: 0,0:15:56.55,0:16:07.22,英文,,0,0,0,,But per the reasons earlier, it's just more common in computer systems and in software to actually use hexadecimal just to describe the locations of the addresses of things in memory.
Dialogue: 0,0:15:56.55,0:16:07.22,中文,,0,0,0,,但根据之前的原因，在计算机系统和软件中更常见的是使用十六进制来描述内存中事物地址的位置。
Dialogue: 0,0:16:07.22,0:16:14.34,英文,,0,0,0,,So instead, a typical programmer or computer scientist would call these first 16 bytes 0 through F, just because.
Dialogue: 0,0:16:07.22,0:16:14.34,中文,,0,0,0,,因此，典型的程序员或计算机科学家会将前 16 个字节称为 0 到 F。
Dialogue: 0,0:16:14.34,0:16:17.06,英文,,0,0,0,,But that's because it's a predictable number of bits.
Dialogue: 0,0:16:14.34,0:16:17.06,中文,,0,0,0,,但这是因为它是一个可预测的位数。
Dialogue: 0,0:16:17.06,0:16:28.84,英文,,0,0,0,,So if we keep going beyond that, you would get not 10, not 11, not 12, but in hexadecimal, 10, 11, 12, and so forth, all the way down on the screen to 1f.
Dialogue: 0,0:16:17.06,0:16:28.84,中文,,0,0,0,,所以如果我们继续下去，你将不会得到 10、11、12，而是十六进制的 10、11、12，以此类推，一直到屏幕上的 1F。
Dialogue: 0,0:16:28.84,0:16:37.52,英文,,0,0,0,,And if I shrunk this down or had a bigger monitor, we would see eventually, 255 bytes later from the start, 255 as well.
Dialogue: 0,0:16:28.84,0:16:37.52,中文,,0,0,0,,如果我把它缩小或者用一个更大的显示器，我们最终会看到，从开始的 255 个字节之后，也是 255。
Dialogue: 0,0:16:37.52,0:16:40.99,英文,,0,0,0,,But there's a potential problem here with using hexadecimal in this way.
Dialogue: 0,0:16:37.52,0:16:40.99,中文,,0,0,0,,但是以这种方式使用十六进制有一个潜在的问题。
Dialogue: 0,0:16:40.99,0:16:42.91,英文,,0,0,0,,There's an ambiguity.
Dialogue: 0,0:16:40.99,0:16:42.91,中文,,0,0,0,,存在歧义。
Dialogue: 0,0:16:42.91,0:16:53.11,英文,,0,0,0,,Can anyone imagine what can go wrong if we use hex to just simply describe locations in memory like this?
Dialogue: 0,0:16:42.91,0:16:53.11,中文,,0,0,0,,谁能想象如果我们用十六进制简单地描述内存中的位置会发生什么问题？
Dialogue: 0,0:16:53.11,0:16:55.66,英文,,0,0,0,,Yeah.
Dialogue: 0,0:16:53.11,0:16:55.66,中文,,0,0,0,,是的。
Dialogue: 0,0:16:55.66,0:16:58.02,英文,,0,0,0,,Yeah, like 1, 0 might also be 10.
Dialogue: 0,0:16:55.66,0:16:58.02,中文,,0,0,0,,是的，像 1、0 也可能是 10。
Dialogue: 0,0:16:58.02,0:17:02.98,英文,,0,0,0,,And maybe if you're really thorough, OK, wait a minute, it can't be 10 because here's F over here.
Dialogue: 0,0:16:58.02,0:17:02.98,中文,,0,0,0,,也许如果你真的很仔细，等等，它不可能是 10，因为 F 在这里。
Dialogue: 0,0:17:02.98,0:17:04.32,英文,,0,0,0,,So it's obviously not decimal.
Dialogue: 0,0:17:02.98,0:17:04.32,中文,,0,0,0,,所以很明显它不是十进制的。
Dialogue: 0,0:17:04.32,0:17:08.22,英文,,0,0,0,,But why create potential confusion, especially when you're collaborating, building something with someone?
Dialogue: 0,0:17:04.32,0:17:08.22,中文,,0,0,0,,但是为什么要制造潜在的困惑呢？尤其是在你和别人合作开发东西的时候。
Dialogue: 0,0:17:08.22,0:17:09.69,英文,,0,0,0,,We want to avoid that ambiguity.
Dialogue: 0,0:17:08.22,0:17:09.69,中文,,0,0,0,,我们想要避免这种歧义。
Dialogue: 0,0:17:09.69,0:17:20.93,英文,,0,0,0,,And so the convention humans decided on years ago is that if you want to make clear that a number is in hexadecimal, just by convention, you prefix all of the digits with 0x.
Dialogue: 0,0:17:09.69,0:17:20.93,中文,,0,0,0,,所以几年前人们决定的惯例是，如果你想明确表示一个数字是十六进制的，按照惯例，你就在所有数字前加上 0x。
Dialogue: 0,0:17:20.93,0:17:22.93,英文,,0,0,0,,The x is not like another character.
Dialogue: 0,0:17:20.93,0:17:22.93,中文,,0,0,0,,x 不像另一个字符。
Dialogue: 0,0:17:22.93,0:17:24.71,英文,,0,0,0,,It's not like a 17th character.
Dialogue: 0,0:17:22.93,0:17:24.71,中文,,0,0,0,,它不像第 17 个字符。
Dialogue: 0,0:17:24.71,0:17:29.72,英文,,0,0,0,,It's just a human convention of putting 0x to imply here comes hexadecimal.
Dialogue: 0,0:17:24.71,0:17:29.72,中文,,0,0,0,,这只是人们的一种惯例，用 0x 来暗示接下来是十六进制。
Dialogue: 0,0:17:29.72,0:17:31.00,英文,,0,0,0,,And now it's unambiguous.
Dialogue: 0,0:17:29.72,0:17:31.00,中文,,0,0,0,,现在就没有歧义了。
Dialogue: 0,0:17:31.00,0:17:41.64,英文,,0,0,0,,So now we see 0x10 obviously is not 10 as we know it in decimal, but rather it's the number that comes after a single f. So it's really the number in decimal 16.
Dialogue: 0,0:17:31.00,0:17:41.64,中文,,0,0,0,,所以现在我们看到 0x10 显然不是我们在十进制中所知的 10，而是紧跟在单个 F 之后的数字。所以它实际上是十进制的 16。
Dialogue: 0,0:17:41.64,0:17:49.11,英文,,0,0,0,,So 0x, any time you see it, that's just a visual cue that what is ahead is actually hexadecimal.
Dialogue: 0,0:17:41.64,0:17:49.11,中文,,0,0,0,,每当你看到 0x，这只是一个视觉提示，告诉你它后面是十六进制的。
Dialogue: 0,0:17:49.11,0:17:52.39,英文,,0,0,0,,So let's now start playing around with this information.
Dialogue: 0,0:17:49.11,0:17:52.39,中文,,0,0,0,,现在让我们开始利用这些信息来做些事情吧。
Dialogue: 0,0:17:52.39,0:17:59.55,英文,,0,0,0,,So here's a super simple line of code from week one, where I'm just declaring a variable n, and I'm defining it to be the value 50.
Dialogue: 0,0:17:52.39,0:17:59.55,中文,,0,0,0,,这是第一周的一个超级简单的代码行，我只是在声明一个变量 n，并将其定义为值 50。
Dialogue: 0,0:17:59.55,0:18:00.55,英文,,0,0,0,,And this is out of context.
Dialogue: 0,0:17:59.55,0:18:00.55,中文,,0,0,0,,这是脱离上下文的。
Dialogue: 0,0:18:00.55,0:18:02.63,英文,,0,0,0,,We probably need a main function and all of that.
Dialogue: 0,0:18:00.55,0:18:02.63,中文,,0,0,0,,我们可能需要一个主函数等等。
Dialogue: 0,0:18:02.63,0:18:08.42,英文,,0,0,0,,But let's just rewind to week one, where we actually saw code like this and do something useful with a line of code like this.
Dialogue: 0,0:18:02.63,0:18:08.42,中文,,0,0,0,,但是让我们回到第一周，我们实际看到了这样的代码，并用这样一行代码做了一些有用的事情。
Dialogue: 0,0:18:08.42,0:18:10.70,英文,,0,0,0,,So let me go over here to VS Code.
Dialogue: 0,0:18:08.42,0:18:10.70,中文,,0,0,0,,让我到 VS Code 那边去。
Dialogue: 0,0:18:10.70,0:18:21.82,英文,,0,0,0,,And in VS Code, I'll create a program called, how about, Addresses, since the goal here is to just play around, ultimately, with a variable like n. And let me go ahead and do this.
Dialogue: 0,0:18:10.70,0:18:21.82,中文,,0,0,0,,在 VS Code 中，我将创建一个名为 Addresses 的程序，因为这里的目标是最终使用像 n 这样的变量来做些事情。让我继续这样做。
Dialogue: 0,0:18:21.82,0:18:24.61,英文,,0,0,0,,I'll include, how about, standard io.h.
Dialogue: 0,0:18:21.82,0:18:24.61,中文,,0,0,0,,我要包含 standard io.h。
Dialogue: 0,0:18:24.61,0:18:28.55,英文,,0,0,0,,I'll do int main void, so no command line arguments for now.
Dialogue: 0,0:18:24.61,0:18:28.55,中文,,0,0,0,,我将使用 `int main (void)`，所以现在没有命令行参数。
Dialogue: 0,0:18:28.55,0:18:30.27,英文,,0,0,0,,Int n gets 50.
Dialogue: 0,0:18:28.55,0:18:30.27,中文,,0,0,0,,`int n` 获取值为 50。
Dialogue: 0,0:18:30.27,0:18:36.43,英文,,0,0,0,,And now, so that we can do something mildly useful with it, let's just go use printf and print out with %i.
Dialogue: 0,0:18:30.27,0:18:36.43,中文,,0,0,0,,现在，为了能够用它做一些稍微有点用的事情，我们使用 `printf` 并用 `%i` 打印出来。
Dialogue: 0,0:18:36.43,0:18:39.07,英文,,0,0,0,,And then a new line, whatever that value of n is.
Dialogue: 0,0:18:36.43,0:18:39.07,中文,,0,0,0,,然后是换行符，无论 `n` 的值是什么。
Dialogue: 0,0:18:39.07,0:18:40.92,英文,,0,0,0,,So this is not going to be interesting per se.
Dialogue: 0,0:18:39.07,0:18:40.92,中文,,0,0,0,,所以这本身并不有趣。
Dialogue: 0,0:18:40.92,0:18:45.68,英文,,0,0,0,,It's just week one stuff where I'm defining a variable and printing it out to the screen.
Dialogue: 0,0:18:40.92,0:18:45.68,中文,,0,0,0,,这只是第一周的内容，我定义了一个变量并将其打印到屏幕上。
Dialogue: 0,0:18:45.68,0:18:49.58,英文,,0,0,0,,So let me go down to my terminal window and do make addresses.
Dialogue: 0,0:18:45.68,0:18:49.58,中文,,0,0,0,,让我进入终端窗口，执行 `make addresses`。
Dialogue: 0,0:18:49.58,0:18:51.02,英文,,0,0,0,,No errors, so that's good.
Dialogue: 0,0:18:49.58,0:18:51.02,中文,,0,0,0,,没有错误，很好。
Dialogue: 0,0:18:51.02,0:18:52.42,英文,,0,0,0,,I'll do dot slash addresses.
Dialogue: 0,0:18:51.02,0:18:52.42,中文,,0,0,0,,我执行 `./addresses`。
Dialogue: 0,0:18:52.42,0:18:55.63,英文,,0,0,0,,And of course, I should see the number 50 here.
Dialogue: 0,0:18:52.42,0:18:55.63,中文,,0,0,0,,当然，我应该在这里看到数字 50。
Dialogue: 0,0:18:55.63,0:18:57.35,英文,,0,0,0,,Now, what's going on underneath the hood?
Dialogue: 0,0:18:55.63,0:18:57.35,中文,,0,0,0,,现在，底层发生了什么？
Dialogue: 0,0:18:57.35,0:19:03.33,英文,,0,0,0,,Let's translate now code to really what's going on underneath the hood of the computer.
Dialogue: 0,0:18:57.35,0:19:03.33,中文,,0,0,0,,让我们把代码翻译成计算机底层真正发生的事情。
Dialogue: 0,0:19:03.33,0:19:10.42,英文,,0,0,0,,So if this is our grid of memory, I don't necessarily know as the programmer, and I definitely don't care as the programmer, where exactly it's ending up in memory.
Dialogue: 0,0:19:03.33,0:19:10.42,中文,,0,0,0,,所以如果这是我们的内存网格，作为程序员，我不一定知道，也绝对不关心它最终存储在内存中的确切位置。
Dialogue: 0,0:19:10.42,0:19:11.68,英文,,0,0,0,,That's the whole point of using code.
Dialogue: 0,0:19:10.42,0:19:11.68,中文,,0,0,0,,这就是使用代码的意义所在。
Dialogue: 0,0:19:11.68,0:19:13.34,英文,,0,0,0,,Let the computer figure this out.
Dialogue: 0,0:19:11.68,0:19:13.34,中文,,0,0,0,,让计算机来解决这个问题。
Dialogue: 0,0:19:13.34,0:19:17.62,英文,,0,0,0,,But at least conceptually, I know that by declaring a line of code like that,
Dialogue: 0,0:19:13.34,0:19:17.62,中文,,0,0,0,,但至少在概念上，我知道通过声明这样一行代码，
Dialogue: 0,0:19:17.62,0:19:26.97,英文,,0,0,0,,The number 50 ends up somewhere in the computer's memory, and it's assigned the name n, a symbol n, via which I, the programmer, can refer to it.
Dialogue: 0,0:19:17.62,0:19:26.97,中文,,0,0,0,,数字 50 最终会出现在计算机内存中的某个位置，并通过一个符号 `n` 被赋予名称 `n`，我，作为程序员，可以通过这个名称来引用它。
Dialogue: 0,0:19:26.97,0:19:33.94,英文,,0,0,0,,And I very deliberately used four of these squares for what reason?
Dialogue: 0,0:19:26.97,0:19:33.94,中文,,0,0,0,,我特意用了四个方块，为什么？
Dialogue: 0,0:19:33.94,0:19:39.64,英文,,0,0,0,,What might be the reason for using four squares specifically? Yeah, so an integer is 4 bytes.
Dialogue: 0,0:19:33.94,0:19:39.64,中文,,0,0,0,,为什么专门使用四个方块呢？对，因为一个整数是 4 个字节。
Dialogue: 0,0:19:39.64,0:19:42.96,英文,,0,0,0,,At least most of the time on modern systems, an integer is 4 bytes.
Dialogue: 0,0:19:39.64,0:19:42.96,中文,,0,0,0,,至少在现代系统中，大多数情况下一个整数是 4 个字节。
Dialogue: 0,0:19:42.96,0:19:46.92,英文,,0,0,0,,On an older computer, it might just use 1 or maybe even 2 bytes.
Dialogue: 0,0:19:42.96,0:19:46.92,中文,,0,0,0,,在旧的计算机上，可能只使用 1 个字节，甚至 2 个字节。
Dialogue: 0,0:19:46.92,0:19:49.73,英文,,0,0,0,,But here, by convention, we're almost always going to see 4 bytes.
Dialogue: 0,0:19:46.92,0:19:49.73,中文,,0,0,0,,但在这里，按照惯例，我们几乎总是会看到 4 个字节。
Dialogue: 0,0:19:49.73,0:19:52.45,英文,,0,0,0,,I don't know if it's going to end up here. It might end up over here.
Dialogue: 0,0:19:49.73,0:19:52.45,中文,,0,0,0,,我不知道它最终会到哪里，它可能会在这边结束。
Dialogue: 0,0:19:52.45,0:19:53.57,英文,,0,0,0,,But for now, who cares?
Dialogue: 0,0:19:52.45,0:19:53.57,中文,,0,0,0,,但现在，谁在乎呢？
Dialogue: 0,0:19:53.57,0:19:58.59,英文,,0,0,0,,I just know that the computer can store the information in this way underneath the hood.
Dialogue: 0,0:19:53.57,0:19:58.59,中文,,0,0,0,,我只是知道计算机可以用这种方式在底层存储信息。
Dialogue: 0,0:19:58.59,0:20:08.70,英文,,0,0,0,,So let's now introduce another feature of C that we haven't had occasion to use just yet that's going to allow us to start poking around the computer's memory, for better or for worse.
Dialogue: 0,0:19:58.59,0:20:08.70,中文,,0,0,0,,现在，让我们介绍 C 语言的另一个特性，这个特性我们目前还没有机会用到，它将允许我们开始探究计算机内存，无论好坏。
Dialogue: 0,0:20:08.70,0:20:13.60,英文,,0,0,0,,And this is one of those situations where you're about to learn, acquire a skill, a power.
Dialogue: 0,0:20:08.70,0:20:13.60,中文,,0,0,0,,这就好比你要学习、获得一项技能、一种力量。
Dialogue: 0,0:20:13.60,0:20:15.42,英文,,0,0,0,,They can actually come back to bite you.
Dialogue: 0,0:20:13.60,0:20:15.42,中文,,0,0,0,,它们最终可能会反咬你一口。
Dialogue: 0,0:20:15.42,0:20:19.93,英文,,0,0,0,,Because once you know how to start poking around a computer's memory, you can do very powerful things.
Dialogue: 0,0:20:15.42,0:20:19.93,中文,,0,0,0,,因为一旦你知道如何开始探究计算机的内存，你就可以做很多强大的事情。
Dialogue: 0,0:20:19.93,0:20:23.05,英文,,0,0,0,,And next week, we'll see what you can build in a computer's memory.
Dialogue: 0,0:20:19.93,0:20:23.05,中文,,0,0,0,,下周，我们将看到你可以在计算机内存中构建什么。
Dialogue: 0,0:20:23.05,0:20:28.14,英文,,0,0,0,,But you can also screw up pretty easily and cause more of those segmentation faults that a few of you have already suffered.
Dialogue: 0,0:20:23.05,0:20:28.14,中文,,0,0,0,,但你也可能很容易搞砸，导致更多人遇到 segmentation faults 错误。
Dialogue: 0,0:20:28.14,0:20:34.55,英文,,0,0,0,,So with that said. Let's just stipulate that, you know what, I don't care necessarily where the 50 is in memory.
Dialogue: 0,0:20:28.14,0:20:34.55,中文,,0,0,0,,话虽如此。 我们规定，我不在乎 50 在内存中的确切位置。
Dialogue: 0,0:20:34.55,0:20:37.37,英文,,0,0,0,,But I know it exists at some address in memory.
Dialogue: 0,0:20:34.55,0:20:37.37,中文,,0,0,0,,但我知道它存在于内存中的某个地址。
Dialogue: 0,0:20:37.37,0:20:42.09,英文,,0,0,0,,And just so I have an easy address to pronounce, let's just suppose it lives at 0x123.
Dialogue: 0,0:20:37.37,0:20:42.09,中文,,0,0,0,,为了方便起见，我们假设它位于 0x123。
Dialogue: 0,0:20:42.09,0:20:45.36,英文,,0,0,0,,So that's the address in memory in hexadecimal by convention.
Dialogue: 0,0:20:42.09,0:20:45.36,中文,,0,0,0,,这就是内存地址，按照惯例用十六进制表示。
Dialogue: 0,0:20:45.36,0:20:48.82,英文,,0,0,0,,And that just happens to be where it ends up when I write that line of code.
Dialogue: 0,0:20:45.36,0:20:48.82,中文,,0,0,0,,当我写下那行代码时，它碰巧就在那里。
Dialogue: 0,0:20:48.82,0:20:52.80,英文,,0,0,0,,But it turns out. C has some other operators we can use.
Dialogue: 0,0:20:48.82,0:20:52.80,中文,,0,0,0,,但事实证明，C 语言还有一些我们可以使用的运算符。
Dialogue: 0,0:20:52.80,0:20:56.77,英文,,0,0,0,,And we've seen the asterisk before, the star, and we've used it for multiplication.
Dialogue: 0,0:20:52.80,0:20:56.77,中文,,0,0,0,,我们之前见过星号 (*)，我们用它来做乘法运算。
Dialogue: 0,0:20:56.77,0:20:59.11,英文,,0,0,0,,But today, we're going to use it for something more powerful.
Dialogue: 0,0:20:56.77,0:20:59.11,中文,,0,0,0,,但是今天，我们要用它来做更强大的事情。
Dialogue: 0,0:20:59.11,0:21:03.11,英文,,0,0,0,,And we're also going to introduce an ampersand, which allows us to do something as well.
Dialogue: 0,0:20:59.11,0:21:03.11,中文,,0,0,0,,我们还将介绍“&”符号，它也允许我们做一些事情。
Dialogue: 0,0:21:03.11,0:21:10.60,英文,,0,0,0,,The ampersand operator is going to allow us to get the address of. A piece of data in memory.
Dialogue: 0,0:21:03.11,0:21:10.60,中文,,0,0,0,,“&”运算符将允许我们获取内存中一段数据的地址。
Dialogue: 0,0:21:10.60,0:21:18.20,英文,,0,0,0,,Like, by literally putting ampersand before the name of a variable, C will tell us, tell you, what address that variable lives at.
Dialogue: 0,0:21:10.60,0:21:18.20,中文,,0,0,0,,例如，通过在变量名前面加上“&”，C 语言会告诉我们，告诉你，该变量所在的地址。
Dialogue: 0,0:21:18.20,0:21:19.44,英文,,0,0,0,,Maybe it's 0x123.
Dialogue: 0,0:21:18.20,0:21:19.44,中文,,0,0,0,,也许是 0x123。
Dialogue: 0,0:21:19.44,0:21:20.72,英文,,0,0,0,,Maybe it's 0x456.
Dialogue: 0,0:21:19.44,0:21:20.72,中文,,0,0,0,,也许是 0x456。
Dialogue: 0,0:21:20.72,0:21:21.40,英文,,0,0,0,,Who knows?
Dialogue: 0,0:21:20.72,0:21:21.40,中文,,0,0,0,,谁知道呢？
Dialogue: 0,0:21:21.40,0:21:23.78,英文,,0,0,0,,But that will give you back the answer.
Dialogue: 0,0:21:21.40,0:21:23.78,中文,,0,0,0,,但这会给你答案。
Dialogue: 0,0:21:23.78,0:21:25.28,英文,,0,0,0,,The star does the opposite.
Dialogue: 0,0:21:23.78,0:21:25.28,中文,,0,0,0,,星号的作用则相反。
Dialogue: 0,0:21:25.28,0:21:26.63,英文,,0,0,0,,It sort of means go there.
Dialogue: 0,0:21:25.28,0:21:26.63,中文,,0,0,0,,它有点像“去那里”。
Dialogue: 0,0:21:26.63,0:21:33.01,英文,,0,0,0,,So using the star, otherwise known as the dereference operator, I can actually go to a specific address if I want.
Dialogue: 0,0:21:26.63,0:21:33.01,中文,,0,0,0,,所以使用星号（也称为解引用运算符），如果我愿意，我可以实际去到一个特定的地址。
Dialogue: 0,0:21:33.01,0:21:35.35,英文,,0,0,0,,And we'll see what this means in code.
Dialogue: 0,0:21:33.01,0:21:35.35,中文,,0,0,0,,我们将在代码中看到这意味着什么。
Dialogue: 0,0:21:35.35,0:21:44.69,英文,,0,0,0,,So how can I leverage this in some mildly interesting way to start poking around, but eventually we'll use this primitive to build more interesting things?
Dialogue: 0,0:21:35.35,0:21:44.69,中文,,0,0,0,,那么，我怎样才能以某种稍微有趣的方式利用它来开始探索呢？最终我们将使用这个原语来构建更有趣的东西。
Dialogue: 0,0:21:44.69,0:21:47.77,英文,,0,0,0,,So let me go back to, say, VS Code here.
Dialogue: 0,0:21:44.69,0:21:47.77,中文,,0,0,0,,让我回到 VS Code。
Dialogue: 0,0:21:47.77,0:21:49.33,英文,,0,0,0,,And let me go ahead and do this.
Dialogue: 0,0:21:47.77,0:21:49.33,中文,,0,0,0,,让我继续这样做。
Dialogue: 0,0:21:49.33,0:21:51.41,英文,,0,0,0,,I'll clear my terminal to start fresh.
Dialogue: 0,0:21:49.33,0:21:51.41,中文,,0,0,0,,我将清除终端重新开始。
Dialogue: 0,0:21:51.41,0:21:55.71,英文,,0,0,0,,And I'll introduce another format code for printf, %p.
Dialogue: 0,0:21:51.41,0:21:55.71,中文,,0,0,0,,我将介绍另一个 printf 的格式代码，%p。
Dialogue: 0,0:21:55.71,0:21:59.77,英文,,0,0,0,,And for now, just take on faith that it is %p because.
Dialogue: 0,0:21:55.71,0:21:59.77,中文,,0,0,0,,现在，请相信它是 %p，
Dialogue: 0,0:21:59.77,0:22:08.38,英文,,0,0,0,,But %p is going to allow me to print the address of a variable if I additionally tell C, get the address of n.
Dialogue: 0,0:21:59.77,0:22:08.38,中文,,0,0,0,,但是 %p 将允许我打印一个变量的地址，如果我另外告诉 C，“获取 n 的地址”。
Dialogue: 0,0:22:08.38,0:22:10.40,英文,,0,0,0,,So I'm changing %i to %p.
Dialogue: 0,0:22:08.38,0:22:10.40,中文,,0,0,0,,所以我将 %i 改为 %p。
Dialogue: 0,0:22:10.40,0:22:13.92,英文,,0,0,0,,And that's just something you have to do when printing addresses for now.
Dialogue: 0,0:22:10.40,0:22:13.92,中文,,0,0,0,,目前打印地址时你必须这样做。
Dialogue: 0,0:22:13.92,0:22:17.23,英文,,0,0,0,,But I need to change an ampersand in front of the variable name.
Dialogue: 0,0:22:13.92,0:22:17.23,中文,,0,0,0,,但是我需要在变量名前面加上一个“&”符号。
Dialogue: 0,0:22:17.23,0:22:19.43,英文,,0,0,0,,So I don't print in the number 50.
Dialogue: 0,0:22:17.23,0:22:19.43,中文,,0,0,0,,所以我打印的不是数字 50。
Dialogue: 0,0:22:19.43,0:22:21.77,英文,,0,0,0,,I print out something like 0x123.
Dialogue: 0,0:22:19.43,0:22:21.77,中文,,0,0,0,,我打印的是类似 0x123 的东西。
Dialogue: 0,0:22:21.77,0:22:22.95,英文,,0,0,0,,And it's not going to be as simple as that.
Dialogue: 0,0:22:21.77,0:22:22.95,中文,,0,0,0,,而且它不会那么简单。
Dialogue: 0,0:22:22.95,0:22:27.12,英文,,0,0,0,,We'll see on the screen, though, where it actually ended up in my code space's memory.
Dialogue: 0,0:22:22.95,0:22:27.12,中文,,0,0,0,,不过我们可以在屏幕上看到，它实际上在我的代码空间的内存中。
Dialogue: 0,0:22:27.12,0:22:32.90,英文,,0,0,0,,So here we go, dot down in my terminal, make addresses again to recompile.
Dialogue: 0,0:22:27.12,0:22:32.90,中文,,0,0,0,,所以我们开始吧，在我的终端中输入“.”，再次生成“addresses”来重新编译。
Dialogue: 0,0:22:32.90,0:22:40.55,英文,,0,0,0,,And now, dot slash addresses should reveal not the value of 50, but the address of 50.
Dialogue: 0,0:22:32.90,0:22:40.55,中文,,0,0,0,,现在，"./addresses" 应该显示的不是 50 的值，而是 50 的地址。
Dialogue: 0,0:22:40.55,0:22:41.73,英文,,0,0,0,,And there it is.
Dialogue: 0,0:22:40.55,0:22:41.73,中文,,0,0,0,,就是这样。
Dialogue: 0,0:22:41.73,0:22:42.91,英文,,0,0,0,,It's pretty long.
Dialogue: 0,0:22:41.73,0:22:42.91,中文,,0,0,0,,它很长。
Dialogue: 0,0:22:42.91,0:22:45.24,英文,,0,0,0,,It's not quite as simple and pretty as 0x123.
Dialogue: 0,0:22:42.91,0:22:45.24,中文,,0,0,0,,它不像 0x123 那样简单漂亮。
Dialogue: 0,0:22:45.24,0:22:47.96,英文,,0,0,0,,But there's the 0x, meaning here's a hexadecimal address.
Dialogue: 0,0:22:45.24,0:22:47.96,中文,,0,0,0,,但是有“0x”，意思是这是一个十六进制地址。
Dialogue: 0,0:22:47.96,0:22:56.75,英文,,0,0,0,,And it's 7f. FC, C7, 8, 4, A, 0, 4, C. Suffice it to say, your code space and even your Macs and PCs nowadays have a lot of memory.
Dialogue: 0,0:22:47.96,0:22:56.75,中文,,0,0,0,,它是 7f, FC, C7, 8, 4, A, 0, 4, C。足以说明，你的代码空间，甚至你现在的 Mac 和 PC，都有很大的内存。
Dialogue: 0,0:22:56.75,0:23:02.23,英文,,0,0,0,,That's why, in part, this address is so big, not as small as the thing on my slide.
Dialogue: 0,0:22:56.75,0:23:02.23,中文,,0,0,0,,这就是为什么这个地址这么大，不像我幻灯片上的那么小。
Dialogue: 0,0:23:02.23,0:23:06.01,英文,,0,0,0,,So this, at the moment, isn't that useful yet.
Dialogue: 0,0:23:02.23,0:23:06.01,中文,,0,0,0,,目前这还没有什么用。
Dialogue: 0,0:23:06.01,0:23:09.96,英文,,0,0,0,,But it introduces us to a concept that we'll now call pointers.
Dialogue: 0,0:23:06.01,0:23:09.96,中文,,0,0,0,,但它向我们介绍了一个概念，我们现在称之为指针。
Dialogue: 0,0:23:09.96,0:23:22.47,英文,,0,0,0,,And pointers are, admittedly, one of the more challenging aspects of C. And if, in future life, you tell friends that, oh, I took a class called CS50 and we learned C, you'll probably get kind of a look at people like, why did you learn C?
Dialogue: 0,0:23:09.96,0:23:22.47,中文,,0,0,0,,诚然，指针是 C 语言中比较难理解的方面之一。\N如果将来你告诉朋友，我上了一门叫 cs50 的课，我们学习了 C 语言，你可能会看到人们的表情，为什么要学 C 语言？
Dialogue: 0,0:23:22.47,0:23:23.89,英文,,0,0,0,,Or like, oh, C was hard.
Dialogue: 0,0:23:22.47,0:23:23.89,中文,,0,0,0,,或者说，C 语言很难。
Dialogue: 0,0:23:23.89,0:23:32.26,英文,,0,0,0,,And it's largely. because of this topic, which isn't to say that it's that hard to wrap your mind around. But it's definitely very different.
Dialogue: 0,0:23:23.89,0:23:32.26,中文,,0,0,0,,这主要是因为这个主题，并不是说它很难理解。但这绝对是非常不同的。
Dialogue: 0,0:23:32.26,0:23:40.03,英文,,0,0,0,,And it's not a feature that you can harness in higher-level languages that we'll see in class 2, like Python and Java and the like.
Dialogue: 0,0:23:32.26,0:23:40.03,中文,,0,0,0,,而且这不是我们在第二节课中将会看到的更高级语言（如 Python、Java 等）所能利用的功能。
Dialogue: 0,0:23:40.03,0:23:45.35,英文,,0,0,0,,C is about as close to the computer's hardware, so to speak, that you can get before things get actually scary.
Dialogue: 0,0:23:40.03,0:23:45.35,中文,,0,0,0,,可以说，C 语言几乎是能接触到的最接近计算机硬件的语言了，再往底层就非常可怕了。
Dialogue: 0,0:23:45.35,0:23:50.74,英文,,0,0,0,,The so-called assembly language we saw in week 2 when I had a link and compile and assemble and all of that.
Dialogue: 0,0:23:45.35,0:23:50.74,中文,,0,0,0,,我们在第二周看到了所谓的汇编语言，当时我演示了链接、编译和汇编等操作。
Dialogue: 0,0:23:50.74,0:23:56.42,英文,,0,0,0,,Like, that gets really low level, and you really have to be an expert with the computer's CPU or brain to understand that.
Dialogue: 0,0:23:50.74,0:23:56.42,中文,,0,0,0,,那种语言非常底层，你必须是计算机 CPU 或大脑方面的专家才能理解。
Dialogue: 0,0:23:56.42,0:24:01.15,英文,,0,0,0,,But with C, you can actually poke around the computer's memory and do powerful things with that.
Dialogue: 0,0:23:56.42,0:24:01.15,中文,,0,0,0,,但是使用 C 语言，你可以实际操作计算机内存，并利用它来做一些强大的事情。
Dialogue: 0,0:24:01.15,0:24:03.55,英文,,0,0,0,,But again, with great power comes responsibility.
Dialogue: 0,0:24:01.15,0:24:03.55,中文,,0,0,0,,但是，能力越大，责任越大。
Dialogue: 0,0:24:03.55,0:24:11.38,英文,,0,0,0,,It's very easy to break programs by misusing memory or just having a bug that touches memory in some way that you don't intend.
Dialogue: 0,0:24:03.55,0:24:11.38,中文,,0,0,0,,如果误用内存或者程序中有 bug 以 unintended 的方式触碰了内存，程序就很容易崩溃。
Dialogue: 0,0:24:11.38,0:24:16.38,英文,,0,0,0,,So pointers, at the end of the day, are pretty much what we just saw.
Dialogue: 0,0:24:11.38,0:24:16.38,中文,,0,0,0,,说到底，指针， 就是我们刚才看到的。
Dialogue: 0,0:24:16.38,0:24:22.97,英文,,0,0,0,,A pointer is really just a variable that contains the address of some value.
Dialogue: 0,0:24:16.38,0:24:22.97,中文,,0,0,0,,指针实际上只是一个包含某个值地址的变量。
Dialogue: 0,0:24:22.97,0:24:25.85,英文,,0,0,0,,A pointer is a variable that contains the address of some value.
Dialogue: 0,0:24:22.97,0:24:25.85,中文,,0,0,0,,指针是一个包含某个值地址的变量。
Dialogue: 0,0:24:25.85,0:24:28.29,英文,,0,0,0,,Or more simply, it's fine to think of it as an address.
Dialogue: 0,0:24:25.85,0:24:28.29,中文,,0,0,0,,或者更简单地说，可以把它理解为一个地址。
Dialogue: 0,0:24:28.29,0:24:31.73,英文,,0,0,0,,A pointer is an address of something in the computer's memory.
Dialogue: 0,0:24:28.29,0:24:31.73,中文,,0,0,0,,指针就是计算机内存中某个东西的地址。
Dialogue: 0,0:24:31.73,0:24:35.77,英文,,0,0,0,,Now, what might we do to actualize this?
Dialogue: 0,0:24:31.73,0:24:35.77,中文,,0,0,0,,现在，我们可以做些什么来实现它呢？
Dialogue: 0,0:24:35.77,0:24:37.54,英文,,0,0,0,,Well, here's two lines of code.
Dialogue: 0,0:24:35.77,0:24:37.54,中文,,0,0,0,,这里有两行代码。
Dialogue: 0,0:24:37.54,0:24:43.04,英文,,0,0,0,,It turns out, by using our two new operators today, I can declare an int, call it n.
Dialogue: 0,0:24:37.54,0:24:43.04,中文,,0,0,0,,事实证明，通过使用今天学习的两个新运算符，我可以声明一个 int 类型的变量，叫做 n。
Dialogue: 0,0:24:43.04,0:24:45.96,英文,,0,0,0,,And assign it a value like 50, just like before.
Dialogue: 0,0:24:43.04,0:24:45.96,中文,,0,0,0,,然后像以前一样给它赋一个值，比如 50。
Dialogue: 0,0:24:45.96,0:24:56.95,英文,,0,0,0,,If I want to store the address of n in a variable and not just print it immediately via printf, I can declare a variable, for instance, called p. But I could call it anything I want, like any variable.
Dialogue: 0,0:24:45.96,0:24:56.95,中文,,0,0,0,,如果我想将 n 的地址存储在一个变量中，而不是通过 printf 直接打印出来，\N我可以声明一个变量，例如，叫做 p。但我可以随便给它起名字，就像其他变量一样。
Dialogue: 0,0:24:56.95,0:25:03.41,英文,,0,0,0,,But because it's an address, It's not int p. It has to be int star p, so to speak.
Dialogue: 0,0:24:56.95,0:25:03.41,中文,,0,0,0,,但因为它是一个地址， 所以它不是 int p，而应该是 int *p。
Dialogue: 0,0:25:03.41,0:25:10.87,英文,,0,0,0,,And the star here on the left-hand side of the equal sign is just a clue to see that means p is going to be a pointer.
Dialogue: 0,0:25:03.41,0:25:10.87,中文,,0,0,0,,等号左侧的星号只是一个提示，表示 p 将是一个指针。
Dialogue: 0,0:25:10.87,0:25:13.61,英文,,0,0,0,,That is, p is going to be the address of what?
Dialogue: 0,0:25:10.87,0:25:13.61,中文,,0,0,0,,p 将会是什么的地址？
Dialogue: 0,0:25:13.61,0:25:15.51,英文,,0,0,0,,The address of an integer.
Dialogue: 0,0:25:13.61,0:25:15.51,中文,,0,0,0,,一个整数的地址。
Dialogue: 0,0:25:15.51,0:25:17.50,英文,,0,0,0,,Now, technically, it's still an integer itself, right?
Dialogue: 0,0:25:15.51,0:25:17.50,中文,,0,0,0,,从技术上讲，它本身仍然是一个整数，对吧？
Dialogue: 0,0:25:17.50,0:25:21.36,英文,,0,0,0,,Because an address is just a number, whether it's 123 or 0x123.
Dialogue: 0,0:25:17.50,0:25:21.36,中文,,0,0,0,,因为地址只是一个数字，无论是 123 还是 0x123。
Dialogue: 0,0:25:21.36,0:25:24.04,英文,,0,0,0,,So this is really just a semantic difference.
Dialogue: 0,0:25:21.36,0:25:24.04,中文,,0,0,0,,所以这实际上只是一个语义上的区别。
Dialogue: 0,0:25:24.04,0:25:28.06,英文,,0,0,0,,int star p just means that this variable doesn't contain any old number, like 50.
Dialogue: 0,0:25:24.04,0:25:28.06,中文,,0,0,0,,int *p 只是意味着这个变量不包含任何普通的数字，比如 50。
Dialogue: 0,0:25:28.06,0:25:33.81,英文,,0,0,0,,It specifically contains a number that is the address of something else.
Dialogue: 0,0:25:28.06,0:25:33.81,中文,,0,0,0,,它专门包含一个数字，这个数字是其他东西的地址。
Dialogue: 0,0:25:33.81,0:25:35.55,英文,,0,0,0,,So how can I now use this?
Dialogue: 0,0:25:33.81,0:25:35.55,中文,,0,0,0,,那么我现在如何使用它呢？
Dialogue: 0,0:25:35.55,0:25:41.57,英文,,0,0,0,,Well, let me go back to VS Code, and let me propose that we add a line of code like that.
Dialogue: 0,0:25:35.55,0:25:41.57,中文,,0,0,0,,让我回到 VS Code，我建议我们添加这样一行代码。
Dialogue: 0,0:25:41.57,0:25:52.22,英文,,0,0,0,,So instead of just directly printing out that value, let's go ahead and define a second variable called p that's of type int star p, set it equal to ampersand n,
Dialogue: 0,0:25:41.57,0:25:52.22,中文,,0,0,0,,因此，我们不再直接打印出该值，而是继续定义第二个名为 p 的变量，其类型为 int *p，并将其设置为等于 &n，
Dialogue: 0,0:25:52.22,0:26:10.37,英文,,0,0,0,,And then this time, let's not just print out ampersand n. Let's actually print out the value of p. So the only two new things here, if I zoom in, are I've used not only the ampersand on the right to get the address of n. I'm now using the star on the left to tell C that p is still a variable, as always.
Dialogue: 0,0:25:52.22,0:26:10.37,中文,,0,0,0,,这次我们不只是打印出 &n，而是打印出 p 的值。如果我放大，这里只有两个新东西，\N我不仅在右边使用了 & 来获取 n 的地址，现在还在左边使用了 * 来告诉 C，p 仍然像往常一样是一个变量。
Dialogue: 0,0:26:10.37,0:26:11.53,英文,,0,0,0,,But it's a pointer.
Dialogue: 0,0:26:10.37,0:26:11.53,中文,,0,0,0,,但它是一个指针。
Dialogue: 0,0:26:11.53,0:26:15.11,英文,,0,0,0,,It is the address of some other value like this.
Dialogue: 0,0:26:11.53,0:26:15.11,中文,,0,0,0,,它是其他值的地址，就像这样。
Dialogue: 0,0:26:15.11,0:26:17.51,英文,,0,0,0,,And I'm still going to print it with the same format code, %p.
Dialogue: 0,0:26:15.11,0:26:17.51,中文,,0,0,0,,我仍然要用相同的格式代码 %p 打印它。
Dialogue: 0,0:26:17.51,0:26:20.61,英文,,0,0,0,,So that doesn't change. So let me go ahead and zoom out.
Dialogue: 0,0:26:17.51,0:26:20.61,中文,,0,0,0,,所以这没有改变，让我继续放大。
Dialogue: 0,0:26:20.61,0:26:24.93,英文,,0,0,0,,And do make addresses and dot slash addresses.
Dialogue: 0,0:26:20.61,0:26:24.93,中文,,0,0,0,,执行 make addresses 和 ./addresses。
Dialogue: 0,0:26:24.93,0:26:27.81,英文,,0,0,0,,And there it is, exactly the same thing.
Dialogue: 0,0:26:24.93,0:26:27.81,中文,,0,0,0,,结果完全一样。
Dialogue: 0,0:26:27.81,0:26:30.61,英文,,0,0,0,,Now, in and of itself, not that useful yet.
Dialogue: 0,0:26:27.81,0:26:30.61,中文,,0,0,0,,目前为止，它本身并没有那么有用。
Dialogue: 0,0:26:30.61,0:26:41.80,英文,,0,0,0,,But the fact that you can now access the addresses of things in memory means that we'll be able to build things and construct things and link things together by knowing where they live, so to speak.
Dialogue: 0,0:26:30.61,0:26:41.80,中文,,0,0,0,,但你现在可以访问内存中事物地址的事实意味着，我们将能够通过知道它们所在的位置来构建事物、构造事物和将事物链接在一起。
Dialogue: 0,0:26:41.80,0:26:44.56,英文,,0,0,0,,So any questions on this technique thus far?
Dialogue: 0,0:26:41.80,0:26:44.56,中文,,0,0,0,,到目前为止，对这项技术有什么问题吗？
Dialogue: 0,0:26:44.56,0:26:49.48,英文,,0,0,0,,Yeah?
Dialogue: 0,0:26:44.56,0:26:49.48,中文,,0,0,0,,是吗？
Dialogue: 0,0:26:49.48,0:26:50.14,英文,,0,0,0,,Oh, good question.
Dialogue: 0,0:26:49.48,0:26:50.14,中文,,0,0,0,,问得好。
Dialogue: 0,0:26:50.14,0:26:52.57,英文,,0,0,0,,On line 6, must it be star, p, and ampersand?
Dialogue: 0,0:26:50.14,0:26:52.57,中文,,0,0,0,,在第 6 行，必须是星号、p 和 “&” 符号吗？
Dialogue: 0,0:26:52.57,0:26:55.41,英文,,0,0,0,,And in this case, yes, because what am I doing?
Dialogue: 0,0:26:52.57,0:26:55.41,中文,,0,0,0,,在这种情况下，是的，因为我在做什么？
Dialogue: 0,0:26:55.41,0:27:04.82,英文,,0,0,0,,On the left, and I'll get rid of the equal sign for now, this would give me a variable called p that's not an integer per se, but that's the address of an integer.
Dialogue: 0,0:26:55.41,0:27:04.82,中文,,0,0,0,,在左边，我现在先去掉等号，这会给我一个名为 p 的变量，它本身不是整数，而是一个整数的地址。
Dialogue: 0,0:27:04.82,0:27:08.20,英文,,0,0,0,,But without the equal sign, I'm not storing anything in that variable.
Dialogue: 0,0:27:04.82,0:27:08.20,中文,,0,0,0,,但是如果没有等号，我不会在这个变量中存储任何东西。
Dialogue: 0,0:27:08.20,0:27:24.11,英文,,0,0,0,,So by adding the equal sign and then ampersand n, I am explicitly figuring out with ampersand what the address of n is, which already exists per line 5, and tucking it away in this new variable called p. Other questions?
Dialogue: 0,0:27:08.20,0:27:24.11,中文,,0,0,0,,所以通过添加等号和 “&” 符号 n，我用 “&” 符号\N明确地找出了 n 的地址（n 已经在第 5 行存在），并将其存储在这个名为 p 的新变量中。还有其他问题吗？
Dialogue: 0,0:27:24.11,0:27:27.32,英文,,0,0,0,,Yeah.
Dialogue: 0,0:27:24.11,0:27:27.32,中文,,0,0,0,,有。
Dialogue: 0,0:27:27.32,0:27:27.70,英文,,0,0,0,,Good question.
Dialogue: 0,0:27:27.32,0:27:27.70,中文,,0,0,0,,好问题。
Dialogue: 0,0:27:27.70,0:27:30.71,英文,,0,0,0,,Every time I run the program, it uses up a different piece of memory.
Dialogue: 0,0:27:27.70,0:27:30.71,中文,,0,0,0,,每次我运行程序时，它都会占用一块不同的内存。
Dialogue: 0,0:27:30.71,0:27:31.85,英文,,0,0,0,,Short answer, yes.
Dialogue: 0,0:27:30.71,0:27:31.85,中文,,0,0,0,,简而言之，是的。
Dialogue: 0,0:27:31.85,0:27:35.19,英文,,0,0,0,,Computers, though, long story short, also have something called virtual memory.
Dialogue: 0,0:27:31.85,0:27:35.19,中文,,0,0,0,,不过，长话短说，计算机还有虚拟内存。
Dialogue: 0,0:27:35.19,0:27:40.78,英文,,0,0,0,,So if you run it again and again, you might actually see the same addresses on the same Mac or PC or cloud-based server.
Dialogue: 0,0:27:35.19,0:27:40.78,中文,,0,0,0,,如果你在一台 Mac、PC 或基于云的服务器上反复运行它，你实际上可能会看到相同的地址。
Dialogue: 0,0:27:40.78,0:27:44.72,英文,,0,0,0,,But we'll see in a bit where, at a high level, it's laid out.
Dialogue: 0,0:27:40.78,0:27:44.72,中文,,0,0,0,,但我们稍后会看到它在高级别上的布局。
Dialogue: 0,0:27:44.72,0:27:47.62,英文,,0,0,0,,But it will always exist at some address.
Dialogue: 0,0:27:44.72,0:27:47.62,中文,,0,0,0,,但它总是存在于某个地址。
Dialogue: 0,0:27:47.62,0:27:50.72,英文,,0,0,0,,Good question, yeah.
Dialogue: 0,0:27:47.62,0:27:50.72,中文,,0,0,0,,问得好。
Dialogue: 0,0:27:50.72,0:28:08.27,英文,,0,0,0,,Correct, ampersand n is the address of n, and int star p is a pointer called p. And honestly, in an ideal world, if C were made today and not decades ago, when humans were first creating languages, ideally, we would just have a data type called pointer.
Dialogue: 0,0:27:50.72,0:28:08.27,中文,,0,0,0,,没错，“&” n 是 n 的地址，int *p 是一个名为 p 的指针。说实话，在理想情况下，\N如果 C 语言是今天而不是几十年前人类刚开始创造语言的时候发明的，理想情况下，我们应该只有一个叫做指针的数据类型。
Dialogue: 0,0:28:08.27,0:28:12.48,英文,,0,0,0,,And then this would be a little less complicated, because it would literally be what it says.
Dialogue: 0,0:28:08.27,0:28:12.48,中文,,0,0,0,,那样的话，这就没那么复杂了，因为它就如字面意思。
Dialogue: 0,0:28:12.48,0:28:18.08,英文,,0,0,0,,The humans who invented C didn't do this, but this is the idea. So pointer is not a legitimate word in the code.
Dialogue: 0,0:28:12.48,0:28:18.08,中文,,0,0,0,,发明 C 语言的人并没有这样做，但这就是想法。所以指针在代码中不是一个合法的词。
Dialogue: 0,0:28:18.08,0:28:20.26,英文,,0,0,0,,It is a term of art in English.
Dialogue: 0,0:28:18.08,0:28:20.26,中文,,0,0,0,,它是英语中的一个专业术语。
Dialogue: 0,0:28:20.26,0:28:21.86,英文,,0,0,0,,But this is really just the idea.
Dialogue: 0,0:28:20.26,0:28:21.86,中文,,0,0,0,,但这只是一种思路。
Dialogue: 0,0:28:21.86,0:28:29.47,英文,,0,0,0,,But the way you express pointer as a data type is a little more cryptic as int star p here.
Dialogue: 0,0:28:21.86,0:28:29.47,中文,,0,0,0,,但用 `int *p` 表示指针数据类型的方式更隐晦一些。
Dialogue: 0,0:28:29.47,0:28:34.75,英文,,0,0,0,,But notice, in line 7, when I print out p, I don't use a star.
Dialogue: 0,0:28:29.47,0:28:34.75,中文,,0,0,0,,注意，在第 7 行，当我打印 p 时，我没有使用星号。
Dialogue: 0,0:28:34.75,0:28:39.43,英文,,0,0,0,,I don't use an ampersand y. I literally just want to print the value of p. And we've been doing that since week 1.
Dialogue: 0,0:28:34.75,0:28:39.43,中文,,0,0,0,,我没有用 &y。我只是想打印 p 的值。我们从第一周就开始这样做了。
Dialogue: 0,0:28:39.43,0:28:42.98,英文,,0,0,0,,If you want to print a variable, just describe the variable by its name.
Dialogue: 0,0:28:39.43,0:28:42.98,中文,,0,0,0,,如果要打印变量，只需用变量名描述它。
Dialogue: 0,0:28:42.98,0:28:44.68,英文,,0,0,0,,No special syntax.
Dialogue: 0,0:28:42.98,0:28:44.68,中文,,0,0,0,,不需要特殊的语法。
Dialogue: 0,0:28:44.68,0:28:48.29,英文,,0,0,0,,Any other questions on this thus far?
Dialogue: 0,0:28:44.68,0:28:48.29,中文,,0,0,0,,到目前为止，还有其他问题吗？
Dialogue: 0,0:28:48.29,0:28:50.65,英文,,0,0,0,,What's the advantage of using pointers?
Dialogue: 0,0:28:48.29,0:28:50.65,中文,,0,0,0,,使用指针有什么好处？
Dialogue: 0,0:28:50.65,0:28:53.73,英文,,0,0,0,,With pointers, we'll see today some applications of them.
Dialogue: 0,0:28:50.65,0:28:53.73,中文,,0,0,0,,今天我们将看到指针的一些应用。
Dialogue: 0,0:28:53.73,0:29:04.91,英文,,0,0,0,,Really, the idea is going to come to fruition next week when we're going to create what are called data structures in memory, where we can build not just, for instance, one-dimensional data structures like an array.
Dialogue: 0,0:28:53.73,0:29:04.91,中文,,0,0,0,,实际上，这个想法将在下周实现，届时我们将创建内存中的数据结构，我们不仅可以构建一维数据结构，例如数组。
Dialogue: 0,0:29:04.91,0:29:13.30,英文,,0,0,0,,We'll see next week we can actually create the equivalent of two-dimensional data structures or even three-dimensional data structures by using these addresses and sort of linking things together.
Dialogue: 0,0:29:04.91,0:29:13.30,中文,,0,0,0,,下周我们将看到，我们可以通过使用这些地址并将事物链接在一起来创建等效的二维数据结构，甚至是三维数据结构。
Dialogue: 0,0:29:13.30,0:29:23.04,英文,,0,0,0,,And we'll see the beginnings of that this week, but for now, Focus, at least for now, on just really the syntax and what these building blocks can do for us.
Dialogue: 0,0:29:13.30,0:29:23.04,中文,,0,0,0,,我们将在本周看到它的开头，但现在，至少现在，只关注语法以及这些构建块可以为我们做什么。
Dialogue: 0,0:29:23.04,0:29:27.96,英文,,0,0,0,,Does the p pointer have to be an integer?
Dialogue: 0,0:29:23.04,0:29:27.96,中文,,0,0,0,,p 指针必须是整数吗？
Dialogue: 0,0:29:27.96,0:29:29.49,英文,,0,0,0,,Short answer, no. And we'll come back to this.
Dialogue: 0,0:29:27.96,0:29:29.49,中文,,0,0,0,,简而言之，不是。我们稍后会回到这一点。
Dialogue: 0,0:29:29.49,0:29:32.81,英文,,0,0,0,,For now, for the sake of discussion, we're only dealing with integers, like the number 50.
Dialogue: 0,0:29:29.49,0:29:32.81,中文,,0,0,0,,目前，为了讨论，我们只处理整数，比如数字 50。
Dialogue: 0,0:29:32.81,0:29:35.47,英文,,0,0,0,,You mentioned strings or characters.
Dialogue: 0,0:29:32.81,0:29:35.47,中文,,0,0,0,,你提到了字符串或字符。
Dialogue: 0,0:29:35.47,0:29:35.99,英文,,0,0,0,,Absolutely.
Dialogue: 0,0:29:35.47,0:29:35.99,中文,,0,0,0,,没错。
Dialogue: 0,0:29:35.99,0:29:38.05,英文,,0,0,0,,We're about to go there soon.
Dialogue: 0,0:29:35.99,0:29:38.05,中文,,0,0,0,,我们马上就会讲到。
Dialogue: 0,0:29:38.05,0:29:41.55,英文,,0,0,0,,So you can use the address of anything you want in the computer's memory.
Dialogue: 0,0:29:38.05,0:29:41.55,中文,,0,0,0,,所以你可以使用计算机内存中任何你想要的东西的地址。
Dialogue: 0,0:29:41.55,0:29:49.04,英文,,0,0,0,,So in fact, let's translate this now to just the same picture, just to help you wrap your minds around what these two lines of code really fundamentally are doing.
Dialogue: 0,0:29:41.55,0:29:49.04,中文,,0,0,0,,实际上，现在让我们把它转换成相同的图片，只是为了帮助你理解这两行代码的根本作用。
Dialogue: 0,0:29:49.04,0:29:55.99,英文,,0,0,0,,So if I come back to my grid of memory here, let's plop the number 50 in the variable n at the bottom right like it was before.
Dialogue: 0,0:29:49.04,0:29:55.99,中文,,0,0,0,,如果回到我们的内存网格，像之前那样，把数字 50 放到右下角的变量 n 中。
Dialogue: 0,0:29:55.99,0:29:58.13,英文,,0,0,0,,So this is that first line of code as before.
Dialogue: 0,0:29:55.99,0:29:58.13,中文,,0,0,0,,这就是之前的代码的第一行。
Dialogue: 0,0:29:58.13,0:30:02.97,英文,,0,0,0,,But with the new second line of code, as soon as I create p, what do I do?
Dialogue: 0,0:29:58.13,0:30:02.97,中文,,0,0,0,,但是有了新的第二行代码，一旦我创建了 p，我会做什么？
Dialogue: 0,0:30:02.97,0:30:09.02,英文,,0,0,0,,Well, first, remember that n lives somewhere in the computer's memory. Usually, I don't care precisely where it is.
Dialogue: 0,0:30:02.97,0:30:09.02,中文,,0,0,0,,首先，记住 n 存储在计算机内存的某个地方，通常我不关心它的确切位置。
Dialogue: 0,0:30:09.02,0:30:14.64,英文,,0,0,0,,But for the sake of discussion, let's suppose it's at 0x123, which is easier to say than where it actually ended up.
Dialogue: 0,0:30:09.02,0:30:14.64,中文,,0,0,0,,但是为了便于讨论，假设它在 0x123，这比它实际存储的位置更容易描述。
Dialogue: 0,0:30:14.64,0:30:15.92,英文,,0,0,0,,And now, what is p?
Dialogue: 0,0:30:14.64,0:30:15.92,中文,,0,0,0,,那么 p 是什么呢？
Dialogue: 0,0:30:15.92,0:30:17.70,英文,,0,0,0,,Well, p is just another variable.
Dialogue: 0,0:30:15.92,0:30:17.70,中文,,0,0,0,,p 只是另一个变量。
Dialogue: 0,0:30:17.70,0:30:19.20,英文,,0,0,0,,And variables live in memory, too.
Dialogue: 0,0:30:17.70,0:30:19.20,中文,,0,0,0,,变量也存储在内存中。
Dialogue: 0,0:30:19.20,0:30:22.68,英文,,0,0,0,,So let me just hypothesize that p lives up here.
Dialogue: 0,0:30:19.20,0:30:22.68,中文,,0,0,0,,假设 p 存储在这里。
Dialogue: 0,0:30:22.68,0:30:34.59,英文,,0,0,0,,And it turns out that p, once you assign it, the value of ampersand n means that c will take a look at the variable n, realize, oh, it lives at 0x123.
Dialogue: 0,0:30:22.68,0:30:34.59,中文,,0,0,0,,事实证明，一旦你给 p 赋值，"&n" 的值意味着 C 语言会查看变量 n，然后意识到它存储在 0x123。
Dialogue: 0,0:30:34.59,0:30:39.73,英文,,0,0,0,,And what goes in the value of p is literally 0x123.
Dialogue: 0,0:30:34.59,0:30:39.73,中文,,0,0,0,,p 的值就是 0x123。
Dialogue: 0,0:30:39.73,0:30:42.53,英文,,0,0,0,,So again, it's still an integer, which is confusing.
Dialogue: 0,0:30:39.73,0:30:42.53,中文,,0,0,0,,它仍然是一个整数，这可能让人感到困惑。
Dialogue: 0,0:30:42.53,0:30:45.79,英文,,0,0,0,,But it's technically an integer being used as an address.
Dialogue: 0,0:30:42.53,0:30:45.79,中文,,0,0,0,,但从技术上讲，它是一个被用作地址的整数。
Dialogue: 0,0:30:45.79,0:30:48.31,英文,,0,0,0,,And now just a prompt here.
Dialogue: 0,0:30:45.79,0:30:48.31,中文,,0,0,0,,这里有一个提示。
Dialogue: 0,0:30:48.31,0:30:49.95,英文,,0,0,0,,Notice that this pointer is pretty darn big.
Dialogue: 0,0:30:48.31,0:30:49.95,中文,,0,0,0,,注意，这个指针相当大。
Dialogue: 0,0:30:49.95,0:30:52.15,英文,,0,0,0,,It's like eight squares.
Dialogue: 0,0:30:49.95,0:30:52.15,中文,,0,0,0,,它有八个格子那么大。
Dialogue: 0,0:30:52.15,0:30:53.33,英文,,0,0,0,,What's the implication of that?
Dialogue: 0,0:30:52.15,0:30:53.33,中文,,0,0,0,,这意味着什么？
Dialogue: 0,0:30:53.33,0:30:55.15,英文,,0,0,0,,Because I did that deliberately.
Dialogue: 0,0:30:53.33,0:30:55.15,中文,,0,0,0,,我故意这样做的。
Dialogue: 0,0:30:55.15,0:31:00.05,英文,,0,0,0,,How big must a pointer apparently be in most modern systems, would you say?
Dialogue: 0,0:30:55.15,0:31:00.05,中文,,0,0,0,,你觉得在大多数现代系统中，指针的大小应该是多少？
Dialogue: 0,0:31:00.05,0:31:01.47,英文,,0,0,0,,OK, good. Computers today are very big.
Dialogue: 0,0:31:00.05,0:31:01.47,中文,,0,0,0,,现在的计算机内存都很大。
Dialogue: 0,0:31:01.47,0:31:03.33,英文,,0,0,0,,You have gigabytes of RAM in your computer.
Dialogue: 0,0:31:01.47,0:31:03.33,中文,,0,0,0,,你的电脑里有 GB 量级的内存。
Dialogue: 0,0:31:03.33,0:31:07.63,英文,,0,0,0,,You therefore need big pointers to be able to point at memory that's conceptually pretty far away.
Dialogue: 0,0:31:03.33,0:31:07.63,中文,,0,0,0,,所以你需要大的指针来指向概念上很远的内存。
Dialogue: 0,0:31:07.63,0:31:10.97,英文,,0,0,0,,So to be clear, how many bytes does a pointer apparently take up?
Dialogue: 0,0:31:07.63,0:31:10.97,中文,,0,0,0,,说清楚点，一个指针占用多少字节？
Dialogue: 0,0:31:10.97,0:31:12.83,英文,,0,0,0,,Well, it seems to take up eight in total.
Dialogue: 0,0:31:10.97,0:31:12.83,中文,,0,0,0,,看起来总共占用了 8 个。
Dialogue: 0,0:31:12.83,0:31:15.39,英文,,0,0,0,,Integers by convention nowadays are usually four.
Dialogue: 0,0:31:12.83,0:31:15.39,中文,,0,0,0,,按照现在的惯例，整数通常是 4 个字节。
Dialogue: 0,0:31:15.39,0:31:18.59,英文,,0,0,0,,Pointers, though, nowadays are typically eight in this case.
Dialogue: 0,0:31:15.39,0:31:18.59,中文,,0,0,0,,不过现在指针通常是 8 个字节。
Dialogue: 0,0:31:18.59,0:31:24.49,英文,,0,0,0,,So I'm drawing it in a manner consistent with the reality, even though at the end of the day, it's not really that interesting what values are in here.
Dialogue: 0,0:31:18.59,0:31:24.49,中文,,0,0,0,,所以我的画法与现实一致，尽管最终指针里是什么值并不重要。
Dialogue: 0,0:31:24.49,0:31:27.13,英文,,0,0,0,,In fact, let's emerge from these weeds.
Dialogue: 0,0:31:24.49,0:31:27.13,中文,,0,0,0,,事实上，让我们跳出这些细节。
Dialogue: 0,0:31:27.13,0:31:32.95,英文,,0,0,0,,I don't really care what else is going on in my computer's memory at the moment, because I've only got those two lines of juicy code.
Dialogue: 0,0:31:27.13,0:31:32.95,中文,,0,0,0,,我不在乎我的电脑内存里还有什么，因为我只写了两行代码。
Dialogue: 0,0:31:32.95,0:31:36.55,英文,,0,0,0,,Defining n and defining p. So let's hide all of the other squares.
Dialogue: 0,0:31:32.95,0:31:36.55,中文,,0,0,0,,定义了 n 和 p，所以我们把其他的方块都隐藏起来。
Dialogue: 0,0:31:36.55,0:31:46.82,英文,,0,0,0,,And honestly, I mean it when I say that programmers need to know that a variable exists somewhere in memory and needs to be able to get that address using the ampersand.
Dialogue: 0,0:31:36.55,0:31:46.82,中文,,0,0,0,,我是认真的，程序员需要知道变量存在于内存中的某个位置，并且需要能够使用 & 符号获取它的地址。
Dialogue: 0,0:31:46.82,0:31:50.14,英文,,0,0,0,,But you're never going to printf, like I did, the actual address.
Dialogue: 0,0:31:46.82,0:31:50.14,中文,,0,0,0,,但你永远不会像我一样用 printf 打印出实际地址。
Dialogue: 0,0:31:50.14,0:31:53.82,英文,,0,0,0,,It's not generally interesting, unless you're debugging your code.
Dialogue: 0,0:31:50.14,0:31:53.82,中文,,0,0,0,,除非是在调试代码，否则地址通常没什么意思。
Dialogue: 0,0:31:53.82,0:31:58.36,英文,,0,0,0,,But you're not going to start typing out crazy 0x numbers in your code to move things around.
Dialogue: 0,0:31:53.82,0:31:58.36,中文,,0,0,0,,你也不会在代码中输入一堆 0x 开头的数字来移动数据。
Dialogue: 0,0:31:58.36,0:32:01.88,英文,,0,0,0,,You just need to know that the computer can figure out where things are.
Dialogue: 0,0:31:58.36,0:32:01.88,中文,,0,0,0,,你只需要知道计算机能找到数据的位置。
Dialogue: 0,0:32:01.88,0:32:05.79,英文,,0,0,0,,So frankly, by that logic, who cares that it's 0x123, right?
Dialogue: 0,0:32:01.88,0:32:05.79,中文,,0,0,0,,坦白说，按照这个逻辑，谁在乎地址是 0x123 呢？
Dialogue: 0,0:32:05.79,0:32:08.61,英文,,0,0,0,,Tomorrow it could be 0x456 or something else.
Dialogue: 0,0:32:05.79,0:32:08.61,中文,,0,0,0,,明天它可能就变成 0x456 或别的什么了。
Dialogue: 0,0:32:08.61,0:32:16.03,英文,,0,0,0,,So one of the ways to think of a pointer is literally as a variable that points at something else.
Dialogue: 0,0:32:08.61,0:32:16.03,中文,,0,0,0,,所以理解指针的一种方式是，它就是一个指向其他东西的变量。
Dialogue: 0,0:32:16.03,0:32:22.15,英文,,0,0,0,,And indeed, in this case, P, yeah, technically, it has an address. And yeah, technically, it's 0x123 in the story.
Dialogue: 0,0:32:16.03,0:32:22.15,中文,,0,0,0,,实际上，在这个例子中，P 确实有地址，而且确实是 0x123。
Dialogue: 0,0:32:22.15,0:32:23.19,英文,,0,0,0,,But honestly, who cares?
Dialogue: 0,0:32:22.15,0:32:23.19,中文,,0,0,0,,但说真的，谁在乎呢？
Dialogue: 0,0:32:23.19,0:32:30.36,英文,,0,0,0,,I just need to know that using P, I can get to the value n. And so what are these addresses?
Dialogue: 0,0:32:23.19,0:32:30.36,中文,,0,0,0,,我只需要知道用 p 可以获得值 n，所以这些地址是什么？
Dialogue: 0,0:32:30.36,0:32:34.44,英文,,0,0,0,,And in fact, if Carter wouldn't mind joining me up here for a moment, what are these addresses?
Dialogue: 0,0:32:30.36,0:32:34.44,中文,,0,0,0,,事实上，如果卡特不介意上来一下，这些地址是什么？
Dialogue: 0,0:32:34.44,0:32:38.72,英文,,0,0,0,,Well, just like in our human world, we have mailboxes, even though you might not check it very frequently nowadays.
Dialogue: 0,0:32:34.44,0:32:38.72,中文,,0,0,0,,就像在我们人类世界中，我们有邮箱，即使你现在可能不经常查看它。
Dialogue: 0,0:32:38.72,0:32:43.10,英文,,0,0,0,,But to get physical mail, every home, every business has a unique address.
Dialogue: 0,0:32:38.72,0:32:43.10,中文,,0,0,0,,但要接收实体邮件，每个家庭、每个企业都有一个唯一的地址。
Dialogue: 0,0:32:43.10,0:32:49.92,英文,,0,0,0,,The Science and Engineering Complex is 150 Western Avenue, Austin, Massachusetts, 02134 USA.
Dialogue: 0,0:32:43.10,0:32:49.92,中文,,0,0,0,,科学与工程中心是美国马萨诸塞州奥斯汀市西部大道 150 号，邮编 02134。
Dialogue: 0,0:32:49.92,0:32:53.92,英文,,0,0,0,,And theoretically, that uniquely identifies that building in the world.
Dialogue: 0,0:32:49.92,0:32:53.92,中文,,0,0,0,,从理论上讲，这能唯一标识世界上那栋建筑。
Dialogue: 0,0:32:53.92,0:32:56.29,英文,,0,0,0,,Well, here we have two mailboxes.
Dialogue: 0,0:32:53.92,0:32:56.29,中文,,0,0,0,,这里有两个邮箱。
Dialogue: 0,0:32:56.29,0:33:02.09,英文,,0,0,0,,Over here, we have a value n that happens to live, I'll claim, at address 0x123.
Dialogue: 0,0:32:56.29,0:33:02.09,中文,,0,0,0,,这边，我们有一个值 n，我声称它位于地址 0x123。
Dialogue: 0,0:33:02.09,0:33:06.09,英文,,0,0,0,,And then over here, I claim, there's another address
Dialogue: 0,0:33:02.09,0:33:06.09,中文,,0,0,0,,然后这边，我声称，还有另一个地址。
Dialogue: 0,0:33:06.09,0:33:11.61,英文,,0,0,0,,Call it by name p. I don't actually care where it is, even though it definitely exists somewhere in the computer's memory.
Dialogue: 0,0:33:06.09,0:33:11.61,中文,,0,0,0,,用名称 p 来称呼它，我并不关心它在哪里，即使它肯定存在于计算机内存中的某个地方。
Dialogue: 0,0:33:11.61,0:33:19.71,英文,,0,0,0,,But if this is p, which is a variable, and that's n, another variable, ideally, this mailbox would be twice as big because of the number of bytes used.
Dialogue: 0,0:33:11.61,0:33:19.71,中文,,0,0,0,,但如果这是 P（一个变量），而那是 N（另一个变量），理想情况下，由于使用的字节数不同，这个邮箱应该大一倍。
Dialogue: 0,0:33:19.71,0:33:22.07,英文,,0,0,0,,But Home Depot only had identical-sized mailboxes.
Dialogue: 0,0:33:19.71,0:33:22.07,中文,,0,0,0,,但 Home Depot 只出售相同大小的邮箱。
Dialogue: 0,0:33:22.07,0:33:23.95,英文,,0,0,0,,But here is p, one variable.
Dialogue: 0,0:33:22.07,0:33:23.95,中文,,0,0,0,,但这是 P，一个变量。
Dialogue: 0,0:33:23.95,0:33:25.83,英文,,0,0,0,,There is n, another variable.
Dialogue: 0,0:33:23.95,0:33:25.83,中文,,0,0,0,,那是 N，另一个变量。
Dialogue: 0,0:33:25.83,0:33:33.08,英文,,0,0,0,,If I open up this mailbox, what should I find inside of it based on our story thus far?
Dialogue: 0,0:33:25.83,0:33:33.08,中文,,0,0,0,,如果我打开这个邮箱，根据我们目前的故事，我应该在里面找到什么？
Dialogue: 0,0:33:33.08,0:33:37.09,英文,,0,0,0,,Like what value will I pull out dramatically in just a moment?
Dialogue: 0,0:33:33.08,0:33:37.09,中文,,0,0,0,,比如过一会儿我会戏剧性地拿出什么价值？
Dialogue: 0,0:33:37.09,0:33:39.79,英文,,0,0,0,,Yeah, I think 0x123.
Dialogue: 0,0:33:37.09,0:33:39.79,中文,,0,0,0,,我认为是 0x123。
Dialogue: 0,0:33:39.79,0:33:50.33,英文,,0,0,0,,Now, using this, you can kind of think of this as like x marks the spot, no pun intended, where I can now walk around the computer's memory and find my way to that location by sort of following the treasure map.
Dialogue: 0,0:33:39.79,0:33:50.33,中文,,0,0,0,,现在，用这个，你可以把它想象成“X 标记位置”（没有双关语的意思），我现在可以在计算机内存中四处走动，通过跟踪藏宝图找到那个位置。
Dialogue: 0,0:33:50.33,0:33:59.39,英文,,0,0,0,,Or if I want to more dramatically, thanks to our little Yale foam finger here, you can think of it more abstractly as p is just pointing at n. OK, that's not going over well.
Dialogue: 0,0:33:50.33,0:33:59.39,中文,,0,0,0,,或者，如果我想更戏剧化一点，感谢我们的小耶鲁泡沫手指，你可以更抽象地把它想象成 p 只是指向 N，好吧，这不太顺利。
Dialogue: 0,0:33:59.39,0:34:01.11,英文,,0,0,0,,So let's switch over to the Harvard one.
Dialogue: 0,0:33:59.39,0:34:01.11,中文,,0,0,0,,那我们换成哈佛的吧。
Dialogue: 0,0:34:01.11,0:34:06.12,英文,,0,0,0,,So p is pointing.
Dialogue: 0,0:34:01.11,0:34:06.12,中文,,0,0,0,,p 指向了。
Dialogue: 0,0:34:06.12,0:34:19.34,英文,,0,0,0,,So P is pointing at N. And so it turns out we will be able to write code now that will do the equivalent of me walking over to N. But for now, Carter, if you want to reveal what's in the mailbox, we should see, indeed, the number 50.
Dialogue: 0,0:34:06.12,0:34:19.34,中文,,0,0,0,,P 指向了 N，我们能写出代码实现我走向 N 的操作，但现在，Carter，如果你想揭晓邮箱里的内容，应该能看到数字 50。
Dialogue: 0,0:34:19.34,0:34:22.18,英文,,0,0,0,,So that's really all that's. Oh, I feel Carter's waiting for applause.
Dialogue: 0,0:34:19.34,0:34:22.18,中文,,0,0,0,,这就是全部内容了，我感觉 Carter 在等待掌声。
Dialogue: 0,0:34:22.18,0:34:28.32,英文,,0,0,0,,So really, well, nicely done.
Dialogue: 0,0:34:22.18,0:34:28.32,中文,,0,0,0,,做得很好。
Dialogue: 0,0:34:28.32,0:34:29.06,英文,,0,0,0,,Thank you.
Dialogue: 0,0:34:28.32,0:34:29.06,中文,,0,0,0,,谢谢。
Dialogue: 0,0:34:29.06,0:34:31.92,英文,,0,0,0,,So that's just like a physical metaphor of what's going on here.
Dialogue: 0,0:34:29.06,0:34:31.92,中文,,0,0,0,,这就像这里发生事情的物理比喻。
Dialogue: 0,0:34:31.92,0:34:33.82,英文,,0,0,0,,In one variable, we have an address.
Dialogue: 0,0:34:31.92,0:34:33.82,中文,,0,0,0,,一个变量中存储地址。
Dialogue: 0,0:34:33.82,0:34:36.20,英文,,0,0,0,,And that variable, by convention, is called a pointer.
Dialogue: 0,0:34:33.82,0:34:36.20,中文,,0,0,0,,按照惯例，这个变量被称为指针。
Dialogue: 0,0:34:36.20,0:34:44.20,英文,,0,0,0,,In the other variable, per week one, we just have a value like n. And you can, yes, follow the map and walk yourself to that particular address.
Dialogue: 0,0:34:36.20,0:34:44.20,中文,,0,0,0,,在另一个变量中，比如第一周的例子，我们只有一个值，比如 n，你可以按照地图走到特定的地址。
Dialogue: 0,0:34:44.20,0:34:45.90,英文,,0,0,0,,And we'll see how to do that in code.
Dialogue: 0,0:34:44.20,0:34:45.90,中文,,0,0,0,,之后我们会学习如何在代码中实现。
Dialogue: 0,0:34:45.90,0:34:54.42,英文,,0,0,0,,But what's really interesting is this abstraction, that pointers literally, or really, I guess, figuratively, point at some other value in memory.
Dialogue: 0,0:34:45.90,0:34:54.42,中文,,0,0,0,,但真正有趣的是这种抽象概念，指针可以指向内存中的某个值。
Dialogue: 0,0:34:54.42,0:34:58.57,英文,,0,0,0,,All right, questions then on pointers in this form.
Dialogue: 0,0:34:54.42,0:34:58.57,中文,,0,0,0,,关于指针的这种形式，有问题吗？
Dialogue: 0,0:34:58.57,0:34:59.89,英文,,0,0,0,,Can pointers point to each other?
Dialogue: 0,0:34:58.57,0:34:59.89,中文,,0,0,0,,指针可以互相指向吗？
Dialogue: 0,0:34:59.89,0:35:02.60,英文,,0,0,0,,So yes, there's things called double pointers.
Dialogue: 0,0:34:59.89,0:35:02.60,中文,,0,0,0,,可以，有叫做双指针的东西。
Dialogue: 0,0:35:02.60,0:35:04.10,英文,,0,0,0,,We're not going to see them anytime soon.
Dialogue: 0,0:35:02.60,0:35:04.10,中文,,0,0,0,,我们暂时不会接触到它们。
Dialogue: 0,0:35:04.10,0:35:08.52,英文,,0,0,0,,But using star star, you can express an address of an address.
Dialogue: 0,0:35:04.10,0:35:08.52,中文,,0,0,0,,但使用 ** 可以表示地址的地址。
Dialogue: 0,0:35:08.52,0:35:10.42,英文,,0,0,0,,But we won't see that just yet.
Dialogue: 0,0:35:08.52,0:35:10.42,中文,,0,0,0,,但我们现在还不会接触到。
Dialogue: 0,0:35:10.42,0:35:14.06,英文,,0,0,0,,Other questions on pointers?
Dialogue: 0,0:35:10.42,0:35:14.06,中文,,0,0,0,,关于指针还有其他问题吗？
Dialogue: 0,0:35:14.06,0:35:19.40,英文,,0,0,0,,Yeah, in front.
Dialogue: 0,0:35:14.06,0:35:19.40,中文,,0,0,0,,前面那位。
Dialogue: 0,0:35:19.40,0:35:21.96,英文,,0,0,0,,So to summarize, are arrays then pointers?
Dialogue: 0,0:35:19.40,0:35:21.96,中文,,0,0,0,,总结一下，数组是指针吗？
Dialogue: 0,0:35:21.96,0:35:23.96,英文,,0,0,0,,So short answer, there's a relationship.
Dialogue: 0,0:35:21.96,0:35:23.96,中文,,0,0,0,,所以简单来说，两者之间有关系。
Dialogue: 0,0:35:23.96,0:35:25.50,英文,,0,0,0,,And we'll come back to that in a little bit.
Dialogue: 0,0:35:23.96,0:35:25.50,中文,,0,0,0,,我们稍后会回过头来讨论这个问题。
Dialogue: 0,0:35:25.50,0:35:28.16,英文,,0,0,0,,But arrays are technically different from pointers.
Dialogue: 0,0:35:25.50,0:35:28.16,中文,,0,0,0,,但从技术上讲，数组与指针不同。
Dialogue: 0,0:35:28.16,0:35:31.59,英文,,0,0,0,,But we're going to be able to blur the lines a little bit by using one like the other.
Dialogue: 0,0:35:28.16,0:35:31.59,中文,,0,0,0,,但我们可以通过像使用另一个一样使用一个，来稍微模糊这两者之间的界限。
Dialogue: 0,0:35:31.59,0:35:34.27,英文,,0,0,0,,But let me come back to that in just a bit of time.
Dialogue: 0,0:35:31.59,0:35:34.27,中文,,0,0,0,,但我稍后会回过头来讨论这个问题。
Dialogue: 0,0:35:34.27,0:35:47.89,英文,,0,0,0,,All right, so if we have now this mental model, if you will, of what a pointer is in memory, I think we can start to peel back a layer of simplification that we've been assuming for the past few weeks since week one.
Dialogue: 0,0:35:34.27,0:35:47.89,中文,,0,0,0,,好了，如果我们现在对指针在内存中的概念模型有了了解，我认为我们可以开始揭开过去几周（从第一周开始）我们一直在假设的简化层。
Dialogue: 0,0:35:47.89,0:35:51.03,英文,,0,0,0,,So a string recall is a sequence of characters.
Dialogue: 0,0:35:47.89,0:35:51.03,中文,,0,0,0,,回忆一下，字符串就是字符序列。
Dialogue: 0,0:35:51.03,0:35:57.49,英文,,0,0,0,,So if you want to create a string that says HI in all caps and an exclamation point, we do string s equals quote unquote HI.
Dialogue: 0,0:35:51.03,0:35:57.49,中文,,0,0,0,,因此，如果要创建一个字符串，表示全部大写的 HI 和一个感叹号，我们可以这样做：string s 等于引号 HI。
Dialogue: 0,0:35:57.49,0:36:06.44,英文,,0,0,0,,And we can hard code it like this, or we could use get string. But for now, just assume that I hard coded it into my code to always say HI in all caps with an exclamation point.
Dialogue: 0,0:35:57.49,0:36:06.44,中文,,0,0,0,,我们可以像这样对其进行硬编码，也可以使用 get_string。但现在，我们假设我已将其硬编码到代码中，使其始终表示全部大写的 HI 和一个感叹号。
Dialogue: 0,0:36:06.44,0:36:08.50,英文,,0,0,0,,Well, what does that look like in the computer's memory?
Dialogue: 0,0:36:06.44,0:36:08.50,中文,,0,0,0,,那么，这在计算机内存中是什么样子的？
Dialogue: 0,0:36:08.50,0:36:10.62,英文,,0,0,0,,Well, let's stop looking at the entire memory.
Dialogue: 0,0:36:08.50,0:36:10.62,中文,,0,0,0,,好吧，我们不要再看整个内存了。
Dialogue: 0,0:36:10.62,0:36:12.98,英文,,0,0,0,,Let's just focus on really what's going on.
Dialogue: 0,0:36:10.62,0:36:12.98,中文,,0,0,0,,我们只关注真正发生的事情。
Dialogue: 0,0:36:12.98,0:36:20.02,英文,,0,0,0,,Once you create. a string called s, and store in it, hi, you know that a couple of things are happening.
Dialogue: 0,0:36:12.98,0:36:20.02,中文,,0,0,0,,一旦创建了一个名为 s 的字符串，并在其中存储了 HI，你就知道会发生一些事情。
Dialogue: 0,0:36:20.02,0:36:24.22,英文,,0,0,0,,H and I and the exclamation point are ending up in the computer's memory.
Dialogue: 0,0:36:20.02,0:36:24.22,中文,,0,0,0,,H、I 和感叹号最终会出现在计算机的内存中。
Dialogue: 0,0:36:24.22,0:36:29.64,英文,,0,0,0,,We know from week two that this thing, the so-called null character, N-U-L, a.k.a.
Dialogue: 0,0:36:24.22,0:36:29.64,中文,,0,0,0,,我们从第二周开始就知道，这个东西，即所谓的空字符，N-U-L，
Dialogue: 0,0:36:29.64,0:36:33.94,英文,,0,0,0,,backslash 0, is also being added for you. And it's somewhere in memory.
Dialogue: 0,0:36:29.64,0:36:33.94,中文,,0,0,0,,也就是反斜杠 0，也会自动添加进去。它在内存中的某个位置。
Dialogue: 0,0:36:33.94,0:36:36.34,英文,,0,0,0,,At the moment, I don't really care where I drew it at the bottom right.
Dialogue: 0,0:36:33.94,0:36:36.34,中文,,0,0,0,,目前，我不太关心我把它画在右下角的位置。
Dialogue: 0,0:36:36.34,0:36:37.34,英文,,0,0,0,,Yes, it has an address.
Dialogue: 0,0:36:36.34,0:36:37.34,中文,,0,0,0,,是的，它有一个地址。
Dialogue: 0,0:36:37.34,0:36:39.20,英文,,0,0,0,,But for now, it just ends up somewhere.
Dialogue: 0,0:36:37.34,0:36:39.20,中文,,0,0,0,,但现在，它只是出现在某个地方。
Dialogue: 0,0:36:39.20,0:36:43.67,英文,,0,0,0,,And in fact, here's a little visual cue as to how this happens.
Dialogue: 0,0:36:39.20,0:36:43.67,中文,,0,0,0,,事实上，这里有一个关于这一切如何发生的视觉提示。
Dialogue: 0,0:36:43.67,0:36:55.61,英文,,0,0,0,,In C, any time you use double quotes to give you a string, you can imagine that the double quotes are like a clue to not only store HI exclamation point, but also put the null character there for you.
Dialogue: 0,0:36:43.67,0:36:55.61,中文,,0,0,0,,在 C 语言中，任何时候使用双引号来表示字符串时，你可以想象双引号就像一个线索，不仅存储 HI 加感叹号，还会自动放置空字符。
Dialogue: 0,0:36:55.61,0:36:57.31,英文,,0,0,0,,And this is in contrast to what?
Dialogue: 0,0:36:55.61,0:36:57.31,中文,,0,0,0,,这与什么形成对比？
Dialogue: 0,0:36:57.31,0:37:02.40,英文,,0,0,0,,Chars, if you want individual characters, what syntax do we use instead?
Dialogue: 0,0:36:57.31,0:37:02.40,中文,,0,0,0,,对于单个字符，我们使用什么语法？
Dialogue: 0,0:37:02.40,0:37:06.16,英文,,0,0,0,,So single quotes, single quotes do not add magically a backslash 0.
Dialogue: 0,0:37:02.40,0:37:06.16,中文,,0,0,0,,单引号不会神奇地添加反斜杠 0。
Dialogue: 0,0:37:06.16,0:37:08.04,英文,,0,0,0,,They literally just store one character.
Dialogue: 0,0:37:06.16,0:37:08.04,中文,,0,0,0,,它们实际上只存储一个字符。
Dialogue: 0,0:37:08.04,0:37:09.99,英文,,0,0,0,,So again, strings have always been a little special.
Dialogue: 0,0:37:08.04,0:37:09.99,中文,,0,0,0,,所以字符串总是有点特殊。
Dialogue: 0,0:37:09.99,0:37:14.49,英文,,0,0,0,,You get some extra, an extra byte for free so that you know where the string ends.
Dialogue: 0,0:37:09.99,0:37:14.49,中文,,0,0,0,,你免费获得了一个额外的字节，以便知道字符串在哪里结束。
Dialogue: 0,0:37:14.49,0:37:17.35,英文,,0,0,0,,And functions like str compare can then find their way there.
Dialogue: 0,0:37:14.49,0:37:17.35,中文,,0,0,0,,像 strcmp 这样的函数就可以找到字符串的末尾。
Dialogue: 0,0:37:17.35,0:37:20.94,英文,,0,0,0,,So in memory. It might indeed look a little like this.
Dialogue: 0,0:37:17.35,0:37:20.94,中文,,0,0,0,,所以在内存中。它可能看起来像这样。
Dialogue: 0,0:37:20.94,0:37:29.18,英文,,0,0,0,,And if we assume that there's going to be somewhere in memory, these things are going to be somewhere in memory, we can address them per week 2 by way of the name of the variable.
Dialogue: 0,0:37:20.94,0:37:29.18,中文,,0,0,0,,假设在内存中的某个地方，这些东西会在内存中的某个位置，我们可以像第二周那样通过变量名来寻址它们。
Dialogue: 0,0:37:29.18,0:37:34.62,英文,,0,0,0,,So if s is the name of the variable, s bracket 0 is how you would refer to the first letter, s bracket 1, s bracket 2.
Dialogue: 0,0:37:29.18,0:37:34.62,中文,,0,0,0,,如果 s 是变量名，s[0] 就是指代第一个字母的方式，s[1]、s[2]。
Dialogue: 0,0:37:34.62,0:37:40.50,英文,,0,0,0,,And if you really want, s bracket 3 would get you at the null character at the very end.
Dialogue: 0,0:37:34.62,0:37:40.50,中文,,0,0,0,,如果你真的想，s[3] 会让你访问到最后面的空字符。
Dialogue: 0,0:37:40.50,0:37:42.02,英文,,0,0,0,,But what is s?
Dialogue: 0,0:37:40.50,0:37:42.02,中文,,0,0,0,,但 s 是什么？
Dialogue: 0,0:37:42.02,0:37:44.80,英文,,0,0,0,,So technically, in this line of code here,
Dialogue: 0,0:37:42.02,0:37:44.80,中文,,0,0,0,,从技术上讲，在这行代码中，
Dialogue: 0,0:37:44.80,0:37:54.38,英文,,0,0,0,,Not only is the computer giving you memory for h, i, exclamation point, backslash 0, it turns out that s itself must take up some amount of space, right?
Dialogue: 0,0:37:44.80,0:37:54.38,中文,,0,0,0,,计算机不仅给你分配了内存来存储 H、H、感叹号、反斜杠 0，事实证明 s 本身也必须占用一定的空间。
Dialogue: 0,0:37:54.38,0:37:55.54,英文,,0,0,0,,Because s is the variable.
Dialogue: 0,0:37:54.38,0:37:55.54,中文,,0,0,0,,因为 s 是变量。
Dialogue: 0,0:37:55.54,0:38:01.11,英文,,0,0,0,,And every time we've talked about variables thus far, I've given you a rectangle on the screen in which to store its value.
Dialogue: 0,0:37:55.54,0:38:01.11,中文,,0,0,0,,到目前为止，每次我们谈到变量时，我都在屏幕上给你一个矩形来存储它的值。
Dialogue: 0,0:38:01.11,0:38:10.99,英文,,0,0,0,,So let's assume for the sake of discussion that the h is at 0x123, and i is at 0x124, exclamation point's at 0x125, and the null character's at 0x126.
Dialogue: 0,0:38:01.11,0:38:10.99,中文,,0,0,0,,假设 H 的地址是 0x123，I 的地址是 0x124，感叹号的地址是 0x125，空字符的地址是 0x126。
Dialogue: 0,0:38:10.99,0:38:13.53,英文,,0,0,0,,Well, what then is s?
Dialogue: 0,0:38:10.99,0:38:13.53,中文,,0,0,0,,那么 s 是什么？
Dialogue: 0,0:38:13.53,0:38:16.12,英文,,0,0,0,,Well, s is just going to be some other variable.
Dialogue: 0,0:38:13.53,0:38:16.12,中文,,0,0,0,,s 只是另一个变量。
Dialogue: 0,0:38:16.12,0:38:19.75,英文,,0,0,0,,And I'll draw it somewhat abstractly without all the other boxes up here.
Dialogue: 0,0:38:16.12,0:38:19.75,中文,,0,0,0,,我将抽象地画一下，不带上面所有其他的框。
Dialogue: 0,0:38:19.75,0:38:22.43,英文,,0,0,0,,And I'll claim that the name of this variable is s.
Dialogue: 0,0:38:19.75,0:38:22.43,中文,,0,0,0,,我假设这个变量的名字是 s。
Dialogue: 0,0:38:22.43,0:38:25.01,英文,,0,0,0,,But it turns out, what is s really?
Dialogue: 0,0:38:22.43,0:38:25.01,中文,,0,0,0,,但实际上，s 到底是什么？
Dialogue: 0,0:38:25.01,0:38:27.33,英文,,0,0,0,,How do strings really work?
Dialogue: 0,0:38:25.01,0:38:27.33,中文,,0,0,0,,字符串到底是如何工作的？
Dialogue: 0,0:38:27.33,0:38:30.87,英文,,0,0,0,,Well, s is a variable and has been since week one.
Dialogue: 0,0:38:27.33,0:38:30.87,中文,,0,0,0,,s 是一个变量，从第一周开始就是了。
Dialogue: 0,0:38:30.87,0:38:38.60,英文,,0,0,0,,But when you define it, what the computer is doing for you automatically is when it knows you want to store HI exclamation point, it puts that somewhere in memory.
Dialogue: 0,0:38:30.87,0:38:38.60,中文,,0,0,0,,当你定义它的时候，计算机自动为你做的是，当它知道你想存储 HI 加感叹号时，它会把字符串放到内存的某个地方。
Dialogue: 0,0:38:38.60,0:38:43.16,英文,,0,0,0,,The computer then figures out for you, what's the address of the very first character?
Dialogue: 0,0:38:38.60,0:38:43.16,中文,,0,0,0,,然后计算机帮你找出第一个字符的地址。
Dialogue: 0,0:38:43.16,0:38:50.32,英文,,0,0,0,,And it stores that address and only that address in the variable you created on the left-hand side of the equal sign.
Dialogue: 0,0:38:43.16,0:38:50.32,中文,,0,0,0,,它将地址存储在你创建的等号左侧的变量中，而且只存储地址。
Dialogue: 0,0:38:50.32,0:38:51.20,英文,,0,0,0,,And that's enough.
Dialogue: 0,0:38:50.32,0:38:51.20,中文,,0,0,0,,这足够了。
Dialogue: 0,0:38:51.20,0:38:57.63,英文,,0,0,0,,Like, to represent a string with three letters of the alphabet or punctuation, you don't need three variables.
Dialogue: 0,0:38:51.20,0:38:57.63,中文,,0,0,0,,比如，要表示一个包含三个字母或标点的字符串，你不需要三个变量。
Dialogue: 0,0:38:57.63,0:38:58.45,英文,,0,0,0,,You just need one.
Dialogue: 0,0:38:57.63,0:38:58.45,中文,,0,0,0,,你只需要一个。
Dialogue: 0,0:38:58.45,0:39:02.25,英文,,0,0,0,,You just need to know the beginning of the string.
Dialogue: 0,0:38:58.45,0:39:02.25,中文,,0,0,0,,你只需要知道字符串的开头。
Dialogue: 0,0:39:02.25,0:39:02.95,英文,,0,0,0,,Why?
Dialogue: 0,0:39:02.25,0:39:02.95,中文,,0,0,0,,为什么？
Dialogue: 0,0:39:02.95,0:39:11.77,英文,,0,0,0,,Why is it sufficient for a variable to only store the first bytes address and not all of the bytes addresses?
Dialogue: 0,0:39:02.95,0:39:11.77,中文,,0,0,0,,为什么一个变量只需要存储第一个字节的地址，而不需要存储所有字节的地址就足够了？
Dialogue: 0,0:39:11.77,0:39:17.52,英文,,0,0,0,,Exactly, because of the design of strings, per week two, we always null terminate them.
Dialogue: 0,0:39:11.77,0:39:17.52,中文,,0,0,0,,没错，根据第二周学习的字符串的设计，我们总是用空字符来结束它们。
Dialogue: 0,0:39:17.52,0:39:23.84,英文,,0,0,0,,So it suffices to only remember the first bytes address, because from there, you can sort of follow the breadcrumbs, byte after byte after byte.
Dialogue: 0,0:39:17.52,0:39:23.84,中文,,0,0,0,,所以只需要记住第一个字节的地址就足够了，因为从那里开始，你可以一个字节一个字节地追踪下去。
Dialogue: 0,0:39:23.84,0:39:31.34,英文,,0,0,0,,And until you see the new line, sorry, the null character, you know that all of those characters are apparently part of the same string.
Dialogue: 0,0:39:23.84,0:39:31.34,中文,,0,0,0,,直到你看到换行符，抱歉，是空字符，你就知道所有这些字符显然都属于同一个字符串。
Dialogue: 0,0:39:31.34,0:39:35.62,英文,,0,0,0,,So this is what's been going on in the computer's memory all since week one.
Dialogue: 0,0:39:31.34,0:39:35.62,中文,,0,0,0,,所以这就是从第一周开始计算机内存中发生的事情。
Dialogue: 0,0:39:35.62,0:39:41.47,英文,,0,0,0,,And in fact, if we abstract this away, you can really think of s as being just this.
Dialogue: 0,0:39:35.62,0:39:41.47,中文,,0,0,0,,事实上，如果我们把这些抽象出来，你可以把 s 看作就是这个。
Dialogue: 0,0:39:41.47,0:39:44.49,英文,,0,0,0,,Really a pointer to that chunk of memory.
Dialogue: 0,0:39:41.47,0:39:44.49,中文,,0,0,0,,实际上是指向那块内存的指针。
Dialogue: 0,0:39:44.49,0:39:46.91,英文,,0,0,0,,So in fact, what do we have here?
Dialogue: 0,0:39:44.49,0:39:46.91,中文,,0,0,0,,实际上，我们在这里看到了什么？
Dialogue: 0,0:39:46.91,0:39:51.41,英文,,0,0,0,,Well, to recap on the code here, on the left-hand side, string.
Dialogue: 0,0:39:46.91,0:39:51.41,中文,,0,0,0,,回顾一下这里的代码，左边是 string。
Dialogue: 0,0:39:51.41,0:39:59.66,英文,,0,0,0,,That's what ensures that we'll actually be able to store a string in a variable called s. We're going to have on the right-hand side, though, the actual value.
Dialogue: 0,0:39:51.41,0:39:59.66,中文,,0,0,0,,这确保我们能够将字符串存储在名为 s 的变量中。不过，我们将在右侧看到实际值。
Dialogue: 0,0:39:59.66,0:40:01.62,英文,,0,0,0,,So let me switch back to VS Code here.
Dialogue: 0,0:39:59.66,0:40:01.62,中文,,0,0,0,,让我切换回 VS Code。
Dialogue: 0,0:40:01.62,0:40:04.68,英文,,0,0,0,,And let me change my code to no longer involve integers alone.
Dialogue: 0,0:40:01.62,0:40:04.68,中文,,0,0,0,,让我修改代码，不再只涉及整数。
Dialogue: 0,0:40:04.68,0:40:08.88,英文,,0,0,0,,So I'm going to add the CS50 library.
Dialogue: 0,0:40:04.68,0:40:08.88,中文,,0,0,0,,我要添加 cs50 库。
Dialogue: 0,0:40:08.88,0:40:14.45,英文,,0,0,0,,Just so that I can use some shortcuts in there, CS50.h. And then in my main function, I'm going to go ahead and do this.
Dialogue: 0,0:40:08.88,0:40:14.45,中文,,0,0,0,,这样我就可以使用其中的一些快捷方式，cs50.h。然后在我的主函数中，我要继续这样做。
Dialogue: 0,0:40:14.45,0:40:18.31,英文,,0,0,0,,String s equals, quote, unquote, HIGH, in all caps, exclamation point.
Dialogue: 0,0:40:14.45,0:40:18.31,中文,,0,0,0,,string s 等于，引号，HI，全部大写，感叹号。
Dialogue: 0,0:40:18.31,0:40:25.44,英文,,0,0,0,,And then I'm going to go ahead and print out, using %s, as always, backslash n, the value of s. So this program, at the moment, not interesting at all.
Dialogue: 0,0:40:18.31,0:40:25.44,中文,,0,0,0,,然后我要继续使用 %s，像往常一样，反斜杠 n，打印出 s 的值。所以这个程序，目前为止，一点也不有趣。
Dialogue: 0,0:40:25.44,0:40:27.18,英文,,0,0,0,,It's just week one stuff again.
Dialogue: 0,0:40:25.44,0:40:27.18,中文,,0,0,0,,这只是第一周的内容。
Dialogue: 0,0:40:27.18,0:40:29.90,英文,,0,0,0,,Dot slash addresses, indeed, prints out HIGH.
Dialogue: 0,0:40:27.18,0:40:29.90,中文,,0,0,0,,点斜杠地址，确实，打印出 HI!。
Dialogue: 0,0:40:29.90,0:40:31.69,英文,,0,0,0,,But it turns out.
Dialogue: 0,0:40:29.90,0:40:31.69,中文,,0,0,0,,但事实证明。
Dialogue: 0,0:40:31.69,0:40:36.61,英文,,0,0,0,,That now that I know this, what's really been going on underneath the hood all this time?
Dialogue: 0,0:40:31.69,0:40:36.61,中文,,0,0,0,,既然我知道了这一点，那么一直以来，幕后到底发生了什么？
Dialogue: 0,0:40:36.61,0:40:47.03,英文,,0,0,0,,Well, here's that same line of code that defines the variable called s. And it turns out, anyone want to guess what string is actually a synonym for?
Dialogue: 0,0:40:36.61,0:40:47.03,中文,,0,0,0,,这就是定义名为 s 的变量的同一行代码。事实证明，有人想猜猜 string 实际上是什么的同义词吗？
Dialogue: 0,0:40:47.03,0:40:50.53,英文,,0,0,0,,String, it turns out, is kind of a white lie we've been telling since week one.
Dialogue: 0,0:40:47.03,0:40:50.53,中文,,0,0,0,,事实证明，string 从第一周开始就是一个善意的谎言。
Dialogue: 0,0:40:50.53,0:40:59.06,英文,,0,0,0,,There is no such thing as string as a keyword in C. It's technically a CS50 thing, yeah?
Dialogue: 0,0:40:50.53,0:40:59.06,中文,,0,0,0,,在 C 语言中没有 string 这样的关键字。从技术上讲，它是 cs50 的东西，对吧？
Dialogue: 0,0:40:59.06,0:41:00.66,英文,,0,0,0,,It's a pointer to a character.
Dialogue: 0,0:40:59.06,0:41:00.66,中文,,0,0,0,,它是一个指向字符的指针。
Dialogue: 0,0:41:00.66,0:41:03.46,英文,,0,0,0,,So really, all this time, we've kind of been lying to you.
Dialogue: 0,0:41:00.66,0:41:03.46,中文,,0,0,0,,所以实际上，一直以来，我们都在对你说谎。
Dialogue: 0,0:41:03.46,0:41:05.62,英文,,0,0,0,,There is no string, quote unquote.
Dialogue: 0,0:41:03.46,0:41:05.62,中文,,0,0,0,,没有字符串，引号。
Dialogue: 0,0:41:05.62,0:41:07.55,英文,,0,0,0,,It's actually char star.
Dialogue: 0,0:41:05.62,0:41:07.55,中文,,0,0,0,,它实际上是 char *。
Dialogue: 0,0:41:07.55,0:41:10.61,英文,,0,0,0,,And if I may, dramatically, here go.
Dialogue: 0,0:41:07.55,0:41:10.61,中文,,0,0,0,,让我来表演一下，看好了。
Dialogue: 0,0:41:10.61,0:41:14.19,英文,,0,0,0,,The training wheels, like, OK, that didn't land very well.
Dialogue: 0,0:41:10.61,0:41:14.19,中文,,0,0,0,,这些辅助轮，好吧，着陆不太顺利。
Dialogue: 0,0:41:14.19,0:41:16.45,英文,,0,0,0,,So what have we been doing?
Dialogue: 0,0:41:14.19,0:41:16.45,中文,,0,0,0,,那么我们一直在做什么？
Dialogue: 0,0:41:16.45,0:41:20.86,英文,,0,0,0,,Well, it turns out that string is a much easier way conceptually to think about what a string of characters is.
Dialogue: 0,0:41:16.45,0:41:20.86,中文,,0,0,0,,事实证明，从概念上讲，string 是思考字符串的一种简单得多的方式。
Dialogue: 0,0:41:20.86,0:41:25.20,英文,,0,0,0,,Like, my god, if we had to start in week one by having you type char star, like, yeah, you might get past it.
Dialogue: 0,0:41:20.86,0:41:25.20,中文,,0,0,0,,天哪，如果我们在第一周就开始让你输入 char*，你可能会越过它。
Dialogue: 0,0:41:25.20,0:41:28.84,英文,,0,0,0,,But like, this is just way too much ugly syntax, not intellectually interesting at all.
Dialogue: 0,0:41:25.20,0:41:28.84,中文,,0,0,0,,但这语法太丑陋了，一点意思都没有。
Dialogue: 0,0:41:28.84,0:41:35.29,英文,,0,0,0,,So we abstracted away what a char star was in the first week of C by telling you it's actually called string.
Dialogue: 0,0:41:28.84,0:41:35.29,中文,,0,0,0,,所以在 C 语言的第一周，我们就把 char* 抽象成了 string。
Dialogue: 0,0:41:35.29,0:41:41.47,英文,,0,0,0,,Now, string is a term of art. Like C programmers, programmers in any language will use the word string to mean a sequence of characters.
Dialogue: 0,0:41:35.29,0:41:41.47,中文,,0,0,0,,现在，string 是一个专业术语。就像 C 语言程序员一样，任何语言的程序员都会使用 string 来表示字符序列。
Dialogue: 0,0:41:41.47,0:41:45.57,英文,,0,0,0,,But in C, it's not technically a word unto itself.
Dialogue: 0,0:41:41.47,0:41:45.57,中文,,0,0,0,,但在 C 语言中，它本身并不是一个技术术语。
Dialogue: 0,0:41:45.57,0:41:49.17,英文,,0,0,0,,It's rather a synonym that we ourselves created in some form.
Dialogue: 0,0:41:45.57,0:41:49.17,中文,,0,0,0,,它更像是我们自己创造的一种同义词。
Dialogue: 0,0:41:49.17,0:41:50.99,英文,,0,0,0,,So in fact, how did we do this?
Dialogue: 0,0:41:49.17,0:41:50.99,中文,,0,0,0,,那么，我们是怎么做到的呢？
Dialogue: 0,0:41:50.99,0:41:52.69,英文,,0,0,0,,Well, think back to just last week.
Dialogue: 0,0:41:50.99,0:41:52.69,中文,,0,0,0,,回想一下上周。
Dialogue: 0,0:41:52.69,0:41:59.64,英文,,0,0,0,,Last week, I proposed that it'd be really nice if we had a person data type, which the creators of C did not think of decades ago.
Dialogue: 0,0:41:52.69,0:41:59.64,中文,,0,0,0,,上周，我提出如果我们有一种 person 数据类型会非常好，这是几十年前 C 语言的创造者没有想到的。
Dialogue: 0,0:41:59.64,0:42:00.22,英文,,0,0,0,,But that's OK.
Dialogue: 0,0:41:59.64,0:42:00.22,中文,,0,0,0,,但这没关系。
Dialogue: 0,0:42:00.22,0:42:01.72,英文,,0,0,0,,We can define it ourselves.
Dialogue: 0,0:42:00.22,0:42:01.72,中文,,0,0,0,,我们可以自己定义。
Dialogue: 0,0:42:01.72,0:42:02.96,英文,,0,0,0,,What did we do here?
Dialogue: 0,0:42:01.72,0:42:02.96,中文,,0,0,0,,我们在这里做了什么？
Dialogue: 0,0:42:02.96,0:42:05.41,英文,,0,0,0,,Well, we're using syntax like this.
Dialogue: 0,0:42:02.96,0:42:05.41,中文,,0,0,0,,我们在使用这样的语法。
Dialogue: 0,0:42:05.41,0:42:08.29,英文,,0,0,0,,Recall that we defined a person to be what?
Dialogue: 0,0:42:05.41,0:42:08.29,中文,,0,0,0,,还记得我们如何定义 person 吗？
Dialogue: 0,0:42:08.29,0:42:09.89,英文,,0,0,0,,To be this structure.
Dialogue: 0,0:42:08.29,0:42:09.89,中文,,0,0,0,,是这种结构。
Dialogue: 0,0:42:09.89,0:42:15.17,英文,,0,0,0,,This structure, using the new keyword last week, struct, means that a person is just a name and a number.
Dialogue: 0,0:42:09.89,0:42:15.17,中文,,0,0,0,,这种结构，使用上周介绍的新关键字 struct，意味着 person 只是一个名字和一个数字。
Dialogue: 0,0:42:15.17,0:42:17.35,英文,,0,0,0,,And it could have been other things. We just kept it simple.
Dialogue: 0,0:42:15.17,0:42:17.35,中文,,0,0,0,,它本来可以是其他的，我们只是保持简单。
Dialogue: 0,0:42:17.35,0:42:22.74,英文,,0,0,0,,But how did I associate person with that structure?
Dialogue: 0,0:42:17.35,0:42:22.74,中文,,0,0,0,,但是，我是如何将 person 与该结构体关联起来的？
Dialogue: 0,0:42:22.74,0:42:28.90,英文,,0,0,0,,Well, we claimed that it was this value here, typedef, which, as you might expect, defines a data type.
Dialogue: 0,0:42:22.74,0:42:28.90,中文,,0,0,0,,我们说过是这里的这个值，typedef，正如你可能预料的那样，它定义了一种数据类型。
Dialogue: 0,0:42:28.90,0:42:33.16,英文,,0,0,0,,So what did we do as CS50 back in week one without telling you
Dialogue: 0,0:42:28.90,0:42:33.16,中文,,0,0,0,,那么我们在 cs50 的第一周没有告诉你们的是什么呢？
Dialogue: 0,0:42:33.16,0:42:38.50,英文,,0,0,0,,Well, we could have done something like this, like int itself is a little cryptic.
Dialogue: 0,0:42:33.16,0:42:38.50,中文,,0,0,0,,我们可以这样做，比如 int 本身有点隐晦。
Dialogue: 0,0:42:38.50,0:42:49.95,英文,,0,0,0,,And maybe we should have, to keep things even simpler, said, hey, everyone, turns out you can define integers in C. And if you wanted to do this, well, if you want to create the keyword integer as a data type, you can just typedef it to int.
Dialogue: 0,0:42:38.50,0:42:49.95,中文,,0,0,0,,为了使事情更简单，也许我们应该这样说，各位，事实证明你可以在 C 语言中定义整数。\N如果你想这样做，如果你想将关键字 integer 创建为数据类型，你可以直接将其 typedef 为 int。
Dialogue: 0,0:42:49.95,0:42:57.54,英文,,0,0,0,,So typedef. creates the word on the far right, integer, and creates a synonym for it, in this case called int.
Dialogue: 0,0:42:49.95,0:42:57.54,中文,,0,0,0,,所以 typedef 创建了最右边的单词 integer，并为其创建了一个同义词，在本例中称为 int。
Dialogue: 0,0:42:57.54,0:43:00.76,英文,,0,0,0,,So what did we do in week one without telling you?
Dialogue: 0,0:42:57.54,0:43:00.76,中文,,0,0,0,,那么我们在第一周没有告诉你们的是什么呢？
Dialogue: 0,0:43:00.76,0:43:10.57,英文,,0,0,0,,We have a line of code like this in the CS50 library that associates quote, unquote, string with, more cryptically, Char star.
Dialogue: 0,0:43:00.76,0:43:10.57,中文,,0,0,0,,在 cs50 库中，我们有一行代码，将带引号的 “string” 与更隐晦的 Char * 关联起来。
Dialogue: 0,0:43:10.57,0:43:19.01,英文,,0,0,0,,And this is why in week one onward, anytime you use the CS50 library, you can write the word string as though it's a real C data type.
Dialogue: 0,0:43:10.57,0:43:19.01,中文,,0,0,0,,这就是为什么从第一周开始，任何时候你使用 cs50 库，你都可以把 string 这个词写得像一个真正的 C 语言数据类型一样。
Dialogue: 0,0:43:19.01,0:43:25.29,英文,,0,0,0,,And that's just because we wanted to have this abstraction, these training wheels on for the first weeks, so we don't have to get in the weeds of all this crazy memory stuff.
Dialogue: 0,0:43:19.01,0:43:25.29,中文,,0,0,0,,这只是因为我们想在开始的几周里使用这种抽象，这些辅助轮，这样我们就不用陷入所有这些疯狂的内存细节中。
Dialogue: 0,0:43:25.29,0:43:27.90,英文,,0,0,0,,We can sort of talk about strings at a higher level.
Dialogue: 0,0:43:25.29,0:43:27.90,中文,,0,0,0,,我们可以从更高的层次来讨论字符串。
Dialogue: 0,0:43:27.90,0:43:29.16,英文,,0,0,0,,But that's all they are.
Dialogue: 0,0:43:27.90,0:43:29.16,中文,,0,0,0,,但这就是它们的全部。
Dialogue: 0,0:43:29.16,0:43:34.88,英文,,0,0,0,,Strings are the address of the first character in that sequence of characters.
Dialogue: 0,0:43:29.16,0:43:34.88,中文,,0,0,0,,字符串是该字符序列中第一个字符的地址。
Dialogue: 0,0:43:34.88,0:43:38.24,英文,,0,0,0,,Questions now on any of these details?
Dialogue: 0,0:43:34.88,0:43:38.24,中文,,0,0,0,,现在对这些细节有什么问题吗？
Dialogue: 0,0:43:38.24,0:43:42.15,英文,,0,0,0,,Yeah?
Dialogue: 0,0:43:38.24,0:43:42.15,中文,,0,0,0,,有吗？
Dialogue: 0,0:43:42.15,0:43:42.57,英文,,0,0,0,,Good question.
Dialogue: 0,0:43:42.15,0:43:42.57,中文,,0,0,0,,问得好。
Dialogue: 0,0:43:42.57,0:43:46.05,英文,,0,0,0,,What about the strings library, which we have used?
Dialogue: 0,0:43:42.57,0:43:46.05,中文,,0,0,0,,我们使用过的 string 库呢？
Dialogue: 0,0:43:46.05,0:43:46.59,英文,,0,0,0,,Unrelated.
Dialogue: 0,0:43:46.05,0:43:46.59,中文,,0,0,0,,无关。
Dialogue: 0,0:43:46.59,0:43:48.61,英文,,0,0,0,,So it does not define the word string.
Dialogue: 0,0:43:46.59,0:43:48.61,中文,,0,0,0,,所以它没有定义 string 这个词。
Dialogue: 0,0:43:48.61,0:43:51.59,英文,,0,0,0,,Everything in there actually relates to char stars.
Dialogue: 0,0:43:48.61,0:43:51.59,中文,,0,0,0,,这里面的所有东西都与字符指针有关。
Dialogue: 0,0:43:51.59,0:44:05.09,英文,,0,0,0,,And so in fact, if you've used the CS50 manual, which is just our user-friendly version of the actual manual pages for the official language C, you'll see throughout that now, if you start poking around or turning off less comfortable mode,
Dialogue: 0,0:43:51.59,0:44:05.09,中文,,0,0,0,,所以实际上，如果你用过 cs50 手册，它只是我们针对 C 语言官方手册页的用户友好版本，你会发现，如果你开始四处查看或关闭不太舒服的模式，
Dialogue: 0,0:44:05.09,0:44:12.77,英文,,0,0,0,,you'll actually see that we've changed any mentions of char star in the official documentation for these first weeks to just string, to simplify it.
Dialogue: 0,0:44:05.09,0:44:12.77,中文,,0,0,0,,你会发现，我们已经将前几周官方文档中所有提到 char 指针的地方都改成了 string，以简化它。
Dialogue: 0,0:44:12.77,0:44:17.39,英文,,0,0,0,,But underneath the hood, C does not know the word string per se as a keyword.
Dialogue: 0,0:44:12.77,0:44:17.39,中文,,0,0,0,,但在底层，C 语言本身并不知道 string 这个词作为一个关键字。
Dialogue: 0,0:44:17.39,0:44:21.41,英文,,0,0,0,,But it's absolutely a concept that every program in the world knows about.
Dialogue: 0,0:44:17.39,0:44:21.41,中文,,0,0,0,,它绝对是世界上每个程序都知道的概念。
Dialogue: 0,0:44:21.41,0:44:25.99,英文,,0,0,0,,And in fact, in other languages, in Python, for instance, there will actually be a proper string.
Dialogue: 0,0:44:21.41,0:44:25.99,中文,,0,0,0,,事实上，在其他语言中，例如 Python 中，实际上会有一个合适的字符串类型。
Dialogue: 0,0:44:25.99,0:44:27.31,英文,,0,0,0,,Although it's not going to be called string.
Dialogue: 0,0:44:25.99,0:44:27.31,中文,,0,0,0,,虽然它不叫 string。
Dialogue: 0,0:44:27.31,0:44:30.47,英文,,0,0,0,,It's going to be called str, S-T-R for short.
Dialogue: 0,0:44:27.31,0:44:30.47,中文,,0,0,0,,它被称为 str，是 S-T-R 的缩写。
Dialogue: 0,0:44:30.47,0:44:33.47,英文,,0,0,0,,Questions on these strings here?
Dialogue: 0,0:44:30.47,0:44:33.47,中文,,0,0,0,,关于字符串，有问题吗？
Dialogue: 0,0:44:33.47,0:44:38.92,英文,,0,0,0,,Well, let me propose there's one other feature of this syntax that we can now leverage as follows.
Dialogue: 0,0:44:33.47,0:44:38.92,中文,,0,0,0,,让我提出这个语法的另一个特性，我们可以利用它来做如下事情。
Dialogue: 0,0:44:38.92,0:44:51.83,英文,,0,0,0,,Let me propose that if we go back to the previous version of my code here, wherein, let me switch back to VS Code in just a moment, I'm going to rewind in VS Code to the integer version of my code from before.
Dialogue: 0,0:44:38.92,0:44:51.83,中文,,0,0,0,,让我假设，如果我们回到之前版本的代码，让我马上切换回 VS Code，我要在 VS Code 中回到之前使用整数版本的代码。
Dialogue: 0,0:44:51.83,0:44:58.74,英文,,0,0,0,,And most recently, it looked like this, before when we were using integers only and not, in fact, strings at all.
Dialogue: 0,0:44:51.83,0:44:58.74,中文,,0,0,0,,最近一次，它看起来像这样，在我们只使用整数而根本没有使用字符串之前。
Dialogue: 0,0:44:58.74,0:45:04.36,英文,,0,0,0,,Let me propose that there's this other feature of C that we can use that actually allows us to go to an address.
Dialogue: 0,0:44:58.74,0:45:04.36,中文,,0,0,0,,我建议，我们可以使用 C 语言的另一个特性，它允许我们访问一个地址。
Dialogue: 0,0:45:04.36,0:45:10.85,英文,,0,0,0,,So at the moment, let me just rewind and do make addresses to remind you what this program did when it was using integers alone.
Dialogue: 0,0:45:04.36,0:45:10.85,中文,,0,0,0,,现在，让我倒回去，执行 make addresses，提醒你这段代码在只使用整数时做了什么。
Dialogue: 0,0:45:10.85,0:45:12.09,英文,,0,0,0,,And there's that address.
Dialogue: 0,0:45:10.85,0:45:12.09,中文,,0,0,0,,地址就在那里。
Dialogue: 0,0:45:12.09,0:45:12.81,英文,,0,0,0,,Why?
Dialogue: 0,0:45:12.09,0:45:12.81,中文,,0,0,0,,为什么？
Dialogue: 0,0:45:12.81,0:45:17.73,英文,,0,0,0,,Because on line 7, notice, I'm printing out the value of p, which is a pointer.
Dialogue: 0,0:45:12.81,0:45:17.73,中文,,0,0,0,,因为在第 7 行，注意，我正在打印出 p 的值，它是一个指针。
Dialogue: 0,0:45:17.73,0:45:20.15,英文,,0,0,0,,So of course, it's going to look like an address.
Dialogue: 0,0:45:17.73,0:45:20.15,中文,,0,0,0,,它看起来像一个地址。
Dialogue: 0,0:45:20.15,0:45:22.93,英文,,0,0,0,,But let me zoom out now and make one change.
Dialogue: 0,0:45:20.15,0:45:22.93,中文,,0,0,0,,但现在让我把它缩小，做一点改动。
Dialogue: 0,0:45:22.93,0:45:32.20,英文,,0,0,0,,Instead of printing out p, how can I use today's second new operator, not the ampersand, but the star, to actually go to that address?
Dialogue: 0,0:45:22.93,0:45:32.20,中文,,0,0,0,,我不打印 p，而是用今天学的第二个新运算符，不是“&”符号，而是“*”，来访问那个地址，怎么做？
Dialogue: 0,0:45:32.20,0:45:35.26,英文,,0,0,0,,Well, what I can actually do on this line of code is this.
Dialogue: 0,0:45:32.20,0:45:35.26,中文,,0,0,0,,实际上，我可以在这行代码中这样做。
Dialogue: 0,0:45:35.26,0:45:47.81,英文,,0,0,0,,If I want to print out the actual integer 50 that's in that variable or equivalently at that address, I can go to p here and not print p literally, because that's just an address, I can now say,
Dialogue: 0,0:45:35.26,0:45:47.81,中文,,0,0,0,,如果我想打印出那个变量中实际的整数 50，或者说那个地址上的整数 50，\N我可以转到 p 这里，而不是直接打印 p，因为那只是一个地址，我现在可以说，
Dialogue: 0,0:45:47.81,0:45:51.33,英文,,0,0,0,,Star P. And star P means go there.
Dialogue: 0,0:45:47.81,0:45:51.33,中文,,0,0,0,,星号 p。星号 p 意思是去那里。
Dialogue: 0,0:45:51.33,0:46:02.57,英文,,0,0,0,,More technically, dereference P. That is, follow the treasure map to the actual address and do what Carter did, open the mailbox and print whatever was in the mailbox, which, recall, was the actual number 50.
Dialogue: 0,0:45:51.33,0:46:02.57,中文,,0,0,0,,更专业的说法是，解引用 p。也就是说，沿着藏宝图找到实际地址，\N然后像 Carter 做的那样，打开邮箱，打印出邮箱里的任何东西，回想一下，那是实际数字 50。
Dialogue: 0,0:46:02.57,0:46:03.57,英文,,0,0,0,,So let me try this.
Dialogue: 0,0:46:02.57,0:46:03.57,中文,,0,0,0,,让我试试这个。
Dialogue: 0,0:46:03.57,0:46:05.43,英文,,0,0,0,,Let me recompile the code.
Dialogue: 0,0:46:03.57,0:46:05.43,中文,,0,0,0,,让我重新编译代码。
Dialogue: 0,0:46:05.43,0:46:08.34,英文,,0,0,0,,So make addresses.
Dialogue: 0,0:46:05.43,0:46:08.34,中文,,0,0,0,,执行 make addresses。
Dialogue: 0,0:46:08.34,0:46:10.50,英文,,0,0,0,,OK, let me clear my terminal window, dot slash addresses.
Dialogue: 0,0:46:08.34,0:46:10.50,中文,,0,0,0,,让我清空终端窗口，输入 ./addresses。
Dialogue: 0,0:46:10.50,0:46:12.73,英文,,0,0,0,,This time, I shouldn't see the 0x anything.
Dialogue: 0,0:46:10.50,0:46:12.73,中文,,0,0,0,,这次，我不应该看到 0x 之类的任何东西。
Dialogue: 0,0:46:12.73,0:46:16.63,英文,,0,0,0,,I should see just the number 50 in this case.
Dialogue: 0,0:46:12.73,0:46:16.63,中文,,0,0,0,,在这种情况下，我应该只看到数字 50。
Dialogue: 0,0:46:16.63,0:46:19.64,英文,,0,0,0,,And here, too, is kind of an unfortunate design decision.
Dialogue: 0,0:46:16.63,0:46:19.64,中文,,0,0,0,,这也是一个不幸的设计决定。
Dialogue: 0,0:46:19.64,0:46:26.56,英文,,0,0,0,,Certainly, pedagogically, I would say in C, if I zoom in on this code, star, is unfortunately being used in two different ways.
Dialogue: 0,0:46:19.64,0:46:26.56,中文,,0,0,0,,当然，从教学上来说，我会说在 C 语言中，如果我放大这段代码，星号， 不幸地被用在了两种不同的方式中。
Dialogue: 0,0:46:26.56,0:46:30.65,英文,,0,0,0,,In an ideal world, they would have used three different symbols to make this more semantically clear.
Dialogue: 0,0:46:26.56,0:46:30.65,中文,,0,0,0,,在理想情况下，他们会使用三种不同的符号来使语义更加清晰。
Dialogue: 0,0:46:30.65,0:46:32.13,英文,,0,0,0,,But this is what we're stuck with.
Dialogue: 0,0:46:30.65,0:46:32.13,中文,,0,0,0,,但这就是我们不得不面对的。
Dialogue: 0,0:46:32.13,0:46:43.32,英文,,0,0,0,,So in line 6, when you declare a pointer, that is a variable that stores an address, you put the type of variable that you want to point at, then a star, just because, and then the name of the variable.
Dialogue: 0,0:46:32.13,0:46:43.32,中文,,0,0,0,,所以在第 6 行，当你声明一个指针时，\N也就是一个存储地址的变量，你把要指向的变量类型放在前面，然后是一个星号，仅仅是因为习惯，然后是变量名。
Dialogue: 0,0:46:43.32,0:46:47.78,英文,,0,0,0,,And then on the right-hand side, you actually get the address of whatever using ampersand.
Dialogue: 0,0:46:43.32,0:46:47.78,中文,,0,0,0,,然后在右侧，使用 & 获取任何东西的地址。
Dialogue: 0,0:46:47.78,0:46:53.54,英文,,0,0,0,,But when you want to go to an address, you want to dereference a pointer, you don't use int again.
Dialogue: 0,0:46:47.78,0:46:53.54,中文,,0,0,0,,但是当你想要访问一个地址，想要解引用一个指针时，你不会再次使用 int。
Dialogue: 0,0:46:53.54,0:46:54.68,英文,,0,0,0,,And we've never done that, right?
Dialogue: 0,0:46:53.54,0:46:54.68,中文,,0,0,0,,我们从来没有这样做过，对吧？
Dialogue: 0,0:46:54.68,0:46:57.10,英文,,0,0,0,,Once you declare a variable, you never again mention the data type.
Dialogue: 0,0:46:54.68,0:46:57.10,中文,,0,0,0,,一旦你声明了一个变量，你就永远不会再提到数据类型。
Dialogue: 0,0:46:57.10,0:47:05.26,英文,,0,0,0,,But in the world of pointers now, if you want to not print out p, but go to whatever address p is storing, you use star p here.
Dialogue: 0,0:46:57.10,0:47:05.26,中文,,0,0,0,,但在指针的世界里，如果你不想打印出 p，而是想去 p 存储的地址，就在这里使用 *p。
Dialogue: 0,0:47:05.26,0:47:14.02,英文,,0,0,0,,So a good visual indicator would be when you declare a pointer, that is, make it exist in your program, you have to declare the data type with the star.
Dialogue: 0,0:47:05.26,0:47:14.02,中文,,0,0,0,,所以一个好的视觉提示是，当你声明一个指针时，也就是让它在你的程序中存在，你必须用星号声明数据类型。
Dialogue: 0,0:47:14.02,0:47:19.02,英文,,0,0,0,,But when you use a pointer, you just use the star. In an ideal world, this would be a completely different symbol.
Dialogue: 0,0:47:14.02,0:47:19.02,中文,,0,0,0,,但是当你使用指针时，你只需要使用星号。在理想情况下，这应该是一个完全不同的符号。
Dialogue: 0,0:47:19.02,0:47:21.45,英文,,0,0,0,,But again, this is what we have.
Dialogue: 0,0:47:19.02,0:47:21.45,中文,,0,0,0,,但这又是我们现有的东西。
Dialogue: 0,0:47:21.45,0:47:24.07,英文,,0,0,0,,Questions now on that syntax?
Dialogue: 0,0:47:21.45,0:47:24.07,中文,,0,0,0,,现在对这个语法有问题吗？
Dialogue: 0,0:47:24.07,0:47:28.11,英文,,0,0,0,,Yeah?
Dialogue: 0,0:47:24.07,0:47:28.11,中文,,0,0,0,,有。
Dialogue: 0,0:47:28.11,0:47:30.83,英文,,0,0,0,,Why can't we just do the ampersand here, are you saying?
Dialogue: 0,0:47:28.11,0:47:30.83,中文,,0,0,0,,你是说为什么我们不能在这里直接用“&”符号？
Dialogue: 0,0:47:30.83,0:47:32.43,英文,,0,0,0,,It was still a little quiet.
Dialogue: 0,0:47:30.83,0:47:32.43,中文,,0,0,0,,还是有点安静。
Dialogue: 0,0:47:32.43,0:47:34.59,英文,,0,0,0,,So strictly speaking, we do not need line 6.
Dialogue: 0,0:47:32.43,0:47:34.59,中文,,0,0,0,,所以严格来说，我们不需要第 6 行。
Dialogue: 0,0:47:34.59,0:47:41.36,英文,,0,0,0,,So this is really for pedagogical sake that I am defining a separate variable p and then printing it out.
Dialogue: 0,0:47:34.59,0:47:41.36,中文,,0,0,0,,这真的是为了教学上的考虑，我定义了一个单独的变量 p，然后把它打印出来。
Dialogue: 0,0:47:41.36,0:47:42.94,英文,,0,0,0,,At this point, though, I'm just kind of
Dialogue: 0,0:47:41.36,0:47:42.94,中文,,0,0,0,,但在这一点上，我只是有点
Dialogue: 0,0:47:42.94,0:47:52.82,英文,,0,0,0,,You know, going in circles, if you will, because more simple would have been what I would have done in week one, which would be get rid of p altogether, get rid of p here, and just print out n, right?
Dialogue: 0,0:47:42.94,0:47:52.82,中文,,0,0,0,,你知道，在兜圈子，如果你愿意，因为更简单的方法就是我在第一周做的事情，那就是完全去掉 p，在这里去掉 p，然后直接打印出 n，对吧？
Dialogue: 0,0:47:52.82,0:48:04.43,英文,,0,0,0,,But today, we're just giving you this new building block, this new syntax via which you can figure out the address of something and then reverse the process later and actually go to it as well.
Dialogue: 0,0:47:52.82,0:48:04.43,中文,,0,0,0,,但今天，我们只是给你这个新的构建块，这个新的语法，通过它你可以找出某个东西的地址，然后反过来，实际地去到那里。
Dialogue: 0,0:48:04.43,0:48:08.45,英文,,0,0,0,,Other questions on what we've done here with these pointers?
Dialogue: 0,0:48:04.43,0:48:08.45,中文,,0,0,0,,关于我们在这里用这些指针做的还有什么问题吗？
Dialogue: 0,0:48:08.45,0:48:14.04,英文,,0,0,0,,All right, well, let's context switch back to the string now and see what more we can do with this here.
Dialogue: 0,0:48:08.45,0:48:14.04,中文,,0,0,0,,好了，让我们将语境切换回字符串，看看我们在这里还能做些什么。
Dialogue: 0,0:48:14.04,0:48:20.24,英文,,0,0,0,,In the case of our strings here, let me refine this to zoom out.
Dialogue: 0,0:48:14.04,0:48:20.24,中文,,0,0,0,,在我们这里的字符串的情况下，让我重新定义它来缩小。
Dialogue: 0,0:48:20.24,0:48:22.80,英文,,0,0,0,,Let me delete the integer-related code here.
Dialogue: 0,0:48:20.24,0:48:22.80,中文,,0,0,0,,让我删除与整数相关的代码。
Dialogue: 0,0:48:22.80,0:48:26.66,英文,,0,0,0,,Let me do string s equals quote, unquote, HIGH in all caps.
Dialogue: 0,0:48:22.80,0:48:26.66,中文,,0,0,0,,让我输入string s 等于引号，引号，大写的 HI。
Dialogue: 0,0:48:26.66,0:48:34.96,英文,,0,0,0,,Let me go ahead and, for the moment, include CS50.h at the top so that, indeed, I can use the keyword s, or string, rather.
Dialogue: 0,0:48:26.66,0:48:34.96,中文,,0,0,0,,让我继续，暂时在顶部包含 cs50.h，以便我可以使用关键字 s，或者说是字符串。
Dialogue: 0,0:48:34.96,0:48:38.40,英文,,0,0,0,,And let me go ahead now and do something more than I did last time.
Dialogue: 0,0:48:34.96,0:48:38.40,中文,,0,0,0,,让我继续，做一些比上次更多的事情。
Dialogue: 0,0:48:38.40,0:48:45.49,英文,,0,0,0,,Last time, I did printf of %s backslash n. And then I printed out s. And again, I'll recompile this just for clarity.
Dialogue: 0,0:48:38.40,0:48:45.49,中文,,0,0,0,,上次我用 printf ("%s\N", s) 打印了 s。为了清楚起见，我再编译一次。
Dialogue: 0,0:48:45.49,0:48:46.87,英文,,0,0,0,,Make addresses, dot slash addresses.
Dialogue: 0,0:48:45.49,0:48:46.87,中文,,0,0,0,,make addresses，./addresses
Dialogue: 0,0:48:46.87,0:48:47.75,英文,,0,0,0,,That just prints out hi.
Dialogue: 0,0:48:46.87,0:48:47.75,中文,,0,0,0,,这样就打印出了 HI!。
Dialogue: 0,0:48:47.75,0:48:49.59,英文,,0,0,0,,So that's, again, week 1 stuff.
Dialogue: 0,0:48:47.75,0:48:49.59,中文,,0,0,0,,这又是第一周的内容。
Dialogue: 0,0:48:49.59,0:48:54.63,英文,,0,0,0,,But now that we have this other bit of syntax, we can do some interesting things too.
Dialogue: 0,0:48:49.59,0:48:54.63,中文,,0,0,0,,但是现在我们有了这种语法，我们可以做一些有趣的事情。
Dialogue: 0,0:48:54.63,0:49:00.91,英文,,0,0,0,,So for instance, suppose I want to print out not s itself, but what if I want to print out the address of s?
Dialogue: 0,0:48:54.63,0:49:00.91,中文,,0,0,0,,例如，假设我想打印的不是 s 本身，而是 s 的地址？
Dialogue: 0,0:49:00.91,0:49:03.37,英文,,0,0,0,,Like, at what memory location is s?
Dialogue: 0,0:49:00.91,0:49:03.37,中文,,0,0,0,,比如，s 在哪个内存地址？
Dialogue: 0,0:49:03.37,0:49:07.35,英文,,0,0,0,,Well, I can change my %s to %p, which now we know p is for pointer.
Dialogue: 0,0:49:03.37,0:49:07.35,中文,,0,0,0,,我可以将 %s 改为 %p，我们现在知道 p 代表指针。
Dialogue: 0,0:49:07.35,0:49:10.19,英文,,0,0,0,,So %p means print out the value of a pointer.
Dialogue: 0,0:49:07.35,0:49:10.19,中文,,0,0,0,,所以 %p 表示打印出一个指针的值。
Dialogue: 0,0:49:10.19,0:49:11.55,英文,,0,0,0,,That is an address.
Dialogue: 0,0:49:10.19,0:49:11.55,中文,,0,0,0,,那是一个地址。
Dialogue: 0,0:49:11.55,0:49:15.29,英文,,0,0,0,,And here, I can actually print out s itself.
Dialogue: 0,0:49:11.55,0:49:15.29,中文,,0,0,0,,在这里，我可以打印出 s 本身。
Dialogue: 0,0:49:15.29,0:49:17.18,英文,,0,0,0,,But why that is, we'll see in a moment.
Dialogue: 0,0:49:15.29,0:49:17.18,中文,,0,0,0,,但为什么会这样，我们稍后会看到。
Dialogue: 0,0:49:17.18,0:49:19.25,英文,,0,0,0,,Let me do this.
Dialogue: 0,0:49:17.18,0:49:19.25,中文,,0,0,0,,我来演示一下。
Dialogue: 0,0:49:19.25,0:49:21.15,英文,,0,0,0,,Here go the training wheels.
Dialogue: 0,0:49:19.25,0:49:21.15,中文,,0,0,0,,辅助轮要上场了。
Dialogue: 0,0:49:21.15,0:49:25.47,英文,,0,0,0,,String does not technically exist, but it does if I'm using the CS50 library.
Dialogue: 0,0:49:21.15,0:49:25.47,中文,,0,0,0,,从技术上讲，string 类型并不存在，但如果我使用 cs50 库，它就存在。
Dialogue: 0,0:49:25.47,0:49:31.59,英文,,0,0,0,,But if I get rid of the CS50 library, as I'm metaphorically doing by taking off the training wheels, I can't use the word string anymore.
Dialogue: 0,0:49:25.47,0:49:31.59,中文,,0,0,0,,但是，如果我去掉 cs50 库，就像我打个比方，把辅助轮拆下来，我就不能再用 string 这个词了。
Dialogue: 0,0:49:31.59,0:49:36.03,英文,,0,0,0,,And in fact, let me make this mistake deliberately, as you might have accidentally in past weeks.
Dialogue: 0,0:49:31.59,0:49:36.03,中文,,0,0,0,,事实上，让我故意犯这个错误，就像你过去几周可能不小心犯的一样。
Dialogue: 0,0:49:36.03,0:49:40.23,英文,,0,0,0,,Here is the error message I get if I forget the CS50 library.
Dialogue: 0,0:49:36.03,0:49:40.23,中文,,0,0,0,,如果我忘记了 cs50 库，就会出现这个错误信息。
Dialogue: 0,0:49:40.23,0:49:42.45,英文,,0,0,0,,Use of undeclared identifier string.
Dialogue: 0,0:49:40.23,0:49:42.45,中文,,0,0,0,,使用未声明的标识符 string。
Dialogue: 0,0:49:42.45,0:49:43.83,英文,,0,0,0,,Did you mean standard n?
Dialogue: 0,0:49:42.45,0:49:43.83,中文,,0,0,0,,你是指 standard n 吗？
Dialogue: 0,0:49:43.83,0:49:51.82,英文,,0,0,0,,It's trying to be helpful, but it's not, because I didn't mean standard n. So indeed, this is confirmation that C does not know the word string exists, at least as a keyword.
Dialogue: 0,0:49:43.83,0:49:51.82,中文,,0,0,0,,它想帮我们，但并没有，因为我指的不是标准 n。这的确证实了 C 不知道 string 这个词的存在，至少不是作为关键字存在的。
Dialogue: 0,0:49:51.82,0:49:54.24,英文,,0,0,0,,Exists as a concept, but not a keyword.
Dialogue: 0,0:49:51.82,0:49:54.24,中文,,0,0,0,,它作为一个概念存在，但不是关键字。
Dialogue: 0,0:49:54.24,0:50:01.11,英文,,0,0,0,,So I could fix this by adding back the CS50 library, but that's kind of a step backwards, educationally, instead of a step forward.
Dialogue: 0,0:49:54.24,0:50:01.11,中文,,0,0,0,,我可以通过添加 cs50 库来解决这个问题，但这在教育意义上是一种倒退，而不是进步。
Dialogue: 0,0:50:01.11,0:50:05.97,英文,,0,0,0,,What could I do instead to fix this now, if the training wheels are now off?
Dialogue: 0,0:50:01.11,0:50:05.97,中文,,0,0,0,,如果现在辅助轮已经拆掉了，我该怎么做才能解决这个问题呢？
Dialogue: 0,0:50:05.97,0:50:09.71,英文,,0,0,0,,Yeah?
Dialogue: 0,0:50:05.97,0:50:09.71,中文,,0,0,0,,嗯？
Dialogue: 0,0:50:09.71,0:50:13.81,英文,,0,0,0,,Exactly, replace string, quote unquote, with char star instead.
Dialogue: 0,0:50:09.71,0:50:13.81,中文,,0,0,0,,没错，用 char* 替换“string”。
Dialogue: 0,0:50:13.81,0:50:16.01,英文,,0,0,0,,So I'm going to go ahead and change this to char.
Dialogue: 0,0:50:13.81,0:50:16.01,中文,,0,0,0,,那我要继续把这个改成 char。
Dialogue: 0,0:50:16.01,0:50:21.42,英文,,0,0,0,,Technically, you can put the literal star here, the asterisk, or you can put it there, or you can put it here.
Dialogue: 0,0:50:16.01,0:50:21.42,中文,,0,0,0,,从技术上讲，你可以把星号放在这里，也可以放在那里，或者放在这里。
Dialogue: 0,0:50:21.42,0:50:28.26,英文,,0,0,0,,By convention is to do what I'd done from the beginning, put the star next to the name of the variable as opposed to anywhere else.
Dialogue: 0,0:50:21.42,0:50:28.26,中文,,0,0,0,,按照惯例，要像我一直做的那样，把星号放在变量名的旁边，而不是其他任何地方。
Dialogue: 0,0:50:28.26,0:50:31.77,英文,,0,0,0,,Let me go ahead now and, or sorry, I meant to add the spaces there.
Dialogue: 0,0:50:28.26,0:50:31.77,中文,,0,0,0,,让我继续，抱歉，我想在那里添加空格。
Dialogue: 0,0:50:31.77,0:50:35.69,英文,,0,0,0,,You could do this too, but this would be the most normal convention. So now let's do this.
Dialogue: 0,0:50:31.77,0:50:35.69,中文,,0,0,0,,你也可以这样做，但这将是最常见的惯例。现在让我们这样做。
Dialogue: 0,0:50:35.69,0:50:36.99,英文,,0,0,0,,Make addresses.
Dialogue: 0,0:50:35.69,0:50:36.99,中文,,0,0,0,,生成地址。
Dialogue: 0,0:50:36.99,0:50:38.82,英文,,0,0,0,,Compile is OK now.
Dialogue: 0,0:50:36.99,0:50:38.82,中文,,0,0,0,,现在可以编译了。
Dialogue: 0,0:50:38.82,0:50:41.14,英文,,0,0,0,,.slash address is what should I see?
Dialogue: 0,0:50:38.82,0:50:41.14,中文,,0,0,0,,./address 我应该看到什么？
Dialogue: 0,0:50:41.14,0:50:44.52,英文,,0,0,0,,High or something else?
Dialogue: 0,0:50:41.14,0:50:44.52,中文,,0,0,0,,“High”还是其他的？
Dialogue: 0,0:50:44.52,0:50:47.35,英文,,0,0,0,,Feel free to just call it out.
Dialogue: 0,0:50:44.52,0:50:47.35,中文,,0,0,0,,请随意说出来。
Dialogue: 0,0:50:47.35,0:50:48.53,英文,,0,0,0,,So still high, you say?
Dialogue: 0,0:50:47.35,0:50:48.53,中文,,0,0,0,,你是说还是“High”？
Dialogue: 0,0:50:48.53,0:50:51.43,英文,,0,0,0,,Someone else?
Dialogue: 0,0:50:48.53,0:50:51.43,中文,,0,0,0,,其他人呢？
Dialogue: 0,0:50:51.43,0:50:52.39,英文,,0,0,0,,A memory location.
Dialogue: 0,0:50:51.43,0:50:52.39,中文,,0,0,0,,一个内存地址。
Dialogue: 0,0:50:52.39,0:50:54.57,英文,,0,0,0,,All right, so it could be one of the two options, right?
Dialogue: 0,0:50:52.39,0:50:54.57,中文,,0,0,0,,所以可能是两种选择之一，对吧？
Dialogue: 0,0:50:54.57,0:50:59.40,英文,,0,0,0,,Either I'm going to see the string, or I'm going to see a memory address, though I do, in fact, see a memory address.
Dialogue: 0,0:50:54.57,0:50:59.40,中文,,0,0,0,,我要么会看到字符串，要么会看到内存地址，虽然实际上我看到了内存地址。
Dialogue: 0,0:50:59.40,0:51:01.64,英文,,0,0,0,,And this one's quite different from the integer one.
Dialogue: 0,0:50:59.40,0:51:01.64,中文,,0,0,0,,这和整数那个很不一样。
Dialogue: 0,0:51:01.64,0:51:09.16,英文,,0,0,0,,But does anyone now want to explain, while you were correct, why am I seeing the address down here and not high?
Dialogue: 0,0:51:01.64,0:51:09.16,中文,,0,0,0,,但是现在有人想解释一下，为什么我在这里看到的是地址而不是高位吗？虽然你们的想法是对的。
Dialogue: 0,0:51:09.16,0:51:12.97,英文,,0,0,0,,It's subtle, yeah.
Dialogue: 0,0:51:09.16,0:51:12.97,中文,,0,0,0,,这很微妙，是的。
Dialogue: 0,0:51:12.97,0:51:17.63,英文,,0,0,0,,Exactly, because I left my %p there, which means, hey, printf, show me a pointer.
Dialogue: 0,0:51:12.97,0:51:17.63,中文,,0,0,0,,没错，因为我留下了 %p，这意味着，printf，给我看一个指针。
Dialogue: 0,0:51:17.63,0:51:21.20,英文,,0,0,0,,But this is where printf is smart and has been smart since week 0.
Dialogue: 0,0:51:17.63,0:51:21.20,中文,,0,0,0,,但这就是 printf 从第 0 周开始就表现得很聪明的地方。
Dialogue: 0,0:51:21.20,0:51:39.47,英文,,0,0,0,,Humans who invented printf decades ago wrote code that notices that, OK, %s means to treat the following value not as just an address per se that gets printed literally, but print it, as with the mailbox demo, as sort of a treasure map that leads you to the address of a character.
Dialogue: 0,0:51:21.20,0:51:39.47,中文,,0,0,0,,几十年前发明 printf 的人们写的代码会注意到，\NOK，%s 意味着不要将后面的值视为按字面打印的地址，而是将其打印为类似于邮箱演示的藏宝图，引导你找到一个字符的地址。
Dialogue: 0,0:51:39.47,0:51:53.04,英文,,0,0,0,,So simply by changing one character, %p to %s, and if I now do make addresses again and .slash addresses, this now is identical to week 1, but hopefully makes sense because %s is just a clue to printf.
Dialogue: 0,0:51:39.47,0:51:53.04,中文,,0,0,0,,因此，只需将一个字符 %p 更改为 %s，如果我现在再次执行\N make addresses 和 ./addresses，现在这与第 1 周相同，但希望有道理，因为 %s 只是对 printf 的一个提示。
Dialogue: 0,0:51:53.04,0:52:01.06,英文,,0,0,0,,That means go to this address in s. We'll print out every character there and thereafter until you see what?
Dialogue: 0,0:51:53.04,0:52:01.06,中文,,0,0,0,,这意味着转到 s 中的这个地址。我们将打印出从那里开始的每个字符，直到看到什么？
Dialogue: 0,0:52:01.06,0:52:03.95,英文,,0,0,0,,The null character, and then stop printing anything more.
Dialogue: 0,0:52:01.06,0:52:03.95,中文,,0,0,0,,空字符，然后停止打印任何内容。
Dialogue: 0,0:52:03.95,0:52:07.17,英文,,0,0,0,,And this is why Hi has printed since week one.
Dialogue: 0,0:52:03.95,0:52:07.17,中文,,0,0,0,,这就是为什么从第一周开始就打印 Hi 的原因。
Dialogue: 0,0:52:07.17,0:52:09.81,英文,,0,0,0,,Today, we can see the address %p.
Dialogue: 0,0:52:07.17,0:52:09.81,中文,,0,0,0,,今天，我们可以看到地址 %p。
Dialogue: 0,0:52:09.81,0:52:21.41,英文,,0,0,0,,But this combination of having access to addresses and the null terminator is all the information printf needs to actually do something more useful by printing the actual strings.
Dialogue: 0,0:52:09.81,0:52:21.41,中文,,0,0,0,,但是，访问地址和空终止符的这种组合是 printf 实际执行更有用的操作（打印实际字符串）所需的所有信息。
Dialogue: 0,0:52:21.41,0:52:26.35,英文,,0,0,0,,Any questions now on this approach to %s?
Dialogue: 0,0:52:21.41,0:52:26.35,中文,,0,0,0,,对这种 %s 的方法还有问题吗？
Dialogue: 0,0:52:26.35,0:52:29.66,英文,,0,0,0,,Yeah, in back.
Dialogue: 0,0:52:26.35,0:52:29.66,中文,,0,0,0,,有的，后面那位。
Dialogue: 0,0:52:29.66,0:52:32.30,英文,,0,0,0,,Oh, so why is it traditionally being used in this way?
Dialogue: 0,0:52:29.66,0:52:32.30,中文,,0,0,0,,那为什么传统上是这样用的呢？
Dialogue: 0,0:52:32.30,0:52:34.62,英文,,0,0,0,,Honestly, the word string has been around for decades.
Dialogue: 0,0:52:32.30,0:52:34.62,中文,,0,0,0,,说实话，“string”这个词已经存在几十年了。
Dialogue: 0,0:52:34.62,0:52:39.57,英文,,0,0,0,,It's not a keyword you should be able to type in C, unless you're using a library like CS50s.
Dialogue: 0,0:52:34.62,0:52:39.57,中文,,0,0,0,,它不是一个你应该在 C 语言中输入的关键字，除非你使用的是像 cs50 这样的库。
Dialogue: 0,0:52:39.57,0:52:41.25,英文,,0,0,0,,And so %s just means string.
Dialogue: 0,0:52:39.57,0:52:41.25,中文,,0,0,0,,所以 %s 只是表示字符串。
Dialogue: 0,0:52:41.25,0:52:45.23,英文,,0,0,0,,So even though it doesn't exist as a keyword, %s connotes string.
Dialogue: 0,0:52:41.25,0:52:45.23,中文,,0,0,0,,所以即使它不存在作为一个关键字，%s 也意味着字符串。
Dialogue: 0,0:52:45.23,0:52:48.18,英文,,0,0,0,,And humans decades ago, like today, just kind of know what that means.
Dialogue: 0,0:52:45.23,0:52:48.18,中文,,0,0,0,,几十年前的人和今天的人一样，都知道这意味着什么。
Dialogue: 0,0:52:48.18,0:52:52.64,英文,,0,0,0,,So they could have chosen any letter of the alphabet, but s sort of makes the most sense.
Dialogue: 0,0:52:48.18,0:52:52.64,中文,,0,0,0,,他们可以选择字母表中的任何字母，但 s 似乎是最合理的。
Dialogue: 0,0:52:52.64,0:52:54.22,英文,,0,0,0,,All right, well, let's in back.
Dialogue: 0,0:52:52.64,0:52:54.22,中文,,0,0,0,,让我们回到正题。
Dialogue: 0,0:52:54.22,0:52:56.83,英文,,0,0,0,,Other question?
Dialogue: 0,0:52:54.22,0:52:56.83,中文,,0,0,0,,还有问题吗？
Dialogue: 0,0:52:56.83,0:52:57.53,英文,,0,0,0,,Good question.
Dialogue: 0,0:52:56.83,0:52:57.53,中文,,0,0,0,,问得好。
Dialogue: 0,0:52:57.53,0:52:58.51,英文,,0,0,0,,Before, let me zoom in.
Dialogue: 0,0:52:57.53,0:52:58.51,中文,,0,0,0,,之前，让我放大一点。
Dialogue: 0,0:52:58.51,0:53:01.95,英文,,0,0,0,,I did not use a star before the s. Why?
Dialogue: 0,0:52:58.51,0:53:01.95,中文,,0,0,0,,我没有在 s 前面使用星号。为什么？
Dialogue: 0,0:53:01.95,0:53:11.32,英文,,0,0,0,,Well, it's subtle here, but printf was invented years ago to know, given an address, like in the variable s, printf knows to go there.
Dialogue: 0,0:53:01.95,0:53:11.32,中文,,0,0,0,,这很微妙，但 printf 是多年前发明的，它知道在给定地址的情况下，比如在变量 s 中，printf 知道去哪里。
Dialogue: 0,0:53:11.32,0:53:18.76,英文,,0,0,0,,So if we looked at the source code that some human wrote years ago for c, we would likely see the actual asterisk that you're referring to.
Dialogue: 0,0:53:11.32,0:53:18.76,中文,,0,0,0,,所以如果我们看一下多年前一些人为 c 编写的源代码，我们很可能会看到你提到的星号。
Dialogue: 0,0:53:18.76,0:53:29.63,英文,,0,0,0,,Printf is taking on the responsibility for going to s. If you were to do star s here instead, an asterisk, and then s, That would now be literally a character.
Dialogue: 0,0:53:18.76,0:53:29.63,中文,,0,0,0,,Printf 负责去 s。如果你在这里使用星号 s，一个星号，然后是 s， 那现在就真的是一个字符了。
Dialogue: 0,0:53:29.63,0:53:35.93,英文,,0,0,0,,Because if I say star s, that means go to the address in s, and all you're going to find there is a single character.
Dialogue: 0,0:53:29.63,0:53:35.93,中文,,0,0,0,,因为如果我说星号 s，这意味着转到 s 中的地址，你在那里找到的只是一个字符。
Dialogue: 0,0:53:35.93,0:53:41.48,英文,,0,0,0,,What printf wants to know is not what is the character there, what is the address of that character.
Dialogue: 0,0:53:35.93,0:53:41.48,中文,,0,0,0,,Printf 想知道的不是那里是什么字符，而是那个字符的地址是什么。
Dialogue: 0,0:53:41.48,0:53:41.98,英文,,0,0,0,,Why?
Dialogue: 0,0:53:41.48,0:53:41.98,中文,,0,0,0,,为什么？
Dialogue: 0,0:53:41.98,0:53:48.99,英文,,0,0,0,,Because printf needs to walk through the rest of those characters looking for the final null character.
Dialogue: 0,0:53:41.98,0:53:48.99,中文,,0,0,0,,因为 printf 需要遍历其余字符来查找最后的空字符。
Dialogue: 0,0:53:48.99,0:53:52.81,英文,,0,0,0,,And in fact, let me see with a bit more syntax if we can highlight this a bit more.
Dialogue: 0,0:53:48.99,0:53:52.81,中文,,0,0,0,,事实上，让我用更多语法看看是否可以更突出地显示这一点。
Dialogue: 0,0:53:52.81,0:53:53.63,英文,,0,0,0,,Let me do this.
Dialogue: 0,0:53:52.81,0:53:53.63,中文,,0,0,0,,让我这样做。
Dialogue: 0,0:53:53.63,0:53:56.93,英文,,0,0,0,,In addition to printing s, let's try out our syntax in another way.
Dialogue: 0,0:53:53.63,0:53:56.93,中文,,0,0,0,,除了打印 s 之外，让我们以另一种方式尝试一下语法。
Dialogue: 0,0:53:56.93,0:53:58.80,英文,,0,0,0,,Let me print out with %s.
Dialogue: 0,0:53:56.93,0:53:58.80,中文,,0,0,0,,让我用 %s 打印出来。
Dialogue: 0,0:53:58.80,0:54:03.28,英文,,0,0,0,,How about not s here, but let's print out some addresses.
Dialogue: 0,0:53:58.80,0:54:03.28,中文,,0,0,0,,这里不用 s，让我们打印出一些地址。
Dialogue: 0,0:54:03.28,0:54:06.04,英文,,0,0,0,,%s backslash n, close quote.
Dialogue: 0,0:54:03.28,0:54:06.04,中文,,0,0,0,,%s 反斜杠 n, 加引号。
Dialogue: 0,0:54:06.04,0:54:08.22,英文,,0,0,0,,And then let's print out, how about this?
Dialogue: 0,0:54:06.04,0:54:08.22,中文,,0,0,0,,然后我们打印出来，这样如何？
Dialogue: 0,0:54:08.22,0:54:12.69,英文,,0,0,0,,The first character in the string s would be called s bracket 0.
Dialogue: 0,0:54:08.22,0:54:12.69,中文,,0,0,0,,string s 中的第一个字符将被称为 s[0]。
Dialogue: 0,0:54:12.69,0:54:16.69,英文,,0,0,0,,But how do I get the address of the first character in s?
Dialogue: 0,0:54:12.69,0:54:16.69,中文,,0,0,0,,但是如何获取 s 中第一个字符的地址呢？
Dialogue: 0,0:54:16.69,0:54:18.81,英文,,0,0,0,,Well, I could technically just use today's new primitive.
Dialogue: 0,0:54:16.69,0:54:18.81,中文,,0,0,0,,从技术上讲，我可以使用今天的新原语。
Dialogue: 0,0:54:18.81,0:54:22.81,英文,,0,0,0,,I can just add an ampersand. That always gives me the address of some value.
Dialogue: 0,0:54:18.81,0:54:22.81,中文,,0,0,0,,我可以加一个 & 符号。这总是给我某个值的地址。
Dialogue: 0,0:54:22.81,0:54:34.90,英文,,0,0,0,,So when I end this thought and clear my terminal window and run make addresses, still compiles, when I run addresses in just a moment, any guesses as to what I will see line by line?
Dialogue: 0,0:54:22.81,0:54:34.90,中文,,0,0,0,,当我结束这个想法并清除我的终端窗口并运行 make addresses 时，仍然可以编译，当我运行 addresses 时，猜猜我会逐行看到什么？
Dialogue: 0,0:54:34.90,0:54:37.29,英文,,0,0,0,,This will print out two things.
Dialogue: 0,0:54:34.90,0:54:37.29,中文,,0,0,0,,这将打印出两样东西。
Dialogue: 0,0:54:37.29,0:54:39.54,英文,,0,0,0,,And you don't have to remember what the actual number was.
Dialogue: 0,0:54:37.29,0:54:39.54,中文,,0,0,0,,你不必记住实际的数字是什么。
Dialogue: 0,0:54:39.54,0:54:42.58,英文,,0,0,0,,But at a high level, what will be printed now?
Dialogue: 0,0:54:39.54,0:54:42.58,中文,,0,0,0,,但在高级层面，现在会打印出什么？
Dialogue: 0,0:54:42.58,0:54:44.12,英文,,0,0,0,,The same thing twice.
Dialogue: 0,0:54:42.58,0:54:44.12,中文,,0,0,0,,两次都一样。
Dialogue: 0,0:54:44.12,0:54:44.70,英文,,0,0,0,,Why?
Dialogue: 0,0:54:44.12,0:54:44.70,中文,,0,0,0,,为什么？
Dialogue: 0,0:54:44.70,0:54:50.91,英文,,0,0,0,,Well, when I run this, what I'm printing here, and let me zoom in at the bottom, I indeed see two really long addresses.
Dialogue: 0,0:54:44.70,0:54:50.91,中文,,0,0,0,,当我运行它时，我在这里打印的是，让我在底部放大，我确实看到了两个非常长的地址。
Dialogue: 0,0:54:50.91,0:54:52.09,英文,,0,0,0,,But they're, in fact, the same.
Dialogue: 0,0:54:50.91,0:54:52.09,中文,,0,0,0,,但实际上，它们是相同的。
Dialogue: 0,0:54:52.09,0:54:52.67,英文,,0,0,0,,Why?
Dialogue: 0,0:54:52.09,0:54:52.67,中文,,0,0,0,,为什么？
Dialogue: 0,0:54:52.67,0:55:04.58,英文,,0,0,0,,Well, that's because, again, if s is the address of a character, as implied now by either the CS50 word string or the actual phrase char star, well, then s is just an address.
Dialogue: 0,0:54:52.67,0:55:04.58,中文,,0,0,0,,这是因为，再次强调，如果 s 是一个字符的地址，正如现在 cs50 词字符串或实际短语 char * 所暗示的那样，那么 s 就只是一个地址。
Dialogue: 0,0:55:04.58,0:55:09.20,英文,,0,0,0,,By contrast, per week 2, s bracket 0 is a char.
Dialogue: 0,0:55:04.58,0:55:09.20,中文,,0,0,0,,相比之下，根据第 2 周的内容，s[0] 是一个 char。
Dialogue: 0,0:55:09.20,0:55:11.26,英文,,0,0,0,,Always has been a char, a specific char.
Dialogue: 0,0:55:09.20,0:55:11.26,中文,,0,0,0,,一直是一个字符，一个特定的字符。
Dialogue: 0,0:55:11.26,0:55:14.33,英文,,0,0,0,,But if you want the address of that char, you just add the ampersand.
Dialogue: 0,0:55:11.26,0:55:14.33,中文,,0,0,0,,但是如果你想要这个字符的地址，你只需添加 & 符号。
Dialogue: 0,0:55:14.33,0:55:20.37,英文,,0,0,0,,Well, it turns out that strings, per the definition we keep emphasizing, is just the address of the first character in a string.
Dialogue: 0,0:55:14.33,0:55:20.37,中文,,0,0,0,,事实证明，根据我们一直强调的定义，字符串就是字符串中第一个字符的地址。
Dialogue: 0,0:55:20.37,0:55:25.14,英文,,0,0,0,,So of course, if you do this, you're going to see the exact same thing. And if I do this a bit more.
Dialogue: 0,0:55:20.37,0:55:25.14,中文,,0,0,0,,当然，如果你这样做，你会看到完全相同的东西。如果我再做一点。
Dialogue: 0,0:55:25.14,0:55:28.96,英文,,0,0,0,,Generally, you don't want to copy-paste, but this is just for visualization's sake.
Dialogue: 0,0:55:25.14,0:55:28.96,中文,,0,0,0,,一般来说，你不应该复制粘贴，但这只是为了便于观察。
Dialogue: 0,0:55:28.96,0:55:30.46,英文,,0,0,0,,Let me print out all of the characters.
Dialogue: 0,0:55:28.96,0:55:30.46,中文,,0,0,0,,让我打印出所有字符。
Dialogue: 0,0:55:30.46,0:55:32.48,英文,,0,0,0,,So another, another, another.
Dialogue: 0,0:55:30.46,0:55:32.48,中文,,0,0,0,,再来一个，再来一个，再来一个。
Dialogue: 0,0:55:32.48,0:55:37.58,英文,,0,0,0,,And let me change this to print out the address of bracket 1, bracket 2, and bracket 3.
Dialogue: 0,0:55:32.48,0:55:37.58,中文,,0,0,0,,让我把这个改成打印出 s[1]、s[2] 和 s[3]  的地址。
Dialogue: 0,0:55:37.58,0:55:41.70,英文,,0,0,0,,So all four characters, HI, exclamation point, and the null character.
Dialogue: 0,0:55:37.58,0:55:41.70,中文,,0,0,0,,所以所有四个字符，HI，感叹号和空字符。
Dialogue: 0,0:55:41.70,0:55:43.96,英文,,0,0,0,,Notice I'm using %p for all of them.
Dialogue: 0,0:55:41.70,0:55:43.96,中文,,0,0,0,,注意我对它们都使用了 %p。
Dialogue: 0,0:55:43.96,0:55:51.66,英文,,0,0,0,,So if I now do make addresses and dot slash addresses, now notice, and this is kind of cool, the first two are indeed still the same.
Dialogue: 0,0:55:43.96,0:55:51.66,中文,,0,0,0,,如果我现在执行 make addresses 和 ./addresses，现在请注意，这有点酷，前两个确实仍然相同。
Dialogue: 0,0:55:51.66,0:55:57.35,英文,,0,0,0,,But what's noteworthy about the other values on the screen?
Dialogue: 0,0:55:51.66,0:55:57.35,中文,,0,0,0,,但屏幕上的其他值有什么值得注意的地方？
Dialogue: 0,0:55:57.35,0:55:58.43,英文,,0,0,0,,Yeah, they're consecutive.
Dialogue: 0,0:55:57.35,0:55:58.43,中文,,0,0,0,,是的，它们是连续的。
Dialogue: 0,0:55:58.43,0:56:00.21,英文,,0,0,0,,Each of these is just one byte away.
Dialogue: 0,0:55:58.43,0:56:00.21,中文,,0,0,0,,每个都只相隔一个字节。
Dialogue: 0,0:56:00.21,0:56:03.53,英文,,0,0,0,,Even if you're not good at hex yet and there's a crazy number of digits here, who cares?
Dialogue: 0,0:56:00.21,0:56:03.53,中文,,0,0,0,,即使你不擅长十六进制，这里有这么多位数字，谁在乎呢？
Dialogue: 0,0:56:03.53,0:56:05.88,英文,,0,0,0,,They're all the same except for the last ones.
Dialogue: 0,0:56:03.53,0:56:05.88,中文,,0,0,0,,除了最后几个，它们都是一样的。
Dialogue: 0,0:56:05.88,0:56:07.94,英文,,0,0,0,,4, 4, and then 5, 6, 7.
Dialogue: 0,0:56:05.88,0:56:07.94,中文,,0,0,0,,4、4，然后是 5、6、7。
Dialogue: 0,0:56:07.94,0:56:13.36,英文,,0,0,0,,And this confirms what I've been claiming for weeks is that in an array, all of the characters are back to back to back.
Dialogue: 0,0:56:07.94,0:56:13.36,中文,,0,0,0,,这证实了我几周来一直声称的，在一个数组中，所有的字符都是挨着的。
Dialogue: 0,0:56:13.36,0:56:16.55,英文,,0,0,0,,Contiguous, one byte away.
Dialogue: 0,0:56:13.36,0:56:16.55,中文,,0,0,0,,连续的，相隔一个字节。
Dialogue: 0,0:56:16.55,0:56:27.24,英文,,0,0,0,,So with just this ampersand, with just this star, it's actually a pretty cool tool in the toolkit to have, because you can start to poke around what's actually going on inside of the computer's memory.
Dialogue: 0,0:56:16.55,0:56:27.24,中文,,0,0,0,,仅仅使用这个“&”符号，仅仅使用这个“*”星号，它实际上就是一个非常酷的工具，因为它可以让你开始探究计算机内存中到底发生了什么。
Dialogue: 0,0:56:27.24,0:56:32.68,英文,,0,0,0,,And in fact, if we do this, I can introduce one other cool trick here, if you will.
Dialogue: 0,0:56:27.24,0:56:32.68,中文,,0,0,0,,事实上，如果我们这样做，我可以在这里介绍另一个很酷的技巧，如果你愿意的话。
Dialogue: 0,0:56:32.68,0:56:38.12,英文,,0,0,0,,Let me propose that. We can actually now do arithmetic on pointers.
Dialogue: 0,0:56:32.68,0:56:38.12,中文,,0,0,0,,我建议，我们现在实际上可以对指针进行算术运算了。
Dialogue: 0,0:56:38.12,0:56:39.09,英文,,0,0,0,,And you don't have to.
Dialogue: 0,0:56:38.12,0:56:39.09,中文,,0,0,0,,你也不必这样做。
Dialogue: 0,0:56:39.09,0:56:40.83,英文,,0,0,0,,You'll see a simpler way to do this.
Dialogue: 0,0:56:39.09,0:56:40.83,中文,,0,0,0,,你会看到更简单的方法。
Dialogue: 0,0:56:40.83,0:56:48.75,英文,,0,0,0,,But now that you have, perhaps, this understanding of where things are in memory, and it's just addresses, we can actually do something kind of neat.
Dialogue: 0,0:56:40.83,0:56:48.75,中文,,0,0,0,,但是现在，你可能对数据在内存中的位置有了一些了解，它们只是地址，我们可以做一些很简洁的事情。
Dialogue: 0,0:56:48.75,0:56:50.91,英文,,0,0,0,,We can do something like this.
Dialogue: 0,0:56:48.75,0:56:50.91,中文,,0,0,0,,我们可以这样做。
Dialogue: 0,0:56:50.91,0:56:55.69,英文,,0,0,0,,Let me go back to, how about, the string version of this with hi.
Dialogue: 0,0:56:50.91,0:56:55.69,中文,,0,0,0,,让我回到字符串版本的 "HI!"。
Dialogue: 0,0:56:55.69,0:56:57.18,英文,,0,0,0,,And let me do this instead.
Dialogue: 0,0:56:55.69,0:56:57.18,中文,,0,0,0,,让我这样做。
Dialogue: 0,0:56:57.18,0:57:01.46,英文,,0,0,0,,Let me clean this up a bit, get rid of some of these lines of code.
Dialogue: 0,0:56:57.18,0:57:01.46,中文,,0,0,0,,让我清理一下代码，去掉一些代码行。
Dialogue: 0,0:57:01.46,0:57:05.16,英文,,0,0,0,,And let me do this. Let me print out %c, %c, %c.
Dialogue: 0,0:57:01.46,0:57:05.16,中文,,0,0,0,,让我这样做，让我打印出 %c, %c, %c。
Dialogue: 0,0:57:05.16,0:57:06.80,英文,,0,0,0,,Let me get rid of all these ampersands.
Dialogue: 0,0:57:05.16,0:57:06.80,中文,,0,0,0,,让我去掉所有这些“&”。
Dialogue: 0,0:57:06.80,0:57:09.39,英文,,0,0,0,,We're going to roll back to, like, week 2 stuff.
Dialogue: 0,0:57:06.80,0:57:09.39,中文,,0,0,0,,我们要回到第二周的内容。
Dialogue: 0,0:57:09.39,0:57:17.16,英文,,0,0,0,,Just to be clear, when I compile and run this version of the program, and I'll zoom in, what should get printed on the screen?
Dialogue: 0,0:57:09.39,0:57:17.16,中文,,0,0,0,,需要说明的是，当我编译并运行这个版本的程序时，我把屏幕放大，屏幕上应该打印什么？
Dialogue: 0,0:57:17.16,0:57:19.48,英文,,0,0,0,,This is just week two stuff now.
Dialogue: 0,0:57:17.16,0:57:19.48,中文,,0,0,0,,这只是第二周的内容。
Dialogue: 0,0:57:19.48,0:57:20.93,英文,,0,0,0,,No pointers per se.
Dialogue: 0,0:57:19.48,0:57:20.93,中文,,0,0,0,,本身没有指针。
Dialogue: 0,0:57:20.93,0:57:23.89,英文,,0,0,0,,Yeah.
Dialogue: 0,0:57:20.93,0:57:23.89,中文,,0,0,0,,是的。
Dialogue: 0,0:57:23.89,0:57:28.05,英文,,0,0,0,,Just HI exclamation point, one per line, because I have all of these backslash n's.
Dialogue: 0,0:57:23.89,0:57:28.05,中文,,0,0,0,,就是 HI 和感叹号，每行一个，因为我用了\N。
Dialogue: 0,0:57:28.05,0:57:29.23,英文,,0,0,0,,So let me do that.
Dialogue: 0,0:57:28.05,0:57:29.23,中文,,0,0,0,,我来运行一下。
Dialogue: 0,0:57:29.23,0:57:32.27,英文,,0,0,0,,Let me go down here, make addresses, Enter.
Dialogue: 0,0:57:29.23,0:57:32.27,中文,,0,0,0,,让我往下走，输入 addresses, 回车。
Dialogue: 0,0:57:32.27,0:57:36.33,英文,,0,0,0,,OK, pretty good, dot slash addresses, and indeed, HI exclamation point.
Dialogue: 0,0:57:32.27,0:57:36.33,中文,,0,0,0,,很好，./addresses，确实是 HI 和感叹号。
Dialogue: 0,0:57:36.33,0:57:50.18,英文,,0,0,0,,But now, if you're getting a little more comfortable, and it's fine if you're not yet today, but over the coming week or weeks, as you get a little more comfortable with the equivalence of addresses with our definition in the past of arrays and strings and all of this, you can start to play around.
Dialogue: 0,0:57:36.33,0:57:50.18,中文,,0,0,0,,但是现在，如果你对地址和我们之前定义的数组、\N字符串等等之间的等价关系感到更适应了，即使你现在还没有，但在接下来的一两周内，你可以开始尝试一下。
Dialogue: 0,0:57:50.18,0:57:51.90,英文,,0,0,0,,And I can do this instead.
Dialogue: 0,0:57:50.18,0:57:51.90,中文,,0,0,0,,我也可以这样做。
Dialogue: 0,0:57:51.90,0:57:53.42,英文,,0,0,0,,If I want to print out.
Dialogue: 0,0:57:51.90,0:57:53.42,中文,,0,0,0,,如果我想打印出来。
Dialogue: 0,0:57:53.42,0:57:58.21,英文,,0,0,0,,The first character in the string, I could do, like week 2, s bracket 0.
Dialogue: 0,0:57:53.42,0:57:58.21,中文,,0,0,0,,字符串中的第一个字符，我可以这样做，比如 week 2，s 中括号 0。
Dialogue: 0,0:57:58.21,0:57:59.95,英文,,0,0,0,,That will always work, and you can keep using that.
Dialogue: 0,0:57:58.21,0:57:59.95,中文,,0,0,0,,这总是有效的，你可以继续使用它。
Dialogue: 0,0:57:59.95,0:58:07.69,英文,,0,0,0,,That's not a CS50 thing. It's just a convenience in C. But I could technically print out not s, because s is an address.
Dialogue: 0,0:57:59.95,0:58:07.69,中文,,0,0,0,,这不是 cs50 的东西。这只是 C 语言中的一个便利之处。但我技术上不能打印出 s，因为 s 是一个地址。
Dialogue: 0,0:58:07.69,0:58:13.43,英文,,0,0,0,,But what would be the syntax I could use to, say, print out the character at s?
Dialogue: 0,0:58:07.69,0:58:13.43,中文,,0,0,0,,但是，我可以使用什么语法来打印出 s 处的字符？
Dialogue: 0,0:58:13.43,0:58:15.22,英文,,0,0,0,,Any instinct?
Dialogue: 0,0:58:13.43,0:58:15.22,中文,,0,0,0,,有什么想法吗？
Dialogue: 0,0:58:15.22,0:58:19.06,英文,,0,0,0,,How can I say go to the address in s?
Dialogue: 0,0:58:15.22,0:58:19.06,中文,,0,0,0,,我怎样才能说转到 s 中的地址？
Dialogue: 0,0:58:19.06,0:58:22.02,英文,,0,0,0,,It's one of two possible answers today.
Dialogue: 0,0:58:19.06,0:58:22.02,中文,,0,0,0,,这是今天两个可能答案中的一个。
Dialogue: 0,0:58:22.02,0:58:27.47,英文,,0,0,0,,So of our two new operators today, we have the ampersand and the star.
Dialogue: 0,0:58:22.02,0:58:27.47,中文,,0,0,0,,所以在我们今天学习的两个新运算符中，我们有“&”和“*”。
Dialogue: 0,0:58:27.47,0:58:32.31,英文,,0,0,0,,Which one will lead us to what is at an address? So the star.
Dialogue: 0,0:58:27.47,0:58:32.31,中文,,0,0,0,,哪一个会引导我们找到某个地址的内容？ 是“*”。
Dialogue: 0,0:58:32.31,0:58:45.50,英文,,0,0,0,,So in fact, if I want to print out what is at address s, I can just do star s. And if you really want to get fancy, how do you print out the second character that's immediately to the right of it, so to speak?
Dialogue: 0,0:58:32.31,0:58:45.50,中文,,0,0,0,,所以实际上，如果我想打印出地址 s 中的内容，我只需要输入“*s”即可。\N如果你真的想要炫耀一下，你如何打印出紧挨着它的右边第二个字符，可以这么说？
Dialogue: 0,0:58:45.50,0:58:51.12,英文,,0,0,0,,Well, you can go to, with the dereference operator, and do you want to answer this one?
Dialogue: 0,0:58:45.50,0:58:51.12,中文,,0,0,0,,你可以使用解引用运算符，你想回答这个问题吗？
Dialogue: 0,0:58:51.12,0:58:54.15,英文,,0,0,0,,S plus 1, ergo pointer arithmetic.
Dialogue: 0,0:58:51.12,0:58:54.15,中文,,0,0,0,,s + 1，也就是指针运算。
Dialogue: 0,0:58:54.15,0:58:58.53,英文,,0,0,0,,Like, you can do math, simple addition, subtraction, whatever, on pointers if you want.
Dialogue: 0,0:58:54.15,0:58:58.53,中文,,0,0,0,,你可以对指针进行数学运算，简单的加法、减法等等，如果你愿意的话。
Dialogue: 0,0:58:58.53,0:59:01.96,英文,,0,0,0,,And you can do this here, too. So star, if you want to pluck this one off, too.
Dialogue: 0,0:58:58.53,0:59:01.96,中文,,0,0,0,,你也可以在这里这样做。所以“*”，如果你想把这个也摘下来。
Dialogue: 0,0:59:01.96,0:59:07.34,英文,,0,0,0,,How do I print out the last character, the third? S plus 2, right?
Dialogue: 0,0:59:01.96,0:59:07.34,中文,,0,0,0,,如何打印出最后一个字符，第三个字符？s + 2，对吧？
Dialogue: 0,0:59:07.34,0:59:17.09,英文,,0,0,0,,Because if you know and understand that a string is just a sequence of characters, every character is just a byte, and these bytes are back to back to back, you can just go wherever you want in the computer's memory.
Dialogue: 0,0:59:07.34,0:59:17.09,中文,,0,0,0,,因为如果你了解字符串只是一系列字符，每个字符只是一个字节，并且这些字节是连续存储的，你就可以在计算机内存中随心所欲地访问。
Dialogue: 0,0:59:17.09,0:59:23.03,英文,,0,0,0,,And here, I can do make addresses again, dot slash addresses, and voila, we now have high exclamation points.
Dialogue: 0,0:59:17.09,0:59:23.03,中文,,0,0,0,,在这里，我可以再次创建地址，输入“./addresses”，瞧，我们现在有了感叹号。
Dialogue: 0,0:59:23.03,0:59:25.21,英文,,0,0,0,,So we haven't printed out anything new.
Dialogue: 0,0:59:23.03,0:59:25.21,中文,,0,0,0,,我们没有打印任何新内容。
Dialogue: 0,0:59:25.21,0:59:33.06,英文,,0,0,0,,But again, just by using these two new operators, the ampersand and the star, you can figure out the address of something, and you can go to the address of something.
Dialogue: 0,0:59:25.21,0:59:33.06,中文,,0,0,0,,但是，再次强调，只需使用这两个新的运算符，& 和 *，你就可以找出某个东西的地址，并且你可以访问该地址。
Dialogue: 0,0:59:33.06,0:59:35.89,英文,,0,0,0,,OK, question in back.
Dialogue: 0,0:59:33.06,0:59:35.89,中文,,0,0,0,,后面的同学有问题。
Dialogue: 0,0:59:35.89,0:59:37.77,英文,,0,0,0,,Indeed, it ends up being the exact same.
Dialogue: 0,0:59:35.89,0:59:37.77,中文,,0,0,0,,确实，结果是完全一样的。
Dialogue: 0,0:59:37.77,0:59:39.65,英文,,0,0,0,,And so I might have used this term before.
Dialogue: 0,0:59:37.77,0:59:39.65,中文,,0,0,0,,我之前可能用过这个词。
Dialogue: 0,0:59:39.65,0:59:49.02,英文,,0,0,0,,The ampersand technique, sorry, the square bracket technique where you do s bracket 0, s bracket 1, s bracket 2, that's actually what we would really call syntactic sugar.
Dialogue: 0,0:59:39.65,0:59:49.02,中文,,0,0,0,,& 技术，抱歉，是方括号技术，你用 s[0], s[1], s[2] 的方式，这实际上就是我们所说的语法糖。
Dialogue: 0,0:59:49.02,0:59:49.82,英文,,0,0,0,,Like, it works.
Dialogue: 0,0:59:49.02,0:59:49.82,中文,,0,0,0,,就像，它可以工作。
Dialogue: 0,0:59:49.82,0:59:50.52,英文,,0,0,0,,And you can use it.
Dialogue: 0,0:59:49.82,0:59:50.52,中文,,0,0,0,,你可以使用它。
Dialogue: 0,0:59:50.52,0:59:51.20,英文,,0,0,0,,You should use it.
Dialogue: 0,0:59:50.52,0:59:51.20,中文,,0,0,0,,你应该使用它。
Dialogue: 0,0:59:51.20,0:59:52.40,英文,,0,0,0,,It's nice and simple.
Dialogue: 0,0:59:51.20,0:59:52.40,中文,,0,0,0,,它很好也很简单。
Dialogue: 0,0:59:52.40,0:59:55.27,英文,,0,0,0,,But the square bracket notation underneath the hood
Dialogue: 0,0:59:52.40,0:59:55.27,中文,,0,0,0,,但是方括号符号在底层
Dialogue: 0,0:59:55.27,0:59:58.69,英文,,0,0,0,,is essentially being converted to this, which this is not fun, right?
Dialogue: 0,0:59:55.27,0:59:58.69,中文,,0,0,0,,本质上是被转换成这样的，这就不有趣了，对吧？
Dialogue: 0,0:59:58.69,1:00:01.87,英文,,0,0,0,,Like, this is when you want to show off to your friends, like, you know how to do cool stuff in code.
Dialogue: 0,0:59:58.69,1:00:01.87,中文,,0,0,0,,就像你想向你的朋友炫耀的时候，你知道如何在代码中做很酷的事情。
Dialogue: 0,1:00:01.87,1:00:05.63,英文,,0,0,0,,But this is not as readable as just s bracket 0 and 1 and 2.
Dialogue: 0,1:00:01.87,1:00:05.63,中文,,0,0,0,,但这不如 s[0]、s[1] 和 s[2] 那样易读。
Dialogue: 0,1:00:05.63,1:00:07.49,英文,,0,0,0,,But that's all that's happening underneath the hood.
Dialogue: 0,1:00:05.63,1:00:07.49,中文,,0,0,0,,但这就是底层发生的一切。
Dialogue: 0,1:00:07.49,1:00:11.59,英文,,0,0,0,,And so again, this is why in CS50, we spend time on some of these lower-level building blocks.
Dialogue: 0,1:00:07.49,1:00:11.59,中文,,0,0,0,,这就是为什么在 cs50 中，我们要花时间在一些底层构建块上。
Dialogue: 0,1:00:11.59,1:00:20.70,英文,,0,0,0,,Because if you assume that, indeed, your computer's memory is just this grid of bytes, and you have now the code ability in code to get an address and go to an address,
Dialogue: 0,1:00:11.59,1:00:20.70,中文,,0,0,0,,因为如果你假设你的计算机内存就是这样一个字节网格，并且你现在拥有了在代码中获取地址和访问地址的能力，
Dialogue: 0,1:00:20.70,1:00:22.60,英文,,0,0,0,,You can start doing anything you want.
Dialogue: 0,1:00:20.70,1:00:22.60,中文,,0,0,0,,你就可以开始做任何你想做的事情了。
Dialogue: 0,1:00:22.60,1:00:25.32,英文,,0,0,0,,And you can poke around a computer's memory at any location.
Dialogue: 0,1:00:22.60,1:00:25.32,中文,,0,0,0,,你可以在计算机内存的任何位置查看。
Dialogue: 0,1:00:25.32,1:00:26.78,英文,,0,0,0,,And herein lies the danger.
Dialogue: 0,1:00:25.32,1:00:26.78,中文,,0,0,0,,这就是危险所在。
Dialogue: 0,1:00:26.78,1:00:35.11,英文,,0,0,0,,Like, I'm kind of on the honor system right now that if my string is high, exclamation point, it's kind of up to me to go to the first byte, the second, and the third.
Dialogue: 0,1:00:26.78,1:00:35.11,中文,,0,0,0,,就像，我现在完全凭自觉，如果我的字符串是 HI，感叹号，我得自己去第一个字节，第二个，第三个。
Dialogue: 0,1:00:35.11,1:00:36.89,英文,,0,0,0,,But I could get kind of crazy now.
Dialogue: 0,1:00:35.11,1:00:36.89,中文,,0,0,0,,但我现在可以为所欲为了。
Dialogue: 0,1:00:36.89,1:00:43.70,英文,,0,0,0,,And if I want to see what's going on in the computer's memory, I mean, there's nothing stopping me from doing, like, s plus 50.
Dialogue: 0,1:00:36.89,1:00:43.70,中文,,0,0,0,,如果我想看看计算机内存中有什么，我的意思是，没有什么能阻止我做 s + 50 这种事。
Dialogue: 0,1:00:43.70,1:00:49.62,英文,,0,0,0,,And let's see what's there. So make addresses, dot slash addresses, hi and then, OK, nothing, it seems.
Dialogue: 0,1:00:43.70,1:00:49.62,中文,,0,0,0,,让我们看看那里有什么。输入地址，点斜杠地址，HI!，然后，好吧，什么都没有。
Dialogue: 0,1:00:49.62,1:00:51.63,英文,,0,0,0,,Well, how about 5,000 bytes away?
Dialogue: 0,1:00:49.62,1:00:51.63,中文,,0,0,0,,那么 5,000 字节以外呢？
Dialogue: 0,1:00:51.63,1:00:52.47,英文,,0,0,0,,Let's just poke around.
Dialogue: 0,1:00:51.63,1:00:52.47,中文,,0,0,0,,我们随便看看。
Dialogue: 0,1:00:52.47,1:00:53.95,英文,,0,0,0,,What's inside of the computer's memory?
Dialogue: 0,1:00:52.47,1:00:53.95,中文,,0,0,0,,计算机内存里有什么？
Dialogue: 0,1:00:53.95,1:00:56.32,英文,,0,0,0,,So make addresses again.
Dialogue: 0,1:00:53.95,1:00:56.32,中文,,0,0,0,,再输入地址。
Dialogue: 0,1:00:56.32,1:00:59.24,英文,,0,0,0,,Make addresses, dot slash addresses, Enter.
Dialogue: 0,1:00:56.32,1:00:59.24,中文,,0,0,0,,输入地址，点斜杠地址，回车。
Dialogue: 0,1:00:59.24,1:01:00.40,英文,,0,0,0,,OK, still nothing there.
Dialogue: 0,1:00:59.24,1:01:00.40,中文,,0,0,0,,好吧，那里还是什么都没有。
Dialogue: 0,1:01:00.40,1:01:01.64,英文,,0,0,0,,Let's try 50,000.
Dialogue: 0,1:01:00.40,1:01:01.64,中文,,0,0,0,,我们试试 50,000。
Dialogue: 0,1:01:01.64,1:01:05.97,英文,,0,0,0,,All right, dot make addresses, dot slash addresses.
Dialogue: 0,1:01:01.64,1:01:05.97,中文,,0,0,0,,点，输入地址，点斜杠地址。
Dialogue: 0,1:01:05.97,1:01:07.93,英文,,0,0,0,,OK, there we see it.
Dialogue: 0,1:01:05.97,1:01:07.93,中文,,0,0,0,,我们看到了。
Dialogue: 0,1:01:07.93,1:01:14.89,英文,,0,0,0,,So you've probably done this, some of you, by accident, because you probably went too far to the left or to the right in an array, touching memory that you shouldn't.
Dialogue: 0,1:01:07.93,1:01:14.89,中文,,0,0,0,,你们中有些人可能不小心做过这种事，因为你们可能在数组中向左或向右走得太远，触碰了不应该触碰的内存。
Dialogue: 0,1:01:14.89,1:01:20.75,英文,,0,0,0,,Suffice it to say, I should not go blindly touching 50,000 bytes away, because who knows what's there.
Dialogue: 0,1:01:14.89,1:01:20.75,中文,,0,0,0,,总而言之，我不应该盲目地去碰 50,000 字节以外的东西，因为谁知道那里有什么。
Dialogue: 0,1:01:20.75,1:01:26.88,英文,,0,0,0,,And indeed, in your computer, when a program is running, the computer segments it into different segments of memory.
Dialogue: 0,1:01:20.75,1:01:26.88,中文,,0,0,0,,事实上，在你的计算机中，当一个程序运行时，计算机将其分割成不同的内存段。
Dialogue: 0,1:01:26.88,1:01:35.82,英文,,0,0,0,,And if you get a little too greedy and you touch another segment of memory that technically was not allocated to you by Mac OS or Windows or Linux or the operating system,
Dialogue: 0,1:01:26.88,1:01:35.82,中文,,0,0,0,,如果你太贪婪，触碰了另一个技术上没有被 Mac OS、Windows、Linux 或操作系统分配给你的内存段，
Dialogue: 0,1:01:35.82,1:01:38.38,英文,,0,0,0,,Bad things happen, and you get a segmentation fault.
Dialogue: 0,1:01:35.82,1:01:38.38,中文,,0,0,0,,就会发生糟糕的事情，你会遇到段错误。
Dialogue: 0,1:01:38.38,1:01:41.61,英文,,0,0,0,,And that means it's a bug in your code. So you can now do this.
Dialogue: 0,1:01:38.38,1:01:41.61,中文,,0,0,0,,这意味着你的代码有错误。所以你现在可以这样做。
Dialogue: 0,1:01:41.61,1:01:44.53,英文,,0,0,0,,And this means hackers, too, can do things like this.
Dialogue: 0,1:01:41.61,1:01:44.53,中文,,0,0,0,,这也意味着黑客也可以做这样的事情。
Dialogue: 0,1:01:44.53,1:01:50.16,英文,,0,0,0,,If they can somehow inject code into your C program, maybe they can poke around the computer's memory.
Dialogue: 0,1:01:44.53,1:01:50.16,中文,,0,0,0,,如果他们能以某种方式将代码注入你的 C 程序，也许就能在计算机内存中四处探查。
Dialogue: 0,1:01:50.16,1:01:54.28,英文,,0,0,0,,And indeed, this is kind of the technique whereby maybe a really sophisticated hacker
Dialogue: 0,1:01:50.16,1:01:54.28,中文,,0,0,0,,事实上，这可能就是一些非常老练的黑客所使用的一种技术，
Dialogue: 0,1:01:54.28,1:02:03.39,英文,,0,0,0,,can jump to this memory, this memory, this memory, looking for something like your password, or your financial information, or anything that's in the program but at some other address.
Dialogue: 0,1:01:54.28,1:02:03.39,中文,,0,0,0,,他们可以跳转到这块内存、这块内存、这块内存，寻找类似你的密码、财务信息或程序中任何其他地址的内容。
Dialogue: 0,1:02:03.39,1:02:11.03,英文,,0,0,0,,There's nothing stopping an adversary, at least right now, from poking around, if they can execute code on your computer, from doing this kind of thing.
Dialogue: 0,1:02:03.39,1:02:11.03,中文,,0,0,0,,如果攻击者能够在你的计算机上执行代码，那么至少目前没有什么能阻止他们四处探查，做这种事情。
Dialogue: 0,1:02:11.03,1:02:13.85,英文,,0,0,0,,So there, and again, is the power of C, but also the danger.
Dialogue: 0,1:02:11.03,1:02:13.85,中文,,0,0,0,,所以这就是 C 语言的强大之处，但同时也是它的危险之处。
Dialogue: 0,1:02:13.85,1:02:16.96,英文,,0,0,0,,And you'll absolutely suffer more segfaults in the coming days.
Dialogue: 0,1:02:13.85,1:02:16.96,中文,,0,0,0,,在接下来的日子里，你绝对会遇到更多 segmentation fault。
Dialogue: 0,1:02:16.96,1:02:22.60,英文,,0,0,0,,But ultimately, the goal is going to be to help you solve them, ultimately, and fix things.
Dialogue: 0,1:02:16.96,1:02:22.60,中文,,0,0,0,,但最终的目标是帮助你解决它们，最终修复它们。
Dialogue: 0,1:02:22.60,1:02:27.08,英文,,0,0,0,,But for now, I think. That was quite a bit.
Dialogue: 0,1:02:22.60,1:02:27.08,中文,,0,0,0,,但现在我认为内容有点多。
Dialogue: 0,1:02:27.08,1:02:33.68,英文,,0,0,0,,So let me propose that we go ahead and take our longer break here, maybe 10 minutes, and have ourselves some whoopie pies in the transept.
Dialogue: 0,1:02:27.08,1:02:33.68,中文,,0,0,0,,我建议我们现在开始稍微休息一下，也许 10 分钟，在教堂过道里吃点小蛋糕。
Dialogue: 0,1:02:33.68,1:02:36.18,英文,,0,0,0,,We'll be back in 10.
Dialogue: 0,1:02:33.68,1:02:36.18,中文,,0,0,0,,我们 10 分钟后回来。
Dialogue: 0,1:02:36.18,1:02:37.22,英文,,0,0,0,,All right.
Dialogue: 0,1:02:36.18,1:02:37.22,中文,,0,0,0,,好的。
Dialogue: 0,1:02:37.22,1:02:38.48,英文,,0,0,0,,So we're back.
Dialogue: 0,1:02:37.22,1:02:38.48,中文,,0,0,0,,我们回来了。
Dialogue: 0,1:02:38.48,1:02:51.51,英文,,0,0,0,,And to recap where we left off, you now have this new capability in code to do pointer arithmetic, like treat addresses as numbers, which they really are in hexadecimal or otherwise, and add them together and kind of poke around a computer's memory.
Dialogue: 0,1:02:38.48,1:02:51.51,中文,,0,0,0,,回顾一下我们刚才的内容，你现在代码中有了这种新的能力，可以进行指针运算，\N比如将地址视为数字（它们实际上是十六进制或其他进制的数字），并将它们加在一起，在计算机内存中四处探查。
Dialogue: 0,1:02:51.51,1:02:56.99,英文,,0,0,0,,And it was asked during break, actually, how we might further harness this in the context of string.
Dialogue: 0,1:02:51.51,1:02:56.99,中文,,0,0,0,,休息期间有人问， 我们如何在字符串的上下文中进一步利用这一点。
Dialogue: 0,1:02:56.99,1:02:59.77,英文,,0,0,0,,So I didn't change the code we wrote just before break.
Dialogue: 0,1:02:56.99,1:02:59.77,中文,,0,0,0,,我没有改变休息前写的代码。
Dialogue: 0,1:02:59.77,1:03:05.09,英文,,0,0,0,,Recall that we last broke the program by checking out bytes 50,000 bytes away.
Dialogue: 0,1:02:59.77,1:03:05.09,中文,,0,0,0,,回想一下，我们最后一次是通过查看 50,000 字节以外的字节来破坏程序的。
Dialogue: 0,1:03:05.09,1:03:06.05,英文,,0,0,0,,But let's not do that.
Dialogue: 0,1:03:05.09,1:03:06.05,中文,,0,0,0,,但我们不要那样做。
Dialogue: 0,1:03:06.05,1:03:15.19,英文,,0,0,0,,And let's actually try printing out not individual characters like I did, per the percent C. But why don't we try printing out strings? and substrings, if you will.
Dialogue: 0,1:03:06.05,1:03:15.19,中文,,0,0,0,,我们来尝试打印字符串，而不是像我之前那样使用 %c 打印单个字符以及子字符串。
Dialogue: 0,1:03:15.19,1:03:16.97,英文,,0,0,0,,So let me clear my terminal window.
Dialogue: 0,1:03:15.19,1:03:16.97,中文,,0,0,0,,让我来清空终端窗口。
Dialogue: 0,1:03:16.97,1:03:21.68,英文,,0,0,0,,Let me change all of these %c's to %s, %s, %s.
Dialogue: 0,1:03:16.97,1:03:21.68,中文,,0,0,0,,让我把所有这些 %c 改成 %s，%s，%s。
Dialogue: 0,1:03:21.68,1:03:28.92,英文,,0,0,0,,And then let me rewind to what we've been doing since week one with strings, which is just print them out, for instance, with that first line.
Dialogue: 0,1:03:21.68,1:03:28.92,中文,,0,0,0,,然后让我回到我们从第一周就开始做的关于字符串的事情，比如把它们打印出来，例如用第一行。
Dialogue: 0,1:03:28.92,1:03:32.80,英文,,0,0,0,,And the only difference at the moment is that now I took off the training wheels.
Dialogue: 0,1:03:28.92,1:03:32.80,中文,,0,0,0,,现在的唯一区别是，我去掉了辅助轮。
Dialogue: 0,1:03:32.80,1:03:38.38,英文,,0,0,0,,I got rid of CS50.h, wherein string is typedef to char star.
Dialogue: 0,1:03:32.80,1:03:38.38,中文,,0,0,0,,我摆脱了 cs50.h，其中 string 被 typedef 定义成 char *。
Dialogue: 0,1:03:38.38,1:03:44.09,英文,,0,0,0,,For you, got rid of that. So now on line 5, I'm declaring s as being a char star, which just means the address of a character.
Dialogue: 0,1:03:38.38,1:03:44.09,中文,,0,0,0,,为你摆脱了它。 所以在第 5 行，我声明 s 为 char *，这意味着一个字符的地址。
Dialogue: 0,1:03:44.09,1:03:48.63,英文,,0,0,0,,And printf is smart enough to know that the end of a string is wherever that null character is.
Dialogue: 0,1:03:44.09,1:03:48.63,中文,,0,0,0,,printf 足够聪明，能够知道字符串的结尾就是空字符所在的位置。
Dialogue: 0,1:03:48.63,1:03:52.87,英文,,0,0,0,,But now that I can do pointer arithmetic, notice that I could do something like this.
Dialogue: 0,1:03:48.63,1:03:52.87,中文,,0,0,0,,但现在我可以进行指针运算了，注意我可以这样做。
Dialogue: 0,1:03:52.87,1:04:02.36,英文,,0,0,0,,If I want to print out s, I just print out s. Suppose I do s plus 1 here and s plus 2 here, again, after changing percent c to percent s.
Dialogue: 0,1:03:52.87,1:04:02.36,中文,,0,0,0,,如果我想打印出 s，我就直接打印出 s。假设我在这里做 s + 1，在这里做 s + 2，同样，在将 %c 改成 %s 之后。
Dialogue: 0,1:04:02.36,1:04:10.39,英文,,0,0,0,,Any intuition around what this code will now print on the screen, line by line?
Dialogue: 0,1:04:02.36,1:04:10.39,中文,,0,0,0,,对这段代码现在将在屏幕上逐行打印什么内容，有什么直觉吗？
Dialogue: 0,1:04:10.39,1:04:12.31,英文,,0,0,0,,Yeah, thoughts?
Dialogue: 0,1:04:10.39,1:04:12.31,中文,,0,0,0,,是的，有什么想法？
Dialogue: 0,1:04:12.31,1:04:13.49,英文,,0,0,0,,OK, reasonable conjecture.
Dialogue: 0,1:04:12.31,1:04:13.49,中文,,0,0,0,,合理的猜想。
Dialogue: 0,1:04:13.49,1:04:17.57,英文,,0,0,0,,Maybe the memory address of h, that of i, that of exclamation point.
Dialogue: 0,1:04:13.49,1:04:17.57,中文,,0,0,0,,也许是 h 的内存地址，i 的内存地址，感叹号的内存地址。
Dialogue: 0,1:04:17.57,1:04:22.49,英文,,0,0,0,,But other thoughts? Yeah, I think it's actually going to do the latter.
Dialogue: 0,1:04:17.57,1:04:22.49,中文,,0,0,0,,但还有其他的想法吗？是的，我认为它实际上会做后者。
Dialogue: 0,1:04:22.49,1:04:32.78,英文,,0,0,0,,It's going to print hi in the usual way, because honestly, line 5 is this, or rather, line 6 is the same as like week 1 stuff, except we took off the training wheel of string and we're calling it char star.
Dialogue: 0,1:04:22.49,1:04:32.78,中文,,0,0,0,,它将以通常的方式打印 hi，因为老实说，第 5 行是这样的，\N或者更确切地说，第 6 行与第 1 周的内容相同，除了我们去掉了 string 的辅助轮，我们称之为 char *。
Dialogue: 0,1:04:32.78,1:04:38.58,英文,,0,0,0,,But I think line 7 is indeed going to print out i, and line 8 is just going to print out b.
Dialogue: 0,1:04:32.78,1:04:38.58,中文,,0,0,0,,但我认为第 7 行确实会打印出 i，而第 8 行只会打印出 b。
Dialogue: 0,1:04:38.58,1:04:40.44,英文,,0,0,0,,Because it'll be just the exclamation point.
Dialogue: 0,1:04:38.58,1:04:40.44,中文,,0,0,0,,因为它将只是感叹号。
Dialogue: 0,1:04:40.44,1:04:47.84,英文,,0,0,0,,Printf will still be smart enough to know where each of those substrings, portions of the string, end by the same logic as always.
Dialogue: 0,1:04:40.44,1:04:47.84,中文,,0,0,0,,Printf 仍然能够像往常一样，通过相同的逻辑知道每个子字符串，字符串的一部分，在哪里结束。
Dialogue: 0,1:04:47.84,1:04:54.87,英文,,0,0,0,,But let me go ahead and zoom out, run make addresses, Enter, compiles OK, dot slash addresses, and now
Dialogue: 0,1:04:47.84,1:04:54.87,中文,,0,0,0,,让我把它缩小，运行 make addresses，回车，编译成功，./addresses。
Dialogue: 0,1:04:54.87,1:04:57.33,英文,,0,0,0,,Indeed, this is all a string is.
Dialogue: 0,1:04:54.87,1:04:57.33,中文,,0,0,0,,现在这确实就是一个字符串。
Dialogue: 0,1:04:57.33,1:05:00.53,英文,,0,0,0,,It's a sequence of characters identified by its first byte.
Dialogue: 0,1:04:57.33,1:05:00.53,中文,,0,0,0,,它是一个以第一个字节标识的字符序列。
Dialogue: 0,1:05:00.53,1:05:12.50,英文,,0,0,0,,If you then start poking around and tell printf to print out what's at the next byte or the next next byte, it's going to do its same thing, printing out that character and everything after it up until that null character.
Dialogue: 0,1:05:00.53,1:05:12.50,中文,,0,0,0,,如果你开始探究，并告诉printf打印出下一个字节或下下一个字节的内容，它会做同样的事情，打印出那个字符以及它之后的所有内容，直到空字符。
Dialogue: 0,1:05:12.50,1:05:19.84,英文,,0,0,0,,So again, even though there's a lot going on, we've introduced these two new operators, there's nothing that's happening today that hasn't been happening for weeks.
Dialogue: 0,1:05:12.50,1:05:19.84,中文,,0,0,0,,即使发生了很多事情，我们也引入了这两个新的运算符，但今天发生的事情在过去几周里都没有发生过。
Dialogue: 0,1:05:19.84,1:05:30.81,英文,,0,0,0,,But hopefully, through this week's lecture, this week's problem set, and beyond, you'll start to realize that now you just have more tools via which to harness those lower-level implementation details.
Dialogue: 0,1:05:19.84,1:05:30.81,中文,,0,0,0,,但希望通过本周的课程、本周的习题集以及之后的学习，你会开始意识到，现在你有了更多工具来利用这些底层的实现细节。
Dialogue: 0,1:05:30.81,1:05:34.41,英文,,0,0,0,,So last week, too, recall one other implementation detail.
Dialogue: 0,1:05:30.81,1:05:34.41,中文,,0,0,0,,回想一下上周的另一个实现细节。
Dialogue: 0,1:05:34.41,1:05:43.32,英文,,0,0,0,,I claimed that you could not compare two strings quite as easily as you could compare two integers, for instance.
Dialogue: 0,1:05:34.41,1:05:43.32,中文,,0,0,0,,我声称你不能像比较两个整数那样容易地比较两个字符串。
Dialogue: 0,1:05:43.32,1:05:49.54,英文,,0,0,0,,And I told you to use a different function instead that you probably used one or more times with the past problem set.
Dialogue: 0,1:05:43.32,1:05:49.54,中文,,0,0,0,,我告诉过你要使用另一个函数来代替它，你可能在上一个习题集中使用过一次或多次。
Dialogue: 0,1:05:49.54,1:05:53.33,英文,,0,0,0,,How are you supposed to compare strings, apparently?
Dialogue: 0,1:05:49.54,1:05:53.33,中文,,0,0,0,,你应该如何比较字符串？
Dialogue: 0,1:05:53.33,1:05:58.08,英文,,0,0,0,,Yeah, so string compare, strcomp, that additional function that we said, eh, you just have to use it for now.
Dialogue: 0,1:05:53.33,1:05:58.08,中文,,0,0,0,,是的，使用字符串比较函数 strcmp，也就是我们说的那个额外的函数，现在你必须使用它。
Dialogue: 0,1:05:58.08,1:06:06.17,英文,,0,0,0,,But you might have a little intuition already as to why we have to use strcompare, and we can't just use equals equals to compare strings.
Dialogue: 0,1:05:58.08,1:06:06.17,中文,,0,0,0,,但你可能已经有点直觉了，为什么我们必须使用 strcmp，而不能仅仅使用等于号来比较字符串。
Dialogue: 0,1:06:06.17,1:06:11.73,英文,,0,0,0,,Any intuition for this already? Why was strcompare necessary last week?
Dialogue: 0,1:06:06.17,1:06:11.73,中文,,0,0,0,,对此有什么直觉吗？为什么上周必须使用 strcmp？
Dialogue: 0,1:06:11.73,1:06:12.43,英文,,0,0,0,,Perfect.
Dialogue: 0,1:06:11.73,1:06:12.43,中文,,0,0,0,,非常好。
Dialogue: 0,1:06:12.43,1:06:18.09,英文,,0,0,0,,Equals equals would compare literally the two memory addresses instead of the actual strings character by character.
Dialogue: 0,1:06:12.43,1:06:18.09,中文,,0,0,0,,等于号将逐字比较两个内存地址，而不是逐个字符地比较实际的字符串。
Dialogue: 0,1:06:18.09,1:06:29.58,英文,,0,0,0,,And unless the memory addresses are literally the same, so you compare the exact same memory address, two different strings probably are not going to be considered equal, even if to us humans, they indeed look equal.
Dialogue: 0,1:06:18.09,1:06:29.58,中文,,0,0,0,,除非内存地址完全相同，也就是说你比较的是完全相同的内存地址，否则两个不同的字符串即使在我们人类看来确实相等，也不会被认为是相等的。
Dialogue: 0,1:06:29.58,1:06:30.54,英文,,0,0,0,,So let's see this.
Dialogue: 0,1:06:29.58,1:06:30.54,中文,,0,0,0,,我们来看看。
Dialogue: 0,1:06:30.54,1:06:32.92,英文,,0,0,0,,Let me go ahead and close addresses.c.
Dialogue: 0,1:06:30.54,1:06:32.92,中文,,0,0,0,,让我关闭 addresses.c。
Dialogue: 0,1:06:32.92,1:06:35.28,英文,,0,0,0,,And actually, before I do, one last mention.
Dialogue: 0,1:06:32.92,1:06:35.28,中文,,0,0,0,,在我这样做之前，最后提一点。
Dialogue: 0,1:06:35.28,1:06:46.14,英文,,0,0,0,,One of the powerful things about pointer arithmetic, as an aside, is that C, and really the compiler, is smart enough to know how many bytes to keep adding and adding.
Dialogue: 0,1:06:35.28,1:06:46.14,中文,,0,0,0,,顺便提一句，指针运算的强大之处之一是 C语言，实际上是编译器，足够聪明，知道要添加多少个字节。
Dialogue: 0,1:06:46.14,1:06:47.00,英文,,0,0,0,,And by that, I mean this.
Dialogue: 0,1:06:46.14,1:06:47.00,中文,,0,0,0,,我的意思是，
Dialogue: 0,1:06:47.00,1:06:49.66,英文,,0,0,0,,Right now, we got lucky, because a string is a sequence of characters.
Dialogue: 0,1:06:47.00,1:06:49.66,中文,,0,0,0,,现在，我们很幸运，因为字符串是字符序列。
Dialogue: 0,1:06:49.66,1:06:52.36,英文,,0,0,0,,And by definition, every character is a single byte.
Dialogue: 0,1:06:49.66,1:06:52.36,中文,,0,0,0,,根据定义，每个字符都是单个字节。
Dialogue: 0,1:06:52.36,1:06:58.20,英文,,0,0,0,,You can poke around and do s plus 1 to get the next byte, s plus 2 to get the third byte.
Dialogue: 0,1:06:52.36,1:06:58.20,中文,,0,0,0,,你可以使用 s+1 获取下一个字节，s+2 获取第三个字节。
Dialogue: 0,1:06:58.20,1:07:04.81,英文,,0,0,0,,However, if we weren't dealing with strings, suppose we were dealing with integers that were in an array, back to back to back.
Dialogue: 0,1:06:58.20,1:07:04.81,中文,,0,0,0,,但是，如果我们处理的不是字符串，假设我们处理的是数组中一个接一个的整数。
Dialogue: 0,1:07:04.81,1:07:11.65,英文,,0,0,0,,If you wanted to get at the next integer, you could still do plus 1 or plus 2 to get at the next or the next next integer.
Dialogue: 0,1:07:04.81,1:07:11.65,中文,,0,0,0,,如果你想访问下一个整数，你仍然可以使用+1或+2来访问下一个或下下一个整数。
Dialogue: 0,1:07:11.65,1:07:16.33,英文,,0,0,0,,You would not start to get into the weeds of doing plus 4 and then plus 8.
Dialogue: 0,1:07:11.65,1:07:16.33,中文,,0,0,0,,你不需要使用+4然后+8。
Dialogue: 0,1:07:16.33,1:07:19.63,英文,,0,0,0,,You don't have to know or care how big the data types are in the computer.
Dialogue: 0,1:07:16.33,1:07:19.63,中文,,0,0,0,,你也不必知道或关心计算机中数据类型的大小。
Dialogue: 0,1:07:19.63,1:07:23.65,英文,,0,0,0,,C in the compiler will figure that out for you based on the data type in question.
Dialogue: 0,1:07:19.63,1:07:23.65,中文,,0,0,0,,C语言编译器会根据相关的数据类型帮你解决这个问题。
Dialogue: 0,1:07:23.65,1:07:27.82,英文,,0,0,0,,Keep that in mind if ever doing this on a different data type than Chars.
Dialogue: 0,1:07:23.65,1:07:27.82,中文,,0,0,0,,如果对 `char` 以外的数据类型执行此操作，请记住这一点。
Dialogue: 0,1:07:27.82,1:07:32.04,英文,,0,0,0,,All right, so let me go ahead and open up a file that I wrote in advance most of.
Dialogue: 0,1:07:27.82,1:07:32.04,中文,,0,0,0,,好了，让我打开一个我提前写好的文件。
Dialogue: 0,1:07:32.04,1:07:34.44,英文,,0,0,0,,And let me hide my terminal window and show you this.
Dialogue: 0,1:07:32.04,1:07:34.44,中文,,0,0,0,,让我隐藏终端窗口，向你展示这个。
Dialogue: 0,1:07:34.44,1:07:39.31,英文,,0,0,0,,So here is a program called compare.c, whose purpose in life is to compare two strings.
Dialogue: 0,1:07:34.44,1:07:39.31,中文,,0,0,0,,这是一个名为 compare.c 的程序，它的作用是比较两个字符串。
Dialogue: 0,1:07:39.31,1:07:42.29,英文,,0,0,0,,I'm back to using the CS50 library, because at least for now,
Dialogue: 0,1:07:39.31,1:07:42.29,中文,,0,0,0,,我又开始使用 cs50 库了，因为至少现在，
Dialogue: 0,1:07:42.29,1:07:43.60,英文,,0,0,0,,Probably a couple more weeks.
Dialogue: 0,1:07:42.29,1:07:43.60,中文,,0,0,0,,可能还有几周。
Dialogue: 0,1:07:43.60,1:07:48.06,英文,,0,0,0,,It is so much easier to get input from the user using CS50's function, getInt.
Dialogue: 0,1:07:43.60,1:07:48.06,中文,,0,0,0,,使用 cs50 的 `get_int` 函数获取用户输入要容易得多。
Dialogue: 0,1:07:48.06,1:07:55.48,英文,,0,0,0,,But we'll conclude today by taking off those training wheels as well so you can see how you can actually get user input with nothing CS50 specific.
Dialogue: 0,1:07:48.06,1:07:55.48,中文,,0,0,0,,但我们今天将结束这个内容，让你看看如何在不使用任何 cs50 特定内容的情况下实际获取用户输入。
Dialogue: 0,1:07:55.48,1:07:58.94,英文,,0,0,0,,So line 6 and 7, pretty boring, week 1 stuff.
Dialogue: 0,1:07:55.48,1:07:58.94,中文,,0,0,0,,第6行和第7行，非常无聊，是第一周的内容。
Dialogue: 0,1:07:58.94,1:08:03.96,英文,,0,0,0,,Get an int called i, get an int called j, and store them in two variables, i and j, respectively.
Dialogue: 0,1:07:58.94,1:08:03.96,中文,,0,0,0,,获取名为 i 的整数，获取名为 j 的整数，并将它们分别存储在变量 i 和 j 中。
Dialogue: 0,1:08:03.96,1:08:06.85,英文,,0,0,0,,If i equals equals j, print out the same.
Dialogue: 0,1:08:03.96,1:08:06.85,中文,,0,0,0,,如果 i == j，就输出相同。
Dialogue: 0,1:08:06.85,1:08:08.49,英文,,0,0,0,,Else, print out that they're different.
Dialogue: 0,1:08:06.85,1:08:08.49,中文,,0,0,0,,否则，输出它们不同。
Dialogue: 0,1:08:08.49,1:08:11.77,英文,,0,0,0,,Let me just stipulate for time's sake. I'm pretty sure this code is correct.
Dialogue: 0,1:08:08.49,1:08:11.77,中文,,0,0,0,,为了节省时间，我直接假设这段代码是正确的。
Dialogue: 0,1:08:11.77,1:08:13.67,英文,,0,0,0,,This will get two integers from the human.
Dialogue: 0,1:08:11.77,1:08:13.67,中文,,0,0,0,,它会从用户那里获取两个整数。
Dialogue: 0,1:08:13.67,1:08:17.47,英文,,0,0,0,,It will compare them and tell me correctly if they're the same or different.
Dialogue: 0,1:08:13.67,1:08:17.47,中文,,0,0,0,,它会比较它们，并正确地告诉我它们是否相同。
Dialogue: 0,1:08:17.47,1:08:21.90,英文,,0,0,0,,And I'll prove as much by running make compare.
Dialogue: 0,1:08:17.47,1:08:21.90,中文,,0,0,0,,我会通过运行 make compare 来证明这一点。
Dialogue: 0,1:08:21.90,1:08:27.17,英文,,0,0,0,,Dot slash compare, and I'll type in 50 for i, 50 for j, and they're the same.
Dialogue: 0,1:08:21.90,1:08:27.17,中文,,0,0,0,,./compare，我输入 50 作为 i，50 作为 j，它们是相同的。
Dialogue: 0,1:08:27.17,1:08:31.85,英文,,0,0,0,,And now I'll do how about 50 and say 13, and those are different.
Dialogue: 0,1:08:27.17,1:08:31.85,中文,,0,0,0,,现在我输入 50 和 13，它们是不同的。
Dialogue: 0,1:08:31.85,1:08:34.19,英文,,0,0,0,,So let me just stipulate this code is indeed correct.
Dialogue: 0,1:08:31.85,1:08:34.19,中文,,0,0,0,,所以我们直接假设这段代码是正确的。
Dialogue: 0,1:08:34.19,1:08:37.51,英文,,0,0,0,,Would have worked in week 1, also works now in week 4.
Dialogue: 0,1:08:34.19,1:08:37.51,中文,,0,0,0,,它在第一周有效，现在在第四周也有效。
Dialogue: 0,1:08:37.51,1:08:43.70,英文,,0,0,0,,But let me now change it to compare not two integers, but as I hinted, maybe two strings instead.
Dialogue: 0,1:08:37.51,1:08:43.70,中文,,0,0,0,,但现在我要改变它，比较的不是两个整数，而是像我之前暗示的那样，可能是两个字符串。
Dialogue: 0,1:08:43.70,1:08:52.40,英文,,0,0,0,,So let me go ahead and change this line of code to maybe be string s equals get string, asking the user for s.
Dialogue: 0,1:08:43.70,1:08:52.40,中文,,0,0,0,,所以我把这行代码改成 string s = get_string，向用户请求 s。
Dialogue: 0,1:08:52.40,1:08:57.13,英文,,0,0,0,,Then let's change this second line here to be string t, just to keep the variable name short for now.
Dialogue: 0,1:08:52.40,1:08:57.13,中文,,0,0,0,,然后把第二行改成 string t，只是为了让变量名短一点。
Dialogue: 0,1:08:57.13,1:09:00.83,英文,,0,0,0,,And t is a good choice after s for something like this.
Dialogue: 0,1:08:57.13,1:09:00.83,中文,,0,0,0,,t 是 s 之后一个不错的选择。
Dialogue: 0,1:09:00.83,1:09:08.57,英文,,0,0,0,,Get string, prompt the human for t. And then let's change our i and j here to do the wrong thing, per the intuition earlier.
Dialogue: 0,1:09:00.83,1:09:08.57,中文,,0,0,0,,get_string，提示用户输入 t。然后把 i 和 j 改成错误的写法，就像之前直觉告诉我们的一样。
Dialogue: 0,1:09:08.57,1:09:11.80,英文,,0,0,0,,If s equals equals t, then print out the same.
Dialogue: 0,1:09:08.57,1:09:11.80,中文,,0,0,0,,如果 s = t，就输出相同。
Dialogue: 0,1:09:11.80,1:09:13.54,英文,,0,0,0,,Else, print out that they're different.
Dialogue: 0,1:09:11.80,1:09:13.54,中文,,0,0,0,,否则，输出它们不同。
Dialogue: 0,1:09:13.54,1:09:16.10,英文,,0,0,0,,Now, if I want, I could take off at least some of the training wheels.
Dialogue: 0,1:09:13.54,1:09:16.10,中文,,0,0,0,,现在，如果我想的话，我可以去掉至少一部分辅助轮。
Dialogue: 0,1:09:16.10,1:09:19.62,英文,,0,0,0,,I could change this to char star.
Dialogue: 0,1:09:16.10,1:09:19.62,中文,,0,0,0,,我可以把它改成 char *。
Dialogue: 0,1:09:19.62,1:09:20.18,英文,,0,0,0,,Either is fine.
Dialogue: 0,1:09:19.62,1:09:20.18,中文,,0,0,0,,两种都可以。
Dialogue: 0,1:09:20.18,1:09:26.94,英文,,0,0,0,,I still need the CS50 library, though, because I'm using get string, because it's actually hard, as we'll see today, to get strings manually without using a library.
Dialogue: 0,1:09:20.18,1:09:26.94,中文,,0,0,0,,不过，我仍然需要 cs50 库，因为我正在使用 `get_string`，因为今天我们会看到，在不使用库的情况下手动获取字符串实际上很困难。
Dialogue: 0,1:09:26.94,1:09:29.62,英文,,0,0,0,,But I'll keep it using string just for now.
Dialogue: 0,1:09:26.94,1:09:29.62,中文,,0,0,0,,但是现在我将继续使用字符串。
Dialogue: 0,1:09:29.62,1:09:30.50,英文,,0,0,0,,with the library.
Dialogue: 0,1:09:29.62,1:09:30.50,中文,,0,0,0,,使用库。
Dialogue: 0,1:09:30.50,1:09:34.00,英文,,0,0,0,,All right, make compare again, dot slash compare.
Dialogue: 0,1:09:30.50,1:09:34.00,中文,,0,0,0,,好了，再次进行比较，`./compare`。
Dialogue: 0,1:09:34.00,1:09:38.41,英文,,0,0,0,,And now let me go ahead and type in, for instance, hi, exclamation point, Enter.
Dialogue: 0,1:09:34.00,1:09:38.41,中文,,0,0,0,,现在让我继续输入，例如，HI！回车。
Dialogue: 0,1:09:38.41,1:09:40.33,英文,,0,0,0,,And hi, exclamation point, Enter.
Dialogue: 0,1:09:38.41,1:09:40.33,中文,,0,0,0,,还有 HI！回车。
Dialogue: 0,1:09:40.33,1:09:42.97,英文,,0,0,0,,And they're different.
Dialogue: 0,1:09:40.33,1:09:42.97,中文,,0,0,0,,它们是不同的。
Dialogue: 0,1:09:42.97,1:09:45.55,英文,,0,0,0,,They're obviously not visually, but they are underneath the hood.
Dialogue: 0,1:09:42.97,1:09:45.55,中文,,0,0,0,,它们显然在视觉上不一样，但在底层它们是不同的。
Dialogue: 0,1:09:45.55,1:09:54.67,英文,,0,0,0,,And you probably do have the intuition for this already, whereby what's going on underneath the hood is that we're comparing accidentally the two memory addresses.
Dialogue: 0,1:09:45.55,1:09:54.67,中文,,0,0,0,,你可能已经对此有所直觉，即在底层发生的事情是我们意外地比较了两个内存地址。
Dialogue: 0,1:09:54.67,1:09:55.41,英文,,0,0,0,,Let's go there.
Dialogue: 0,1:09:54.67,1:09:55.41,中文,,0,0,0,,我们去看看。
Dialogue: 0,1:09:55.41,1:09:56.75,英文,,0,0,0,,Let's consider the memory.
Dialogue: 0,1:09:55.41,1:09:56.75,中文,,0,0,0,,我们来看看内存。
Dialogue: 0,1:09:56.75,1:09:59.53,英文,,0,0,0,,And let me zoom out now so I can just have more bytes to play with.
Dialogue: 0,1:09:56.75,1:09:59.53,中文,,0,0,0,,现在让我缩小一下，这样我就可以有更多的字节可以使用了。
Dialogue: 0,1:09:59.53,1:10:03.18,英文,,0,0,0,,So the squares are a little smaller than before, just so we can fit more in them.
Dialogue: 0,1:09:59.53,1:10:03.18,中文,,0,0,0,,所以方块比以前小了一些，只是为了我们可以容纳更多的东西。
Dialogue: 0,1:10:03.18,1:10:06.13,英文,,0,0,0,,And let me propose that when I declare s,
Dialogue: 0,1:10:03.18,1:10:06.13,中文,,0,0,0,,让我假设当我声明 `s` 时，
Dialogue: 0,1:10:06.13,1:10:13.28,英文,,0,0,0,,on what was line 6 a moment ago, it ends up somewhere in memory, like the top left-hand corner of my picture, for discussion's sake.
Dialogue: 0,1:10:06.13,1:10:13.28,中文,,0,0,0,,就在刚才的第 6 行，为了便于讨论，它最终出现在内存中的某个位置，比如我图片的左上角。
Dialogue: 0,1:10:13.28,1:10:25.03,英文,,0,0,0,,And when I execute that same line of code, and getString is called, and I type in high exclamation point, we know from week 1 that getString puts it somewhere in the computer's memory.
Dialogue: 0,1:10:13.28,1:10:25.03,中文,,0,0,0,,当我执行相同的代码行，并且调用 `get_string`，我输入“HI！!”时，我们从第 1 周就知道 `get_string` 将其放在计算机内存中的某个位置。
Dialogue: 0,1:10:25.03,1:10:28.81,英文,,0,0,0,,And I'll propose that it's in the bottom left-hand corner of the screen here.
Dialogue: 0,1:10:25.03,1:10:28.81,中文,,0,0,0,,我将假设它在这个屏幕的左下角。
Dialogue: 0,1:10:28.81,1:10:29.85,英文,,0,0,0,,What happens after that?
Dialogue: 0,1:10:28.81,1:10:29.85,中文,,0,0,0,,之后会发生什么？
Dialogue: 0,1:10:29.85,1:10:36.55,英文,,0,0,0,,Well, I know, even though I don't generally care, that HI exclamation point in the null character exists at some address, like 0x123, 124, 125, 126, for discussion's sake.
Dialogue: 0,1:10:29.85,1:10:36.55,中文,,0,0,0,,好吧，我知道，即使我通常不关心，“HI！!\0” 存在于某个地址，比如 0x123、124、125、126，为了便于讨论。
Dialogue: 0,1:10:36.55,1:10:41.71,英文,,0,0,0,,And what's in S?
Dialogue: 0,1:10:36.55,1:10:41.71,中文,,0,0,0,,`s` 中是什么？
Dialogue: 0,1:10:41.71,1:10:44.76,英文,,0,0,0,,Same as before, break, 0x123.
Dialogue: 0,1:10:41.71,1:10:44.76,中文,,0,0,0,,和之前一样，break，0x123。
Dialogue: 0,1:10:44.76,1:10:51.34,英文,,0,0,0,,So that's all that's happening, again, on line 6, which is pretty much the same as when we were getting an s earlier.
Dialogue: 0,1:10:44.76,1:10:51.34,中文,,0,0,0,,所以这就是在第 6 行发生的事情，这跟我们之前获取 s 时非常相似。
Dialogue: 0,1:10:51.34,1:10:57.07,英文,,0,0,0,,But notice now, with line 7, when I get a second variable called t and I call getString again,
Dialogue: 0,1:10:51.34,1:10:57.07,中文,,0,0,0,,但现在注意，在第 7 行，当我创建第二个变量 t 并再次调用 get_string 时，
Dialogue: 0,1:10:57.07,1:11:00.07,英文,,0,0,0,,And by coincidence, as the human, I typed the same thing.
Dialogue: 0,1:10:57.07,1:11:00.07,中文,,0,0,0,,巧合的是，作为人类，我输入了相同的内容。
Dialogue: 0,1:11:00.07,1:11:04.27,英文,,0,0,0,,Well, what happens here? T gets its own chunk of memory, maybe at the top right.
Dialogue: 0,1:11:00.07,1:11:04.27,中文,,0,0,0,,那么，这里发生了什么？ t 在内存中获得了自己的块，可能在右上角。
Dialogue: 0,1:11:04.27,1:11:08.06,英文,,0,0,0,,That second version of hi gets somewhere else in memory.
Dialogue: 0,1:11:04.27,1:11:08.06,中文,,0,0,0,,第二个版本的 "HI！" 被存储在内存中的其他位置。
Dialogue: 0,1:11:08.06,1:11:11.98,英文,,0,0,0,,The computer could be smart and notice that it's the same, but C doesn't generally do that for you.
Dialogue: 0,1:11:08.06,1:11:11.98,中文,,0,0,0,,计算机可以很聪明地注意到它们是相同的，但 C 语言通常不会为你做这件事。
Dialogue: 0,1:11:11.98,1:11:13.90,英文,,0,0,0,,It just plops it somewhere else in memory.
Dialogue: 0,1:11:11.98,1:11:13.90,中文,,0,0,0,,它只是把它放在内存中的其他地方。
Dialogue: 0,1:11:13.90,1:11:19.22,英文,,0,0,0,,And maybe it's at address 0x456, 457, 458, 459, or wherever.
Dialogue: 0,1:11:13.90,1:11:19.22,中文,,0,0,0,,也许它在地址 0x456、457、458、459，或者其他任何地方。
Dialogue: 0,1:11:19.22,1:11:21.03,英文,,0,0,0,,But you can perhaps see where this is going already.
Dialogue: 0,1:11:19.22,1:11:21.03,中文,,0,0,0,,但你可能已经预见到接下来会发生什么。
Dialogue: 0,1:11:21.03,1:11:23.97,英文,,0,0,0,,T now, of course, contains the address of that first byte.
Dialogue: 0,1:11:21.03,1:11:23.97,中文,,0,0,0,,当然，t 现在包含第一个字节的地址。
Dialogue: 0,1:11:23.97,1:11:32.15,英文,,0,0,0,,And so in my code on line 9, when I compare s and t for equality, suffice it to say, they are not equal.
Dialogue: 0,1:11:23.97,1:11:32.15,中文,,0,0,0,,所以在我的代码的第 9 行，当我比较 s 和 t 是否相等时，可以肯定地说，它们不相等。
Dialogue: 0,1:11:32.15,1:11:37.79,英文,,0,0,0,,Because of the way the strings are laid out in the computer's memory, it indeed looks the same.
Dialogue: 0,1:11:32.15,1:11:37.79,中文,,0,0,0,,因为字符串在计算机内存中的存储方式，它看起来确实是一样的。
Dialogue: 0,1:11:37.79,1:11:38.87,英文,,0,0,0,,The same values are there.
Dialogue: 0,1:11:37.79,1:11:38.87,中文,,0,0,0,,它们的值是相同的。
Dialogue: 0,1:11:38.87,1:11:45.39,英文,,0,0,0,,But if we abstract away further, you can really see that s and t are not the same themselves.
Dialogue: 0,1:11:38.87,1:11:45.39,中文,,0,0,0,,但如果我们进一步抽象，你会发现 s 和 t 本身并不相同。
Dialogue: 0,1:11:45.39,1:11:54.00,英文,,0,0,0,,And so how did we fix this, or really, how did we avoid this last week without spilling the beans and going down this rabbit hole of explaining why you have to use strcmp?
Dialogue: 0,1:11:45.39,1:11:54.00,中文,,0,0,0,,那么，我们是如何解决这个问题的呢？或者说，上周我们是如何在不泄露秘密，不深入解释为什么必须使用 strcmp 的情况下避免这个问题的呢？
Dialogue: 0,1:11:54.00,1:11:57.84,英文,,0,0,0,,Well, if I go back to my code here, let's do it now the right way.
Dialogue: 0,1:11:54.00,1:11:57.84,中文,,0,0,0,,如果我回到我的代码这里，现在让我们用正确的方式来做。
Dialogue: 0,1:11:57.84,1:12:04.74,英文,,0,0,0,,Let me go ahead and include a line of code that says string compare of s comma t, both as inputs.
Dialogue: 0,1:11:57.84,1:12:04.74,中文,,0,0,0,,让我继续添加一行代码，它调用 string compare 函数，传入 s 和 t 作为输入。
Dialogue: 0,1:12:04.74,1:12:10.05,英文,,0,0,0,,And then if you recall, what does strcmp return when two strings are equal?
Dialogue: 0,1:12:04.74,1:12:10.05,中文,,0,0,0,,然后你还记得吗，当两个字符串相等时，strcmp 函数返回什么？
Dialogue: 0,1:12:10.05,1:12:12.52,英文,,0,0,0,,There's three possible return values.
Dialogue: 0,1:12:10.05,1:12:12.52,中文,,0,0,0,,它有三种可能的返回值。
Dialogue: 0,1:12:12.52,1:12:13.10,英文,,0,0,0,,So 0.
Dialogue: 0,1:12:12.52,1:12:13.10,中文,,0,0,0,,所以 0。
Dialogue: 0,1:12:13.10,1:12:17.16,英文,,0,0,0,,So 1 is for if it comes alphabetically or ascobetically first or second.
Dialogue: 0,1:12:13.10,1:12:17.16,中文,,0,0,0,,1 代表按字母顺序，看是第一个还是第二个。
Dialogue: 0,1:12:17.16,1:12:18.78,英文,,0,0,0,,But for now, I just want 0.
Dialogue: 0,1:12:17.16,1:12:18.78,中文,,0,0,0,,但现在，我只要 0。
Dialogue: 0,1:12:18.78,1:12:22.59,英文,,0,0,0,,If I want to use str compare, I do need string.h.
Dialogue: 0,1:12:18.78,1:12:22.59,中文,,0,0,0,,如果要用 strcmp，我需要 string.h。
Dialogue: 0,1:12:22.59,1:12:24.11,英文,,0,0,0,,So string.h does exist.
Dialogue: 0,1:12:22.59,1:12:24.11,中文,,0,0,0,,所以 string.h 是存在的。
Dialogue: 0,1:12:24.11,1:12:25.45,英文,,0,0,0,,That's not a CS50 thing.
Dialogue: 0,1:12:24.11,1:12:25.45,中文,,0,0,0,,这不是 cs50 的东西。
Dialogue: 0,1:12:25.45,1:12:28.01,英文,,0,0,0,,There's no keyword string as a data type.
Dialogue: 0,1:12:25.45,1:12:28.01,中文,,0,0,0,,没有 string 作为数据类型的关键词。
Dialogue: 0,1:12:28.01,1:12:30.69,英文,,0,0,0,,That's a CS50 thing. But string.h does exist.
Dialogue: 0,1:12:28.01,1:12:30.69,中文,,0,0,0,,那是 cs50 的东西。但 string.h 确实存在。
Dialogue: 0,1:12:30.69,1:12:35.32,英文,,0,0,0,,So I think now, with that change on line 10, if I do make compare,
Dialogue: 0,1:12:30.69,1:12:35.32,中文,,0,0,0,,所以我认为现在，在第 10 行做了修改后，如果我执行 make compare，
Dialogue: 0,1:12:35.32,1:12:40.54,英文,,0,0,0,,And .slash compare, and then run again, type again, HI!
Dialogue: 0,1:12:35.32,1:12:40.54,中文,,0,0,0,,以及 ./compare，然后再次运行，再次输入，HI！
Dialogue: 0,1:12:40.54,1:12:41.30,英文,,0,0,0,,HI!
Dialogue: 0,1:12:40.54,1:12:41.30,中文,,0,0,0,,HI！
Dialogue: 0,1:12:41.30,1:12:43.28,英文,,0,0,0,,I think now they're the same.
Dialogue: 0,1:12:41.30,1:12:43.28,中文,,0,0,0,,我认为现在它们是一样的。
Dialogue: 0,1:12:43.28,1:12:50.47,英文,,0,0,0,,And just as a second check, HI in all caps, maybe HI in lowercase, those are, in fact, different.
Dialogue: 0,1:12:43.28,1:12:50.47,中文,,0,0,0,,作为第二次检查，全部大写的 HI，以及小写的 hi，实际上是不同的。
Dialogue: 0,1:12:50.47,1:12:51.11,英文,,0,0,0,,Why?
Dialogue: 0,1:12:50.47,1:12:51.11,中文,,0,0,0,,为什么？
Dialogue: 0,1:12:51.11,1:13:02.33,英文,,0,0,0,,Well, str compare, which was written by some other human decades ago, is just smart enough to know that it should go to s and go to t, start comparing them left to right,
Dialogue: 0,1:12:51.11,1:13:02.33,中文,,0,0,0,,几十年前由其他人编写的 strcmp 函数很聪明，它会从 s 和 t 开始，从左到右比较它们，
Dialogue: 0,1:13:02.33,1:13:11.22,英文,,0,0,0,,stopping once it hits one or both null characters, and return 0 only if everything in s, n, and t are exactly the same.
Dialogue: 0,1:13:02.33,1:13:11.22,中文,,0,0,0,,一旦遇到一个或两个空字符就停止，并且仅当 s、n 和 t 中的所有内容完全相同时才返回 0。
Dialogue: 0,1:13:11.22,1:13:15.54,英文,,0,0,0,,Are any questions, then, on this here?
Dialogue: 0,1:13:11.22,1:13:15.54,中文,,0,0,0,,那么，对此有任何问题吗？
Dialogue: 0,1:13:15.54,1:13:18.87,英文,,0,0,0,,Any questions on why we're using str compare?
Dialogue: 0,1:13:15.54,1:13:18.87,中文,,0,0,0,,关于我们为什么要使用 strcmp 有什么问题吗？
Dialogue: 0,1:13:18.87,1:13:20.85,英文,,0,0,0,,All right, if no, yeah, oh, in the middle.
Dialogue: 0,1:13:18.87,1:13:20.85,中文,,0,0,0,,如果没有，是的，在中间。
Dialogue: 0,1:13:26.26,1:13:28.62,英文,,0,0,0,,So why is it not the case with integers?
Dialogue: 0,1:13:26.26,1:13:28.62,中文,,0,0,0,,为什么整数不是这样呢？
Dialogue: 0,1:13:28.62,1:13:35.06,英文,,0,0,0,,So it turns out it's not the case with integers, with floats, with bools, with doubles, with longs.
Dialogue: 0,1:13:28.62,1:13:35.06,中文,,0,0,0,,事实证明，整数、浮点数、布尔值、双精度数、长整型都不是这样的。
Dialogue: 0,1:13:35.06,1:13:38.07,英文,,0,0,0,,Literally every other data type works correctly.
Dialogue: 0,1:13:35.06,1:13:38.07,中文,,0,0,0,,实际上，其他所有数据类型都能正常工作。
Dialogue: 0,1:13:38.07,1:13:39.59,英文,,0,0,0,,Strings, though, are special.
Dialogue: 0,1:13:38.07,1:13:39.59,中文,,0,0,0,,但字符串很特殊。
Dialogue: 0,1:13:39.59,1:13:42.59,英文,,0,0,0,,They are useful enough in programming and have been for decades.
Dialogue: 0,1:13:39.59,1:13:42.59,中文,,0,0,0,,它们在编程中非常有用，而且已经存在了几十年。
Dialogue: 0,1:13:42.59,1:13:51.64,英文,,0,0,0,,that the authors of printf and the authors of strcmp and bunches of other functions, strling for that matter, just kind of treat strings special because they're just useful, right?
Dialogue: 0,1:13:42.59,1:13:51.64,中文,,0,0,0,,以至于 printf、strcmp 以及许多其他函数（例如 strling）的作者都对字符串进行了特殊处理，因为它们很有用，对吧？
Dialogue: 0,1:13:51.64,1:13:54.70,英文,,0,0,0,,We humans interact using language, be it English or anything else.
Dialogue: 0,1:13:51.64,1:13:54.70,中文,,0,0,0,,我们人类使用语言进行交流，无论是英语还是其他任何语言。
Dialogue: 0,1:13:54.70,1:14:03.11,英文,,0,0,0,,And so it's just useful to have into the language C just sort of first class support for this notion of strings of human text.
Dialogue: 0,1:13:54.70,1:14:03.11,中文,,0,0,0,,因此，在 C 语言中直接支持这种人类文本字符串的概念是很有用的。
Dialogue: 0,1:14:03.11,1:14:05.81,英文,,0,0,0,,So the short answer is just because.
Dialogue: 0,1:14:03.11,1:14:05.81,中文,,0,0,0,,所以简而言之，就是因为这个原因。
Dialogue: 0,1:14:05.81,1:14:08.41,英文,,0,0,0,,Strings are different.
Dialogue: 0,1:14:05.81,1:14:08.41,中文,,0,0,0,,字符串是不同的。
Dialogue: 0,1:14:08.41,1:14:11.69,英文,,0,0,0,,They're implemented with this address and the null character.
Dialogue: 0,1:14:08.41,1:14:11.69,中文,,0,0,0,,它们是用地址和空字符实现的。
Dialogue: 0,1:14:11.69,1:14:14.19,英文,,0,0,0,,Everything else, though, is just a value.
Dialogue: 0,1:14:11.69,1:14:14.19,中文,,0,0,0,,而其他所有东西都只是一个值。
Dialogue: 0,1:14:14.19,1:14:19.54,英文,,0,0,0,,But a string, again, is a white lie. It's an address. It's not a thing unto itself.
Dialogue: 0,1:14:14.19,1:14:19.54,中文,,0,0,0,,但字符串，再说一遍，是一个善意的谎言。它是一个地址。它本身不是一个东西。
Dialogue: 0,1:14:19.54,1:14:20.18,英文,,0,0,0,,Good question.
Dialogue: 0,1:14:19.54,1:14:20.18,中文,,0,0,0,,问得好。
Dialogue: 0,1:14:20.18,1:14:23.88,英文,,0,0,0,,Yeah, in front.
Dialogue: 0,1:14:20.18,1:14:23.88,中文,,0,0,0,,是的，前面。
Dialogue: 0,1:14:23.88,1:14:24.88,英文,,0,0,0,,Oh, really good question.
Dialogue: 0,1:14:23.88,1:14:24.88,中文,,0,0,0,,问得真好。
Dialogue: 0,1:14:24.88,1:14:30.22,英文,,0,0,0,,So in my code here, in VS Code, what if I do this?
Dialogue: 0,1:14:24.88,1:14:30.22,中文,,0,0,0,,在我的 VS Code 代码中，如果我这样做会怎么样？
Dialogue: 0,1:14:30.22,1:14:39.09,英文,,0,0,0,,Instead of str compare, and instead of if s equals equals t, what if I start playing around using star s and star t?
Dialogue: 0,1:14:30.22,1:14:39.09,中文,,0,0,0,,不使用 strcmp，也不使用 if s == t，而是使用 *s 和 *t 会怎么样？
Dialogue: 0,1:14:39.09,1:14:41.03,英文,,0,0,0,,Really interesting case to consider.
Dialogue: 0,1:14:39.09,1:14:41.03,中文,,0,0,0,,这是一个非常有趣的案例。
Dialogue: 0,1:14:41.03,1:14:43.23,英文,,0,0,0,,Let's go back to our sort of deductive logic here.
Dialogue: 0,1:14:41.03,1:14:43.23,中文,,0,0,0,,让我们回到演绎逻辑。
Dialogue: 0,1:14:43.23,1:14:46.81,英文,,0,0,0,,So star, the asterisk operator today, means go there.
Dialogue: 0,1:14:43.23,1:14:46.81,中文,,0,0,0,,星号运算符今天的意思是“去那里”。
Dialogue: 0,1:14:46.81,1:14:51.83,英文,,0,0,0,,So when I've typed in hi once, and then hi again, both uppercase, for instance,
Dialogue: 0,1:14:46.81,1:14:51.83,中文,,0,0,0,,比如当我输入了 "HI！"，然后再输入一次 "HI！"，都是大写，
Dialogue: 0,1:14:51.83,1:14:53.91,英文,,0,0,0,,What is at the address s, literally?
Dialogue: 0,1:14:51.83,1:14:53.91,中文,,0,0,0,,地址 s 处到底是什么？
Dialogue: 0,1:14:53.91,1:14:56.51,英文,,0,0,0,,Someone else.
Dialogue: 0,1:14:53.91,1:14:56.51,中文,,0,0,0,,其他人。
Dialogue: 0,1:14:56.51,1:14:57.59,英文,,0,0,0,,What is at the address s?
Dialogue: 0,1:14:56.51,1:14:57.59,中文,,0,0,0,,地址 s 处是什么？
Dialogue: 0,1:14:57.59,1:14:59.14,英文,,0,0,0,,Yeah.
Dialogue: 0,1:14:57.59,1:14:59.14,中文,,0,0,0,,对。
Dialogue: 0,1:14:59.14,1:15:00.26,英文,,0,0,0,,So not quite.
Dialogue: 0,1:14:59.14,1:15:00.26,中文,,0,0,0,,不完全是。
Dialogue: 0,1:15:00.26,1:15:01.56,英文,,0,0,0,,At the address.
Dialogue: 0,1:15:00.26,1:15:01.56,中文,,0,0,0,,在这个地址处。
Dialogue: 0,1:15:01.56,1:15:02.82,英文,,0,0,0,,So not what is the address.
Dialogue: 0,1:15:01.56,1:15:02.82,中文,,0,0,0,,不是问地址是什么。
Dialogue: 0,1:15:02.82,1:15:04.50,英文,,0,0,0,,What is at the address 0x123?
Dialogue: 0,1:15:02.82,1:15:04.50,中文,,0,0,0,,地址 0x123 处是什么？
Dialogue: 0,1:15:04.50,1:15:09.84,英文,,0,0,0,,H. And what is at the address 0x456?
Dialogue: 0,1:15:04.50,1:15:09.84,中文,,0,0,0,,是 'H'。那地址 0x456 处是什么？
Dialogue: 0,1:15:09.84,1:15:10.82,英文,,0,0,0,,H also.
Dialogue: 0,1:15:09.84,1:15:10.82,中文,,0,0,0,,也是 'H'。
Dialogue: 0,1:15:10.82,1:15:12.82,英文,,0,0,0,,And so here, you're kind of cheating.
Dialogue: 0,1:15:10.82,1:15:12.82,中文,,0,0,0,,所以这里，你有点偷懒了。
Dialogue: 0,1:15:12.82,1:15:17.94,英文,,0,0,0,,You're comparing the first character of both strings, but not every other one.
Dialogue: 0,1:15:12.82,1:15:17.94,中文,,0,0,0,,你只比较了两个字符串的第一个字符，而不是所有字符。
Dialogue: 0,1:15:17.94,1:15:19.55,英文,,0,0,0,,Now, you could be really pedantic.
Dialogue: 0,1:15:17.94,1:15:19.55,中文,,0,0,0,,你可以更较真一点。
Dialogue: 0,1:15:19.55,1:15:22.65,英文,,0,0,0,,And here, again, this is not a good use of code.
Dialogue: 0,1:15:19.55,1:15:22.65,中文,,0,0,0,,再说一次，这不是一种好的代码编写方式。
Dialogue: 0,1:15:22.65,1:15:24.77,英文,,0,0,0,,But you could do this, if that.
Dialogue: 0,1:15:22.65,1:15:24.77,中文,,0,0,0,,但你可以这样做，如果那样的话。
Dialogue: 0,1:15:24.77,1:15:26.39,英文,,0,0,0,,And how about this craziness?
Dialogue: 0,1:15:24.77,1:15:26.39,中文,,0,0,0,,那这种疯狂的做法呢？
Dialogue: 0,1:15:26.39,1:15:32.35,英文,,0,0,0,,So star s plus 1 equals equals star t plus 1.
Dialogue: 0,1:15:26.39,1:15:32.35,中文,,0,0,0,,*s + 1 是否等于 *t + 1。
Dialogue: 0,1:15:32.35,1:15:35.86,英文,,0,0,0,,And you could do this for every character manually, but that's why str compare exists.
Dialogue: 0,1:15:32.35,1:15:35.86,中文,,0,0,0,,你可以手动对每个字符都这样做，但这就是 strcmp 函数存在的原因。
Dialogue: 0,1:15:35.86,1:15:37.12,英文,,0,0,0,,It does all of this for you.
Dialogue: 0,1:15:35.86,1:15:37.12,中文,,0,0,0,,它会为你完成所有这些操作。
Dialogue: 0,1:15:37.12,1:15:38.88,英文,,0,0,0,,But that's why, and that's the intuition.
Dialogue: 0,1:15:37.12,1:15:38.88,中文,,0,0,0,,但这就是原因，这就是直觉。
Dialogue: 0,1:15:38.88,1:15:46.98,英文,,0,0,0,,So I would encourage you to, any time there's something kind of weird going on, there's, I realize we might be straining credibility now, we haven't told you that many white lies.
Dialogue: 0,1:15:38.88,1:15:46.98,中文,,0,0,0,,我鼓励你，任何时候，只要发生了一些奇怪的事情，你要意识到，我们可能在挑战你的信任，我们没有告诉你很多善意的谎言。
Dialogue: 0,1:15:46.98,1:15:50.29,英文,,0,0,0,,And so most everything that we've seen thus far
Dialogue: 0,1:15:46.98,1:15:50.29,中文,,0,0,0,,到目前为止我们所看到的大部分内容
Dialogue: 0,1:15:50.29,1:15:56.85,英文,,0,0,0,,can explain pretty much all of the behavior up until now from week one onward in C. So let me revert this back to the right way.
Dialogue: 0,1:15:50.29,1:15:56.85,中文,,0,0,0,,都可以解释从第一周开始，C 语言中到现在为止的所有行为。让我把它改回正确的方式。
Dialogue: 0,1:15:56.85,1:16:01.79,英文,,0,0,0,,If s dir compare of s and t equals equals 0, this now is the right version of the code.
Dialogue: 0,1:15:56.85,1:16:01.79,中文,,0,0,0,,如果 strcmp(s , t )== 0，现在这就是代码的正确版本。
Dialogue: 0,1:16:01.79,1:16:03.41,英文,,0,0,0,,And now here is, again, where you can play.
Dialogue: 0,1:16:01.79,1:16:03.41,中文,,0,0,0,,现在，你可以在这里试玩一下。
Dialogue: 0,1:16:03.41,1:16:04.17,英文,,0,0,0,,So let me do this.
Dialogue: 0,1:16:03.41,1:16:04.17,中文,,0,0,0,,让我来做这件事。
Dialogue: 0,1:16:04.17,1:16:07.77,英文,,0,0,0,,Let me clear my terminal window just to tidy things up.
Dialogue: 0,1:16:04.17,1:16:07.77,中文,,0,0,0,,让我清空我的终端窗口，整理一下。
Dialogue: 0,1:16:07.77,1:16:10.97,英文,,0,0,0,,Let me get rid of all of this comparison stuff. And let's just see what's going on.
Dialogue: 0,1:16:07.77,1:16:10.97,中文,,0,0,0,,让我摆脱所有这些比较的东西。让我们看看发生了什么。
Dialogue: 0,1:16:10.97,1:16:19.00,英文,,0,0,0,,As you are welcome to in your own code, let's print out, for instance, as we might have in week one, the value of s itself in a new line.
Dialogue: 0,1:16:10.97,1:16:19.00,中文,,0,0,0,,就像你在自己的代码中可以做的那样，让我们打印出，例如，就像我们在第一周做的那样，在新的行中打印出 s 本身的值。
Dialogue: 0,1:16:19.00,1:16:22.94,英文,,0,0,0,,And then let's just print out t, just to make sure it compiles and I'm not doing anything wrong.
Dialogue: 0,1:16:19.00,1:16:22.94,中文,,0,0,0,,然后让我们打印出 t，只是为了确保它能编译并且我没有做错任何事。
Dialogue: 0,1:16:22.94,1:16:24.68,英文,,0,0,0,,But this is not going to be that interesting.
Dialogue: 0,1:16:22.94,1:16:24.68,中文,,0,0,0,,但这并不会那么有趣。
Dialogue: 0,1:16:24.68,1:16:29.54,英文,,0,0,0,,And frankly, I don't need string.h anymore, because I'm not using strcmp.
Dialogue: 0,1:16:24.68,1:16:29.54,中文,,0,0,0,,坦率地说，我不再需要 string.h 了，因为我没有使用 strcmp。
Dialogue: 0,1:16:29.54,1:16:31.82,英文,,0,0,0,,So make addresses, dot slash addresses.
Dialogue: 0,1:16:29.54,1:16:31.82,中文,,0,0,0,,所以 make addresses，./addresses。
Dialogue: 0,1:16:31.82,1:16:34.70,英文,,0,0,0,,There's my string.h.
Dialogue: 0,1:16:31.82,1:16:34.70,中文,,0,0,0,,这是我的 string.h。
Dialogue: 0,1:16:34.70,1:16:36.12,英文,,0,0,0,,Oh, sorry, that's fun.
Dialogue: 0,1:16:34.70,1:16:36.12,中文,,0,0,0,,对不起，这很有趣。
Dialogue: 0,1:16:36.12,1:16:39.18,英文,,0,0,0,,OK, not %t, %s here, too.
Dialogue: 0,1:16:36.12,1:16:39.18,中文,,0,0,0,,不是 %t，这里也是 %s。
Dialogue: 0,1:16:39.18,1:16:40.63,英文,,0,0,0,,Ignore that. Let's do this again.
Dialogue: 0,1:16:39.18,1:16:40.63,中文,,0,0,0,,忽略它。让我们再做一次。
Dialogue: 0,1:16:40.63,1:16:41.25,英文,,0,0,0,,Make address.
Dialogue: 0,1:16:40.63,1:16:41.25,中文,,0,0,0,,Make address。
Dialogue: 0,1:16:41.25,1:16:43.19,英文,,0,0,0,,Oh, and that's the wrong program.
Dialogue: 0,1:16:41.25,1:16:43.19,中文,,0,0,0,,那是错误的程序。
Dialogue: 0,1:16:43.19,1:16:47.93,英文,,0,0,0,,OK, let's do make compare, ./.compare.
Dialogue: 0,1:16:43.19,1:16:47.93,中文,,0,0,0,,好，我们来试试 `make compare`，`./compare`。
Dialogue: 0,1:16:47.93,1:16:50.35,英文,,0,0,0,,And let's type in hi again and hi again.
Dialogue: 0,1:16:47.93,1:16:50.35,中文,,0,0,0,,再输入 `HI！` 和 `HI！`。
Dialogue: 0,1:16:50.35,1:16:52.52,英文,,0,0,0,,And now we just see the two strings. I'm not comparing.
Dialogue: 0,1:16:50.35,1:16:52.52,中文,,0,0,0,,现在只显示了两个字符串，没有进行比较。
Dialogue: 0,1:16:52.52,1:16:54.16,英文,,0,0,0,,But now we can kind of play around, right?
Dialogue: 0,1:16:52.52,1:16:54.16,中文,,0,0,0,,但现在我们可以尝试一些操作，对吧？
Dialogue: 0,1:16:54.16,1:17:02.07,英文,,0,0,0,,Instead of printing out %s, which prints the string, how do I print the address in s?
Dialogue: 0,1:16:54.16,1:17:02.07,中文,,0,0,0,,不想打印 `%s` 来打印字符串，如何打印 `s` 的地址？
Dialogue: 0,1:17:02.07,1:17:04.45,英文,,0,0,0,,I just need to make a slight change.
Dialogue: 0,1:17:02.07,1:17:04.45,中文,,0,0,0,,只需要做一个小改动。
Dialogue: 0,1:17:04.45,1:17:09.51,英文,,0,0,0,,If I want to see not what's at s, but I want to see s, the address.
Dialogue: 0,1:17:04.45,1:17:09.51,中文,,0,0,0,,如果不想看 `s` 中的内容，而是想看 `s` 的地址。
Dialogue: 0,1:17:09.51,1:17:13.58,英文,,0,0,0,,Yeah.
Dialogue: 0,1:17:09.51,1:17:13.58,中文,,0,0,0,,是的。
Dialogue: 0,1:17:13.58,1:17:14.06,英文,,0,0,0,,Perfect.
Dialogue: 0,1:17:13.58,1:17:14.06,中文,,0,0,0,,完美。
Dialogue: 0,1:17:14.06,1:17:20.62,英文,,0,0,0,,So change percent s in both places here to percent p. So now, printf will treat it literally as an address.
Dialogue: 0,1:17:14.06,1:17:20.62,中文,,0,0,0,,将这两个地方的 `%s` 改成 `%p`。这样，`printf` 就会把它原样当作地址处理。
Dialogue: 0,1:17:20.62,1:17:24.42,英文,,0,0,0,,It's not going to do any fanciness with a loop from left to right looking for the null character.
Dialogue: 0,1:17:20.62,1:17:24.42,中文,,0,0,0,,它不会从左到右循环查找空字符，不会做任何花哨的操作。
Dialogue: 0,1:17:24.42,1:17:28.43,英文,,0,0,0,,It's just going to print out s and t. So let me clear my terminal, run make compare.
Dialogue: 0,1:17:24.42,1:17:28.43,中文,,0,0,0,,它只会打印出 `s` 和 `t`。让我清空终端，运行 `make compare`。
Dialogue: 0,1:17:28.43,1:17:29.19,英文,,0,0,0,,Whoops.
Dialogue: 0,1:17:28.43,1:17:29.19,中文,,0,0,0,,糟糕。
Dialogue: 0,1:17:29.19,1:17:32.15,英文,,0,0,0,,Let's do make compare, dot slash compare, Enter.
Dialogue: 0,1:17:29.19,1:17:32.15,中文,,0,0,0,,我们来试试 `make compare`，`./compare`，回车。
Dialogue: 0,1:17:32.15,1:17:33.09,英文,,0,0,0,,Type in hi.
Dialogue: 0,1:17:32.15,1:17:33.09,中文,,0,0,0,,输入 `HI！`。
Dialogue: 0,1:17:33.09,1:17:34.05,英文,,0,0,0,,Type in hi again.
Dialogue: 0,1:17:33.09,1:17:34.05,中文,,0,0,0,,再输入 `HI！`。
Dialogue: 0,1:17:34.05,1:17:37.85,英文,,0,0,0,,And now you see, oh, so this is interesting.
Dialogue: 0,1:17:34.05,1:17:37.85,中文,,0,0,0,,现在看到了，这很有趣。
Dialogue: 0,1:17:37.85,1:17:42.03,英文,,0,0,0,,It's not quite as straightforward as the other values, which were one byte away.
Dialogue: 0,1:17:37.85,1:17:42.03,中文,,0,0,0,,它不像其他相差一个字节的值那样直接。
Dialogue: 0,1:17:42.03,1:17:43.11,英文,,0,0,0,,They're almost the same.
Dialogue: 0,1:17:42.03,1:17:43.11,中文,,0,0,0,,它们几乎相同。
Dialogue: 0,1:17:43.11,1:17:45.11,英文,,0,0,0,,But this one ends in b0.
Dialogue: 0,1:17:43.11,1:17:45.11,中文,,0,0,0,,但这个以 `b0` 结尾。
Dialogue: 0,1:17:45.11,1:17:46.57,英文,,0,0,0,,This one ends in f0.
Dialogue: 0,1:17:45.11,1:17:46.57,中文,,0,0,0,,这个以 f0 结尾。
Dialogue: 0,1:17:46.57,1:17:50.30,英文,,0,0,0,,So they're indeed separated by some number of bytes.
Dialogue: 0,1:17:46.57,1:17:50.30,中文,,0,0,0,,所以它们之间确实隔着一些字节。
Dialogue: 0,1:17:50.30,1:17:54.12,英文,,0,0,0,,Not just one, but a few, because these strings are indeed longer.
Dialogue: 0,1:17:50.30,1:17:54.12,中文,,0,0,0,,不只一个，而是好几个，因为这些字符串确实更长。
Dialogue: 0,1:17:54.12,1:18:00.23,英文,,0,0,0,,All right, so once you've seen this here, how can we now maybe leverage this to solve other problems?
Dialogue: 0,1:17:54.12,1:18:00.23,中文,,0,0,0,,好了，既然你已经看到了这些，我们现在怎样才能利用它来解决其他问题呢？
Dialogue: 0,1:18:00.23,1:18:01.79,英文,,0,0,0,,Well, let me propose that we do this.
Dialogue: 0,1:18:00.23,1:18:01.79,中文,,0,0,0,,让我提议我们这样做。
Dialogue: 0,1:18:01.79,1:18:03.78,英文,,0,0,0,,Let me zoom out here.
Dialogue: 0,1:18:01.79,1:18:03.78,中文,,0,0,0,,让我把它缩小。
Dialogue: 0,1:18:03.78,1:18:05.88,英文,,0,0,0,,Let me close compare.
Dialogue: 0,1:18:03.78,1:18:05.88,中文,,0,0,0,,让我关闭比较。
Dialogue: 0,1:18:05.88,1:18:10.36,英文,,0,0,0,,And let me open up another program I wrote part of in advance called copy.c.
Dialogue: 0,1:18:05.88,1:18:10.36,中文,,0,0,0,,让我打开另一个我提前写了一部分的程序，叫做 copy.c。
Dialogue: 0,1:18:10.36,1:18:14.27,英文,,0,0,0,,So copy.c, in theory, makes a copy of a string.
Dialogue: 0,1:18:10.36,1:18:14.27,中文,,0,0,0,,所以理论上，copy.c 可以复制字符串。
Dialogue: 0,1:18:14.27,1:18:15.11,英文,,0,0,0,,How?
Dialogue: 0,1:18:14.27,1:18:15.11,中文,,0,0,0,,怎么做？
Dialogue: 0,1:18:15.11,1:18:22.49,英文,,0,0,0,,On line 8, I'm using the same thing as before, getString, storing it in a string, or char star, and asking the user for it.
Dialogue: 0,1:18:15.11,1:18:22.49,中文,,0,0,0,,在第 8 行，我使用了和之前一样的东西，get_string，将它存储在一个字符串中，或者说 char *，并询问用户。
Dialogue: 0,1:18:22.49,1:18:25.06,英文,,0,0,0,,Then I'm not asking getString again.
Dialogue: 0,1:18:22.49,1:18:25.06,中文,,0,0,0,,然后我没有再次询问 get_string。
Dialogue: 0,1:18:25.06,1:18:30.78,英文,,0,0,0,,I'm just making a copy, super simply, with line 10 here, string t equals s.
Dialogue: 0,1:18:25.06,1:18:30.78,中文,,0,0,0,,我只是在第 10 行，用 string t = s 做了一个简单的复制。
Dialogue: 0,1:18:30.78,1:18:33.80,英文,,0,0,0,,Now, intuitively, I think that's how I would copy a variable, right?
Dialogue: 0,1:18:30.78,1:18:33.80,中文,,0,0,0,,现在，凭直觉，我认为这就是我复制变量的方式，对吧？
Dialogue: 0,1:18:33.80,1:18:39.36,英文,,0,0,0,,That's how we've copied variables every week thus far in C. But something's going to go wrong.
Dialogue: 0,1:18:33.80,1:18:39.36,中文,,0,0,0,,这就是我们到目前为止每周在 C 语言中复制变量的方式。但有些地方会出错。
Dialogue: 0,1:18:39.36,1:18:44.59,英文,,0,0,0,,In line 12, in English, does someone want to explain what you think line 12 does?
Dialogue: 0,1:18:39.36,1:18:44.59,中文,,0,0,0,,在第 12 行，用英语，有人想解释一下你认为第 12 行是做什么的吗？
Dialogue: 0,1:18:44.59,1:18:46.45,英文,,0,0,0,,Don't worry about finding any bugs or mistakes.
Dialogue: 0,1:18:44.59,1:18:46.45,中文,,0,0,0,,别担心会发现任何错误或漏洞。
Dialogue: 0,1:18:46.45,1:18:57.21,英文,,0,0,0,,But what does line 12 seem to be doing using toUpper, which is thanks to the C type library, which I've included the header file for?
Dialogue: 0,1:18:46.45,1:18:57.21,中文,,0,0,0,,但是第 12 行似乎在用 toupper 做什么，toupper 来自于 C 类型库，我已经包含了它的头文件？
Dialogue: 0,1:18:57.21,1:18:59.35,英文,,0,0,0,,Yeah, right, it's kind of like ugly syntax.
Dialogue: 0,1:18:57.21,1:18:59.35,中文,,0,0,0,,是的，没错，这语法有点难看。
Dialogue: 0,1:18:59.35,1:19:04.80,英文,,0,0,0,,But this would seem to be capitalizing the first letter of T specifically and just changing it.
Dialogue: 0,1:18:59.35,1:19:04.80,中文,,0,0,0,,但这似乎只是将 t 的第一个字母大写，并只改变了它。
Dialogue: 0,1:19:04.80,1:19:07.88,英文,,0,0,0,,So we have T bracket 0 here because we want to save the change.
Dialogue: 0,1:19:04.80,1:19:07.88,中文,,0,0,0,,这里我们用 t[0]，因为我们要保存修改。
Dialogue: 0,1:19:07.88,1:19:12.60,英文,,0,0,0,,And we're passing to toUpper the first character here. So this is how we did uppercase in the past.
Dialogue: 0,1:19:07.88,1:19:12.60,中文,,0,0,0,,我们将第一个字符传递给 toupper 函数，就像我们之前将字母大写那样。
Dialogue: 0,1:19:12.60,1:19:17.08,英文,,0,0,0,,And now I print out S and T respectively using %S.
Dialogue: 0,1:19:12.60,1:19:17.08,中文,,0,0,0,,现在我用 %S 分别打印出 S 和 t。
Dialogue: 0,1:19:17.08,1:19:18.55,英文,,0,0,0,,So this feels like it should work.
Dialogue: 0,1:19:17.08,1:19:18.55,中文,,0,0,0,,这样看起来应该可以工作。
Dialogue: 0,1:19:18.55,1:19:21.99,英文,,0,0,0,,I copied S and stored it in T on line 10.
Dialogue: 0,1:19:18.55,1:19:21.99,中文,,0,0,0,,我在第 10 行复制了 s 并将其存储在 t 中。
Dialogue: 0,1:19:21.99,1:19:25.61,英文,,0,0,0,,And then I change T and only T on line 12.
Dialogue: 0,1:19:21.99,1:19:25.61,中文,,0,0,0,,然后我在第 12 行只更改了 t。
Dialogue: 0,1:19:25.61,1:19:33.01,英文,,0,0,0,,But you can perhaps, if you're comfy thus far, see where this is going if I do make copy, dot slash copy.
Dialogue: 0,1:19:25.61,1:19:33.01,中文,,0,0,0,,但如果你到目前为止觉得舒服的话，也许你能看出来，如果我执行 copy，./copy 会发生什么。
Dialogue: 0,1:19:33.01,1:19:37.23,英文,,0,0,0,,And let me type in lowercase h-i, exclamation point this time, just once.
Dialogue: 0,1:19:33.01,1:19:37.23,中文,,0,0,0,,这次让我输入小写的 h-i，感叹号，只输入一次。
Dialogue: 0,1:19:37.23,1:19:38.70,英文,,0,0,0,,So I'm going to hit Enter.
Dialogue: 0,1:19:37.23,1:19:38.70,中文,,0,0,0,,我要按回车键了。
Dialogue: 0,1:19:38.70,1:19:43.62,英文,,0,0,0,,And watch what we see for the value of s and t. Huh.
Dialogue: 0,1:19:38.70,1:19:43.62,中文,,0,0,0,,看看 s 和 t 的值是什么。 咦。
Dialogue: 0,1:19:43.62,1:19:48.84,英文,,0,0,0,,The new value of s and t at the end of my program seems to be what?
Dialogue: 0,1:19:43.62,1:19:48.84,中文,,0,0,0,,程序结束时 s 和 t 的新值似乎是什么？
Dialogue: 0,1:19:48.84,1:19:50.81,英文,,0,0,0,,It seems to be.
Dialogue: 0,1:19:48.84,1:19:50.81,中文,,0,0,0,,它似乎是。
Dialogue: 0,1:19:50.81,1:19:54.32,英文,,0,0,0,,The same high is capitalized both times.
Dialogue: 0,1:19:50.81,1:19:54.32,中文,,0,0,0,,两次都是大写的 “Hi”。
Dialogue: 0,1:19:54.32,1:19:56.80,英文,,0,0,0,,So what's the intuition then for this?
Dialogue: 0,1:19:54.32,1:19:56.80,中文,,0,0,0,,那么对此的直觉是什么？
Dialogue: 0,1:19:56.80,1:20:02.78,英文,,0,0,0,,Why did this just happen?
Dialogue: 0,1:19:56.80,1:20:02.78,中文,,0,0,0,,为什么会发生这种情况？
Dialogue: 0,1:20:02.78,1:20:05.20,英文,,0,0,0,,Yeah, I assigned s and t the same memory address.
Dialogue: 0,1:20:02.78,1:20:05.20,中文,,0,0,0,,是的，我给 s 和 t 分配了相同的内存地址。
Dialogue: 0,1:20:05.20,1:20:09.55,英文,,0,0,0,,So it did copy s into t. But C takes this very literally.
Dialogue: 0,1:20:05.20,1:20:09.55,中文,,0,0,0,,所以它确实把 s 复制到了 t 中。但 C 语言非常字面地理解这一点。
Dialogue: 0,1:20:09.55,1:20:10.77,英文,,0,0,0,,What is s? It's an address.
Dialogue: 0,1:20:09.55,1:20:10.77,中文,,0,0,0,,s 是什么？它是一个地址。
Dialogue: 0,1:20:10.77,1:20:12.83,英文,,0,0,0,,What is t? It's a copy of that address.
Dialogue: 0,1:20:10.77,1:20:12.83,中文,,0,0,0,,t 是什么？ 它是该地址的副本。
Dialogue: 0,1:20:12.83,1:20:18.18,英文,,0,0,0,,If you want to copy the whole string like a normal human would expect, hey, you or someone has to do a lot more work.
Dialogue: 0,1:20:12.83,1:20:18.18,中文,,0,0,0,,如果你想像普通人期望的那样复制整个字符串，你和其他人就得多费些功夫。
Dialogue: 0,1:20:18.18,1:20:22.30,英文,,0,0,0,,You have to go to that address, copy this character, this one, this one, this one.
Dialogue: 0,1:20:18.18,1:20:22.30,中文,,0,0,0,,你必须转到那个地址，复制这个字符、这个、这个、这个。
Dialogue: 0,1:20:22.30,1:20:24.46,英文,,0,0,0,,and copy it to a new location in memory.
Dialogue: 0,1:20:22.30,1:20:24.46,中文,,0,0,0,,并将其复制到内存中的新位置。
Dialogue: 0,1:20:24.46,1:20:28.07,英文,,0,0,0,,That does not happen automatically here for you in C. It does in some other languages.
Dialogue: 0,1:20:24.46,1:20:28.07,中文,,0,0,0,,在 C 语言中，这不会自动发生。但在其他一些语言中会。
Dialogue: 0,1:20:28.07,1:20:32.19,英文,,0,0,0,,Those of you who've programmed in certain higher-level languages, this just works as you would hope.
Dialogue: 0,1:20:28.07,1:20:32.19,中文,,0,0,0,,对于用某些更高级语言编程的人来说，这会按预期工作。
Dialogue: 0,1:20:32.19,1:20:35.67,英文,,0,0,0,,And that's one of the benefits of Python and other languages that we'll soon see.
Dialogue: 0,1:20:32.19,1:20:35.67,中文,,0,0,0,,这也是 Python 和我们很快就会看到的其他语言的优势之一。
Dialogue: 0,1:20:35.67,1:20:38.97,英文,,0,0,0,,But for now, it literally takes at face value what this is.
Dialogue: 0,1:20:35.67,1:20:38.97,中文,,0,0,0,,但现在，它只是从字面上理解了这是什么。
Dialogue: 0,1:20:38.97,1:20:40.79,英文,,0,0,0,,Copy the address into this address.
Dialogue: 0,1:20:38.97,1:20:40.79,中文,,0,0,0,,将地址复制到这个地址。
Dialogue: 0,1:20:40.79,1:20:46.04,英文,,0,0,0,,And I'll make that more clear by getting rid of the string keyword, which, again, is just a typedef.
Dialogue: 0,1:20:40.79,1:20:46.04,中文,,0,0,0,,为了更清楚地说明这一点，我去掉了 string 关键字，它同样只是一个 typedef。
Dialogue: 0,1:20:46.04,1:20:49.62,英文,,0,0,0,,This is technically an address here.
Dialogue: 0,1:20:46.04,1:20:49.62,中文,,0,0,0,,从技术上讲，这是一个地址。
Dialogue: 0,1:20:49.62,1:20:55.85,英文,,0,0,0,,So what's being copied is the value of that address, not all of the characters that might very well follow it.
Dialogue: 0,1:20:49.62,1:20:55.85,中文,,0,0,0,,所以被复制的是那个地址的值，而不是它后面可能跟着的所有字符。
Dialogue: 0,1:20:55.85,1:20:58.61,英文,,0,0,0,,So I should make one note, too, here.
Dialogue: 0,1:20:55.85,1:20:58.61,中文,,0,0,0,,这里我还有一点要注意。
Dialogue: 0,1:20:58.61,1:21:05.06,英文,,0,0,0,,I'm going to start getting more in the habit of trying to avoid segmentation faults because things could go wrong here.
Dialogue: 0,1:20:58.61,1:21:05.06,中文,,0,0,0,,我将开始养成尽量避免段错误的习惯，因为这里可能会出错。
Dialogue: 0,1:21:05.06,1:21:15.38,英文,,0,0,0,,For instance, on line 12 previously, I was kind of blindly, naively, dangerously assuming that there will be at least one character in S or T. That might not be the case.
Dialogue: 0,1:21:05.06,1:21:15.38,中文,,0,0,0,,例如，在之前的第 12 行，我有点盲目、天真、危险地假设 s 或 t 中至少有一个字符。可能并非如此。
Dialogue: 0,1:21:15.38,1:21:18.38,英文,,0,0,0,,If the user just hits Enter, there's no characters to uppercase.
Dialogue: 0,1:21:15.38,1:21:18.38,中文,,0,0,0,,如果用户只按了回车键，就没有字符需要大写。
Dialogue: 0,1:21:18.38,1:21:21.90,英文,,0,0,0,,And so this is reckless of me and could theoretically create a seg fault.
Dialogue: 0,1:21:18.38,1:21:21.90,中文,,0,0,0,,所以我不负责任，理论上可能会造成段错误。
Dialogue: 0,1:21:21.90,1:21:25.62,英文,,0,0,0,,So I should probably start to be smarter and say something like this.
Dialogue: 0,1:21:21.90,1:21:25.62,中文,,0,0,0,,所以我可能应该变得更聪明，像这样说。
Dialogue: 0,1:21:25.62,1:21:32.31,英文,,0,0,0,,If the length of t is greater than 0, OK, now it's safe to actually capitalize the first letter.
Dialogue: 0,1:21:25.62,1:21:32.31,中文,,0,0,0,,如果 t 的长度大于 0，就可以安全地将第一个字母大写。
Dialogue: 0,1:21:32.31,1:21:40.22,英文,,0,0,0,,And that will decrease the probability now of those segmentation faults by just not making any assumptions about what the human does.
Dialogue: 0,1:21:32.31,1:21:40.22,中文,,0,0,0,,这将减少段错误的可能性，因为它不假设人的行为。
Dialogue: 0,1:21:40.22,1:21:42.86,英文,,0,0,0,,Almost always, your programs will crash.
Dialogue: 0,1:21:40.22,1:21:42.86,中文,,0,0,0,,你的程序几乎总会崩溃。
Dialogue: 0,1:21:42.86,1:21:49.28,英文,,0,0,0,,When you've made a mistake, yes, but the user gives you an input that you yourself did not expect.
Dialogue: 0,1:21:42.86,1:21:49.28,中文,,0,0,0,,当你犯了错误，用户给了你一个你自己也没预料到的输入。
Dialogue: 0,1:21:49.28,1:21:51.04,英文,,0,0,0,,So what does this all look like in memory?
Dialogue: 0,1:21:49.28,1:21:51.04,中文,,0,0,0,,那么，这一切在内存中是什么样子的呢？
Dialogue: 0,1:21:51.04,1:21:55.26,英文,,0,0,0,,Well, let's go back to the big grid, this time focusing on the copying of values.
Dialogue: 0,1:21:51.04,1:21:55.26,中文,,0,0,0,,让我们回到大的网格，这次关注值的复制。
Dialogue: 0,1:21:55.26,1:22:01.22,英文,,0,0,0,,And let's do this. Here's s, as in this new program, just declared to be a char star.
Dialogue: 0,1:21:55.26,1:22:01.22,中文,,0,0,0,,我们这样做。这里有一个 s，就像在这个新程序中一样，声明为 char*。
Dialogue: 0,1:22:01.22,1:22:04.52,英文,,0,0,0,,Here is where my lowercase i maybe ended up in the computer's memory.
Dialogue: 0,1:22:01.22,1:22:04.52,中文,,0,0,0,,这里是我的小写字母 i 最终可能在计算机内存中的位置。
Dialogue: 0,1:22:04.52,1:22:08.92,英文,,0,0,0,,That's probably at 0x123, 0x124, 0x125, whatever, something like that.
Dialogue: 0,1:22:04.52,1:22:08.92,中文,,0,0,0,,那可能是在 0x123、0x124、0x125 之类的地址上。
Dialogue: 0,1:22:08.92,1:22:12.35,英文,,0,0,0,,And that's, of course, what ends up in s as a value.
Dialogue: 0,1:22:08.92,1:22:12.35,中文,,0,0,0,,当然，这也是最终存储在 s 中的值。
Dialogue: 0,1:22:12.35,1:22:17.09,英文,,0,0,0,,When I declare t, I do get a second variable called t, just like before.
Dialogue: 0,1:22:12.35,1:22:17.09,中文,,0,0,0,,当我声明 t 时，我确实得到了第二个变量 t，就像之前一样。
Dialogue: 0,1:22:17.09,1:22:21.53,英文,,0,0,0,,But when I copy s into t, what happens?
Dialogue: 0,1:22:17.09,1:22:21.53,中文,,0,0,0,,但是当我把 s 复制到 t 中时，会发生什么呢？
Dialogue: 0,1:22:21.53,1:22:24.17,英文,,0,0,0,,It's really just literally 0x123.
Dialogue: 0,1:22:21.53,1:22:24.17,中文,,0,0,0,,它实际上就是 0x123。
Dialogue: 0,1:22:24.17,1:22:33.17,英文,,0,0,0,,Whatever the value of s is is now also the value of t. And so if we abstract this away at a high level, get rid of all of those extra squares, this is what s and t now are.
Dialogue: 0,1:22:24.17,1:22:33.17,中文,,0,0,0,,s 的值现在也是 t 的值。所以如果我们在更高的层次上抽象出来，去掉所有这些额外的方块，这就是现在的 s 和 t。
Dialogue: 0,1:22:33.17,1:22:38.09,英文,,0,0,0,,They're indeed copies, but copies of each other, not copies of the underlying characters.
Dialogue: 0,1:22:33.17,1:22:38.09,中文,,0,0,0,,它们确实是副本，但彼此是副本，而不是底层字符的副本。
Dialogue: 0,1:22:38.09,1:22:40.75,英文,,0,0,0,,And so if you follow those arrows, you
Dialogue: 0,1:22:38.09,1:22:40.75,中文,,0,0,0,,所以如果你沿着这些箭头，你
Dialogue: 0,1:22:40.75,1:22:42.20,英文,,0,0,0,,And try to print them both out.
Dialogue: 0,1:22:40.75,1:22:42.20,中文,,0,0,0,,并尝试将它们都打印出来。
Dialogue: 0,1:22:42.20,1:22:53.04,英文,,0,0,0,,After capitalizing one or the other, you're going to unfortunately end up capitalizing not just one of them, S, but both of them, S and T. Because literally, it's the same address.
Dialogue: 0,1:22:42.20,1:22:53.04,中文,,0,0,0,,将其中一个大写后，你最终不幸地将两个都大写了，s 和 t。因为实际上，它们是同一个地址。
Dialogue: 0,1:22:53.04,1:22:56.24,英文,,0,0,0,,Any questions, then, on this visualization?
Dialogue: 0,1:22:53.04,1:22:56.24,中文,,0,0,0,,对这个可视化还有问题吗？
Dialogue: 0,1:22:56.24,1:22:59.15,英文,,0,0,0,,Yeah.
Dialogue: 0,1:22:56.24,1:22:59.15,中文,,0,0,0,,有。
Dialogue: 0,1:22:59.15,1:23:01.17,英文,,0,0,0,,Good question, is this pass by reference?
Dialogue: 0,1:22:59.15,1:23:01.17,中文,,0,0,0,,问得好，这是按引用传递吗？
Dialogue: 0,1:23:01.17,1:23:07.36,英文,,0,0,0,,We have not seen in detail an example like that.
Dialogue: 0,1:23:01.17,1:23:07.36,中文,,0,0,0,,我们还没有详细地看到这样的例子。
Dialogue: 0,1:23:07.36,1:23:09.36,英文,,0,0,0,,Right now, you're copying by value.
Dialogue: 0,1:23:07.36,1:23:09.36,中文,,0,0,0,,现在，你正在按值复制。
Dialogue: 0,1:23:09.36,1:23:10.54,英文,,0,0,0,,But references will come into play.
Dialogue: 0,1:23:09.36,1:23:10.54,中文,,0,0,0,,但引用将会起作用。
Dialogue: 0,1:23:10.54,1:23:12.72,英文,,0,0,0,,And remind me in a bit if I haven't used that term yet.
Dialogue: 0,1:23:10.54,1:23:12.72,中文,,0,0,0,,如果我还没有用过这个术语，请提醒我。
Dialogue: 0,1:23:12.72,1:23:17.44,英文,,0,0,0,,But this is just copying things by, could have ended poorly, value.
Dialogue: 0,1:23:12.72,1:23:17.44,中文,,0,0,0,,但这只是通过值复制内容，可能会导致糟糕的结果。
Dialogue: 0,1:23:17.44,1:23:20.37,英文,,0,0,0,,Other questions?
Dialogue: 0,1:23:17.44,1:23:20.37,中文,,0,0,0,,还有其他问题吗？
Dialogue: 0,1:23:20.37,1:23:26.12,英文,,0,0,0,,All right, so with this in mind, how do we actually copy things properly?
Dialogue: 0,1:23:20.37,1:23:26.12,中文,,0,0,0,,考虑到这一点，我们如何正确地复制内容呢？
Dialogue: 0,1:23:26.12,1:23:28.24,英文,,0,0,0,,For this, we actually need another building block.
Dialogue: 0,1:23:26.12,1:23:28.24,中文,,0,0,0,,为此，我们实际上需要另一个构建块。
Dialogue: 0,1:23:28.24,1:23:32.98,英文,,0,0,0,,So today, we give you two functions, one of which is called malloc, one of which is called free.
Dialogue: 0,1:23:28.24,1:23:32.98,中文,,0,0,0,,今天，我们为你提供两个函数，一个叫做 malloc，一个叫做 free。
Dialogue: 0,1:23:32.98,1:23:41.08,英文,,0,0,0,,And these are used all of the time by every piece of software you and I use on our Macs, PCs, and phones, whether it's written in C or some equivalent other language.
Dialogue: 0,1:23:32.98,1:23:41.08,中文,,0,0,0,,无论是在 Mac、PC 还是手机上，你我使用的每一个软件，无论是用 C 语言还是其他等效语言编写的，都在一直使用它们。
Dialogue: 0,1:23:41.08,1:23:43.42,英文,,0,0,0,,Malloc is for memory allocation.
Dialogue: 0,1:23:41.08,1:23:43.42,中文,,0,0,0,,Malloc 用于内存分配。
Dialogue: 0,1:23:43.42,1:23:50.39,英文,,0,0,0,,It's a function that you can use to ask the operating system, Mac OS, Linux, Windows, anything, for some number of bytes.
Dialogue: 0,1:23:43.42,1:23:50.39,中文,,0,0,0,,它是一个函数，你可以使用它向操作系统（Mac OS、Linux、Windows 等）请求任意数量的字节。
Dialogue: 0,1:23:50.39,1:23:52.59,英文,,0,0,0,,One byte, 100 bytes, a gigabyte of memory.
Dialogue: 0,1:23:50.39,1:23:52.59,中文,,0,0,0,,一个字节，100 个字节，一个 GB 的内存。
Dialogue: 0,1:23:52.59,1:23:55.98,英文,,0,0,0,,You can ask malloc for however much memory you want in advance.
Dialogue: 0,1:23:52.59,1:23:55.98,中文,,0,0,0,,你可以提前向 malloc 请求任意数量的内存。
Dialogue: 0,1:23:55.98,1:24:02.23,英文,,0,0,0,,It will return to you the address of the first byte of memory that it found free for you.
Dialogue: 0,1:23:55.98,1:24:02.23,中文,,0,0,0,,它将返回它为你找到的空闲内存的第一个字节的地址。
Dialogue: 0,1:24:02.23,1:24:04.97,英文,,0,0,0,,Unlike a string, it is not null terminated.
Dialogue: 0,1:24:02.23,1:24:04.97,中文,,0,0,0,,与字符串不同，它不是以空字符结尾的。
Dialogue: 0,1:24:04.97,1:24:07.93,英文,,0,0,0,,And so the danger with malloc is that it's on the honor system.
Dialogue: 0,1:24:04.97,1:24:07.93,中文,,0,0,0,,所以使用 malloc 的危险在于它是基于信任的。
Dialogue: 0,1:24:07.93,1:24:16.33,英文,,0,0,0,,If you ask it for 1 byte or 10 bytes, you, the programmer, in like a variable, have to remember how many bytes you requested, 1 or 10 or the like.
Dialogue: 0,1:24:07.93,1:24:16.33,中文,,0,0,0,,如果你请求 1 个字节或 10 个字节，作为程序员，你必须像变量一样记住你请求了多少个字节，1 个还是 10 个等等。
Dialogue: 0,1:24:16.33,1:24:19.39,英文,,0,0,0,,Strings do that for you, not when we're getting now to this low level.
Dialogue: 0,1:24:16.33,1:24:19.39,中文,,0,0,0,,当我们现在深入到这个低级时，字符串会为你做到这一点。
Dialogue: 0,1:24:19.39,1:24:23.46,英文,,0,0,0,,Malloc's just going to give you some memory, and it's up to you to manage it. Free does the opposite.
Dialogue: 0,1:24:19.39,1:24:23.46,中文,,0,0,0,,Malloc 只会给你一些内存，而管理它是你的责任。free 则相反。
Dialogue: 0,1:24:23.46,1:24:30.27,英文,,0,0,0,,When you're done with some chunk of memory, you can free it by passing in that same address and just hand it back to Mac OS, Windows, or Linux and say, I'm done with this.
Dialogue: 0,1:24:23.46,1:24:30.27,中文,,0,0,0,,当你使用完某个内存块时，可以通过传入相同的地址来释放它，并将其交还给 Mac OS、Windows 或 Linux，并说，我已经完成了。
Dialogue: 0,1:24:30.27,1:24:33.25,英文,,0,0,0,,You can let me use this for something else later.
Dialogue: 0,1:24:30.27,1:24:33.25,中文,,0,0,0,,你可以让我以后将其用于其他用途。
Dialogue: 0,1:24:33.25,1:24:37.60,英文,,0,0,0,,As an aside, if your computer has ever frozen,
Dialogue: 0,1:24:33.25,1:24:37.60,中文,,0,0,0,,顺便说一下，如果你的电脑曾经死机，
Dialogue: 0,1:24:37.60,1:24:40.30,英文,,0,0,0,,Or hung, like the whole thing maybe just spontaneously reboots.
Dialogue: 0,1:24:37.60,1:24:40.30,中文,,0,0,0,,或者卡住，比如整个系统可能就自发重启了。
Dialogue: 0,1:24:40.30,1:24:56.22,英文,,0,0,0,,Yet another reason for a bug like that might be, if you write a program with a bug that keeps mallocing, mallocing, mallocing, that is asking for more and more and more memory, but you make a mistake and you never free it, well, eventually, the computer is going to literally run out of memory, and something's going to go wrong.
Dialogue: 0,1:24:40.30,1:24:56.22,中文,,0,0,0,,造成这种 bug 的另一个原因可能是，如果你写了一个程序，它不停地malloc、malloc、malloc，\N也就是不停地请求更多内存，但你犯了个错误，从来没有释放它，那么最终，计算机的内存将会耗尽，然后就会出现问题。
Dialogue: 0,1:24:56.22,1:24:59.94,英文,,0,0,0,,And that's often when. Computers freeze, like they're just out of memory.
Dialogue: 0,1:24:56.22,1:24:59.94,中文,,0,0,0,,这通常就是电脑死机的原因，因为内存不足。
Dialogue: 0,1:24:59.94,1:25:04.19,英文,,0,0,0,,It has the memory there, but the program was trying to use too much of it endlessly.
Dialogue: 0,1:24:59.94,1:25:04.19,中文,,0,0,0,,内存是有的，但程序却试图无休止地使用太多内存。
Dialogue: 0,1:25:04.19,1:25:07.73,英文,,0,0,0,,So this, too, will be a mistake that some of us will surely make in the coming weeks.
Dialogue: 0,1:25:04.19,1:25:07.73,中文,,0,0,0,,这也是我们中的一些人在未来几周内肯定会犯的错误。
Dialogue: 0,1:25:07.73,1:25:09.83,英文,,0,0,0,,But hopefully, you'll now see the solution.
Dialogue: 0,1:25:07.73,1:25:09.83,中文,,0,0,0,,但希望你现在能看到解决方案。
Dialogue: 0,1:25:09.83,1:25:12.95,英文,,0,0,0,,So let me go back to VS Code here.
Dialogue: 0,1:25:09.83,1:25:12.95,中文,,0,0,0,,让我回到 VS Code。
Dialogue: 0,1:25:12.95,1:25:15.10,英文,,0,0,0,,And let me propose that we do the following.
Dialogue: 0,1:25:12.95,1:25:15.10,中文,,0,0,0,,我建议我们这样做。
Dialogue: 0,1:25:15.10,1:25:17.04,英文,,0,0,0,,I'll hide my terminal window for a moment.
Dialogue: 0,1:25:15.10,1:25:17.04,中文,,0,0,0,,我先把终端窗口隐藏起来。
Dialogue: 0,1:25:17.04,1:25:20.08,英文,,0,0,0,,And I'm going to introduce another header file up here.
Dialogue: 0,1:25:17.04,1:25:20.08,中文,,0,0,0,,我要在这里引入另一个头文件。
Dialogue: 0,1:25:20.08,1:25:27.11,英文,,0,0,0,,And I promise there's not going to be too many more of these, but this one is called standardlib.h for standard library.
Dialogue: 0,1:25:20.08,1:25:27.11,中文,,0,0,0,,我保证不会有太多这样的文件了，这个文件叫做 stdlib.h，代表标准库。
Dialogue: 0,1:25:27.11,1:25:32.54,英文,,0,0,0,,And in this file are the declarations, the prototypes for malloc and free and a bunch of other stuff as well.
Dialogue: 0,1:25:27.11,1:25:32.54,中文,,0,0,0,,在这个文件中，有 malloc 和 free 以及其他一些东西的声明，也就是它们的原型。
Dialogue: 0,1:25:32.54,1:25:37.56,英文,,0,0,0,,It lets me now manage my own memory. So let's focus now on line 11.
Dialogue: 0,1:25:32.54,1:25:37.56,中文,,0,0,0,,它让我现在可以管理自己的内存了，让我们把注意力集中在第 11 行。
Dialogue: 0,1:25:37.56,1:25:41.79,英文,,0,0,0,,Line 11 is where I went wrong before, because conceptually, I want to copy the whole string.
Dialogue: 0,1:25:37.56,1:25:41.79,中文,,0,0,0,,第 11 行就是我之前出错的地方，因为从概念上讲，我想复制整个字符串。
Dialogue: 0,1:25:41.79,1:25:45.43,英文,,0,0,0,,But of course, I'm only copying, modestly, the individual address.
Dialogue: 0,1:25:41.79,1:25:45.43,中文,,0,0,0,,但实际上，我只复制了单个地址，这有点少。
Dialogue: 0,1:25:45.43,1:25:47.85,英文,,0,0,0,,So how do I copy the whole darn thing?
Dialogue: 0,1:25:45.43,1:25:47.85,中文,,0,0,0,,那么，如何才能复制整个字符串呢？
Dialogue: 0,1:25:47.85,1:25:49.46,英文,,0,0,0,,Well, what I need to do is this.
Dialogue: 0,1:25:47.85,1:25:49.46,中文,,0,0,0,,我需要这样做。
Dialogue: 0,1:25:49.46,1:25:53.54,英文,,0,0,0,,When I declare t to be the address of something in memory,
Dialogue: 0,1:25:49.46,1:25:53.54,中文,,0,0,0,,当我声明 t 是内存中某个东西的地址时，
Dialogue: 0,1:25:53.54,1:25:56.78,英文,,0,0,0,,Why don't I set t to be the address of a free chunk of memory?
Dialogue: 0,1:25:53.54,1:25:56.78,中文,,0,0,0,,为什么不把 t 设置成一块空闲内存的地址呢？
Dialogue: 0,1:25:56.78,1:26:04.92,英文,,0,0,0,,So let me ask the operating system, give me this many bytes, tell me what the address is, and I'm going to store that in t initially, just so I know where there's free space for me.
Dialogue: 0,1:25:56.78,1:26:04.92,中文,,0,0,0,,我得请求操作系统给我分配这么多字节，并告诉我地址是什么，我先把地址存放在 t 中，这样我就知道哪里有空闲空间了。
Dialogue: 0,1:26:04.92,1:26:05.90,英文,,0,0,0,,So how do I do that?
Dialogue: 0,1:26:04.92,1:26:05.90,中文,,0,0,0,,那该怎么做呢？
Dialogue: 0,1:26:05.90,1:26:09.95,英文,,0,0,0,,Well, quite simply, I call malloc, and then I pass in the number of bytes that I need.
Dialogue: 0,1:26:05.90,1:26:09.95,中文,,0,0,0,,很简单，我调用 malloc，然后传入我需要的字节数。
Dialogue: 0,1:26:09.95,1:26:11.19,英文,,0,0,0,,Now, for hi!
Dialogue: 0,1:26:09.95,1:26:11.19,中文,,0,0,0,,现在，对于 HI！
Dialogue: 0,1:26:11.19,1:26:16.89,英文,,0,0,0,,I think I need three, although wait, no, I really need four because of the null character.
Dialogue: 0,1:26:11.19,1:26:16.89,中文,,0,0,0,,我想我需要三个字节，等等，不，实际上我需要四个字节，因为还有空字符。
Dialogue: 0,1:26:16.89,1:26:21.15,英文,,0,0,0,,But I don't think I should be hard-coding numbers like this, because who knows what the human is going to type in.
Dialogue: 0,1:26:16.89,1:26:21.15,中文,,0,0,0,,但我不应该像这样把数字写死，因为谁知道用户会输入什么。
Dialogue: 0,1:26:21.15,1:26:25.85,英文,,0,0,0,,So I can actually use strlen of s and then plus 1.
Dialogue: 0,1:26:21.15,1:26:25.85,中文,,0,0,0,,所以实际上我可以使用 strlen(s) 再加 1。
Dialogue: 0,1:26:25.85,1:26:32.49,英文,,0,0,0,,This will ask malloc, then, for however many bytes corresponds to the number of characters the human typed in plus 1.
Dialogue: 0,1:26:25.85,1:26:32.49,中文,,0,0,0,,这会向 malloc 请求分配对应于用户输入的字符数加 1 的字节数。
Dialogue: 0,1:26:32.49,1:26:33.95,英文,,0,0,0,,for, again, the null character.
Dialogue: 0,1:26:32.49,1:26:33.95,中文,,0,0,0,,同样，加 1 是为了空字符。
Dialogue: 0,1:26:33.95,1:26:37.60,英文,,0,0,0,,So it's just being smart and defensive rather than choosing a number myself.
Dialogue: 0,1:26:33.95,1:26:37.60,中文,,0,0,0,,所以这是在明智地采取防御措施，而不是我自己选择一个数字。
Dialogue: 0,1:26:37.60,1:26:43.60,英文,,0,0,0,,But now all t is is a pointer, if you will, to some random chunk of free space.
Dialogue: 0,1:26:37.60,1:26:43.60,中文,,0,0,0,,但现在 t 只是一个指针，指向某个随机的空闲空间块。
Dialogue: 0,1:26:43.60,1:26:47.34,英文,,0,0,0,,So there's nothing there yet, or there's bits there, but who knows what value they are.
Dialogue: 0,1:26:43.60,1:26:47.34,中文,,0,0,0,,所以那里现在还没有内容，或者说那里有一些位，但谁知道它们的值是多少。
Dialogue: 0,1:26:47.34,1:26:50.10,英文,,0,0,0,,They're certainly not identical to what the human typed in.
Dialogue: 0,1:26:47.34,1:26:50.10,中文,,0,0,0,,它们肯定与用户输入的不一样。
Dialogue: 0,1:26:50.10,1:26:51.65,英文,,0,0,0,,I now have to do this.
Dialogue: 0,1:26:50.10,1:26:51.65,中文,,0,0,0,,我现在必须这样做。
Dialogue: 0,1:26:51.65,1:26:55.19,英文,,0,0,0,,So how can I copy one string into the other?
Dialogue: 0,1:26:51.65,1:26:55.19,中文,,0,0,0,,那么如何将一个字符串复制到另一个字符串呢？
Dialogue: 0,1:26:55.19,1:27:00.53,英文,,0,0,0,,Well, let me do this. Capitalizing something just yet, let me do this.
Dialogue: 0,1:26:55.19,1:27:00.53,中文,,0,0,0,,我先这样做，暂时先不考虑大小写，我先这样做。
Dialogue: 0,1:27:00.53,1:27:09.32,英文,,0,0,0,,How about for int i gets 0, i is less than the length of s, and then i plus plus.
Dialogue: 0,1:27:00.53,1:27:09.32,中文,,0,0,0,,用 `for (int i = 0; i < strlen(s); i++)` 这样的循环怎么样？
Dialogue: 0,1:27:09.32,1:27:11.90,英文,,0,0,0,,So I'm going to iterate for the whole length of the string.
Dialogue: 0,1:27:09.32,1:27:11.90,中文,,0,0,0,,我要遍历整个字符串。
Dialogue: 0,1:27:11.90,1:27:13.77,英文,,0,0,0,,And in here, I'm just going to do this.
Dialogue: 0,1:27:11.90,1:27:13.77,中文,,0,0,0,,在循环里面，我要这样做。
Dialogue: 0,1:27:13.77,1:27:18.79,英文,,0,0,0,,The i-th character in t should be identical to the i-th character in s.
Dialogue: 0,1:27:13.77,1:27:18.79,中文,,0,0,0,,t 中的第 i 个字符应该与 s 中的第 i 个字符相同。
Dialogue: 0,1:27:18.79,1:27:27.84,英文,,0,0,0,,So I'm just literally copying from right to left each and every character in s. And I can trust that there's enough memory in ty, because I asked for that many bytes plus 1.
Dialogue: 0,1:27:18.79,1:27:27.84,中文,,0,0,0,,我只是逐个字符地从右到左复制 s 中的每一个字符。而且我可以确定 ty 中有足够的内存，因为我要求了那么多字节的空间再加上 1。
Dialogue: 0,1:27:27.84,1:27:29.62,英文,,0,0,0,,Now, there's technically a bug here.
Dialogue: 0,1:27:27.84,1:27:29.62,中文,,0,0,0,,这里其实有个 bug。
Dialogue: 0,1:27:29.62,1:27:31.34,英文,,0,0,0,,I actually should probably do this.
Dialogue: 0,1:27:29.62,1:27:31.34,中文,,0,0,0,,实际上我可能应该这样做。
Dialogue: 0,1:27:31.34,1:27:34.76,英文,,0,0,0,,I should do plus 1 here.
Dialogue: 0,1:27:31.34,1:27:34.76,中文,,0,0,0,,我应该在这里加 1。
Dialogue: 0,1:27:34.76,1:27:39.28,英文,,0,0,0,,Or if you prefer, I should do less than or equal to the strlen.
Dialogue: 0,1:27:34.76,1:27:39.28,中文,,0,0,0,,或者，如果你愿意，我应该写小于等于 strlen 的值。
Dialogue: 0,1:27:39.28,1:27:41.64,英文,,0,0,0,,But I think it's a little clearer to do the plus 1.
Dialogue: 0,1:27:39.28,1:27:41.64,中文,,0,0,0,,但我认为加 1 更清楚一些。
Dialogue: 0,1:27:41.64,1:27:49.31,英文,,0,0,0,,Why do I, for the first time, want to go just beyond the boundary of s and copy one more byte?
Dialogue: 0,1:27:41.64,1:27:49.31,中文,,0,0,0,,为什么这次，或许也只有这次，我想越过 s 的边界并多复制一个字节？
Dialogue: 0,1:27:49.31,1:27:50.65,英文,,0,0,0,,Yeah, I need the null character.
Dialogue: 0,1:27:49.31,1:27:50.65,中文,,0,0,0,,是的，我需要空字符。
Dialogue: 0,1:27:50.65,1:27:57.75,英文,,0,0,0,,Like, I could technically manually add it with some additional line of code, but I might as well just copy it because backslash 0 is backslash 0.
Dialogue: 0,1:27:50.65,1:27:57.75,中文,,0,0,0,,也就是说，我技术上可以用另外一行代码手动添加它，但我也可以直接复制它，因为反斜杠 0 就是反斜杠 0。
Dialogue: 0,1:27:57.75,1:28:08.26,英文,,0,0,0,,So this time, and probably only this time, it's reasonable and correct to go just beyond the boundary of your string so you copy the null terminating character so that the computer also knows where t ends.
Dialogue: 0,1:27:57.75,1:28:08.26,中文,,0,0,0,,所以这次，也许只有这次，越过字符串的边界并复制空终止字符是合理且正确的，这样计算机也知道 t 在哪里结束。
Dialogue: 0,1:28:08.26,1:28:12.81,英文,,0,0,0,,And now I think what I can do a little more safely is this.
Dialogue: 0,1:28:08.26,1:28:12.81,中文,,0,0,0,,现在我认为我可以更安全地做的是这个。
Dialogue: 0,1:28:12.81,1:28:21.35,英文,,0,0,0,,Let me go down here and say t bracket 0 equals 2 upper of t bracket 0.
Dialogue: 0,1:28:12.81,1:28:21.35,中文,,0,0,0,,让我往下写，输入 t[0] 等于将 t[0] 转换为大写字母。
Dialogue: 0,1:28:21.35,1:28:22.69,英文,,0,0,0,,So same line of code as before.
Dialogue: 0,1:28:21.35,1:28:22.69,中文,,0,0,0,,和之前同一行代码。
Dialogue: 0,1:28:22.69,1:28:24.95,英文,,0,0,0,,If I actually want to be really safe, I should probably do this.
Dialogue: 0,1:28:22.69,1:28:24.95,中文,,0,0,0,,如果我真的想保证安全，我可能应该这样做。
Dialogue: 0,1:28:24.95,1:28:33.88,英文,,0,0,0,,So if the strlen of t is greater than 0, so there's at least one byte there, OK, now it's safe to blindly capitalize the first character.
Dialogue: 0,1:28:24.95,1:28:33.88,中文,,0,0,0,,如果 t 的 strlen 大于 0，也就是说至少有一个字节，现在可以安全地将第一个字符大写了。
Dialogue: 0,1:28:33.88,1:28:36.36,英文,,0,0,0,,And I think that now puts me in better shape.
Dialogue: 0,1:28:33.88,1:28:36.36,中文,,0,0,0,,我认为现在这样更好一些。
Dialogue: 0,1:28:36.36,1:28:37.28,英文,,0,0,0,,So let me try this now.
Dialogue: 0,1:28:36.36,1:28:37.28,中文,,0,0,0,,现在让我试试这个。
Dialogue: 0,1:28:37.28,1:28:41.90,英文,,0,0,0,,Let me open up my terminal, make a copy.
Dialogue: 0,1:28:37.28,1:28:41.90,中文,,0,0,0,,让我打开终端，复制一份。
Dialogue: 0,1:28:41.90,1:28:48.33,英文,,0,0,0,,Dot slash copy, I'm going to type in hi exclamation point in all lowercase, crossing my fingers this time.
Dialogue: 0,1:28:41.90,1:28:48.33,中文,,0,0,0,,输入 ./copy，我要输入全部小写的 hi 和感叹号，这次祈祷它能成功。
Dialogue: 0,1:28:48.33,1:28:55.74,英文,,0,0,0,,And now if I zoom in, it indeed capitalized only t and not s in this case.
Dialogue: 0,1:28:48.33,1:28:55.74,中文,,0,0,0,,现在如果我放大，可以看到它确实只将 t 大写了，而 s 仍然是小写。
Dialogue: 0,1:28:55.74,1:28:57.76,英文,,0,0,0,,So pictorially, let me switch over here.
Dialogue: 0,1:28:55.74,1:28:57.76,中文,,0,0,0,,形象地说，让我切换到这里。
Dialogue: 0,1:28:57.76,1:29:03.09,英文,,0,0,0,,Here is, as before, dot. The variable s pointing at hi in all lowercase.
Dialogue: 0,1:28:57.76,1:29:03.09,中文,,0,0,0,,就像之前一样，这里有一个点。变量 s 指向全部小写的 hi。
Dialogue: 0,1:29:03.09,1:29:09.59,英文,,0,0,0,,When I call malloc, though, that gives me a chunk of memory that I'm going to store the address in t of.
Dialogue: 0,1:29:03.09,1:29:09.59,中文,,0,0,0,,当我调用 malloc 时，它会给我一块内存，我将把地址存储在 t 中。
Dialogue: 0,1:29:09.59,1:29:21.23,英文,,0,0,0,,So if t is some other variable, as it is in my code, and there's some other available chunk of memory, I don't know where it is, but let's assume, as always, it's at 0x456, 0x457, 0x458, 0x459, so four bytes total.
Dialogue: 0,1:29:09.59,1:29:21.23,中文,,0,0,0,,所以如果 t 是另一个变量，就像在我的代码中一样，\N并且还有另一块可用的内存，我不知道它在哪里，但我们假设，像往常一样，它在 0x456、0x457、0x458、0x459，所以总共四个字节。
Dialogue: 0,1:29:21.23,1:29:22.35,英文,,0,0,0,,What is now happening?
Dialogue: 0,1:29:21.23,1:29:22.35,中文,,0,0,0,,现在发生了什么？
Dialogue: 0,1:29:22.35,1:29:29.52,英文,,0,0,0,,Well, T is defined as pointing to that, because that's what malloc gives us, the address of the first byte of the free memory.
Dialogue: 0,1:29:22.35,1:29:29.52,中文,,0,0,0,,t 被定义为指向它，因为这就是 malloc 给我们的，空闲内存的第一个字节的地址。
Dialogue: 0,1:29:29.52,1:29:39.97,英文,,0,0,0,,And now with my for loop, I'm just iterating over it, copying the H, then the I, then the exclamation point, and then for good measure, the backslash 0 instead.
Dialogue: 0,1:29:29.52,1:29:39.97,中文,,0,0,0,,现在，使用 for 循环，我只是遍历它，复制 H，然后是 I，然后是感叹号，然后为了保险起见，复制反斜杠 0。
Dialogue: 0,1:29:39.97,1:29:44.43,英文,,0,0,0,,Questions then on this process here.
Dialogue: 0,1:29:39.97,1:29:44.43,中文,,0,0,0,,那么对这里的过程有什么问题吗？
Dialogue: 0,1:29:44.43,1:29:46.05,英文,,0,0,0,,A really good question.
Dialogue: 0,1:29:44.43,1:29:46.05,中文,,0,0,0,,这是一个非常好的问题。
Dialogue: 0,1:29:46.05,1:29:59.49,英文,,0,0,0,,If I omitted in my code the plus 1, and I didn't do less than or equal to so that I'm copying the fourth byte, odds are in this program, because it's so short, you wouldn't notice that there's an actual error.
Dialogue: 0,1:29:46.05,1:29:59.49,中文,,0,0,0,,如果我在代码中省略了加 1，并且没有使用小于等于来复制第四个字节，那么在这个程序中，因为它非常短，你可能不会注意到实际上有一个错误。
Dialogue: 0,1:29:59.49,1:30:02.46,英文,,0,0,0,,But what could happen is.
Dialogue: 0,1:29:59.49,1:30:02.46,中文,,0,0,0,,但是可能会发生的是。
Dialogue: 0,1:30:02.46,1:30:18.43,英文,,0,0,0,,When I call printf on t, if there's no null byte there, it might print h, i, exclamation point, some random value, some random value, some random value, some random value, until it gets lucky and there happens to be a 0 byte, a null byte, by chance, for instance.
Dialogue: 0,1:30:02.46,1:30:18.43,中文,,0,0,0,,当我调用 printf(t) 时，如果那里没有空字节，它可能会打印出 h、i、感叹号、\N一些随机值、一些随机值、一些随机值、一些随机值，直到它幸运地碰巧有一个 0 字节，一个空字节，例如。
Dialogue: 0,1:30:18.43,1:30:22.85,英文,,0,0,0,,So if you don't include the backslash 0 some way, that's going to happen.
Dialogue: 0,1:30:18.43,1:30:22.85,中文,,0,0,0,,所以如果你没有以某种方式包含反斜杠 0，就会发生这种情况。
Dialogue: 0,1:30:22.85,1:30:24.01,英文,,0,0,0,,And I say some way.
Dialogue: 0,1:30:22.85,1:30:24.01,中文,,0,0,0,,我说是某种方式。
Dialogue: 0,1:30:24.01,1:30:25.01,英文,,0,0,0,,I could even do this.
Dialogue: 0,1:30:24.01,1:30:25.01,中文,,0,0,0,,我甚至可以这样做。
Dialogue: 0,1:30:25.01,1:30:31.41,英文,,0,0,0,,I could technically just copy the length of the string s. And at the very bottom here, I could do something like t,
Dialogue: 0,1:30:25.01,1:30:31.41,中文,,0,0,0,,从技术上讲，我可以只复制string s 的长度。然后在最下面，我可以做类似 t 的事情，
Dialogue: 0,1:30:31.41,1:30:40.84,英文,,0,0,0,,Bracket i, sorry, t bracket, sterling of t. I could do this, but this is just not necessary.
Dialogue: 0,1:30:31.41,1:30:40.84,中文,,0,0,0,,中括号 i，抱歉，t 中括号，sterling of t，我可以这样做，但这根本没有必要。
Dialogue: 0,1:30:40.84,1:30:43.60,英文,,0,0,0,,Like, I could manually add it at the end of the string.
Dialogue: 0,1:30:40.84,1:30:43.60,中文,,0,0,0,,就像，我可以手动将它添加到字符串的末尾。
Dialogue: 0,1:30:43.60,1:30:50.50,英文,,0,0,0,,But again, I'd claim that it's just simpler to borrow, that is, copy the one that's already in s, because it's the same thing at the end of the day.
Dialogue: 0,1:30:43.60,1:30:50.50,中文,,0,0,0,,但我还是要说，借用，也就是复制 s 中已有的那个更简单，因为最终结果是一样的。
Dialogue: 0,1:30:50.50,1:30:51.04,英文,,0,0,0,,Good question.
Dialogue: 0,1:30:50.50,1:30:51.04,中文,,0,0,0,,问得好。
Dialogue: 0,1:30:51.04,1:30:57.23,英文,,0,0,0,,Other questions on this copying correctly now?
Dialogue: 0,1:30:51.04,1:30:57.23,中文,,0,0,0,,关于这个复制功能，还有其他问题吗？
Dialogue: 0,1:30:57.23,1:31:00.09,英文,,0,0,0,,All right, is there any room for improvements here?
Dialogue: 0,1:30:57.23,1:31:00.09,中文,,0,0,0,,好了，这里还有改进的空间吗？
Dialogue: 0,1:31:00.09,1:31:02.29,英文,,0,0,0,,Well, let me propose a slight optimization.
Dialogue: 0,1:31:00.09,1:31:02.29,中文,,0,0,0,,我来提出一个小的优化。
Dialogue: 0,1:31:02.29,1:31:04.93,英文,,0,0,0,,This is kind of a throwback now to week one.
Dialogue: 0,1:31:02.29,1:31:04.93,中文,,0,0,0,,这可以追溯到第一周的内容。
Dialogue: 0,1:31:04.93,1:31:15.28,英文,,0,0,0,,Turns out that arguably my line 13 here, wherein I have this for loop, now that I'm doing things in loops again and again and using a function like strlen, this is correct.
Dialogue: 0,1:31:04.93,1:31:15.28,中文,,0,0,0,,事实证明，可以说我的第 13 行代码，也就是这个 for 循环，现在我反复地在循环中使用 strlen 函数，这样做是正确的。
Dialogue: 0,1:31:15.28,1:31:21.73,英文,,0,0,0,,It will iterate from 0 on up to the length of s plus 1.
Dialogue: 0,1:31:15.28,1:31:21.73,中文,,0,0,0,,它将从 0 迭代到 s 的长度加 1。
Dialogue: 0,1:31:21.73,1:31:24.69,英文,,0,0,0,,But it's kind of stupid of me.
Dialogue: 0,1:31:21.73,1:31:24.69,中文,,0,0,0,,但我这样做有点蠢。
Dialogue: 0,1:31:24.69,1:31:26.91,英文,,0,0,0,,to write this for loop in this way.
Dialogue: 0,1:31:24.69,1:31:26.91,中文,,0,0,0,,用这种方式写 for 循环。
Dialogue: 0,1:31:26.91,1:31:27.37,英文,,0,0,0,,Why?
Dialogue: 0,1:31:26.91,1:31:27.37,中文,,0,0,0,,为什么？
Dialogue: 0,1:31:27.37,1:31:29.25,英文,,0,0,0,,Well, here's my initialization on the left.
Dialogue: 0,1:31:27.37,1:31:29.25,中文,,0,0,0,,左边是我的初始化。
Dialogue: 0,1:31:29.25,1:31:31.08,英文,,0,0,0,,Here's my condition in the middle.
Dialogue: 0,1:31:29.25,1:31:31.08,中文,,0,0,0,,中间是我的条件。
Dialogue: 0,1:31:31.08,1:31:38.18,英文,,0,0,0,,And in general, calling a function inside of your condition is probably not very good design.
Dialogue: 0,1:31:31.08,1:31:38.18,中文,,0,0,0,,一般来说，在条件语句中调用函数可能不是一个好的设计。
Dialogue: 0,1:31:38.18,1:31:39.05,英文,,0,0,0,,Like, why?
Dialogue: 0,1:31:38.18,1:31:39.05,中文,,0,0,0,,为什么？
Dialogue: 0,1:31:39.05,1:31:44.69,英文,,0,0,0,,Why is it bad for me to be calling a function like Sterling in this condition, in the middle of my for loop?
Dialogue: 0,1:31:39.05,1:31:44.69,中文,,0,0,0,,为什么在 for 循环的条件语句中调用 strlen 函数不好？
Dialogue: 0,1:31:44.69,1:31:49.31,英文,,0,0,0,,Yeah?
Dialogue: 0,1:31:44.69,1:31:49.31,中文,,0,0,0,,对吧？
Dialogue: 0,1:31:49.31,1:31:51.61,英文,,0,0,0,,Yeah, you're just calling it again and again for no reason.
Dialogue: 0,1:31:49.31,1:31:51.61,中文,,0,0,0,,是的，你只是在毫无理由地一遍又一遍地调用它。
Dialogue: 0,1:31:51.61,1:31:52.93,英文,,0,0,0,,The length of s never changes.
Dialogue: 0,1:31:51.61,1:31:52.93,中文,,0,0,0,,s 的长度不会改变。
Dialogue: 0,1:31:52.93,1:32:01.40,英文,,0,0,0,,So why are you wasting everyone's time by calling strlen of s again, again, again, again, just to check this inequality, whether i is less than that value?
Dialogue: 0,1:31:52.93,1:32:01.40,中文,,0,0,0,,那你为什么要一遍又一遍地调用 strlen(s) 来浪费大家的时间，仅仅是为了检查这个不等式，看 i 是否小于那个值？
Dialogue: 0,1:32:01.40,1:32:09.95,英文,,0,0,0,,So it turns out, if you haven't discovered this already, there's a slight optimization we can do here that has nothing to do fundamentally with strings or pointers, just with better design.
Dialogue: 0,1:32:01.40,1:32:09.95,中文,,0,0,0,,如果你还没有发现的话，我们可以在这里做一个小的优化，这与字符串或指针无关，只与更好的设计有关。
Dialogue: 0,1:32:09.95,1:32:12.35,英文,,0,0,0,,I can actually define two variables at once.
Dialogue: 0,1:32:09.95,1:32:12.35,中文,,0,0,0,,我可以一次性定义两个变量。
Dialogue: 0,1:32:12.35,1:32:13.39,英文,,0,0,0,,I could do this.
Dialogue: 0,1:32:12.35,1:32:13.39,中文,,0,0,0,,我可以这样做。
Dialogue: 0,1:32:13.39,1:32:15.49,英文,,0,0,0,,Let me remove this whole condition.
Dialogue: 0,1:32:13.39,1:32:15.49,中文,,0,0,0,,让我删除整个条件。
Dialogue: 0,1:32:15.49,1:32:18.58,英文,,0,0,0,,And let me add a comma after i equals 0.
Dialogue: 0,1:32:15.49,1:32:18.58,中文,,0,0,0,,让我在 i = 0 后面加个逗号。
Dialogue: 0,1:32:18.58,1:32:24.81,英文,,0,0,0,,Set n, or any variable, equal to the strlen of s plus 1.
Dialogue: 0,1:32:18.58,1:32:24.81,中文,,0,0,0,,设置 n，或任何变量，使其等于 s 的 strlen 加 1。
Dialogue: 0,1:32:24.81,1:32:31.63,英文,,0,0,0,,And then, after the semicolon, just ask the question, while i is less than n. So it's almost the same.
Dialogue: 0,1:32:24.81,1:32:31.63,中文,,0,0,0,,然后，在分号之后，只需问这个问题：当 i < n 时。所以它几乎是一样的。
Dialogue: 0,1:32:31.63,1:32:37.96,英文,,0,0,0,,But notice now my condition in the very middle of this loop is at least comparing two static values.
Dialogue: 0,1:32:31.63,1:32:37.96,中文,,0,0,0,,但现在请注意，在这个循环的最中间，我的条件至少在比较两个静态值。
Dialogue: 0,1:32:37.96,1:32:38.90,英文,,0,0,0,,n never changes.
Dialogue: 0,1:32:37.96,1:32:38.90,中文,,0,0,0,,n 永远不会改变。
Dialogue: 0,1:32:38.90,1:32:40.32,英文,,0,0,0,,Sorry, one static value.
Dialogue: 0,1:32:38.90,1:32:40.32,中文,,0,0,0,,抱歉，是一个静态值。
Dialogue: 0,1:32:40.32,1:32:45.84,英文,,0,0,0,,n never changes. All that changes is i. But I'm not foolishly calling strleng, strleng, strleng again and again.
Dialogue: 0,1:32:40.32,1:32:45.84,中文,,0,0,0,,n 永远不会改变。所有改变的只是 i。但我不会愚蠢地一次又一次地调用 strleng、strleng、strleng。
Dialogue: 0,1:32:45.84,1:32:47.76,英文,,0,0,0,,Why? Well, how does strleng work?
Dialogue: 0,1:32:45.84,1:32:47.76,中文,,0,0,0,,为什么？那么，strleng 是如何工作的呢？
Dialogue: 0,1:32:47.76,1:32:57.59,英文,,0,0,0,,Similar in spirit to printf, strleng, given the name of a string, looks at the first character and then starts looking through the entire string, looking for the null character.
Dialogue: 0,1:32:47.76,1:32:57.59,中文,,0,0,0,,与 printf 的精神相似，strleng 给定一个字符串的名称，查看第一个字符，然后开始查看整个字符串，寻找空字符。
Dialogue: 0,1:32:57.59,1:33:01.35,英文,,0,0,0,,And we saw this in week 2, counting up how many characters are there.
Dialogue: 0,1:32:57.59,1:33:01.35,中文,,0,0,0,,我们在第 2 周看到了这一点，计算有多少个字符。
Dialogue: 0,1:33:01.35,1:33:03.02,英文,,0,0,0,,It's just a waste of time again and again.
Dialogue: 0,1:33:01.35,1:33:03.02,中文,,0,0,0,,一次又一次地这样做只是浪费时间。
Dialogue: 0,1:33:09.91,1:33:17.83,英文,,0,0,0,,Totally. If you wanted to use n multiple times, you could absolutely take it out of the for loop, put it right after s is defined, and reuse n and again and again.
Dialogue: 0,1:33:09.91,1:33:17.83,中文,,0,0,0,,完全正确。如果你想多次使用 n，你完全可以把它从 for 循环中拿出来，放在 s 定义之后，然后一次又一次地重复使用 n。
Dialogue: 0,1:33:17.83,1:33:18.55,英文,,0,0,0,,Absolutely.
Dialogue: 0,1:33:17.83,1:33:18.55,中文,,0,0,0,,没错。
Dialogue: 0,1:33:18.55,1:33:20.13,英文,,0,0,0,,But in general, consider this.
Dialogue: 0,1:33:18.55,1:33:20.13,中文,,0,0,0,,但总的来说，请考虑这一点。
Dialogue: 0,1:33:20.13,1:33:33.22,英文,,0,0,0,,When designing your for loops, even though modern compilers like Clang can actually fix this problem, this inefficiency for you, good practice would be don't call functions unnecessarily, especially if the answer is always going to be the same.
Dialogue: 0,1:33:20.13,1:33:33.22,中文,,0,0,0,,在设计 for 循环时，即使像 Clang 这样的现代编译器实际上可以为你解决这个问题，\N解决这种低效率问题，但好的做法是不要不必要地调用函数，尤其是在答案总是相同的情况下。
Dialogue: 0,1:33:33.22,1:33:37.14,英文,,0,0,0,,All right, so what else should I perhaps refine here?
Dialogue: 0,1:33:33.22,1:33:37.14,中文,,0,0,0,,好了，那么我还应该在这里改进些什么呢？
Dialogue: 0,1:33:37.14,1:33:42.78,英文,,0,0,0,,Well, how about I do one last thing and just comment on what exactly could go wrong here?
Dialogue: 0,1:33:37.14,1:33:42.78,中文,,0,0,0,,好吧，我再做最后一件事，就是评论一下这里到底可能出什么问题？
Dialogue: 0,1:33:42.78,1:33:44.32,英文,,0,0,0,,Well, a couple of things.
Dialogue: 0,1:33:42.78,1:33:44.32,中文,,0,0,0,,嗯，有几件事。
Dialogue: 0,1:33:44.32,1:33:46.53,英文,,0,0,0,,Well, actually, this is just silly, too.
Dialogue: 0,1:33:44.32,1:33:46.53,中文,,0,0,0,,实际上，这也太傻了。
Dialogue: 0,1:33:46.53,1:33:50.43,英文,,0,0,0,,Surely, someone before me in the world has had to copy a string before.
Dialogue: 0,1:33:46.53,1:33:50.43,中文,,0,0,0,,当然，在我之前世界上肯定有人复制过字符串。
Dialogue: 0,1:33:50.43,1:33:54.99,英文,,0,0,0,,Surely, there's a function called strcpy, maybe, like strcompare, like strling.
Dialogue: 0,1:33:50.43,1:33:54.99,中文,,0,0,0,,肯定有一个函数叫 strcpy，可能像 strcompare，像 strlen。
Dialogue: 0,1:33:54.99,1:33:55.93,英文,,0,0,0,,And indeed, there is.
Dialogue: 0,1:33:54.99,1:33:55.93,中文,,0,0,0,,确实有。
Dialogue: 0,1:33:55.93,1:33:59.08,英文,,0,0,0,,So let me propose that we actually get rid of this whole for loop
Dialogue: 0,1:33:55.93,1:33:59.08,中文,,0,0,0,,所以我建议我们把整个 for 循环去掉。
Dialogue: 0,1:33:59.08,1:34:10.45,英文,,0,0,0,,And we actually just call a function called strcpy, no O, just S-T-R-C-P-Y, and pass in the destination, which is T first, and then the source that you want to copy into the destination.
Dialogue: 0,1:33:59.08,1:34:10.45,中文,,0,0,0,,我们实际上只是调用一个叫做 strcpy 的函数，没有 O，只有 S-T-R-C-P-Y，并传入目的地，也就是先传入 T，然后是你想复制到目的地的源。
Dialogue: 0,1:34:10.45,1:34:13.91,英文,,0,0,0,,And that takes the place entirely of that whole loop.
Dialogue: 0,1:34:10.45,1:34:13.91,中文,,0,0,0,,这完全替代了整个循环。
Dialogue: 0,1:34:13.91,1:34:17.27,英文,,0,0,0,,So again, I demonstrated the loop first just to be very pedantic about it.
Dialogue: 0,1:34:13.91,1:34:17.27,中文,,0,0,0,,我再次演示了循环，只是为了对此非常迂腐。
Dialogue: 0,1:34:17.27,1:34:18.20,英文,,0,0,0,,But that's wasting time.
Dialogue: 0,1:34:17.27,1:34:18.20,中文,,0,0,0,,但这浪费时间。
Dialogue: 0,1:34:18.20,1:34:20.44,英文,,0,0,0,,You're wasting time writing lines of code you don't need to.
Dialogue: 0,1:34:18.20,1:34:20.44,中文,,0,0,0,,你在浪费时间写不需要写的代码。
Dialogue: 0,1:34:20.44,1:34:23.98,英文,,0,0,0,,Strcpy is what you can use here instead.
Dialogue: 0,1:34:20.44,1:34:23.98,中文,,0,0,0,,你可以在这里使用 strcpy。
Dialogue: 0,1:34:23.98,1:34:25.68,英文,,0,0,0,,And so this has now always existed.
Dialogue: 0,1:34:23.98,1:34:25.68,中文,,0,0,0,,所以它现在一直存在。
Dialogue: 0,1:34:25.68,1:34:26.98,英文,,0,0,0,,And what more can I do?
Dialogue: 0,1:34:25.68,1:34:26.98,中文,,0,0,0,,我还能做什么？
Dialogue: 0,1:34:26.98,1:34:34.81,英文,,0,0,0,,Well, as one final point, it turns out that there's actually things that can go wrong in this code, even besides the string being too short.
Dialogue: 0,1:34:26.98,1:34:34.81,中文,,0,0,0,,最后一点，事实证明，即使字符串长度足够，这段代码中也可能出现问题。
Dialogue: 0,1:34:34.81,1:34:40.10,英文,,0,0,0,,Like, if the human just hits Enter and there are no characters, I don't want to blindly capitalize the first character that doesn't exist.
Dialogue: 0,1:34:34.81,1:34:40.10,中文,,0,0,0,,比如，如果用户直接按下回车键，没有任何字符，我不想盲目地将不存在的第一个字符大写。
Dialogue: 0,1:34:40.10,1:34:42.16,英文,,0,0,0,,That's why I added that if condition.
Dialogue: 0,1:34:40.10,1:34:42.16,中文,,0,0,0,,这就是我添加 if 条件的原因。
Dialogue: 0,1:34:42.16,1:34:43.86,英文,,0,0,0,,But there's other things that can go wrong.
Dialogue: 0,1:34:42.16,1:34:43.86,中文,,0,0,0,,但还有其他可能出错的地方。
Dialogue: 0,1:34:43.86,1:34:45.54,英文,,0,0,0,,And we introduced those to you today.
Dialogue: 0,1:34:43.86,1:34:45.54,中文,,0,0,0,,我们今天向大家介绍了这些。
Dialogue: 0,1:34:45.54,1:34:54.39,英文,,0,0,0,,It turns out. that functions like getString and functions like malloc return potentially a special value.
Dialogue: 0,1:34:45.54,1:34:54.39,中文,,0,0,0,,事实证明， 像 get_string 和 malloc 这样的函数有可能返回一个特殊的值。
Dialogue: 0,1:34:54.39,1:34:58.75,英文,,0,0,0,,And wonderfully confusingly, it's also called null, but with two L's, all right?
Dialogue: 0,1:34:54.39,1:34:58.75,中文,,0,0,0,,令人困惑的是，它也叫做 null，但有两个 L。
Dialogue: 0,1:34:58.75,1:35:02.12,英文,,0,0,0,,So left-hand and right-hand weren't talking so well, like, decades ago.
Dialogue: 0,1:34:58.75,1:35:02.12,中文,,0,0,0,,就像几十年前，左手和右手沟通不良一样。
Dialogue: 0,1:35:02.12,1:35:04.48,英文,,0,0,0,,NUL is a backslash 0.
Dialogue: 0,1:35:02.12,1:35:04.48,中文,,0,0,0,,NUL 是反斜杠 0。
Dialogue: 0,1:35:04.48,1:35:06.30,英文,,0,0,0,,It's a single character.
Dialogue: 0,1:35:04.48,1:35:06.30,中文,,0,0,0,,它是一个字符。
Dialogue: 0,1:35:06.30,1:35:09.22,英文,,0,0,0,,as it always has been for a couple of weeks now.
Dialogue: 0,1:35:06.30,1:35:09.22,中文,,0,0,0,,就像过去几周一样。
Dialogue: 0,1:35:09.22,1:35:12.06,英文,,0,0,0,,N-U-L-L is technically a pointer.
Dialogue: 0,1:35:09.22,1:35:12.06,中文,,0,0,0,,N-U-L-L 从技术上讲是一个指针。
Dialogue: 0,1:35:12.06,1:35:14.66,英文,,0,0,0,,It's an address, but it's address 0.
Dialogue: 0,1:35:12.06,1:35:14.66,中文,,0,0,0,,它是一个地址，地址为 0。
Dialogue: 0,1:35:14.66,1:35:21.53,英文,,0,0,0,,It's like the top left-hand corner, if you will, of your computer's memory that just nothing is ever supposed to go in by convention.
Dialogue: 0,1:35:14.66,1:35:21.53,中文,,0,0,0,,如果你愿意，可以把它想象成计算机内存的左上角，按照惯例，那里不应该存储任何东西。
Dialogue: 0,1:35:21.53,1:35:26.27,英文,,0,0,0,,So null is a synonym for 0, but it's specifically an address.
Dialogue: 0,1:35:21.53,1:35:26.27,中文,,0,0,0,,所以 null 是 0 的同义词，但它特指一个地址。
Dialogue: 0,1:35:26.27,1:35:27.51,英文,,0,0,0,,Now, why is this useful?
Dialogue: 0,1:35:26.27,1:35:27.51,中文,,0,0,0,,那么，它有什么用呢？
Dialogue: 0,1:35:27.51,1:35:30.93,英文,,0,0,0,,Well, suppose that in my code here, something goes wrong with getString.
Dialogue: 0,1:35:27.51,1:35:30.93,中文,,0,0,0,,假设我的代码中，get_string 出现了问题。
Dialogue: 0,1:35:30.93,1:35:33.73,英文,,0,0,0,,Suppose you're being a little crazy and you type in way too long of a string.
Dialogue: 0,1:35:30.93,1:35:33.73,中文,,0,0,0,,假设你有点疯狂，输入了一个很长的字符串。
Dialogue: 0,1:35:33.73,1:35:34.77,英文,,0,0,0,,It's not just high.
Dialogue: 0,1:35:33.73,1:35:34.77,中文,,0,0,0,,它不仅很高。
Dialogue: 0,1:35:34.77,1:35:36.49,英文,,0,0,0,,But it's like an entire essay of text.
Dialogue: 0,1:35:34.77,1:35:36.49,中文,,0,0,0,,它就像一篇完整的文章。
Dialogue: 0,1:35:36.49,1:35:38.27,英文,,0,0,0,,And there's not enough memory in the computer.
Dialogue: 0,1:35:36.49,1:35:38.27,中文,,0,0,0,,并且计算机内存不足。
Dialogue: 0,1:35:38.27,1:35:42.74,英文,,0,0,0,,How does getString signal to the programmer, whoa, that's way too big of a string.
Dialogue: 0,1:35:38.27,1:35:42.74,中文,,0,0,0,,get_string 如何向程序员发出信号，表示字符串太大了，放不下。
Dialogue: 0,1:35:42.74,1:35:45.80,英文,,0,0,0,,I can't fit it in memory. Well, we never told you this.
Dialogue: 0,1:35:42.74,1:35:45.80,中文,,0,0,0,,我无法把它放入内存。我们从未告诉过你。
Dialogue: 0,1:35:45.80,1:35:53.64,英文,,0,0,0,,But all of this time, it turns out that getString will return this special value called null if something goes wrong.
Dialogue: 0,1:35:45.80,1:35:53.64,中文,,0,0,0,,但一直以来，如果出现问题，get_string 会返回这个名为 null 的特殊值。
Dialogue: 0,1:35:53.64,1:35:57.08,英文,,0,0,0,,So to be really careful now, you should do something like this.
Dialogue: 0,1:35:53.64,1:35:57.08,中文,,0,0,0,,所以为了谨慎起见，你应该这样做。
Dialogue: 0,1:35:57.08,1:36:06.41,英文,,0,0,0,,If s equals equals literally null, then you better exit the program entirely and return like 1 or 2 or 3 to signify that something went wrong.
Dialogue: 0,1:35:57.08,1:36:06.41,中文,,0,0,0,,如果 s 等于空值，那么你最好完全退出程序，并返回像 1、2 或 3 这样的值，表示出现了错误。
Dialogue: 0,1:36:06.41,1:36:08.61,英文,,0,0,0,,Don't go any further.
Dialogue: 0,1:36:06.41,1:36:08.61,中文,,0,0,0,,不要再继续了。
Dialogue: 0,1:36:08.61,1:36:15.94,英文,,0,0,0,,Similarly with malloc, it's possible if you ask for way too much memory, that could fail, especially if you're asking now for double the memory after the human types something in.
Dialogue: 0,1:36:08.61,1:36:15.94,中文,,0,0,0,,类似地，对于 malloc，如果你请求过多的内存，它可能会失败，特别是如果在用户输入内容后，你要求的内存是原来的两倍。
Dialogue: 0,1:36:15.94,1:36:18.78,英文,,0,0,0,,So if t equals equals null, then you know what?
Dialogue: 0,1:36:15.94,1:36:18.78,中文,,0,0,0,,所以如果 t 等于空值，你知道吗？
Dialogue: 0,1:36:18.78,1:36:25.28,英文,,0,0,0,,Let's also return 1 or some other value to just get out before something crashes or freezes on the human as well.
Dialogue: 0,1:36:18.78,1:36:25.28,中文,,0,0,0,,我们也返回 1 或其他值，以便在程序崩溃或卡住之前退出。
Dialogue: 0,1:36:25.28,1:36:29.68,英文,,0,0,0,,So honestly, I tend not to do this always in class because the code just gets so bloated and complicated.
Dialogue: 0,1:36:25.28,1:36:29.68,中文,,0,0,0,,老实说，我倾向于不在课堂上总是这样做，因为代码会变得非常臃肿和复杂。
Dialogue: 0,1:36:29.68,1:36:32.73,英文,,0,0,0,,But you absolutely, in practice, need to start doing this.
Dialogue: 0,1:36:29.68,1:36:32.73,中文,,0,0,0,,但在实践中，你绝对需要开始这样做。
Dialogue: 0,1:36:32.73,1:36:40.53,英文,,0,0,0,,Otherwise, you will be responsible for the freezes and the crashes and the reboots that users in the real world might actually encounter otherwise.
Dialogue: 0,1:36:32.73,1:36:40.53,中文,,0,0,0,,否则，你将要为现实世界中用户可能遇到的程序冻结、崩溃和重启负责。
Dialogue: 0,1:36:40.53,1:36:50.33,英文,,0,0,0,,Of course, if we get to the bottom of this program now, I should probably return 0 explicitly or implicitly to just signify that everything is successful.
Dialogue: 0,1:36:40.53,1:36:50.33,中文,,0,0,0,,当然，如果我们现在进入程序的底部，我应该显式或隐式地返回 0，以表示一切运行正常。
Dialogue: 0,1:36:50.33,1:36:52.84,英文,,0,0,0,,But there's one other thing I haven't done.
Dialogue: 0,1:36:50.33,1:36:52.84,中文,,0,0,0,,但我还有一件事没做。
Dialogue: 0,1:36:52.84,1:36:56.51,英文,,0,0,0,,We introduced malloc, but what did I claim also existed?
Dialogue: 0,1:36:52.84,1:36:56.51,中文,,0,0,0,,我们介绍了 malloc，但我还说了什么也存在？
Dialogue: 0,1:36:56.51,1:36:57.31,英文,,0,0,0,,So free.
Dialogue: 0,1:36:56.51,1:36:57.31,中文,,0,0,0,,是 free。
Dialogue: 0,1:36:57.31,1:36:58.77,英文,,0,0,0,,I'm also being a little reckless now.
Dialogue: 0,1:36:57.31,1:36:58.77,中文,,0,0,0,,我现在也有点鲁莽了。
Dialogue: 0,1:36:58.77,1:37:00.85,英文,,0,0,0,,Here I am, not practicing what I'm preaching.
Dialogue: 0,1:36:58.77,1:37:00.85,中文,,0,0,0,,我没有践行我所宣扬的。
Dialogue: 0,1:37:00.85,1:37:03.43,英文,,0,0,0,,I'm asking the computer for memory via get string.
Dialogue: 0,1:37:00.85,1:37:03.43,中文,,0,0,0,,我正在通过 get_string 向计算机请求内存。
Dialogue: 0,1:37:03.43,1:37:08.32,英文,,0,0,0,,I'm asking the computer for more memory via malloc, and I'm never technically handing it back.
Dialogue: 0,1:37:03.43,1:37:08.32,中文,,0,0,0,,我正在通过 malloc 向计算机请求更多内存，并且从技术上讲，我从未将它归还。
Dialogue: 0,1:37:08.32,1:37:16.29,英文,,0,0,0,,So really, what I should be doing at the very bottom of my program 2 is Freeing the memory I've asked for.
Dialogue: 0,1:37:08.32,1:37:16.29,中文,,0,0,0,,所以实际上，我应该在我的程序 2 的最底部做的是释放我请求的内存。
Dialogue: 0,1:37:16.29,1:37:27.89,英文,,0,0,0,,So henceforth, it is a rule, a law, if you will, in C, whenever you allocate memory with malloc, or certain other functions as well, you, the programmer, must free it when you're all done with it.
Dialogue: 0,1:37:16.29,1:37:27.89,中文,,0,0,0,,因此，从今以后，在 C 语言中，只要你使用 malloc 或其他某些函数分配内存，\N程序员就必须在使用完毕后释放它，这是一条规则，一条法则，如果你愿意这样称呼它的话。
Dialogue: 0,1:37:27.89,1:37:32.82,英文,,0,0,0,,Now, this is a bit of an overstatement, because technically, when programs quit, they'll free the memory automatically.
Dialogue: 0,1:37:27.89,1:37:32.82,中文,,0,0,0,,现在，这有点言过其实，因为从技术上讲，当程序退出时，它们会自动释放内存。
Dialogue: 0,1:37:32.82,1:37:36.12,英文,,0,0,0,,So you're not going to break someone's Mac or PC because you necessarily have this bug.
Dialogue: 0,1:37:32.82,1:37:36.12,中文,,0,0,0,,所以你不会因为这个错误而弄坏别人的 Mac 或 PC。
Dialogue: 0,1:37:36.12,1:37:41.38,英文,,0,0,0,,But for programs that are running all the time, like someone keeps Chrome, their browser open, Microsoft Word, or the like,
Dialogue: 0,1:37:36.12,1:37:41.38,中文,,0,0,0,,但对于那些一直运行的程序，比如一直开着 Chrome 浏览器、Microsoft Word 或类似程序，
Dialogue: 0,1:37:41.38,1:37:46.38,英文,,0,0,0,,Bad things will happen if over time you never, never, never call free and the program keeps running.
Dialogue: 0,1:37:41.38,1:37:46.38,中文,,0,0,0,,如果随着时间的推移，你从来没有调用过 free 函数，而且程序一直在运行，就会出现问题。
Dialogue: 0,1:37:46.38,1:37:48.38,英文,,0,0,0,,So always get into this habit here.
Dialogue: 0,1:37:46.38,1:37:48.38,中文,,0,0,0,,所以一定要养成这个习惯。
Dialogue: 0,1:37:48.38,1:37:54.59,英文,,0,0,0,,You do not need to free memory that comes from get string, because the CS50 library automatically frees it for you.
Dialogue: 0,1:37:48.38,1:37:54.59,中文,,0,0,0,,你不需要释放 get_string 函数返回的内存，因为 cs50 库会自动为你释放。
Dialogue: 0,1:37:54.59,1:38:04.23,英文,,0,0,0,,But you, any time you use malloc, henceforth, as you did or I did here, you must free that by just passing in the same address you got back.
Dialogue: 0,1:37:54.59,1:38:04.23,中文,,0,0,0,,但是从现在开始，任何时候你使用 malloc 函数，就像你或我在这里做的那样，你都必须通过传入你得到的相同地址来释放它。
Dialogue: 0,1:38:04.23,1:38:09.82,英文,,0,0,0,,Questions now on malloc and free.
Dialogue: 0,1:38:04.23,1:38:09.82,中文,,0,0,0,,现在关于 malloc 和 free 有什么问题吗？
Dialogue: 0,1:38:09.82,1:38:11.15,英文,,0,0,0,,Questions?
Dialogue: 0,1:38:09.82,1:38:11.15,中文,,0,0,0,,有问题吗？
Dialogue: 0,1:38:11.15,1:38:18.32,英文,,0,0,0,,Yeah?
Dialogue: 0,1:38:11.15,1:38:18.32,中文,,0,0,0,,有。
Dialogue: 0,1:38:18.32,1:38:19.30,英文,,0,0,0,,A really good question.
Dialogue: 0,1:38:18.32,1:38:19.30,中文,,0,0,0,,问得很好。
Dialogue: 0,1:38:19.30,1:38:22.26,英文,,0,0,0,,So free just, so what does free do?
Dialogue: 0,1:38:19.30,1:38:22.26,中文,,0,0,0,,free 到底做了什么？
Dialogue: 0,1:38:22.26,1:38:34.00,英文,,0,0,0,,So free just lets the computer know that you are done with that chunk of memory, which means that if you have another line of code elsewhere, that same memory might be reused and can be used again and again.
Dialogue: 0,1:38:22.26,1:38:34.00,中文,,0,0,0,,free 函数只是让计算机知道你已经用完了那块内存，\N这意味着如果你在其他地方有另一行代码，那么同一块内存可能会被重用，并且可以一次又一次地使用。
Dialogue: 0,1:38:34.00,1:38:36.16,英文,,0,0,0,,And that's going to be necessary certainly for any long-running program.
Dialogue: 0,1:38:34.00,1:38:36.16,中文,,0,0,0,,对于任何长时间运行的程序来说，这都是必要的。
Dialogue: 0,1:38:36.16,1:38:37.94,英文,,0,0,0,,You can't ask for memory constantly.
Dialogue: 0,1:38:36.16,1:38:37.94,中文,,0,0,0,,你不能一直请求内存。
Dialogue: 0,1:38:37.94,1:38:42.12,英文,,0,0,0,,You'll eventually run out. So you need to free it in this way. Other languages, as an aside, Python.
Dialogue: 0,1:38:37.94,1:38:42.12,中文,,0,0,0,,你最终会耗尽内存。所以你需要以这种方式释放它。顺便说一下，其他语言，比如 Python。
Dialogue: 0,1:38:42.12,1:38:47.91,英文,,0,0,0,,Yet another motivation in a couple of weeks for it is going to be Python and certain other languages manage all this headache for you.
Dialogue: 0,1:38:42.12,1:38:47.91,中文,,0,0,0,,几周后，我们将学习 Python，它和某些其他语言会为你解决所有这些麻烦。
Dialogue: 0,1:38:47.91,1:38:52.84,英文,,0,0,0,,But in C, the goal here is to really harness these capabilities ourselves.
Dialogue: 0,1:38:47.91,1:38:52.84,中文,,0,0,0,,但在 C 语言中，我们的目标是自己掌握这些能力。
Dialogue: 0,1:38:52.84,1:39:00.15,英文,,0,0,0,,All right, so it turns out almost everyone in the room, everyone in the room, myself included, you're going to screw up when it comes to anything memory-related if you haven't already.
Dialogue: 0,1:38:52.84,1:39:00.15,中文,,0,0,0,,好了，事实证明，房间里几乎所有人，包括我自己在内，如果你还没有遇到过与内存相关的问题，那么你迟早会搞砸的。
Dialogue: 0,1:39:00.15,1:39:09.75,英文,,0,0,0,,Segfaults are in your future. But hopefully, there's tools via which you can detect these things and fix them proactively and not just use printf or debug50 or rubberduck.
Dialogue: 0,1:39:00.15,1:39:09.75,中文,,0,0,0,,段错误在你的未来等着你。但希望通过一些工具，你可以提前发现并修复这些问题，而不仅仅是使用 printf、debug50 或 小黄鸭调试法。
Dialogue: 0,1:39:09.75,1:39:14.15,英文,,0,0,0,,We actually have another tool we can equip you with now that'll help you find some mistakes.
Dialogue: 0,1:39:09.75,1:39:14.15,中文,,0,0,0,,我们实际上还有另一个工具可以帮助你找到一些错误。
Dialogue: 0,1:39:14.15,1:39:24.20,英文,,0,0,0,,So let me do this. Let me close copy.c. Let me open a program I wrote in advance called memory.c that doesn't do anything really interesting, but it's going to have two bugs in it.
Dialogue: 0,1:39:14.15,1:39:24.20,中文,,0,0,0,,我来演示一下。我先关闭 copy.c。我打开一个预先写好的程序 memory.c，它没有做什么特别的事情，但它有两个错误。
Dialogue: 0,1:39:24.20,1:39:27.22,英文,,0,0,0,,Notice that I've included standard io.h, as always.
Dialogue: 0,1:39:24.20,1:39:27.22,中文,,0,0,0,,请注意，我已经像往常一样包含了 stdio.h。
Dialogue: 0,1:39:27.22,1:39:33.89,英文,,0,0,0,,I've also included standard lib.h, which is necessary now for anything related to malloc and or free and the like.
Dialogue: 0,1:39:27.22,1:39:33.89,中文,,0,0,0,,我还包含了 stdlib.h，它现在对于任何与 malloc 或 free 等相关的内容都是必需的。
Dialogue: 0,1:39:33.89,1:39:42.40,英文,,0,0,0,,Line 6, it's a little weird what I've done here, but this is like the manual way of asking for enough memory for an array.
Dialogue: 0,1:39:33.89,1:39:42.40,中文,,0,0,0,,第 6 行，我在这里做的事情有点奇怪，但这就像是用手动方式请求足够数组内存。
Dialogue: 0,1:39:42.40,1:39:45.84,英文,,0,0,0,,In week 2, how do we ask for memory for an array?
Dialogue: 0,1:39:42.40,1:39:45.84,中文,,0,0,0,,在第 2 周，我们如何请求数组的内存？
Dialogue: 0,1:39:45.84,1:39:52.29,英文,,0,0,0,,You very simply say int x 3, and that gives you an array called x of size 3.
Dialogue: 0,1:39:45.84,1:39:52.29,中文,,0,0,0,,你只需要写 int x[3]，这会给你一个大小为 3 的数组 x。
Dialogue: 0,1:39:52.29,1:39:57.87,英文,,0,0,0,,But if you do it manually now using malloc, what you have to do is use syntax like this.
Dialogue: 0,1:39:52.29,1:39:57.87,中文,,0,0,0,,但是，如果现在使用 malloc 手动执行此操作，则必须使用如下语法。
Dialogue: 0,1:39:57.87,1:39:59.09,英文,,0,0,0,,You call malloc.
Dialogue: 0,1:39:57.87,1:39:59.09,中文,,0,0,0,,你要调用 malloc。
Dialogue: 0,1:39:59.09,1:40:02.27,英文,,0,0,0,,You ask for three things times however big an int is.
Dialogue: 0,1:39:59.09,1:40:02.27,中文,,0,0,0,,你要请求三个东西乘以一个 int 的大小。
Dialogue: 0,1:40:02.27,1:40:04.81,英文,,0,0,0,,Now, we know it's 4, so you could literally write 12 here.
Dialogue: 0,1:40:02.27,1:40:04.81,中文,,0,0,0,,现在，我们知道它是 4，所以你可以在这里直接写 12。
Dialogue: 0,1:40:04.81,1:40:06.15,英文,,0,0,0,,But this is more generic.
Dialogue: 0,1:40:04.81,1:40:06.15,中文,,0,0,0,,但这更通用。
Dialogue: 0,1:40:06.15,1:40:10.15,英文,,0,0,0,,So 3 times the size of an integer will give you 12 dynamically.
Dialogue: 0,1:40:06.15,1:40:10.15,中文,,0,0,0,,所以 3 乘以一个整数的大小将动态地给你 12。
Dialogue: 0,1:40:10.15,1:40:11.27,英文,,0,0,0,,And what does malloc return?
Dialogue: 0,1:40:10.15,1:40:11.27,中文,,0,0,0,,malloc 返回什么？
Dialogue: 0,1:40:11.27,1:40:14.61,英文,,0,0,0,,The address of the first byte you get back.
Dialogue: 0,1:40:11.27,1:40:14.61,中文,,0,0,0,,返回的第一个字节的地址。
Dialogue: 0,1:40:14.61,1:40:15.85,英文,,0,0,0,,What do I want to put that?
Dialogue: 0,1:40:14.61,1:40:15.85,中文,,0,0,0,,我想把它放在哪里？
Dialogue: 0,1:40:15.85,1:40:17.55,英文,,0,0,0,,Well, I want to put it in a variable.
Dialogue: 0,1:40:15.85,1:40:17.55,中文,,0,0,0,,我想把它放在一个变量里。
Dialogue: 0,1:40:17.55,1:40:20.51,英文,,0,0,0,,Now, the variable can't just be int x, because that's a number.
Dialogue: 0,1:40:17.55,1:40:20.51,中文,,0,0,0,,现在，这个变量不能仅仅是 int x，因为它是一个数字。
Dialogue: 0,1:40:20.51,1:40:22.43,英文,,0,0,0,,It's not an address per se.
Dialogue: 0,1:40:20.51,1:40:22.43,中文,,0,0,0,,它本身不是一个地址。
Dialogue: 0,1:40:22.43,1:40:36.73,英文,,0,0,0,,If I want to store this address in a variable, I could call it x. I could call it p. But int star x just means that x is now the address of a chunk of memory, specifically a chunk of memory that's big enough not for one, but for three ints in total.
Dialogue: 0,1:40:22.43,1:40:36.73,中文,,0,0,0,,如果我想将此地址存储在变量中，我可以将其称为 x，也可以称为 p。\N但 int *x 仅表示 x 现在是一块内存的地址，更准确地说是足以容纳三个 int 的内存块的地址，而不是一个。
Dialogue: 0,1:40:36.73,1:40:45.13,英文,,0,0,0,,All right, now I'm just sort of naively putting our old friends 72, 73, and 33 at the first, second, and third locations in memory.
Dialogue: 0,1:40:36.73,1:40:45.13,中文,,0,0,0,,现在我只是简单地将我们的老朋友 72、73 和 33 放在内存中的第一个、第二个和第三个位置。
Dialogue: 0,1:40:45.13,1:40:49.62,英文,,0,0,0,,But perhaps based on week two or week four, I'm clearly screwing up here in a couple of ways.
Dialogue: 0,1:40:45.13,1:40:49.62,中文,,0,0,0,,但也许根据第二周或第四周的内容，我在这里显然在几个方面搞砸了。
Dialogue: 0,1:40:49.62,1:40:52.28,英文,,0,0,0,,Someone want to identify at least one bug?
Dialogue: 0,1:40:49.62,1:40:52.28,中文,,0,0,0,,有人能找出至少一个 bug 吗？
Dialogue: 0,1:40:52.28,1:40:55.22,英文,,0,0,0,,What did I do wrong?
Dialogue: 0,1:40:52.28,1:40:55.22,中文,,0,0,0,,我哪里做错了？
Dialogue: 0,1:40:55.22,1:40:58.22,英文,,0,0,0,,Yeah, like this is now amateur stuff.
Dialogue: 0,1:40:55.22,1:40:58.22,中文,,0,0,0,,这也太不专业了。
Dialogue: 0,1:40:58.22,1:41:00.68,英文,,0,0,0,,Like I should be zero indexing, not one indexing.
Dialogue: 0,1:40:58.22,1:41:00.68,中文,,0,0,0,,我应该用 0 索引，而不是 1 索引。
Dialogue: 0,1:41:00.68,1:41:03.41,英文,,0,0,0,,So this has got to be 0, 1, 2, ultimately.
Dialogue: 0,1:41:00.68,1:41:03.41,中文,,0,0,0,,所以这里应该是 0，1，2。
Dialogue: 0,1:41:03.41,1:41:08.41,英文,,0,0,0,,And other bugs that are maybe more week four specific?
Dialogue: 0,1:41:03.41,1:41:08.41,中文,,0,0,0,,还有其他可能更针对第四周内容的 bug 吗？
Dialogue: 0,1:41:08.41,1:41:09.21,英文,,0,0,0,,Other bugs.
Dialogue: 0,1:41:08.41,1:41:09.21,中文,,0,0,0,,其他 bug。
Dialogue: 0,1:41:09.21,1:41:09.89,英文,,0,0,0,,It's more subtle.
Dialogue: 0,1:41:09.21,1:41:09.89,中文,,0,0,0,,这个更隐蔽。
Dialogue: 0,1:41:09.89,1:41:12.39,英文,,0,0,0,,Yeah. I'm not freeing the memory, right?
Dialogue: 0,1:41:09.89,1:41:12.39,中文,,0,0,0,,我没有释放内存，对吧？
Dialogue: 0,1:41:12.39,1:41:14.97,英文,,0,0,0,,So I'm not practicing what I'm preaching by freeing this memory.
Dialogue: 0,1:41:12.39,1:41:14.97,中文,,0,0,0,,我没有做到自己所说的释放内存。
Dialogue: 0,1:41:14.97,1:41:16.45,英文,,0,0,0,,Now, suppose these are non-obvious.
Dialogue: 0,1:41:14.97,1:41:16.45,中文,,0,0,0,,假设这些都不明显。
Dialogue: 0,1:41:16.45,1:41:20.08,英文,,0,0,0,,And honestly, after an hour or two of this, this shouldn't be obvious yet.
Dialogue: 0,1:41:16.45,1:41:20.08,中文,,0,0,0,,老实说，即使看一两个小时，这也不应该很明显。
Dialogue: 0,1:41:20.08,1:41:21.64,英文,,0,0,0,,It will be over time.
Dialogue: 0,1:41:20.08,1:41:21.64,中文,,0,0,0,,随着时间推移会发现的。
Dialogue: 0,1:41:21.64,1:41:28.64,英文,,0,0,0,,How could I find these bugs with software as opposed to just staring at the thing or asking someone for help?
Dialogue: 0,1:41:21.64,1:41:28.64,中文,,0,0,0,,除了盯着代码看或寻求帮助，我怎样才能用软件找到这些 bug？
Dialogue: 0,1:41:28.64,1:41:30.00,英文,,0,0,0,,Well, let me propose this.
Dialogue: 0,1:41:28.64,1:41:30.00,中文,,0,0,0,,我来提个建议。
Dialogue: 0,1:41:30.00,1:41:34.03,英文,,0,0,0,,Let me first go ahead and run make memory to compile the program.
Dialogue: 0,1:41:30.00,1:41:34.03,中文,,0,0,0,,我先运行 `make memory` 来编译程序。
Dialogue: 0,1:41:34.03,1:41:36.03,英文,,0,0,0,,And it seems to look fine.
Dialogue: 0,1:41:34.03,1:41:36.03,中文,,0,0,0,,看起来没问题。
Dialogue: 0,1:41:36.03,1:41:37.93,英文,,0,0,0,,There's no syntax errors, at least.
Dialogue: 0,1:41:36.03,1:41:37.93,中文,,0,0,0,,至少没有语法错误。
Dialogue: 0,1:41:37.93,1:41:41.13,英文,,0,0,0,,Dot slash memory, notice, seems to work fine, too.
Dialogue: 0,1:41:37.93,1:41:41.13,中文,,0,0,0,,运行 `./memory`， 看起来也正常。
Dialogue: 0,1:41:41.13,1:41:42.75,英文,,0,0,0,,Now, this program doesn't do anything interesting.
Dialogue: 0,1:41:41.13,1:41:42.75,中文,,0,0,0,,这个程序没有做什么特别的事情。
Dialogue: 0,1:41:42.75,1:41:44.77,英文,,0,0,0,,There's no printf or anything like that.
Dialogue: 0,1:41:42.75,1:41:44.77,中文,,0,0,0,,这里没有 printf 之类的打印语句。
Dialogue: 0,1:41:44.77,1:41:45.63,英文,,0,0,0,,But it didn't crash.
Dialogue: 0,1:41:44.77,1:41:45.63,中文,,0,0,0,,但它没有崩溃。
Dialogue: 0,1:41:45.63,1:41:47.38,英文,,0,0,0,,There's no segmentation fault.
Dialogue: 0,1:41:45.63,1:41:47.38,中文,,0,0,0,,也没有出现段错误。
Dialogue: 0,1:41:47.38,1:41:51.20,英文,,0,0,0,,But that doesn't mean there aren't bugs latent in the software.
Dialogue: 0,1:41:47.38,1:41:51.20,中文,,0,0,0,,但这并不意味着软件中没有潜在的错误。
Dialogue: 0,1:41:51.20,1:41:57.30,英文,,0,0,0,,And this is true, sadly, of all of today's software, like Chrome and Microsoft Word and other programs, surely.
Dialogue: 0,1:41:51.20,1:41:57.30,中文,,0,0,0,,可悲的是，现在所有的软件都是这样，比如 Chrome、Microsoft Word 以及其他程序，肯定也是这样。
Dialogue: 0,1:41:57.30,1:42:01.23,英文,,0,0,0,,have memory-related bugs that people at Google and Microsoft haven't yet found.
Dialogue: 0,1:41:57.30,1:42:01.23,中文,,0,0,0,,它们都存在 Google 和 Microsoft 的人们还没有发现的内存相关错误。
Dialogue: 0,1:42:01.23,1:42:04.53,英文,,0,0,0,,But there are tools, at least, to find the most obvious of those bugs.
Dialogue: 0,1:42:01.23,1:42:04.53,中文,,0,0,0,,但至少有一些工具可以找到那些最明显的错误。
Dialogue: 0,1:42:04.53,1:42:07.79,英文,,0,0,0,,And we're going to introduce you now to a program called Valgrind.
Dialogue: 0,1:42:04.53,1:42:07.79,中文,,0,0,0,,现在我们将向大家介绍一个叫做 Valgrind 的程序。
Dialogue: 0,1:42:07.79,1:42:11.83,英文,,0,0,0,,So Valgrind, it's a fairly fancy program, but we'll use it for very simple ways.
Dialogue: 0,1:42:07.79,1:42:11.83,中文,,0,0,0,,Valgrind 是一个相当高级的程序，但我们会用它来做一些非常简单的事情。
Dialogue: 0,1:42:11.83,1:42:18.24,英文,,0,0,0,,We'll look at your code and find memory errors as it's executing and try to help you understand where they are.
Dialogue: 0,1:42:11.83,1:42:18.24,中文,,0,0,0,,它会在你的代码执行时查找内存错误，并尝试帮助你理解这些错误在哪里。
Dialogue: 0,1:42:18.24,1:42:20.40,英文,,0,0,0,,So let me go back to VS Code here.
Dialogue: 0,1:42:18.24,1:42:20.40,中文,,0,0,0,,让我回到 VS Code。
Dialogue: 0,1:42:20.40,1:42:21.88,英文,,0,0,0,,Memory seems to be fine.
Dialogue: 0,1:42:20.40,1:42:21.88,中文,,0,0,0,,内存看起来没问题。
Dialogue: 0,1:42:21.88,1:42:23.68,英文,,0,0,0,,I feel like, OK, I'm going to submit this homework.
Dialogue: 0,1:42:21.88,1:42:23.68,中文,,0,0,0,,我觉得我可以提交这份作业了。
Dialogue: 0,1:42:23.68,1:42:25.24,英文,,0,0,0,,All is good. No error messages.
Dialogue: 0,1:42:23.68,1:42:25.24,中文,,0,0,0,,一切正常，没有错误信息。
Dialogue: 0,1:42:25.24,1:42:26.61,英文,,0,0,0,,That's no longer the case.
Dialogue: 0,1:42:25.24,1:42:26.61,中文,,0,0,0,,但这不再是正确的做法了。
Dialogue: 0,1:42:26.61,1:42:30.91,英文,,0,0,0,,Now you need to poke a little more at your code to see if maybe there's still some bug there.
Dialogue: 0,1:42:26.61,1:42:30.91,中文,,0,0,0,,现在你需要更仔细地检查你的代码，看看是否还存在一些错误。
Dialogue: 0,1:42:30.91,1:42:31.91,英文,,0,0,0,,So let me do this.
Dialogue: 0,1:42:30.91,1:42:31.91,中文,,0,0,0,,让我来演示一下。
Dialogue: 0,1:42:31.91,1:42:35.45,英文,,0,0,0,,Valgrind and then space dot slash memory.
Dialogue: 0,1:42:31.91,1:42:35.45,中文,,0,0,0,,Valgrind，空格，./memory。
Dialogue: 0,1:42:35.45,1:42:38.83,英文,,0,0,0,,So just like debug50, you run it on a program you already compiled.
Dialogue: 0,1:42:35.45,1:42:38.83,中文,,0,0,0,,就像 debug50 一样，你可以在已经编译好的程序上运行它。
Dialogue: 0,1:42:38.83,1:42:41.66,英文,,0,0,0,,Valgrind, I'm going to run it on a program I already compiled.
Dialogue: 0,1:42:38.83,1:42:41.66,中文,,0,0,0,,Valgrind，我要在一个已经编译好的程序上运行它。
Dialogue: 0,1:42:41.66,1:42:46.18,英文,,0,0,0,,Let me zoom in on my terminal window so we can see more at once and Enter.
Dialogue: 0,1:42:41.66,1:42:46.18,中文,,0,0,0,,让我放大终端窗口，这样我们就能一次看到更多内容，然后回车。
Dialogue: 0,1:42:46.18,1:42:49.28,英文,,0,0,0,,All right, the output is crazy cryptic for no good reason.
Dialogue: 0,1:42:46.18,1:42:49.28,中文,,0,0,0,,输出信息非常混乱，毫无意义。
Dialogue: 0,1:42:49.28,1:42:50.92,英文,,0,0,0,,There's lots of numbers and equal signs.
Dialogue: 0,1:42:49.28,1:42:50.92,中文,,0,0,0,,有很多数字和等号
Dialogue: 0,1:42:50.92,1:42:52.38,英文,,0,0,0,,It's a lot of clutter.
Dialogue: 0,1:42:50.92,1:42:52.38,中文,,0,0,0,,充斥着大量无用信息。
Dialogue: 0,1:42:52.38,1:42:54.13,英文,,0,0,0,,But there is some juicy information here.
Dialogue: 0,1:42:52.38,1:42:54.13,中文,,0,0,0,,但这里有一些有用的信息。
Dialogue: 0,1:42:54.13,1:42:56.29,英文,,0,0,0,,And let me start from the top down.
Dialogue: 0,1:42:54.13,1:42:56.29,中文,,0,0,0,,让我从上往下开始。
Dialogue: 0,1:42:56.29,1:42:58.53,英文,,0,0,0,,Invalid write of size 4.
Dialogue: 0,1:42:56.29,1:42:58.53,中文,,0,0,0,,大小为 4 的非法写入。
Dialogue: 0,1:42:58.53,1:43:00.23,英文,,0,0,0,,So write means to change a value.
Dialogue: 0,1:42:58.53,1:43:00.23,中文,,0,0,0,,写入意味着更改值。
Dialogue: 0,1:43:00.23,1:43:02.65,英文,,0,0,0,,Read means to access a value.
Dialogue: 0,1:43:00.23,1:43:02.65,中文,,0,0,0,,读取意味着访问值。
Dialogue: 0,1:43:02.65,1:43:06.22,英文,,0,0,0,,And this is, again, esoteric like a lot of our error messages are.
Dialogue: 0,1:43:02.65,1:43:06.22,中文,,0,0,0,,这又是深奥的，就像我们的很多错误信息一样。
Dialogue: 0,1:43:06.22,1:43:08.80,英文,,0,0,0,,But it looks like.
Dialogue: 0,1:43:06.22,1:43:08.80,中文,,0,0,0,,但它看起来像。
Dialogue: 0,1:43:08.80,1:43:13.28,英文,,0,0,0,,After a block of size 12 alloc, and then there's these weird hex notation.
Dialogue: 0,1:43:08.80,1:43:13.28,中文,,0,0,0,,在一个大小为 12 的块分配之后，然后是这些奇怪的十六进制表示法。
Dialogue: 0,1:43:13.28,1:43:18.08,英文,,0,0,0,,There's some mention of malloc. But honestly, the juicy part here is memory.c, line 6.
Dialogue: 0,1:43:13.28,1:43:18.08,中文,,0,0,0,,这里提到了一些 malloc。但说实话，这里关键的部分是 memory.c，第 6 行。
Dialogue: 0,1:43:18.08,1:43:19.10,英文,,0,0,0,,That's probably my fault.
Dialogue: 0,1:43:18.08,1:43:19.10,中文,,0,0,0,,这可能是我造成的。
Dialogue: 0,1:43:19.10,1:43:21.55,英文,,0,0,0,,So let's look at line 6 per that output.
Dialogue: 0,1:43:19.10,1:43:21.55,中文,,0,0,0,,根据输出，我们来看看第 6 行。
Dialogue: 0,1:43:21.55,1:43:23.15,英文,,0,0,0,,Let me shrink the terminal window.
Dialogue: 0,1:43:21.55,1:43:23.15,中文,,0,0,0,,让我缩小终端窗口。
Dialogue: 0,1:43:23.15,1:43:24.37,英文,,0,0,0,,Look at line 6.
Dialogue: 0,1:43:23.15,1:43:24.37,中文,,0,0,0,,看第 6 行。
Dialogue: 0,1:43:24.37,1:43:26.07,英文,,0,0,0,,OK, 12 is now germane.
Dialogue: 0,1:43:24.37,1:43:26.07,中文,,0,0,0,,12 现在就很关键了。
Dialogue: 0,1:43:26.07,1:43:31.35,英文,,0,0,0,,If you did the mental math of the size of an int times 3, 12 is somehow involved here.
Dialogue: 0,1:43:26.07,1:43:31.35,中文,,0,0,0,,如果用心算一下一个 int 类型的大小乘以 3，你会发现 12 在这里起了作用。
Dialogue: 0,1:43:31.35,1:43:36.24,英文,,0,0,0,,But line 6 is now happening next here.
Dialogue: 0,1:43:31.35,1:43:36.24,中文,,0,0,0,,但现在第 6 行是接下来要发生的事情。
Dialogue: 0,1:43:36.24,1:43:37.72,英文,,0,0,0,,That's where the memory came from.
Dialogue: 0,1:43:36.24,1:43:37.72,中文,,0,0,0,,这就是内存的来源。
Dialogue: 0,1:43:37.72,1:43:38.38,英文,,0,0,0,,What is this?
Dialogue: 0,1:43:37.72,1:43:38.38,中文,,0,0,0,,这是什么？
Dialogue: 0,1:43:38.38,1:43:39.82,英文,,0,0,0,,Let me zoom back in.
Dialogue: 0,1:43:38.38,1:43:39.82,中文,,0,0,0,,让我放大一点。
Dialogue: 0,1:43:39.82,1:43:44.92,英文,,0,0,0,,Where is there invalid write of size 4?
Dialogue: 0,1:43:39.82,1:43:44.92,中文,,0,0,0,,哪里有大小为 4 的非法写入？
Dialogue: 0,1:43:44.92,1:43:48.02,英文,,0,0,0,,Like, what's perhaps going wrong here?
Dialogue: 0,1:43:44.92,1:43:48.02,中文,,0,0,0,,比如，这里可能出了什么问题？
Dialogue: 0,1:43:48.02,1:43:49.82,英文,,0,0,0,,Invalid write of size 4.
Dialogue: 0,1:43:48.02,1:43:49.82,中文,,0,0,0,,大小为 4 的非法写入。
Dialogue: 0,1:43:49.82,1:43:50.92,英文,,0,0,0,,What does that mean?
Dialogue: 0,1:43:49.82,1:43:50.92,中文,,0,0,0,,这是什么意思？
Dialogue: 0,1:43:50.92,1:43:53.88,英文,,0,0,0,,It's like a very technical way of explaining.
Dialogue: 0,1:43:50.92,1:43:53.88,中文,,0,0,0,,这是一种非常技术性的解释方式。
Dialogue: 0,1:43:53.88,1:43:57.24,英文,,0,0,0,,The bug is actually one line later, on line 7, as we already identified.
Dialogue: 0,1:43:53.88,1:43:57.24,中文,,0,0,0,,正如我们已经确定的那样，这个 bug 实际上在下一行，第 7 行。
Dialogue: 0,1:43:57.24,1:43:58.94,英文,,0,0,0,,Yeah.
Dialogue: 0,1:43:57.24,1:43:58.94,中文,,0,0,0,,是的。
Dialogue: 0,1:43:58.94,1:44:00.42,英文,,0,0,0,,Indeed, and I misspoke a moment ago.
Dialogue: 0,1:43:58.94,1:44:00.42,中文,,0,0,0,,确实，我刚才说错了。
Dialogue: 0,1:44:00.42,1:44:02.40,英文,,0,0,0,,The bug actually arises here with line 9.
Dialogue: 0,1:44:00.42,1:44:02.40,中文,,0,0,0,,这个 bug 实际上出现在第 9 行。
Dialogue: 0,1:44:02.40,1:44:06.81,英文,,0,0,0,,So after the allocation of memory, I'm somehow writing four bytes incorrectly.
Dialogue: 0,1:44:02.40,1:44:06.81,中文,,0,0,0,,所以在分配内存之后，我以某种方式错误地写入了 4 个字节。
Dialogue: 0,1:44:06.81,1:44:11.55,英文,,0,0,0,,And unfortunately, the onus is kind of on you to sort of think through deductively, like, what could that mean?
Dialogue: 0,1:44:06.81,1:44:11.55,中文,,0,0,0,,不幸的是，你需要自己去思考，比如，这意味着什么？
Dialogue: 0,1:44:11.55,1:44:15.97,英文,,0,0,0,,But I'm clearly touching four bytes of memory in these few lines of code that I shouldn't be.
Dialogue: 0,1:44:11.55,1:44:15.97,中文,,0,0,0,,但很明显，我在这几行代码中触碰了 4 个字节的内存，这是我不应该做的。
Dialogue: 0,1:44:15.97,1:44:20.19,英文,,0,0,0,,And hopefully here, as the light bulb already went off earlier, oh, I'm not zero indexing.
Dialogue: 0,1:44:15.97,1:44:20.19,中文,,0,0,0,,希望在这里，就像之前灵光一闪那样，哦，我没有进行零索引。
Dialogue: 0,1:44:20.19,1:44:25.21,英文,,0,0,0,,OK, that must mean that x bracket 3, as you know, It's just too far past the chunk of memory.
Dialogue: 0,1:44:20.19,1:44:25.21,中文,,0,0,0,,那一定意味着 x[3]， 它已经超出了内存块的范围。
Dialogue: 0,1:44:25.21,1:44:28.69,英文,,0,0,0,,So I'm invalidly writing to four bytes that I shouldn't be.
Dialogue: 0,1:44:25.21,1:44:28.69,中文,,0,0,0,,所以我错误地写入了 4 个字节，这是我不应该做的。
Dialogue: 0,1:44:28.69,1:44:30.18,英文,,0,0,0,,So again, it's not super obvious.
Dialogue: 0,1:44:28.69,1:44:30.18,中文,,0,0,0,,这并不明显。
Dialogue: 0,1:44:30.18,1:44:31.98,英文,,0,0,0,,This is not super user-friendly.
Dialogue: 0,1:44:30.18,1:44:31.98,中文,,0,0,0,,这不是对用户很友好的。
Dialogue: 0,1:44:31.98,1:44:35.12,英文,,0,0,0,,But at least it does give you a clue as to where that bug is.
Dialogue: 0,1:44:31.98,1:44:35.12,中文,,0,0,0,,但至少它给了你一个线索，告诉你错误在哪里。
Dialogue: 0,1:44:35.12,1:44:41.47,英文,,0,0,0,,So the fix there is going to be quite simply to change the 1 to a 0, the 2 to a 1, and the 3 to a 2.
Dialogue: 0,1:44:35.12,1:44:41.47,中文,,0,0,0,,所以这里的修复方法很简单，就是把 1 改成 0，2 改成 1，3 改成 2。
Dialogue: 0,1:44:41.47,1:44:42.95,英文,,0,0,0,,That'll fix that.
Dialogue: 0,1:44:41.47,1:44:42.95,中文,,0,0,0,,这样就能解决这个问题了。
Dialogue: 0,1:44:42.95,1:44:44.15,英文,,0,0,0,,But there's still a second error.
Dialogue: 0,1:44:42.95,1:44:44.15,中文,,0,0,0,,但还有第二个错误。
Dialogue: 0,1:44:44.15,1:44:46.35,英文,,0,0,0,,And let me look at the cryptic output again.
Dialogue: 0,1:44:44.15,1:44:46.35,中文,,0,0,0,,让我再看看这个神秘的输出。
Dialogue: 0,1:44:46.35,1:44:48.17,英文,,0,0,0,,Heap summary, some stuff there.
Dialogue: 0,1:44:46.35,1:44:48.17,中文,,0,0,0,,堆摘要，这里有一些东西。
Dialogue: 0,1:44:48.17,1:44:50.75,英文,,0,0,0,,OK, this does not sound good down here.
Dialogue: 0,1:44:48.17,1:44:50.75,中文,,0,0,0,,好吧，这听起来不太妙。
Dialogue: 0,1:44:50.75,1:44:54.79,英文,,0,0,0,,12 bytes in one blocks are definitely lost in loss record 1 of 1.
Dialogue: 0,1:44:50.75,1:44:54.79,中文,,0,0,0,,一个块中的 12 个字节肯定在 1 个丢失记录中的第 1 个丢失了。
Dialogue: 0,1:44:54.79,1:45:00.04,英文,,0,0,0,,Very arcane output 2, but clearly related to line 6 again, our allocation of memory.
Dialogue: 0,1:44:54.79,1:45:00.04,中文,,0,0,0,,非常神秘的输出 2，但显然又与第 6 行有关，我们分配内存的那一行。
Dialogue: 0,1:45:00.04,1:45:04.06,英文,,0,0,0,,Now here, too, it's not obvious what the solution is, but memory is lost.
Dialogue: 0,1:45:00.04,1:45:04.06,中文,,0,0,0,,在这里，解决方案也不明显，但内存丢失了。
Dialogue: 0,1:45:04.06,1:45:06.04,英文,,0,0,0,,AKA, this is a memory leak.
Dialogue: 0,1:45:04.06,1:45:06.04,中文,,0,0,0,,也就是内存泄漏。
Dialogue: 0,1:45:06.04,1:45:09.06,英文,,0,0,0,,And now the deduction's kind of up to you.
Dialogue: 0,1:45:06.04,1:45:09.06,中文,,0,0,0,,现在就由你来推断。
Dialogue: 0,1:45:09.06,1:45:09.79,英文,,0,0,0,,What is leak?
Dialogue: 0,1:45:09.06,1:45:09.79,中文,,0,0,0,,泄漏是什么？
Dialogue: 0,1:45:09.79,1:45:10.23,英文,,0,0,0,,Oh, wait.
Dialogue: 0,1:45:09.79,1:45:10.23,中文,,0,0,0,,哦，等等。
Dialogue: 0,1:45:10.23,1:45:11.63,英文,,0,0,0,,I didn't call free.
Dialogue: 0,1:45:10.23,1:45:11.63,中文,,0,0,0,,我没有调用 free。
Dialogue: 0,1:45:11.63,1:45:16.51,英文,,0,0,0,,And so the second solution here is probably to free x at the very end of the program.
Dialogue: 0,1:45:11.63,1:45:16.51,中文,,0,0,0,,所以这里的第二个解决方案可能是在程序的最末尾释放 x。
Dialogue: 0,1:45:16.51,1:45:20.45,英文,,0,0,0,,And if you really want to be pedantic, you should probably check like I proposed earlier.
Dialogue: 0,1:45:16.51,1:45:20.45,中文,,0,0,0,,如果你真的想要严谨，你可能应该像我之前建议的那样检查。
Dialogue: 0,1:45:20.45,1:45:23.72,英文,,0,0,0,,If x is null, just get out now while you still can.
Dialogue: 0,1:45:20.45,1:45:23.72,中文,,0,0,0,,如果 x 是空指针，趁早退出。
Dialogue: 0,1:45:23.72,1:45:27.62,英文,,0,0,0,,And don't even touch those other lines of code. But if you get to the bottom, return 0.
Dialogue: 0,1:45:23.72,1:45:27.62,中文,,0,0,0,,甚至不要碰其他代码行。但如果你执行到最底部，返回 0。
Dialogue: 0,1:45:27.62,1:45:36.26,英文,,0,0,0,,But really, the takeaways are I fixed my zero indexing of the array to avoid the invalid write of size 4, and now I'm freeing the memory that I asked for.
Dialogue: 0,1:45:27.62,1:45:36.26,中文,,0,0,0,,但重点是，我修复了数组的零索引问题，避免了大小为 4 的无效写入，现在我释放了我申请的内存。
Dialogue: 0,1:45:36.26,1:45:38.12,英文,,0,0,0,,So there should be no leak lost.
Dialogue: 0,1:45:36.26,1:45:38.12,中文,,0,0,0,,所以应该没有泄漏。
Dialogue: 0,1:45:38.12,1:45:39.32,英文,,0,0,0,,All right, let's try this again.
Dialogue: 0,1:45:38.12,1:45:39.32,中文,,0,0,0,,好了，我们再试一次。
Dialogue: 0,1:45:39.32,1:45:42.02,英文,,0,0,0,,Make memory dot slash memory.
Dialogue: 0,1:45:39.32,1:45:42.02,中文,,0,0,0,,make memory ./memory
Dialogue: 0,1:45:42.02,1:45:50.73,英文,,0,0,0,,No visible errors yet, but let me now increase my terminal window again, do valgrind of dot slash memory, crossing my fingers, and now
Dialogue: 0,1:45:42.02,1:45:50.73,中文,,0,0,0,,目前还没有明显的错误，现在让我再次增大终端窗口，运行 valgrind ./memory，祈祷一下，get strin
Dialogue: 0,1:45:50.73,1:45:52.23,英文,,0,0,0,,All heap blocks were freed.
Dialogue: 0,1:45:50.73,1:45:52.23,中文,,0,0,0,,现在所有堆块都被释放了。
Dialogue: 0,1:45:52.23,1:45:53.57,英文,,0,0,0,,No leaks are possible.
Dialogue: 0,1:45:52.23,1:45:53.57,中文,,0,0,0,,没有泄漏的可能。
Dialogue: 0,1:45:53.57,1:45:54.85,英文,,0,0,0,,I don't see any invalid writes.
Dialogue: 0,1:45:53.57,1:45:54.85,中文,,0,0,0,,我没有看到任何无效写入。
Dialogue: 0,1:45:54.85,1:45:56.13,英文,,0,0,0,,There's still a crazy amount of output.
Dialogue: 0,1:45:54.85,1:45:56.13,中文,,0,0,0,,仍然有大量的输出。
Dialogue: 0,1:45:56.13,1:45:57.33,英文,,0,0,0,,But none of it is erroneous.
Dialogue: 0,1:45:56.13,1:45:57.33,中文,,0,0,0,,但没有一个是错误的。
Dialogue: 0,1:45:57.33,1:45:59.99,英文,,0,0,0,,It's not bad. Now I've fixed my memory bugs.
Dialogue: 0,1:45:57.33,1:45:59.99,中文,,0,0,0,,还不错。现在我已经修复了内存错误。
Dialogue: 0,1:45:59.99,1:46:06.09,英文,,0,0,0,,And so now my TA, my TF, they're not going to find them either, because at least Valgrind has proactively done that for me.
Dialogue: 0,1:45:59.99,1:46:06.09,中文,,0,0,0,,所以现在我的助教，他们也找不到了，因为至少 Valgrind 已经帮我主动完成了这项工作。
Dialogue: 0,1:46:06.09,1:46:08.90,英文,,0,0,0,,Questions, then, on Valgrind?
Dialogue: 0,1:46:06.09,1:46:08.90,中文,,0,0,0,,关于 Valgrind 还有什么问题吗？
Dialogue: 0,1:46:08.90,1:46:11.26,英文,,0,0,0,,Generally, it's those two types of errors you might trip over.
Dialogue: 0,1:46:08.90,1:46:11.26,中文,,0,0,0,,通常，你可能会遇到这两种类型的错误。
Dialogue: 0,1:46:11.26,1:46:14.86,英文,,0,0,0,,There's not too much else in the way of arcane output.
Dialogue: 0,1:46:11.26,1:46:14.86,中文,,0,0,0,,除此之外，没有太多其他的神秘输出了。
Dialogue: 0,1:46:14.86,1:46:17.71,英文,,0,0,0,,Questions, then, on this?
Dialogue: 0,1:46:14.86,1:46:17.71,中文,,0,0,0,,对此还有什么问题吗？
Dialogue: 0,1:46:17.71,1:46:18.05,英文,,0,0,0,,No?
Dialogue: 0,1:46:17.71,1:46:18.05,中文,,0,0,0,,没有？
Dialogue: 0,1:46:18.05,1:46:18.93,英文,,0,0,0,,All right.
Dialogue: 0,1:46:18.05,1:46:18.93,中文,,0,0,0,,好的。
Dialogue: 0,1:46:18.93,1:46:20.51,英文,,0,0,0,,Well, what else might be going on?
Dialogue: 0,1:46:18.93,1:46:20.51,中文,,0,0,0,,还有什么可能发生呢？
Dialogue: 0,1:46:20.51,1:46:22.63,英文,,0,0,0,,So someone alluded to this earlier.
Dialogue: 0,1:46:20.51,1:46:22.63,中文,,0,0,0,,之前有人提到过。
Dialogue: 0,1:46:22.63,1:46:33.52,英文,,0,0,0,,What happens when you, for instance, forget the null terminator, or you generally start poking around memory that you yourself didn't ask for, or looking at values you didn't put there?
Dialogue: 0,1:46:22.63,1:46:33.52,中文,,0,0,0,,例如，当你忘记了字符串结束符，或者你开始查看你没有申请的内存，或者查看你没有放入的值时，会发生什么？
Dialogue: 0,1:46:33.52,1:46:34.98,英文,,0,0,0,,Well, let me go ahead and open this.
Dialogue: 0,1:46:33.52,1:46:34.98,中文,,0,0,0,,让我打开它。
Dialogue: 0,1:46:34.98,1:46:39.31,英文,,0,0,0,,Code of garbage.c, in honor of Oscar the Grouch here of sorts.
Dialogue: 0,1:46:34.98,1:46:39.31,中文,,0,0,0,,garbage.c 的代码，为了纪念 Oscar the Grouch。
Dialogue: 0,1:46:39.31,1:46:41.31,英文,,0,0,0,,And here is a simple program.
Dialogue: 0,1:46:39.31,1:46:41.31,中文,,0,0,0,,这是一个简单的程序。
Dialogue: 0,1:46:41.31,1:46:44.53,英文,,0,0,0,,If I hide my terminal window, that just does something kind of arbitrary.
Dialogue: 0,1:46:41.31,1:46:44.53,中文,,0,0,0,,如果我隐藏我的终端窗口，它就会做一些任意的事情。
Dialogue: 0,1:46:44.53,1:46:49.75,英文,,0,0,0,,I first declare an array called scores, but I made it crazy big, like 1024.
Dialogue: 0,1:46:44.53,1:46:49.75,中文,,0,0,0,,我首先声明了一个名为 scores 的数组，但我把它设置得非常大，比如 1024。
Dialogue: 0,1:46:49.75,1:46:53.49,英文,,0,0,0,,That's a lot of integers, but so be it.
Dialogue: 0,1:46:49.75,1:46:53.49,中文,,0,0,0,,那是很多整数，但就这样吧。
Dialogue: 0,1:46:53.49,1:46:57.36,英文,,0,0,0,,And then I iterate over those integers, and I print each of those scores out.
Dialogue: 0,1:46:53.49,1:46:57.36,中文,,0,0,0,,然后我遍历这些整数，并打印出每个分数。
Dialogue: 0,1:46:57.36,1:46:59.70,英文,,0,0,0,,So I'm using week two syntax here.
Dialogue: 0,1:46:57.36,1:46:59.70,中文,,0,0,0,,所以我在这里使用第二周的语法。
Dialogue: 0,1:46:59.70,1:47:04.44,英文,,0,0,0,,But based on this program, what have I clearly not done that I did do back in week two?
Dialogue: 0,1:46:59.70,1:47:04.44,中文,,0,0,0,,但是根据这个程序，我明显没有做什么，而我在第二周做了？
Dialogue: 0,1:47:04.44,1:47:05.86,英文,,0,0,0,,I've allocated the array.
Dialogue: 0,1:47:04.44,1:47:05.86,中文,,0,0,0,,我分配了数组。
Dialogue: 0,1:47:05.86,1:47:06.72,英文,,0,0,0,,I'm printing the array.
Dialogue: 0,1:47:05.86,1:47:06.72,中文,,0,0,0,,我正在打印数组。
Dialogue: 0,1:47:06.72,1:47:09.79,英文,,0,0,0,,But, but, but.
Dialogue: 0,1:47:06.72,1:47:09.79,中文,,0,0,0,,但是，但是，但是。
Dialogue: 0,1:47:09.79,1:47:12.59,英文,,0,0,0,,Yeah, I didn't initialize any values for that array.
Dialogue: 0,1:47:09.79,1:47:12.59,中文,,0,0,0,,是的，我没有初始化数组的任何值。
Dialogue: 0,1:47:12.59,1:47:14.13,英文,,0,0,0,,Back in week two, we didn't do 1024.
Dialogue: 0,1:47:12.59,1:47:14.13,中文,,0,0,0,,回到第二周，我们没有做 1024。
Dialogue: 0,1:47:14.13,1:47:17.50,英文,,0,0,0,,We did like three, and I typed in like three test scores or something like that.
Dialogue: 0,1:47:14.13,1:47:17.50,中文,,0,0,0,,我们做了类似三个，我输入了三个测试分数之类的东西。
Dialogue: 0,1:47:17.50,1:47:22.32,英文,,0,0,0,,Here, I'm allocating memory even more than that, just because I really want to be dramatic with what I'm demonstrating.
Dialogue: 0,1:47:17.50,1:47:22.32,中文,,0,0,0,,在这里，我分配了比这更多的内存，因为我真的想在我演示的内容上更加戏剧化。
Dialogue: 0,1:47:22.32,1:47:24.80,英文,,0,0,0,,But I'm not initializing those values to anything.
Dialogue: 0,1:47:22.32,1:47:24.80,中文,,0,0,0,,但我没有将这些值初始化为任何值。
Dialogue: 0,1:47:24.80,1:47:43.99,英文,,0,0,0,,And so here it turns out in C, generally, if you do not initialize a variable or you do not initialize an array with explicit values, there are going to be garbage values there, so to speak, remnants of that memory having been used before Probably by some other function of yours, some library function, or something else while your program is running.
Dialogue: 0,1:47:24.80,1:47:43.99,中文,,0,0,0,,因此，在 C 语言中，通常情况下，如果你没有初始化一个变量或者没有用显式值初始化一个数组，\N那么那里就会有所谓的垃圾值，也就是之前使用过的内存的残留物，可能是你的一些其他函数、一些库函数，或者你的程序运行时的其他东西。
Dialogue: 0,1:47:43.99,1:47:46.39,英文,,0,0,0,,Not a huge deal with a super small program like this.
Dialogue: 0,1:47:43.99,1:47:46.39,中文,,0,0,0,,对于像这样的小程序来说，这不是什么大问题。
Dialogue: 0,1:47:46.39,1:47:50.51,英文,,0,0,0,,But for anything sizable, memory is going to be used and unused and used and unused.
Dialogue: 0,1:47:46.39,1:47:50.51,中文,,0,0,0,,但是对于任何规模稍大的程序，内存的使用和闲置状态会不断变化。
Dialogue: 0,1:47:50.51,1:47:52.63,英文,,0,0,0,,That is malloced and freed again and again.
Dialogue: 0,1:47:50.51,1:47:52.63,中文,,0,0,0,,内存会反复地被 `malloc` 分配和释放。
Dialogue: 0,1:47:52.63,1:47:56.78,英文,,0,0,0,,There's going to be lots of garbage values in the computer's memory by default.
Dialogue: 0,1:47:52.63,1:47:56.78,中文,,0,0,0,,默认情况下，计算机内存中会有很多垃圾值。
Dialogue: 0,1:47:56.78,1:47:59.32,英文,,0,0,0,,So if I open my terminal window here.
Dialogue: 0,1:47:56.78,1:47:59.32,中文,,0,0,0,,比如我在这里打开终端窗口。
Dialogue: 0,1:47:59.32,1:48:01.50,英文,,0,0,0,,Let me do make garbage.
Dialogue: 0,1:47:59.32,1:48:01.50,中文,,0,0,0,,运行 `make garbage`。
Dialogue: 0,1:48:01.50,1:48:04.40,英文,,0,0,0,,Let me zoom in on my terminal so we can see the output.
Dialogue: 0,1:48:01.50,1:48:04.40,中文,,0,0,0,,放大一下终端，以便我们看到输出。
Dialogue: 0,1:48:04.40,1:48:11.63,英文,,0,0,0,,When I run dot slash garbage, theoretically, I should see 1,024 integers, but none of which have been initialized.
Dialogue: 0,1:48:04.40,1:48:11.63,中文,,0,0,0,,当我运行 `./garbage` 时，理论上我应该看到 1,024 个整数，但它们都没有被初始化。
Dialogue: 0,1:48:11.63,1:48:13.47,英文,,0,0,0,,Now, I'm going to get lucky with some of them.
Dialogue: 0,1:48:11.63,1:48:13.47,中文,,0,0,0,,当然，其中一些我可能会碰巧遇到。
Dialogue: 0,1:48:13.47,1:48:16.51,英文,,0,0,0,,And it looks like, wow, OK, a lot of them are initialized to 0.
Dialogue: 0,1:48:13.47,1:48:16.51,中文,,0,0,0,,看起来，哇，很多都被初始化为 0 了。
Dialogue: 0,1:48:16.51,1:48:22.99,英文,,0,0,0,,And C does, in some context, initialize memory for you to 0, at least at the beginning, but not again and again, typically.
Dialogue: 0,1:48:16.51,1:48:22.99,中文,,0,0,0,,C 语言在某些情况下会为你将内存初始化为 0，至少在开始时是这样，但通常不会反复进行初始化。
Dialogue: 0,1:48:22.99,1:48:28.11,英文,,0,0,0,,But if I start scrolling backwards in time at this array of size 1024,
Dialogue: 0,1:48:22.99,1:48:28.11,中文,,0,0,0,,但是，如果我开始在这个大小为 1024 的数组中向前滚动，
Dialogue: 0,1:48:28.11,1:48:30.95,英文,,0,0,0,,Where did these values come from?
Dialogue: 0,1:48:28.11,1:48:30.95,中文,,0,0,0,,这些值是从哪里来的？
Dialogue: 0,1:48:30.95,1:48:34.88,英文,,0,0,0,,So just random positive and negative numbers interspersed among the zeros?
Dialogue: 0,1:48:30.95,1:48:34.88,中文,,0,0,0,,零之间散布着随机的正数和负数？
Dialogue: 0,1:48:34.88,1:48:40.12,英文,,0,0,0,,Well, that's because I'm literally poking around on random 1,024 bytes of the computer's memory.
Dialogue: 0,1:48:34.88,1:48:40.12,中文,,0,0,0,,这是因为我实际上是在随机查看计算机内存中的 1,024 个字节。
Dialogue: 0,1:48:40.12,1:48:41.50,英文,,0,0,0,,Who knows what's there?
Dialogue: 0,1:48:40.12,1:48:41.50,中文,,0,0,0,,谁知道那里有什么？
Dialogue: 0,1:48:41.50,1:48:44.90,英文,,0,0,0,,So the lesson here is that garbage values are indeed this term of art.
Dialogue: 0,1:48:41.50,1:48:44.90,中文,,0,0,0,,所以这里的教训是，垃圾值确实是这个专业术语。
Dialogue: 0,1:48:44.90,1:48:48.00,英文,,0,0,0,,It means that a variable that you might have
Dialogue: 0,1:48:44.90,1:48:48.00,中文,,0,0,0,,这意味着你可能已经定义了的变量
Dialogue: 0,1:48:48.00,1:48:49.98,英文,,0,0,0,,defined that you might have declared.
Dialogue: 0,1:48:48.00,1:48:49.98,中文,,0,0,0,,你可能已经声明了的变量。
Dialogue: 0,1:48:49.98,1:48:53.58,英文,,0,0,0,,If you don't give it an explicit value, who knows what's going to be there?
Dialogue: 0,1:48:49.98,1:48:53.58,中文,,0,0,0,,如果你不给它一个明确的值，谁知道那里会有什么？
Dialogue: 0,1:48:53.58,1:48:55.57,英文,,0,0,0,,And the lesson here is just don't do that.
Dialogue: 0,1:48:53.58,1:48:55.57,中文,,0,0,0,,这里的教训就是不要这样做。
Dialogue: 0,1:48:55.57,1:49:02.09,英文,,0,0,0,,Always initialize variables to something, either yourself or prompting the human for it.
Dialogue: 0,1:48:55.57,1:49:02.09,中文,,0,0,0,,务必初始化变量，要么你自己初始化，要么提示用户输入。
Dialogue: 0,1:49:02.09,1:49:05.69,英文,,0,0,0,,Questions about garbage values.
Dialogue: 0,1:49:02.09,1:49:05.69,中文,,0,0,0,,垃圾值相关的问题。
Dialogue: 0,1:49:05.69,1:49:11.78,英文,,0,0,0,,You'll see them sometimes if you print things you shouldn't or touch arrays beyond their boundaries.
Dialogue: 0,1:49:05.69,1:49:11.78,中文,,0,0,0,,如果你打印了不应该打印的内容，或者访问了数组边界之外的元素，有时就会看到它们。
Dialogue: 0,1:49:11.78,1:49:16.83,英文,,0,0,0,,All right, so maybe to make this a little visual, too, it turns out that a lot of things can go wrong, unfortunately, with pointers.
Dialogue: 0,1:49:11.78,1:49:16.83,中文,,0,0,0,,好，也许为了让它更直观一些，事实证明，使用指针可能会出现很多问题。
Dialogue: 0,1:49:16.83,1:49:18.01,英文,,0,0,0,,And we've seen some of them.
Dialogue: 0,1:49:16.83,1:49:18.01,中文,,0,0,0,,我们已经见过其中一些了。
Dialogue: 0,1:49:18.01,1:49:19.83,英文,,0,0,0,,And here's another program that's a little contrived.
Dialogue: 0,1:49:18.01,1:49:19.83,中文,,0,0,0,,这是另一个有点做作的程序。
Dialogue: 0,1:49:19.83,1:49:21.09,英文,,0,0,0,,It's very simple.
Dialogue: 0,1:49:19.83,1:49:21.09,中文,,0,0,0,,它非常简单。
Dialogue: 0,1:49:21.09,1:49:23.73,英文,,0,0,0,,And it just is about manipulating values.
Dialogue: 0,1:49:21.09,1:49:23.73,中文,,0,0,0,,它只是操作值。
Dialogue: 0,1:49:23.73,1:49:26.85,英文,,0,0,0,,It doesn't do anything useful, per se, except demonstrate some of today's concepts.
Dialogue: 0,1:49:23.73,1:49:26.85,中文,,0,0,0,,它本身不做任何有用的事情，只是演示今天的一些概念。
Dialogue: 0,1:49:26.85,1:49:33.78,英文,,0,0,0,,So in main here, let me propose that we declare a pointer called x that's going to store eventually the address of an integer, apparently.
Dialogue: 0,1:49:26.85,1:49:33.78,中文,,0,0,0,,所以在 main 函数中，我建议我们声明一个名为 x 的指针，它最终将存储一个整数的地址。
Dialogue: 0,1:49:33.78,1:49:37.22,英文,,0,0,0,,Here's another one called y that's going to store the address of an integer as well.
Dialogue: 0,1:49:33.78,1:49:37.22,中文,,0,0,0,,这是另一个名为 y 的指针，它也将存储一个整数的地址。
Dialogue: 0,1:49:37.22,1:49:42.11,英文,,0,0,0,,Here, now, I'm allocating enough memory to fit one integer. Now, technically, it's four.
Dialogue: 0,1:49:37.22,1:49:42.11,中文,,0,0,0,,这里，我现在分配了足够存储一个整数的内存。实际上是 4 个字节。
Dialogue: 0,1:49:42.11,1:49:42.67,英文,,0,0,0,,We know that.
Dialogue: 0,1:49:42.11,1:49:42.67,中文,,0,0,0,,我们知道这一点。
Dialogue: 0,1:49:42.67,1:49:45.91,英文,,0,0,0,,But size of int just gives me that answer dynamically.
Dialogue: 0,1:49:42.67,1:49:45.91,中文,,0,0,0,,但 sizeof(int) 会动态地给出答案。
Dialogue: 0,1:49:45.91,1:49:47.95,英文,,0,0,0,,So it will work on all systems.
Dialogue: 0,1:49:45.91,1:49:47.95,中文,,0,0,0,,所以它可以在所有系统上运行。
Dialogue: 0,1:49:47.95,1:49:52.44,英文,,0,0,0,,And I'm going to store the address that malloc finds for me in x.
Dialogue: 0,1:49:47.95,1:49:52.44,中文,,0,0,0,,我将把 malloc 为我找到的地址存储在 x 中。
Dialogue: 0,1:49:52.44,1:49:56.70,英文,,0,0,0,,Then I go to x and put the number 42 there.
Dialogue: 0,1:49:52.44,1:49:56.70,中文,,0,0,0,,然后我去 x 的地址，把数字 42 放在那里。
Dialogue: 0,1:49:56.70,1:50:00.66,英文,,0,0,0,,All right, y, that's the sort of meaning of life, the universe, and everything here.
Dialogue: 0,1:49:56.70,1:50:00.66,中文,,0,0,0,,y，这就是生命、宇宙和一切的意义。
Dialogue: 0,1:50:00.66,1:50:04.90,英文,,0,0,0,,But star x, again, just means go to that address and put a value there.
Dialogue: 0,1:50:00.66,1:50:04.90,中文,,0,0,0,,但 *x 仍然意味着去那个地址，把一个值放在那里。
Dialogue: 0,1:50:04.90,1:50:08.78,英文,,0,0,0,,So y, I don't know, but it's just correct at this point.
Dialogue: 0,1:50:04.90,1:50:08.78,中文,,0,0,0,,所以 y，我不知道，但在这一点上它是正确的。
Dialogue: 0,1:50:08.78,1:50:10.32,英文,,0,0,0,,But what about this line here?
Dialogue: 0,1:50:08.78,1:50:10.32,中文,,0,0,0,,但这条线是怎么回事？
Dialogue: 0,1:50:10.32,1:50:13.01,英文,,0,0,0,,Star y equals 13.
Dialogue: 0,1:50:10.32,1:50:13.01,中文,,0,0,0,,*y = 13。
Dialogue: 0,1:50:13.01,1:50:14.41,英文,,0,0,0,,Unlucky in this case.
Dialogue: 0,1:50:13.01,1:50:14.41,中文,,0,0,0,,这种情况就不妙了。
Dialogue: 0,1:50:14.41,1:50:17.41,英文,,0,0,0,,What's bad about this line here, star y?
Dialogue: 0,1:50:14.41,1:50:17.41,中文,,0,0,0,,这行代码有什么问题，*y？
Dialogue: 0,1:50:17.41,1:50:20.09,英文,,0,0,0,,It's a combination now of today's primitives and that point here.
Dialogue: 0,1:50:17.41,1:50:20.09,中文,,0,0,0,,它现在是今天的原语和这里的那个点的组合。
Dialogue: 0,1:50:20.09,1:50:22.69,英文,,0,0,0,,Yeah.
Dialogue: 0,1:50:20.09,1:50:22.69,中文,,0,0,0,,是的。
Dialogue: 0,1:50:22.69,1:50:24.79,英文,,0,0,0,,Yeah, we didn't ask the computer to allocate any space.
Dialogue: 0,1:50:22.69,1:50:24.79,中文,,0,0,0,,是的，我们没有要求计算机分配任何空间。
Dialogue: 0,1:50:24.79,1:50:28.65,英文,,0,0,0,,So y was not initialized with an equal sign at any point to anything.
Dialogue: 0,1:50:24.79,1:50:28.65,中文,,0,0,0,,所以 y 在任何时候都没有用等号初始化为任何值。
Dialogue: 0,1:50:28.65,1:50:31.15,英文,,0,0,0,,And so what is inside y, so to speak?
Dialogue: 0,1:50:28.65,1:50:31.15,中文,,0,0,0,,那么 y 里面是什么，可以这么说？
Dialogue: 0,1:50:31.15,1:50:32.36,英文,,0,0,0,,Like a garbage value.
Dialogue: 0,1:50:31.15,1:50:32.36,中文,,0,0,0,,像一个垃圾值。
Dialogue: 0,1:50:32.36,1:50:34.92,英文,,0,0,0,,Maybe it's 0, which isn't bad, because at least it's nice and simple.
Dialogue: 0,1:50:32.36,1:50:34.92,中文,,0,0,0,,也许它是 0，这还不错，因为它至少简单明了。
Dialogue: 0,1:50:34.92,1:50:38.74,英文,,0,0,0,,But maybe it's some crazy large positive number, some crazy large negative number.
Dialogue: 0,1:50:34.92,1:50:38.74,中文,,0,0,0,,但也许它是一个很大的正数，一个很大的负数。
Dialogue: 0,1:50:38.74,1:50:44.79,英文,,0,0,0,,Either way, odds are if I go to this address or that address randomly with star y, bad things are going to happen.
Dialogue: 0,1:50:38.74,1:50:44.79,中文,,0,0,0,,无论哪种方式，如果我随机用*y 去访问这个地址或那个地址，都有可能会发生不好的事情。
Dialogue: 0,1:50:44.79,1:50:47.21,英文,,0,0,0,,And so let me go ahead and propose, well, let's not do that.
Dialogue: 0,1:50:44.79,1:50:47.21,中文,,0,0,0,,我建议，我们不要那样做。
Dialogue: 0,1:50:47.21,1:50:49.21,英文,,0,0,0,,Let's actually do this instead.
Dialogue: 0,1:50:47.21,1:50:49.21,中文,,0,0,0,,我们这样做。
Dialogue: 0,1:50:49.21,1:50:51.91,英文,,0,0,0,,Assign y equal to x. And we've done that before.
Dialogue: 0,1:50:49.21,1:50:51.91,中文,,0,0,0,,赋值 y = x。我们以前做过。
Dialogue: 0,1:50:51.91,1:50:55.88,英文,,0,0,0,,And then I can go to y now and change what was a 42.
Dialogue: 0,1:50:51.91,1:50:55.88,中文,,0,0,0,,然后我可以转到 y，改变原来的 42。
Dialogue: 0,1:50:55.88,1:50:56.62,英文,,0,0,0,,2 or 13.
Dialogue: 0,1:50:55.88,1:50:56.62,中文,,0,0,0,,2 或 13。
Dialogue: 0,1:50:56.62,1:50:58.90,英文,,0,0,0,,Again, y, this is just for educational sake.
Dialogue: 0,1:50:56.62,1:50:58.90,中文,,0,0,0,,同样，y，这只是为了教学。
Dialogue: 0,1:50:58.90,1:51:09.74,英文,,0,0,0,,But for now, this does not crash, because I only dereference y with star y after actually giving it a value, albeit a duplicate value, similar to our copy example earlier.
Dialogue: 0,1:50:58.90,1:51:09.74,中文,,0,0,0,,但就目前而言，这不会崩溃，因为我只在给 y 赋了一个值之后才用*y 解引用它，尽管它是一个重复的值，类似于我们之前的复制示例。
Dialogue: 0,1:51:09.74,1:51:12.41,英文,,0,0,0,,So our friends at Stanford have put together a wonderful visual.
Dialogue: 0,1:51:09.74,1:51:12.41,中文,,0,0,0,,斯坦福的伙伴们制作了一个很棒的可视化演示。
Dialogue: 0,1:51:12.41,1:51:13.49,英文,,0,0,0,,It's about two minutes long.
Dialogue: 0,1:51:12.41,1:51:13.49,中文,,0,0,0,,大概有两分钟长。
Dialogue: 0,1:51:13.49,1:51:24.00,英文,,0,0,0,,Allow me to dramatically dim the lights, if we could, and play with what happens with memory when you do bad things like this.
Dialogue: 0,1:51:13.49,1:51:24.00,中文,,0,0,0,,请允许我调暗灯光，如果可以的话，让我们看看当你做这种坏事时内存会发生什么。
Dialogue: 0,1:51:24.00,1:51:25.72,英文,,0,0,0,,Hey, Binky. Wake up.
Dialogue: 0,1:51:24.00,1:51:25.72,中文,,0,0,0,,嘿，Binky。 醒醒。
Dialogue: 0,1:51:25.72,1:51:28.21,英文,,0,0,0,,It's time for pointer fun.
Dialogue: 0,1:51:25.72,1:51:28.21,中文,,0,0,0,,该学习指针的乐趣了。
Dialogue: 0,1:51:28.21,1:51:29.43,英文,,0,0,0,,What's that?
Dialogue: 0,1:51:28.21,1:51:29.43,中文,,0,0,0,,那是什么？
Dialogue: 0,1:51:29.43,1:51:31.21,英文,,0,0,0,,Learn about pointers?
Dialogue: 0,1:51:29.43,1:51:31.21,中文,,0,0,0,,学习指针？
Dialogue: 0,1:51:31.21,1:51:32.79,英文,,0,0,0,,Oh, goody!
Dialogue: 0,1:51:31.21,1:51:32.79,中文,,0,0,0,,太好了！
Dialogue: 0,1:51:32.79,1:51:35.87,英文,,0,0,0,,Well, to get started, I guess we're going to need a couple pointers.
Dialogue: 0,1:51:32.79,1:51:35.87,中文,,0,0,0,,好吧，我想我们需要几个指针来开始。
Dialogue: 0,1:51:35.87,1:51:36.59,英文,,0,0,0,,Okay.
Dialogue: 0,1:51:35.87,1:51:36.59,中文,,0,0,0,,好的。
Dialogue: 0,1:51:36.59,1:51:40.38,英文,,0,0,0,,This code allocates two pointers which can point to integers.
Dialogue: 0,1:51:36.59,1:51:40.38,中文,,0,0,0,,这段代码分配了两个可以指向整数的指针。
Dialogue: 0,1:51:40.38,1:51:44.36,英文,,0,0,0,,Okay, well, I see the two pointers, but they don't seem to be pointing to anything.
Dialogue: 0,1:51:40.38,1:51:44.36,中文,,0,0,0,,我看到了这两个指针，但它们似乎没有指向任何东西。
Dialogue: 0,1:51:44.36,1:51:45.22,英文,,0,0,0,,That's right.
Dialogue: 0,1:51:44.36,1:51:45.22,中文,,0,0,0,,没错。
Dialogue: 0,1:51:45.22,1:51:47.30,英文,,0,0,0,,Initially, pointers don't point to anything.
Dialogue: 0,1:51:45.22,1:51:47.30,中文,,0,0,0,,最初，指针不指向任何东西。
Dialogue: 0,1:51:47.30,1:51:51.67,英文,,0,0,0,,The things they point to are called pointees, and setting them up is a separate step.
Dialogue: 0,1:51:47.30,1:51:51.67,中文,,0,0,0,,它们指向的东西被称为被指对象，设置它们是另一个步骤。
Dialogue: 0,1:51:51.67,1:51:52.47,英文,,0,0,0,,Oh, right, right.
Dialogue: 0,1:51:51.67,1:51:52.47,中文,,0,0,0,,对，对。
Dialogue: 0,1:51:52.47,1:51:53.15,英文,,0,0,0,,I knew that.
Dialogue: 0,1:51:52.47,1:51:53.15,中文,,0,0,0,,我知道。
Dialogue: 0,1:51:53.15,1:51:55.03,英文,,0,0,0,,The pointees are separate.
Dialogue: 0,1:51:53.15,1:51:55.03,中文,,0,0,0,,被指对象是独立的。
Dialogue: 0,1:51:55.03,1:51:57.47,英文,,0,0,0,,So, how do you allocate a pointee?
Dialogue: 0,1:51:55.03,1:51:57.47,中文,,0,0,0,,那么，如何分配一个被指对象呢？
Dialogue: 0,1:51:57.47,1:51:58.16,英文,,0,0,0,,Okay.
Dialogue: 0,1:51:57.47,1:51:58.16,中文,,0,0,0,,好的。
Dialogue: 0,1:51:58.16,1:52:04.26,英文,,0,0,0,,Well, this code allocates a new integer pointee, and this part sets x to point to it.
Dialogue: 0,1:51:58.16,1:52:04.26,中文,,0,0,0,,这段代码分配了一个新的整数指针，这部分让 x 指向它。
Dialogue: 0,1:52:04.26,1:52:05.48,英文,,0,0,0,,Hey, that looks better.
Dialogue: 0,1:52:04.26,1:52:05.48,中文,,0,0,0,,这看起来好多了。
Dialogue: 0,1:52:05.48,1:52:07.16,英文,,0,0,0,,So make it do something.
Dialogue: 0,1:52:05.48,1:52:07.16,中文,,0,0,0,,让它做点什么。
Dialogue: 0,1:52:07.16,1:52:08.00,英文,,0,0,0,,Okay.
Dialogue: 0,1:52:07.16,1:52:08.00,中文,,0,0,0,,好的。
Dialogue: 0,1:52:08.00,1:52:12.80,英文,,0,0,0,,I'll dereference the pointer x to store the number 42 into its pointee.
Dialogue: 0,1:52:08.00,1:52:12.80,中文,,0,0,0,,我将对指针 x 进行解引用，将数字 42 存储到它的指针指向的对象中。
Dialogue: 0,1:52:12.80,1:52:16.39,英文,,0,0,0,,For this trick, I'll need my magic wand of dereferencing.
Dialogue: 0,1:52:12.80,1:52:16.39,中文,,0,0,0,,为了这个戏法，我需要我的解引用魔杖。
Dialogue: 0,1:52:16.39,1:52:19.95,英文,,0,0,0,,Your magic wand of dereferencing?
Dialogue: 0,1:52:16.39,1:52:19.95,中文,,0,0,0,,你的解引用魔杖？
Dialogue: 0,1:52:19.95,1:52:21.53,英文,,0,0,0,,That's great.
Dialogue: 0,1:52:19.95,1:52:21.53,中文,,0,0,0,,太棒了。
Dialogue: 0,1:52:21.53,1:52:23.29,英文,,0,0,0,,This is what the code looks like.
Dialogue: 0,1:52:21.53,1:52:23.29,中文,,0,0,0,,代码看起来是这样的。
Dialogue: 0,1:52:23.29,1:52:28.41,英文,,0,0,0,,I'll just set up the number and... Hey look, there it goes.
Dialogue: 0,1:52:23.29,1:52:28.41,中文,,0,0,0,,我只要设置好数字，然后... 看，它动了。
Dialogue: 0,1:52:28.41,1:52:35.36,英文,,0,0,0,,So doing a dereference on X follows the arrow to access its point E, in this case to store 42 in there.
Dialogue: 0,1:52:28.41,1:52:35.36,中文,,0,0,0,,对 x 解引用会沿着箭头找到它指向的对象，在本例中是在那里存储 42。
Dialogue: 0,1:52:35.36,1:52:51.16,英文,,0,0,0,,Hey, try using it to store the number 13 through the other pointer, Y. Okay, I'll just go over here to Y and get the number 13 set up and then take the wand of dereferencing and just... Whoa!
Dialogue: 0,1:52:35.36,1:52:51.16,中文,,0,0,0,,试着用它来存储数字 13，通过另一个指针 y。我就到 y 这里，把数字 13 设置好，然后拿着解引用魔杖，就这样... 哇！
Dialogue: 0,1:52:51.16,1:52:53.32,英文,,0,0,0,,Oh, hey, that didn't work.
Dialogue: 0,1:52:51.16,1:52:53.32,中文,,0,0,0,,这不管用。
Dialogue: 0,1:52:53.32,1:53:02.13,英文,,0,0,0,,Say, Binky, I don't think dereferencing Y is a good idea, because setting up the point D is a separate step, and I don't think we ever did it.
Dialogue: 0,1:52:53.32,1:53:02.13,中文,,0,0,0,,我说，Binky，我觉得解引用 y 不是个好主意，因为设置指针指向的对象是一个单独的步骤，而我认为我们从来没有做过。
Dialogue: 0,1:53:02.13,1:53:03.83,英文,,0,0,0,,Hmm, good point.
Dialogue: 0,1:53:02.13,1:53:03.83,中文,,0,0,0,,说得好。
Dialogue: 0,1:53:03.83,1:53:10.88,英文,,0,0,0,,Yeah, we allocated the pointer Y, but we never set it to point to a point D. Hmm, very observant.
Dialogue: 0,1:53:03.83,1:53:10.88,中文,,0,0,0,,是的，我们分配了指针 y，但我们从未将其设置为指向一个对象。观察得很仔细。
Dialogue: 0,1:53:10.88,1:53:12.64,英文,,0,0,0,,Hey, you're looking good there, Binky.
Dialogue: 0,1:53:10.88,1:53:12.64,中文,,0,0,0,,你看起来不错，Binky。
Dialogue: 0,1:53:12.64,1:53:15.68,英文,,0,0,0,,Can you fix it so that Y points to the same point D as X?
Dialogue: 0,1:53:12.64,1:53:15.68,中文,,0,0,0,,你能修复它，让 y 指向与 x 相同的对象吗？
Dialogue: 0,1:53:15.68,1:53:19.02,英文,,0,0,0,,Sure, I'll use my magic wand of pointer assignment.
Dialogue: 0,1:53:15.68,1:53:19.02,中文,,0,0,0,,当然，我会用我的指针赋值魔杖。
Dialogue: 0,1:53:19.02,1:53:21.21,英文,,0,0,0,,Is that going to be a problem like before?
Dialogue: 0,1:53:19.02,1:53:21.21,中文,,0,0,0,,这样会不会像之前那样出问题？
Dialogue: 0,1:53:21.21,1:53:23.01,英文,,0,0,0,,No, this doesn't touch the pointees.
Dialogue: 0,1:53:21.21,1:53:23.01,中文,,0,0,0,,不会，这不会影响被指向的对象。
Dialogue: 0,1:53:23.01,1:53:26.70,英文,,0,0,0,,It just changes one pointer to point to the same thing as another.
Dialogue: 0,1:53:23.01,1:53:26.70,中文,,0,0,0,,这只是改变一个指针，让它指向和另一个指针相同的东西。
Dialogue: 0,1:53:26.70,1:53:27.72,英文,,0,0,0,,Oh, I see.
Dialogue: 0,1:53:26.70,1:53:27.72,中文,,0,0,0,,我明白了。
Dialogue: 0,1:53:27.72,1:53:32.24,英文,,0,0,0,,Now y points to the same place as x. So wait, now y is fixed.
Dialogue: 0,1:53:27.72,1:53:32.24,中文,,0,0,0,,现在 y 指向和 x 相同的位置。等等，现在 y 固定了。
Dialogue: 0,1:53:32.24,1:53:33.36,英文,,0,0,0,,It has a pointee.
Dialogue: 0,1:53:32.24,1:53:33.36,中文,,0,0,0,,它有一个被指向的对象。
Dialogue: 0,1:53:33.36,1:53:37.39,英文,,0,0,0,,So you can try the wand of dereferencing again to send the 13 over.
Dialogue: 0,1:53:33.36,1:53:37.39,中文,,0,0,0,,所以你可以再试试解引用魔杖，把 13 传过去。
Dialogue: 0,1:53:37.39,1:53:38.53,英文,,0,0,0,,Uh, OK.
Dialogue: 0,1:53:37.39,1:53:38.53,中文,,0,0,0,,嗯，好的。
Dialogue: 0,1:53:38.53,1:53:40.31,英文,,0,0,0,,Here goes.
Dialogue: 0,1:53:38.53,1:53:40.31,中文,,0,0,0,,开始吧。
Dialogue: 0,1:53:40.31,1:53:41.57,英文,,0,0,0,,Hey, look at that.
Dialogue: 0,1:53:40.31,1:53:41.57,中文,,0,0,0,,快看。
Dialogue: 0,1:53:41.57,1:53:47.38,英文,,0,0,0,,Now dereferencing works on y. And because the pointers are sharing that one pointee, they both see the 13.
Dialogue: 0,1:53:41.57,1:53:47.38,中文,,0,0,0,,现在解引用对 y 有效。因为指针共享同一个被指向对象，所以它们都能看到 13。
Dialogue: 0,1:53:47.38,1:53:49.08,英文,,0,0,0,,Yeah, sharing, whatever.
Dialogue: 0,1:53:47.38,1:53:49.08,中文,,0,0,0,,好吧，共享，随便吧。
Dialogue: 0,1:53:49.08,1:53:51.08,英文,,0,0,0,,So are we going to switch places now?
Dialogue: 0,1:53:49.08,1:53:51.08,中文,,0,0,0,,那我们现在要交换位置吗？
Dialogue: 0,1:53:51.08,1:53:52.94,英文,,0,0,0,,Oh, look, we're out of time.
Dialogue: 0,1:53:51.08,1:53:52.94,中文,,0,0,0,,看，我们没时间了。
Dialogue: 0,1:53:52.94,1:53:59.35,英文,,0,0,0,,But our thanks to Professor Nick Parlante of Stanford for spending a huge amount of time doing stop motion animation for that.
Dialogue: 0,1:53:52.94,1:53:59.35,中文,,0,0,0,,但我们要感谢斯坦福大学的 Nick Parlante 教授，他花了大量时间为我们制作定格动画。
Dialogue: 0,1:53:59.35,1:54:04.75,英文,,0,0,0,,But hopefully now you have a sense of what, too, can go wrong when you misuse memory in this way.
Dialogue: 0,1:53:59.35,1:54:04.75,中文,,0,0,0,,但希望你现在明白，当你错误地使用内存时，会发生什么问题。
Dialogue: 0,1:54:04.75,1:54:11.23,英文,,0,0,0,,But at the end of the day, we really only have these four new building blocks today, like the star operator, the ampersand operator, malloc, and free.
Dialogue: 0,1:54:04.75,1:54:11.23,中文,,0,0,0,,但总的来说，我们今天实际上只学习了四个新的构建块：星号运算符、取地址运算符、malloc 和 free。
Dialogue: 0,1:54:11.23,1:54:19.68,英文,,0,0,0,,And really, with that and the underlying understanding of what your computer is doing underneath the hood, we have this way now to really manipulate things in memory, for better or for worse.
Dialogue: 0,1:54:11.23,1:54:19.68,中文,,0,0,0,,实际上，有了这些以及对计算机底层操作的理解，我们就可以在内存中进行操作了，无论好坏。
Dialogue: 0,1:54:19.68,1:54:21.98,英文,,0,0,0,,And eventually, we'll see how we can build things.
Dialogue: 0,1:54:19.68,1:54:21.98,中文,,0,0,0,,最终，我们会看到如何构建东西。
Dialogue: 0,1:54:21.98,1:54:29.05,英文,,0,0,0,,But we can also now use today's primitives to better explain some things that we've been asking you to take for granted over the past several weeks.
Dialogue: 0,1:54:21.98,1:54:29.05,中文,,0,0,0,,但我们现在也可以用今天学习的基本概念来更好地解释过去几周我们要求你默认接受的一些事情。
Dialogue: 0,1:54:29.05,1:54:32.57,英文,,0,0,0,,So for instance, let me propose that we
Dialogue: 0,1:54:29.05,1:54:32.57,中文,,0,0,0,,比如，我们找个志愿者上来。
Dialogue: 0,1:54:32.57,1:54:35.33,英文,,0,0,0,,Do one volunteer up here, if we could.
Dialogue: 0,1:54:32.57,1:54:35.33,中文,,0,0,0,,找个志愿者上来。
Dialogue: 0,1:54:35.33,1:54:37.41,英文,,0,0,0,,Could we get one volunteer?
Dialogue: 0,1:54:35.33,1:54:37.41,中文,,0,0,0,,谁想上来？
Dialogue: 0,1:54:37.41,1:54:38.61,英文,,0,0,0,,You want to come straight up?
Dialogue: 0,1:54:37.41,1:54:38.61,中文,,0,0,0,,你想直接上来吗？
Dialogue: 0,1:54:38.61,1:54:39.11,英文,,0,0,0,,Yep.
Dialogue: 0,1:54:38.61,1:54:39.11,中文,,0,0,0,,好的。
Dialogue: 0,1:54:39.11,1:54:39.69,英文,,0,0,0,,Right in the middle.
Dialogue: 0,1:54:39.11,1:54:39.69,中文,,0,0,0,,就从中间上来。
Dialogue: 0,1:54:39.69,1:54:40.13,英文,,0,0,0,,Come on.
Dialogue: 0,1:54:39.69,1:54:40.13,中文,,0,0,0,,来吧。
Dialogue: 0,1:54:40.13,1:54:47.88,英文,,0,0,0,,You'll have to take a left or a right there.
Dialogue: 0,1:54:40.13,1:54:47.88,中文,,0,0,0,,你得从左边或者右边绕过来。
Dialogue: 0,1:54:47.88,1:54:48.44,英文,,0,0,0,,All right.
Dialogue: 0,1:54:47.88,1:54:48.44,中文,,0,0,0,,好的。
Dialogue: 0,1:54:48.44,1:54:52.44,英文,,0,0,0,,So we have two empty glasses here and two colors of liquid.
Dialogue: 0,1:54:48.44,1:54:52.44,中文,,0,0,0,,这里有两个空杯子和两种颜色的液体。
Dialogue: 0,1:54:52.44,1:54:57.11,英文,,0,0,0,,And we have, let me give you the mic, if you'd like to say hello to the group.
Dialogue: 0,1:54:52.44,1:54:57.11,中文,,0,0,0,,给你麦克风，跟大家打个招呼吧。
Dialogue: 0,1:54:57.11,1:54:58.95,英文,,0,0,0,,Hello, I'm Owen.
Dialogue: 0,1:54:57.11,1:54:58.95,中文,,0,0,0,,大家好，我叫 Owen。
Dialogue: 0,1:54:58.95,1:55:00.85,英文,,0,0,0,,I'm in third and first year.
Dialogue: 0,1:54:58.95,1:55:00.85,中文,,0,0,0,,我今年大三。
Dialogue: 0,1:55:00.85,1:55:01.41,英文,,0,0,0,,All right, welcome.
Dialogue: 0,1:55:00.85,1:55:01.41,中文,,0,0,0,,欢迎。
Dialogue: 0,1:55:01.41,1:55:02.61,英文,,0,0,0,,Well, welcome here.
Dialogue: 0,1:55:01.41,1:55:02.61,中文,,0,0,0,,欢迎你来。
Dialogue: 0,1:55:02.61,1:55:08.35,英文,,0,0,0,,I'm going to go ahead and fill these two glasses with this colored liquid, purple here on my right.
Dialogue: 0,1:55:02.61,1:55:08.35,中文,,0,0,0,,我先把这两个杯子装满彩色液体，我右手边是紫色。
Dialogue: 0,1:55:08.35,1:55:12.69,英文,,0,0,0,,Let's fill up a glass here.
Dialogue: 0,1:55:08.35,1:55:12.69,中文,,0,0,0,,我们把这个杯子装满。
Dialogue: 0,1:55:12.69,1:55:14.70,英文,,0,0,0,,Yeah, don't drink.
Dialogue: 0,1:55:12.69,1:55:14.70,中文,,0,0,0,,别喝。
Dialogue: 0,1:55:14.70,1:55:18.36,英文,,0,0,0,,And now we'll put some orange in here.
Dialogue: 0,1:55:14.70,1:55:18.36,中文,,0,0,0,,现在我们在另一个杯子里倒入橙色液体。
Dialogue: 0,1:55:18.36,1:55:23.89,英文,,0,0,0,,And what we'd like you to do for the audience, if you don't mind, is swap the two values.
Dialogue: 0,1:55:18.36,1:55:23.89,中文,,0,0,0,,麻烦你为观众演示一下，如何交换两种液体的值。
Dialogue: 0,1:55:23.89,1:55:25.51,英文,,0,0,0,,You've got a purple value and an orange value.
Dialogue: 0,1:55:23.89,1:55:25.51,中文,,0,0,0,,这边是紫色液体，那边是橙色液体。
Dialogue: 0,1:55:25.51,1:55:34.20,英文,,0,0,0,,And I'd like the purple liquid in this glass and the orange liquid in that glass, please.
Dialogue: 0,1:55:25.51,1:55:34.20,中文,,0,0,0,,我想要紫色液体倒进这个杯子，橙色液体倒进那个杯子。
Dialogue: 0,1:55:34.20,1:55:37.38,英文,,0,0,0,,Oh, OK, good intuition, but for the microphone.
Dialogue: 0,1:55:34.20,1:55:37.38,中文,,0,0,0,,直觉不错，不过这是说给麦克风听的。
Dialogue: 0,1:55:37.38,1:55:38.72,英文,,0,0,0,,Can I have another glass?
Dialogue: 0,1:55:37.38,1:55:38.72,中文,,0,0,0,,能再给我一个杯子吗？
Dialogue: 0,1:55:38.72,1:55:39.42,英文,,0,0,0,,You can.
Dialogue: 0,1:55:38.72,1:55:39.42,中文,,0,0,0,,可以。
Dialogue: 0,1:55:39.42,1:55:41.54,英文,,0,0,0,,And just in fact, I brought one here for you.
Dialogue: 0,1:55:39.42,1:55:41.54,中文,,0,0,0,,事实上，我正好带了一个。
Dialogue: 0,1:55:41.54,1:55:42.96,英文,,0,0,0,,Why are you asking for this, though?
Dialogue: 0,1:55:41.54,1:55:42.96,中文,,0,0,0,,为什么要这个？
Dialogue: 0,1:55:42.96,1:55:45.70,英文,,0,0,0,,Because if I just pour this into this, then it'll get mixed up.
Dialogue: 0,1:55:42.96,1:55:45.70,中文,,0,0,0,,因为如果我直接把这个倒进去，就会混在一起了。
Dialogue: 0,1:55:45.70,1:55:49.30,英文,,0,0,0,,Right. So obviously, we need a temporary variable, if you will.
Dialogue: 0,1:55:45.70,1:55:49.30,中文,,0,0,0,,没错，很显然我们需要一个临时变量。
Dialogue: 0,1:55:49.30,1:55:53.15,英文,,0,0,0,,So here is your temporary variable.
Dialogue: 0,1:55:49.30,1:55:53.15,中文,,0,0,0,,这就是你的临时变量。
Dialogue: 0,1:55:53.15,1:55:56.73,英文,,0,0,0,,Yeah, there's, yeah.
Dialogue: 0,1:55:53.15,1:55:56.73,中文,,0,0,0,,是的。
Dialogue: 0,1:55:56.73,1:55:57.29,英文,,0,0,0,,All right.
Dialogue: 0,1:55:56.73,1:55:57.29,中文,,0,0,0,,好的。
Dialogue: 0,1:55:57.29,1:56:03.42,英文,,0,0,0,,So pouring the value of the orange glass into this temporary variable, if you will.
Dialogue: 0,1:55:57.29,1:56:03.42,中文,,0,0,0,,把橙色杯子里的液体倒进这个临时变量。
Dialogue: 0,1:56:03.42,1:56:13.11,英文,,0,0,0,,All right, and now pouring the value of the purple glass into the former orange glass.
Dialogue: 0,1:56:03.42,1:56:13.11,中文,,0,0,0,,现在把紫色杯子里的液体倒进原来的橙色杯子里。
Dialogue: 0,1:56:13.11,1:56:20.15,英文,,0,0,0,,And now the temporary value goes back into the original purple glass.
Dialogue: 0,1:56:13.11,1:56:20.15,中文,,0,0,0,,现在把临时变量里的液体倒回原来的紫色杯子里。
Dialogue: 0,1:56:20.15,1:56:25.98,英文,,0,0,0,,And now I think we give you a round of applause for having done that very well.
Dialogue: 0,1:56:20.15,1:56:25.98,中文,,0,0,0,,现在让我们为你的精彩操作鼓掌。
Dialogue: 0,1:56:25.98,1:56:27.06,英文,,0,0,0,,Thank you.
Dialogue: 0,1:56:25.98,1:56:27.06,中文,,0,0,0,,谢谢。
Dialogue: 0,1:56:27.06,1:56:31.58,英文,,0,0,0,,All right, so it should go without saying that, in the real world, that's how you do this.
Dialogue: 0,1:56:27.06,1:56:31.58,中文,,0,0,0,,在现实世界中，事情就是这样做的。
Dialogue: 0,1:56:31.58,1:56:38.88,英文,,0,0,0,,And in fact, in code, that's pretty much how you have to do this, although ask us some time for a super fancy way of doing it without a temporary variable.
Dialogue: 0,1:56:31.58,1:56:38.88,中文,,0,0,0,,实际上在代码中，也是这么做的，不过可以问问我们有没有什么神奇的方法不用临时变量。
Dialogue: 0,1:56:38.88,1:56:41.10,英文,,0,0,0,,Turns out that is possible using bits.
Dialogue: 0,1:56:38.88,1:56:41.10,中文,,0,0,0,,事实证明，使用比特位操作是可以做到的。
Dialogue: 0,1:56:41.10,1:56:44.84,英文,,0,0,0,,But for now, let's suppose that, indeed, this demonstrates what is the reality in code.
Dialogue: 0,1:56:41.10,1:56:44.84,中文,,0,0,0,,但现在，我们先假设这确实展示了代码中的现实情况。
Dialogue: 0,1:56:44.84,1:56:48.89,英文,,0,0,0,,If you want to swap two values, you need to have something like a temporary variable.
Dialogue: 0,1:56:44.84,1:56:48.89,中文,,0,0,0,,如果要交换两个值，需要用到类似临时变量的东西。
Dialogue: 0,1:56:48.89,1:57:01.81,英文,,0,0,0,,So for instance, On the screen here is the beginning of a function called swap, whose purpose in life is to, as you just did, swap two values, call it a and b. So orange and purple, respectively, are now just a and b in integers to keep things simple.
Dialogue: 0,1:56:48.89,1:57:01.81,中文,,0,0,0,,例如， 屏幕上是名为 swap 函数的开头部分，\N它的作用就像你刚才做的那样，交换两个值，称为 a 和 b。橙色和紫色现在分别是整数 a 和 b，这样更容易理解。
Dialogue: 0,1:57:01.81,1:57:05.45,英文,,0,0,0,,Well, here is the corresponding code, if I may, to what you just enacted as a human.
Dialogue: 0,1:57:01.81,1:57:05.45,中文,,0,0,0,,如果可以的话，这就是你作为人类所做的动作对应的代码。
Dialogue: 0,1:57:05.45,1:57:07.49,英文,,0,0,0,,You declared a temporary variable.
Dialogue: 0,1:57:05.45,1:57:07.49,中文,,0,0,0,,你声明了一个临时变量。
Dialogue: 0,1:57:07.49,1:57:10.78,英文,,0,0,0,,I'll call temp in this case, which was like me handing you the empty glass.
Dialogue: 0,1:57:07.49,1:57:10.78,中文,,0,0,0,,在本例中，我将其称为 temp，就像我递给你一个空玻璃杯。
Dialogue: 0,1:57:10.78,1:57:13.20,英文,,0,0,0,,And you stored the orange liquid in it, a.k.a.
Dialogue: 0,1:57:10.78,1:57:13.20,中文,,0,0,0,,你把橙色的液体，也就是
Dialogue: 0,1:57:13.20,1:57:20.59,英文,,0,0,0,,a. You then changed the value of the formerly orange glass to be equal to the purple by pouring one into the other.
Dialogue: 0,1:57:13.20,1:57:20.59,中文,,0,0,0,,a 存储在里面。然后，你把原来橙色杯子里的液体倒入紫色杯子中，从而改变了它的值。
Dialogue: 0,1:57:20.59,1:57:22.19,英文,,0,0,0,,And then you did the opposite there.
Dialogue: 0,1:57:20.59,1:57:22.19,中文,,0,0,0,,然后你又做了相反的操作。
Dialogue: 0,1:57:22.19,1:57:25.43,英文,,0,0,0,,Now, at the end of this, you still have a temporary variable that's now empty.
Dialogue: 0,1:57:22.19,1:57:25.43,中文,,0,0,0,,现在，结束时，你还有一个现在为空的临时变量。
Dialogue: 0,1:57:25.43,1:57:27.27,英文,,0,0,0,,So it's temporary in literally that sense.
Dialogue: 0,1:57:25.43,1:57:27.27,中文,,0,0,0,,从字面上看，它是“临时”的。
Dialogue: 0,1:57:27.27,1:57:28.33,英文,,0,0,0,,You just don't need it anymore.
Dialogue: 0,1:57:27.27,1:57:28.33,中文,,0,0,0,,你不再需要它了。
Dialogue: 0,1:57:28.33,1:57:30.60,英文,,0,0,0,,But it was necessary along the way.
Dialogue: 0,1:57:28.33,1:57:30.60,中文,,0,0,0,,但在整个过程中它是必需的。
Dialogue: 0,1:57:30.60,1:57:33.56,英文,,0,0,0,,So I dare say this code is correct logically.
Dialogue: 0,1:57:30.60,1:57:33.56,中文,,0,0,0,,所以我敢说这段代码逻辑上是正确的。
Dialogue: 0,1:57:33.56,1:57:39.56,英文,,0,0,0,,Like, this will swap two values, a and b, thanks to the use of that temporary variable.
Dialogue: 0,1:57:33.56,1:57:39.56,中文,,0,0,0,,借助临时变量的使用，这将会交换 a 和 b 两个值。
Dialogue: 0,1:57:39.56,1:57:49.15,英文,,0,0,0,,Unfortunately, though, if I actually do this in practice, let me go over to VS Code here and open a program I wrote in advance called swap.c, which does this as follows.
Dialogue: 0,1:57:39.56,1:57:49.15,中文,,0,0,0,,但不幸的是，如果我在实际操作中这样做，让我打开 VS Code，打开一个我预先写好的名为 swap.c 的程序，它会像下面这样操作。
Dialogue: 0,1:57:49.15,1:57:52.93,英文,,0,0,0,,In here, notice I have my prototype for a swap function at the very top.
Dialogue: 0,1:57:49.15,1:57:52.93,中文,,0,0,0,,注意，这里在最上面有 swap 函数的原型。
Dialogue: 0,1:57:52.93,1:57:54.70,英文,,0,0,0,,And let me scroll down to the very bottom.
Dialogue: 0,1:57:52.93,1:57:54.70,中文,,0,0,0,,让我向下滚动到底部。
Dialogue: 0,1:57:54.70,1:57:56.30,英文,,0,0,0,,There is that exact same code.
Dialogue: 0,1:57:54.70,1:57:56.30,中文,,0,0,0,,是完全相同的代码。
Dialogue: 0,1:57:56.30,1:58:02.51,英文,,0,0,0,,So I'm the same code for swapping two values, a and b, which I'm claiming for now is correct.
Dialogue: 0,1:57:56.30,1:58:02.51,中文,,0,0,0,,这就是用于交换两个值 a 和 b 的相同代码，我现在认为它是正确的。
Dialogue: 0,1:58:02.51,1:58:08.31,英文,,0,0,0,,Now, if I go back up here, what is main going to do for us? Main is really just meant to be a demonstration of the correctness of your algorithm.
Dialogue: 0,1:58:02.51,1:58:08.31,中文,,0,0,0,,现在，如果我回到这里，main 函数会为我们做什么？ main 函数实际上只是为了演示算法的正确性。
Dialogue: 0,1:58:08.31,1:58:14.84,英文,,0,0,0,,So here I declare, on line 7 and 8, two variables, x and y, being 1 and 2 arbitrarily, respectively.
Dialogue: 0,1:58:08.31,1:58:14.84,中文,,0,0,0,,所以在这里，我在第 7 行和第 8 行声明了两个变量，x 和 y，它们的值分别任意设为 1 和 2。
Dialogue: 0,1:58:14.84,1:58:20.40,英文,,0,0,0,,I then, on line 10, just print out what the value of x is and y is, just so I can see it on the screen.
Dialogue: 0,1:58:14.84,1:58:20.40,中文,,0,0,0,,然后，在第 10 行，我只是打印出 x 和 y 的值，这样我就可以在屏幕上看到它们。
Dialogue: 0,1:58:20.40,1:58:23.08,英文,,0,0,0,,I then call the swap function on line 11.
Dialogue: 0,1:58:20.40,1:58:23.08,中文,,0,0,0,,然后我在第 11 行调用 swap 函数。
Dialogue: 0,1:58:23.08,1:58:25.50,英文,,0,0,0,,And then I literally print the exact same thing again.
Dialogue: 0,1:58:23.08,1:58:25.50,中文,,0,0,0,,然后我再次打印完全相同的东西。
Dialogue: 0,1:58:25.50,1:58:29.29,英文,,0,0,0,,I print x and y. Hopefully, it'll obviously be the opposite.
Dialogue: 0,1:58:25.50,1:58:29.29,中文,,0,0,0,,我打印 x 和 y。希望它们的值会交换。
Dialogue: 0,1:58:29.29,1:58:31.65,英文,,0,0,0,,So I think, logically, swap is indeed correct.
Dialogue: 0,1:58:29.29,1:58:31.65,中文,,0,0,0,,所以我认为，逻辑上，swap 确实是正确的。
Dialogue: 0,1:58:31.65,1:58:33.45,英文,,0,0,0,,Let me do make swap.
Dialogue: 0,1:58:31.65,1:58:33.45,中文,,0,0,0,,让我编译 swap。
Dialogue: 0,1:58:33.45,1:58:34.49,英文,,0,0,0,,And then dot slash swap.
Dialogue: 0,1:58:33.45,1:58:34.49,中文,,0,0,0,,然后执行 ./swap。
Dialogue: 0,1:58:34.49,1:58:37.30,英文,,0,0,0,,And I should see x is 1, y is 2.
Dialogue: 0,1:58:34.49,1:58:37.30,中文,,0,0,0,,我应该看到 x = 1，y = 2。
Dialogue: 0,1:58:37.30,1:58:40.32,英文,,0,0,0,,And then hopefully, x is 2, y is 1.
Dialogue: 0,1:58:37.30,1:58:40.32,中文,,0,0,0,,然后希望看到，x 是 2，y 是 1。
Dialogue: 0,1:58:40.32,1:58:41.77,英文,,0,0,0,,Enter.
Dialogue: 0,1:58:40.32,1:58:41.77,中文,,0,0,0,,回车。
Dialogue: 0,1:58:41.77,1:58:43.20,英文,,0,0,0,,But I don't.
Dialogue: 0,1:58:41.77,1:58:43.20,中文,,0,0,0,,但我没有看到。
Dialogue: 0,1:58:43.20,1:58:46.70,英文,,0,0,0,,And it did work in the sense that the code compiled, the code ran.
Dialogue: 0,1:58:43.20,1:58:46.70,中文,,0,0,0,,它确实在代码编译和运行的意义上有效。
Dialogue: 0,1:58:46.70,1:58:49.20,英文,,0,0,0,,So it's not like some bug in that sense.
Dialogue: 0,1:58:46.70,1:58:49.20,中文,,0,0,0,,所以从这个意义上说，它不像是什么 bug。
Dialogue: 0,1:58:49.20,1:58:59.53,英文,,0,0,0,,But because I don't quite understand what's going on underneath the hood, at least as of right now or prior weeks, this code here is indeed buggy in some way.
Dialogue: 0,1:58:49.20,1:58:59.53,中文,,0,0,0,,但是因为我不太了解底层发生了什么，至少就现在或前几周而言，这里的代码确实在某种程度上存在 bug。
Dialogue: 0,1:58:59.53,1:59:09.83,英文,,0,0,0,,But does anyone have an intuition, perhaps based on today's discussion, as to why this code, while logically correct, clearly works in reality, apparently does not work in C?
Dialogue: 0,1:58:59.53,1:59:09.83,中文,,0,0,0,,但是，根据今天的讨论，有没有人直观地知道为什么这段代码逻辑上正确，在现实中显然有效，但在 C 语言中却行不通？
Dialogue: 0,1:59:09.83,1:59:10.85,英文,,0,0,0,,Any intuition?
Dialogue: 0,1:59:09.83,1:59:10.85,中文,,0,0,0,,有什么想法吗？
Dialogue: 0,1:59:10.85,1:59:14.58,英文,,0,0,0,,Yeah.
Dialogue: 0,1:59:10.85,1:59:14.58,中文,,0,0,0,,有。
Dialogue: 0,1:59:14.58,1:59:17.08,英文,,0,0,0,,Perfect, and to summarize, here's that term of art I promised.
Dialogue: 0,1:59:14.58,1:59:17.08,中文,,0,0,0,,很好，总结一下，这就是我之前提到的专业术语。
Dialogue: 0,1:59:17.08,1:59:25.93,英文,,0,0,0,,When you call a function and pass in two arguments, like a and b, you're passing those arguments by value, so copies of those values effectively.
Dialogue: 0,1:59:17.08,1:59:25.93,中文,,0,0,0,,当你调用一个函数并传入两个参数，比如 a 和 b 时，你实际上是在按值传递这些参数，也就是说传递的是这些值的副本。
Dialogue: 0,1:59:25.93,1:59:33.86,英文,,0,0,0,,And so when swap is actually called here, sorry, when you pass in x and y, we call them a and b, but that's just a convention.
Dialogue: 0,1:59:25.93,1:59:33.86,中文,,0,0,0,,所以当 swap 在这里被调用时，抱歉，当你传入 x 和 y 时，我们把它们叫做 a 和 b，但这只是一个惯例。
Dialogue: 0,1:59:33.86,1:59:35.66,英文,,0,0,0,,Parameter is anything we want.
Dialogue: 0,1:59:33.86,1:59:35.66,中文,,0,0,0,,参数可以是任何我们想要的。
Dialogue: 0,1:59:35.66,1:59:41.90,英文,,0,0,0,,What a and b are are indeed the values of x and y, respectively, but copies of the values.
Dialogue: 0,1:59:35.66,1:59:41.90,中文,,0,0,0,,a 和 b 的确分别是 x 和 y 的值，但只是值的副本。
Dialogue: 0,1:59:41.90,1:59:54.94,英文,,0,0,0,,So this code here is very successfully, in VS Code 2, swapping the values of a and b. But as you note, because I'm passing them in by value, literally 1, literally 2, and not by another term of art, by reference,
Dialogue: 0,1:59:41.90,1:59:54.94,中文,,0,0,0,,所以在 VS Code 2 中，这段代码非常成功地交换了 a 和 b 的值。\N但正如你所注意到的，因为我是在按值传递它们，实际上是 1，实际上是 2，而不是按另一个专业术语，按引用传递，
Dialogue: 0,1:59:54.94,2:00:05.11,英文,,0,0,0,,AKA, by their addresses, swap has no capability in C to go to those locations, swap the actual locations, just like we did successfully in reality.
Dialogue: 0,1:59:54.94,2:00:05.11,中文,,0,0,0,,也就是通过它们的地址，swap 在 C 语言中没有能力去到那些位置，交换实际的位置，就像我们在现实中成功做到的那样。
Dialogue: 0,2:00:05.11,2:00:10.71,英文,,0,0,0,,But I think we really have the syntax all ready for solving this if we consider that, really, this is just an issue of scope.
Dialogue: 0,2:00:05.11,2:00:10.71,中文,,0,0,0,,但我认为，如果我们考虑到这实际上只是一个作用域的问题，我们已经准备好了解决这个问题的语法。
Dialogue: 0,2:00:10.71,2:00:16.30,英文,,0,0,0,,And we've talked a bit about scope in the past, whereby scope refers to the context in which a variable lives.
Dialogue: 0,2:00:10.71,2:00:16.30,中文,,0,0,0,,我们过去讨论过作用域，作用域指的是变量存在的上下文。
Dialogue: 0,2:00:16.30,2:00:20.44,英文,,0,0,0,,And generally, I've claimed that a variable exists between the most recent curly braces.
Dialogue: 0,2:00:16.30,2:00:20.44,中文,,0,0,0,,通常情况下，我认为一个变量存在于最近的一对花括号之间。
Dialogue: 0,2:00:20.44,2:00:27.64,英文,,0,0,0,,And that's pretty much true for the swap function, because a and b, I now claim again, exist only in the context of these curly braces.
Dialogue: 0,2:00:20.44,2:00:27.64,中文,,0,0,0,,对于 swap 函数来说，这几乎是正确的，因为我现在再次声明，a 和 b 只存在于这些花括号的上下文中。
Dialogue: 0,2:00:27.64,2:00:32.32,英文,,0,0,0,,They have no effect on main up top, which has different variables, x and y.
Dialogue: 0,2:00:27.64,2:00:32.32,中文,,0,0,0,,它们对上面有不同变量 x 和 y 的 main 函数没有影响。
Dialogue: 0,2:00:32.32,2:00:34.82,英文,,0,0,0,,But we can consider now what's really going on underneath the hood.
Dialogue: 0,2:00:32.32,2:00:34.82,中文,,0,0,0,,但我们现在可以考虑一下底层到底发生了什么。
Dialogue: 0,2:00:34.82,2:00:37.52,英文,,0,0,0,,And here's that same picture of memory as we've seen in the past.
Dialogue: 0,2:00:34.82,2:00:37.52,中文,,0,0,0,,这里是我们过去见过的内存的相同图片。
Dialogue: 0,2:00:37.52,2:00:41.33,英文,,0,0,0,,If we zoom in and see on these little black chips, this is a bunch of bytes of memory.
Dialogue: 0,2:00:37.52,2:00:41.33,中文,,0,0,0,,如果我们放大来看这些小黑芯片，就会发现这是一堆内存字节。
Dialogue: 0,2:00:41.33,2:00:55.73,英文,,0,0,0,,If I create a grid out of it just to kind of highlight that we can address each of these bytes, throw away the plastic circuit board and focus only on those bytes, what's going on underneath the hood when functions are called in C, which you've been doing for weeks now?
Dialogue: 0,2:00:41.33,2:00:55.73,中文,,0,0,0,,如果我把它做成一个网格，只是为了强调我们可以对每个字节进行寻址，\N扔掉塑料电路板，只关注这些字节，当你调用 C 语言函数时，底层发生了什么，你已经做了好几周了？
Dialogue: 0,2:00:55.73,2:01:04.23,英文,,0,0,0,,Well, this rectangle of memory, if we kind of abstract it away further, It's generally broken up into different regions, or segments, like I called them earlier.
Dialogue: 0,2:00:55.73,2:01:04.23,中文,,0,0,0,,这个内存矩形，如果我们进一步抽象出来， 它通常被分成不同的区域，或者我之前所说的段。
Dialogue: 0,2:01:04.23,2:01:07.87,英文,,0,0,0,,And different things get put in different parts of the computer's memory.
Dialogue: 0,2:01:04.23,2:01:07.87,中文,,0,0,0,,不同的东西被放在计算机内存的不同部分。
Dialogue: 0,2:01:07.87,2:01:21.47,英文,,0,0,0,,And without getting too into the weeds, when you double-click a program on your Mac or PC, or when you do dot slash something on a Linux, you are loading your machine code into the computer's memory from the computer's hard drive.
Dialogue: 0,2:01:07.87,2:01:21.47,中文,,0,0,0,,在不深入细节的情况下，当你在 Mac 或 PC 上双击一个程序，\N或者在 Linux 上执行 ./something 时，你就是在从计算机硬盘加载机器代码到计算机内存中。
Dialogue: 0,2:01:21.47,2:01:28.08,英文,,0,0,0,,So all the 0's and 1's that compose Microsoft Word or Chrome or whatever are loaded into the computer's memory or RAM.
Dialogue: 0,2:01:21.47,2:01:28.08,中文,,0,0,0,,构成 Microsoft Word、Chrome 或其他程序的所有 0 和 1 都被加载到计算机的内存或 RAM 中。
Dialogue: 0,2:01:28.08,2:01:31.44,英文,,0,0,0,,And by convention, it's put up top in the so-called machine code area.
Dialogue: 0,2:01:28.08,2:01:31.44,中文,,0,0,0,,按照惯例，它们被放在顶部的所谓机器码区域。
Dialogue: 0,2:01:31.44,2:01:34.88,英文,,0,0,0,,And that's how the CPU has access to them, quickly, at that.
Dialogue: 0,2:01:31.44,2:01:34.88,中文,,0,0,0,,这就是 CPU 如何快速访问它们的方式。
Dialogue: 0,2:01:34.88,2:01:44.22,英文,,0,0,0,,Below that are what are going to be our globals, so global variables, which we haven't used very much in C. But you can declare them outside of main at the very top of your files.
Dialogue: 0,2:01:34.88,2:01:44.22,中文,,0,0,0,,在它下面是全局变量，我们在 C 语言中没有怎么使用过。但是你可以在 main 函数之外，在文件的顶部声明它们。
Dialogue: 0,2:01:44.22,2:01:47.52,英文,,0,0,0,,If you have globals, they end up up there as well, just FYI.
Dialogue: 0,2:01:44.22,2:01:47.52,中文,,0,0,0,,如果你有全局变量，它们也会放在那里，仅供参考。
Dialogue: 0,2:01:47.52,2:01:52.53,英文,,0,0,0,,And then there's this big chunk of memory that we saw Valgrind mention indirectly earlier called the heap.
Dialogue: 0,2:01:47.52,2:01:52.53,中文,,0,0,0,,然后是这块很大的内存，我们之前看到 Valgrind 间接提到了，叫做堆。
Dialogue: 0,2:01:52.53,2:01:57.83,英文,,0,0,0,,And it's kind of like heap, literally, like it's a heap of memory that you can use as you see fit.
Dialogue: 0,2:01:52.53,2:01:57.83,中文,,0,0,0,,它就像一堆内存一样，你可以根据需要使用它。
Dialogue: 0,2:01:57.83,2:02:01.06,英文,,0,0,0,,And the heap is where malloc grabs memory from.
Dialogue: 0,2:01:57.83,2:02:01.06,中文,,0,0,0,,malloc 就是从堆中获取内存的。
Dialogue: 0,2:02:01.06,2:02:02.92,英文,,0,0,0,,So initially, there's nothing in the heap.
Dialogue: 0,2:02:01.06,2:02:02.92,中文,,0,0,0,,所以一开始，堆里什么都没有。
Dialogue: 0,2:02:02.92,2:02:04.68,英文,,0,0,0,,It's just a big chunk of free space.
Dialogue: 0,2:02:02.92,2:02:04.68,中文,,0,0,0,,只是一大块空闲空间。
Dialogue: 0,2:02:04.68,2:02:09.82,英文,,0,0,0,,Anytime you call malloc, malloc kind of carves out from the heap area more and more bytes.
Dialogue: 0,2:02:04.68,2:02:09.82,中文,,0,0,0,,每次你调用 malloc 时，它都会从堆区域中分割出越来越多的字节。
Dialogue: 0,2:02:09.82,2:02:13.61,英文,,0,0,0,,And malloc keeps track of, essentially, which bytes have already been allocated.
Dialogue: 0,2:02:09.82,2:02:13.61,中文,,0,0,0,,malloc 会跟踪哪些字节已经被分配了。
Dialogue: 0,2:02:13.61,2:02:15.07,英文,,0,0,0,,So initially, it looks empty.
Dialogue: 0,2:02:13.61,2:02:15.07,中文,,0,0,0,,所以一开始，它看起来是空的。
Dialogue: 0,2:02:15.07,2:02:21.61,英文,,0,0,0,,But different bytes, squares, if you will, keep getting requested again and again as a program runs, thanks to functions like malloc.
Dialogue: 0,2:02:15.07,2:02:21.61,中文,,0,0,0,,但是随着程序的运行，不同的字节（或者说方块）会被反复请求，这要归功于 malloc 这样的函数。
Dialogue: 0,2:02:21.61,2:02:23.81,英文,,0,0,0,,And it grows, if you will, conceptually down.
Dialogue: 0,2:02:21.61,2:02:23.81,中文,,0,0,0,,从概念上讲，它是向下增长的。
Dialogue: 0,2:02:23.81,2:02:27.31,英文,,0,0,0,,So the more and more memory you request from malloc, it starts up here.
Dialogue: 0,2:02:23.81,2:02:27.31,中文,,0,0,0,,所以你向 malloc 请求的内存越多，它就从这里开始。
Dialogue: 0,2:02:27.31,2:02:29.57,英文,,0,0,0,,But then the next chunk you get is down here conceptually.
Dialogue: 0,2:02:27.31,2:02:29.57,中文,,0,0,0,,但是你得到的下一块内存就在这里。
Dialogue: 0,2:02:29.57,2:02:31.28,英文,,0,0,0,,The next chunk is down here, down here.
Dialogue: 0,2:02:29.57,2:02:31.28,中文,,0,0,0,,下一块在这里，这里。
Dialogue: 0,2:02:31.28,2:02:35.36,英文,,0,0,0,,So it kind of fills the available space in the computer's overall memory.
Dialogue: 0,2:02:31.28,2:02:35.36,中文,,0,0,0,,所以它会填满计算机内存中的可用空间。
Dialogue: 0,2:02:35.36,2:02:38.96,英文,,0,0,0,,But there's this other chunk of memory. called the stack.
Dialogue: 0,2:02:35.36,2:02:38.96,中文,,0,0,0,,但是还有另一块内存叫做栈。
Dialogue: 0,2:02:38.96,2:02:45.40,英文,,0,0,0,,And just like a stack of trays in like Annenberg or a cafeteria kind of grow upward, so does the stack of memory.
Dialogue: 0,2:02:38.96,2:02:45.40,中文,,0,0,0,,就像 Annenberg 或自助餐厅里的托盘栈一样向上增长，内存栈也是如此。
Dialogue: 0,2:02:45.40,2:02:53.69,英文,,0,0,0,,And it turns out the stack is where functions have variables and have arguments stored temporarily.
Dialogue: 0,2:02:45.40,2:02:53.69,中文,,0,0,0,,事实证明，栈是函数临时存储变量和参数的地方。
Dialogue: 0,2:02:53.69,2:03:03.76,英文,,0,0,0,,So whenever you call a function and it has variables inside of it or has arguments there too, this is the chunk of memory in the computer's overall block of memory that are used for functions.
Dialogue: 0,2:02:53.69,2:03:03.76,中文,,0,0,0,,所以每当你调用一个函数，并且它内部有变量或也有参数时，这就是计算机整个内存块中用于函数的那块内存。
Dialogue: 0,2:03:03.76,2:03:06.88,英文,,0,0,0,,But anytime you call malloc, it's memory up here.
Dialogue: 0,2:03:03.76,2:03:06.88,中文,,0,0,0,,但每次调用 malloc 时，内存都在上面。
Dialogue: 0,2:03:06.88,2:03:09.36,英文,,0,0,0,,At the end of the day, they just had to pick a direction, top, bottom.
Dialogue: 0,2:03:06.88,2:03:09.36,中文,,0,0,0,,最后，他们只需要选择一个方向，顶部或底部。
Dialogue: 0,2:03:09.36,2:03:13.39,英文,,0,0,0,,And technically, it's an artist's rendition. You could circle this thing around any orientation you want.
Dialogue: 0,2:03:09.36,2:03:13.39,中文,,0,0,0,,从技术上讲，这是一种艺术渲染。 你可以按照你想要的任何方向绕这个东西画圈。
Dialogue: 0,2:03:13.39,2:03:16.71,英文,,0,0,0,,But you're just using a finite amount of memory in this conventional way.
Dialogue: 0,2:03:13.39,2:03:16.71,中文,,0,0,0,,但你只是以这种传统的方式使用有限的内存。
Dialogue: 0,2:03:16.71,2:03:18.21,英文,,0,0,0,,Malloc starts here.
Dialogue: 0,2:03:16.71,2:03:18.21,中文,,0,0,0,,Malloc 从这里开始。
Dialogue: 0,2:03:18.21,2:03:19.47,英文,,0,0,0,,Functions start here.
Dialogue: 0,2:03:18.21,2:03:19.47,中文,,0,0,0,,函数从这里开始。
Dialogue: 0,2:03:19.47,2:03:22.35,英文,,0,0,0,,Now, you can kind of see where bad things can happen.
Dialogue: 0,2:03:19.47,2:03:22.35,中文,,0,0,0,,现在，你可以看到坏事可能发生的地方。
Dialogue: 0,2:03:22.35,2:03:30.26,英文,,0,0,0,,And indeed, one of the other reasons programs, computers, can crash is if you ask for way too much memory from the heap by calling malloc many, many, many times.
Dialogue: 0,2:03:22.35,2:03:30.26,中文,,0,0,0,,事实上，程序、计算机崩溃的另一个原因是，如果你通过多次调用 malloc 从堆中请求过多的内存。
Dialogue: 0,2:03:30.26,2:03:37.55,英文,,0,0,0,,Or if you call way too many functions or accidentally per last week, you recurse infinitely many times, you might have a segmentation fault.
Dialogue: 0,2:03:30.26,2:03:37.55,中文,,0,0,0,,或者，如果你调用了过多的函数，或者像上周那样意外地无限次递归，你可能会遇到段错误。
Dialogue: 0,2:03:37.55,2:03:40.01,英文,,0,0,0,,And that's because you're using too much stack memory.
Dialogue: 0,2:03:37.55,2:03:40.01,中文,,0,0,0,,那是因为你使用了过多的堆栈内存。
Dialogue: 0,2:03:40.01,2:03:42.57,英文,,0,0,0,,So this is bound to be a problem eventually.
Dialogue: 0,2:03:40.01,2:03:42.57,中文,,0,0,0,,所以这最终必然会成为一个问题。
Dialogue: 0,2:03:42.57,2:03:50.88,英文,,0,0,0,,And the onus is on the programmer to just minimize the probability of doing that and really avoid the possibility of doing that by just checking return values.
Dialogue: 0,2:03:42.57,2:03:50.88,中文,,0,0,0,,程序员有责任通过检查返回值来尽量减少发生这种情况的可能性，并真正避免发生这种情况的可能性。
Dialogue: 0,2:03:50.88,2:03:53.78,英文,,0,0,0,,Like checking if malloc or getString return null.
Dialogue: 0,2:03:50.88,2:03:53.78,中文,,0,0,0,,比如检查 malloc 或 get_string 是否返回 null。
Dialogue: 0,2:03:53.78,2:04:02.15,英文,,0,0,0,,Because you can proactively, with conditionals, make sure that these two things do not collide by just making sure that you get back non-null values.
Dialogue: 0,2:03:53.78,2:04:02.15,中文,,0,0,0,,因为你可以主动地，通过条件语句，通过确保你得到非空值来确保这两件事不会发生冲突。
Dialogue: 0,2:04:02.15,2:04:06.41,英文,,0,0,0,,So let's consider the stack in the context of swap and what's really happening here.
Dialogue: 0,2:04:02.15,2:04:06.41,中文,,0,0,0,,因此，让我们在 swap 的上下文中考虑栈以及这里实际发生的事情。
Dialogue: 0,2:04:06.41,2:04:17.44,英文,,0,0,0,,And Carter, if you wouldn't mind helping me animate the screen here, when I call The main function of any program, it is allocated a slice of memory called a frame at the bottom of this stack.
Dialogue: 0,2:04:06.41,2:04:17.44,中文,,0,0,0,,Carter，如果你不介意帮我演示一下屏幕，当我调用任何程序的 main 函数时，它会在堆栈的底部分配一个称为帧的内存切片。
Dialogue: 0,2:04:17.44,2:04:26.60,英文,,0,0,0,,So if, Carter, you want to go ahead and advance here, here's the first slice of memory that will always be used by main, whether it has command line arguments or local variables.
Dialogue: 0,2:04:17.44,2:04:26.60,中文,,0,0,0,,如果 Carter 你想继续，这里的第一块内存将始终由 main 使用，无论它是否有命令行参数或局部变量。
Dialogue: 0,2:04:26.60,2:04:28.50,英文,,0,0,0,,It just ends up here in memory.
Dialogue: 0,2:04:26.60,2:04:28.50,中文,,0,0,0,,它最终会出现在内存中。
Dialogue: 0,2:04:28.50,2:04:32.96,英文,,0,0,0,,Suppose now, per our swap.c program, that main calls swap.
Dialogue: 0,2:04:28.50,2:04:32.96,中文,,0,0,0,,假设现在，根据我们的 swap.c 程序，main 调用了 swap。
Dialogue: 0,2:04:32.96,2:04:34.98,英文,,0,0,0,,Well, where does the memory for swap end up?
Dialogue: 0,2:04:32.96,2:04:34.98,中文,,0,0,0,,那么，swap 的内存最终会放在哪里呢？
Dialogue: 0,2:04:34.98,2:04:35.90,英文,,0,0,0,,Like, right up here.
Dialogue: 0,2:04:34.98,2:04:35.90,中文,,0,0,0,,就像，就在这里。
Dialogue: 0,2:04:35.90,2:04:41.03,英文,,0,0,0,,So swap had two arguments, a and b. And it also had a temporary variable.
Dialogue: 0,2:04:35.90,2:04:41.03,中文,,0,0,0,,swap 有两个参数，a 和 b，它还有一个临时变量。
Dialogue: 0,2:04:41.03,2:04:43.63,英文,,0,0,0,,So all of those end up in here, in memory.
Dialogue: 0,2:04:41.03,2:04:43.63,中文,,0,0,0,,所以所有这些都存储在内存中。
Dialogue: 0,2:04:43.63,2:04:47.81,英文,,0,0,0,,And if you want to go ahead and advance again, Carter, once swap is done executing,
Dialogue: 0,2:04:43.63,2:04:47.81,中文,,0,0,0,,carter，如果你想继续，一旦 swap 执行完毕，
Dialogue: 0,2:04:47.81,2:04:54.60,英文,,0,0,0,,Whether it just returns, because there's no more lines of code, or you explicitly return, this memory is just freed up automatically.
Dialogue: 0,2:04:47.81,2:04:54.60,中文,,0,0,0,,无论是由于没有更多代码行而返回，还是你显式地返回，这块内存都会自动释放。
Dialogue: 0,2:04:54.60,2:04:58.11,英文,,0,0,0,,You don't call free. You don't undo malloc. This just all happens automatically.
Dialogue: 0,2:04:54.60,2:04:58.11,中文,,0,0,0,,你不必调用 free，也不必撤销 malloc，这一切都是自动发生的。
Dialogue: 0,2:04:58.11,2:05:00.09,英文,,0,0,0,,It has been since week one.
Dialogue: 0,2:04:58.11,2:05:00.09,中文,,0,0,0,,从第一周开始就是这样。
Dialogue: 0,2:05:00.09,2:05:04.35,英文,,0,0,0,,Now, technically, it's still there, even though we've removed it from the picture.
Dialogue: 0,2:05:00.09,2:05:04.35,中文,,0,0,0,,从技术上讲，即使我们已将它从图片中移除，它仍然在那里。
Dialogue: 0,2:05:04.35,2:05:06.68,英文,,0,0,0,,And there's your first hint of garbage values.
Dialogue: 0,2:05:04.35,2:05:06.68,中文,,0,0,0,,这是你第一次看到垃圾值的提示。
Dialogue: 0,2:05:06.68,2:05:11.56,英文,,0,0,0,,Like, there's still 0's and 1's there, and they're left in the previous configuration.
Dialogue: 0,2:05:06.68,2:05:11.56,中文,,0,0,0,,就像，那里仍然有 0 和 1，它们保留在上一次的配置中。
Dialogue: 0,2:05:11.56,2:05:17.85,英文,,0,0,0,,And so the reason you get random values in the memory is because even though we haven't drawn swap here, there was stuff there a moment ago.
Dialogue: 0,2:05:11.56,2:05:17.85,中文,,0,0,0,,你在内存中得到随机值的原因是，即使我们没有在这里绘制 swap，但就在刚才，那里还有东西。
Dialogue: 0,2:05:17.85,2:05:20.59,英文,,0,0,0,,It's going to be there the next time you use that same memory.
Dialogue: 0,2:05:17.85,2:05:20.59,中文,,0,0,0,,下次你使用同一块内存时，它还会在那里。
Dialogue: 0,2:05:20.59,2:05:23.45,英文,,0,0,0,,Now, let's go ahead and step through this a little more methodically.
Dialogue: 0,2:05:20.59,2:05:23.45,中文,,0,0,0,,现在，让我们更有条理地逐步完成这个过程。
Dialogue: 0,2:05:23.45,2:05:27.35,英文,,0,0,0,,Main has two variables called x and y, 1 and 2.
Dialogue: 0,2:05:23.45,2:05:27.35,中文,,0,0,0,,main 有两个变量，分别叫做 x 和 y，值为 1 和 2。
Dialogue: 0,2:05:27.35,2:05:32.13,英文,,0,0,0,,So let's advance and represent x as 1, y as 2, taking up these two chunks of memory.
Dialogue: 0,2:05:27.35,2:05:32.13,中文,,0,0,0,,让我们继续，将 x 表示为 1，y 表示为 2，占据这两块内存。
Dialogue: 0,2:05:32.13,2:05:40.98,英文,,0,0,0,,When we call swap now, swap gets a new slice of memory that then gives us Three variables, a and b, technically the arguments, and temp.
Dialogue: 0,2:05:32.13,2:05:40.98,中文,,0,0,0,,当我们现在调用 swap 时，swap 会获得一块新的内存，这块内存给了我们三个变量，a 和 b，技术上是参数，还有 temp。
Dialogue: 0,2:05:40.98,2:05:41.82,英文,,0,0,0,,So what happens?
Dialogue: 0,2:05:40.98,2:05:41.82,中文,,0,0,0,,发生什么了？
Dialogue: 0,2:05:41.82,2:05:57.16,英文,,0,0,0,,Well, because functions automatically pass in values by value, or rather pass in arguments by value, x gets copied into a, y gets copied into b. And then once we start executing the algorithm a la the watered glasses, well, what happens here?
Dialogue: 0,2:05:41.82,2:05:57.16,中文,,0,0,0,,由于函数自动按值传递，或者更确切地说是按值传递参数，\Nx 被复制到 a 中，y 被复制到 b 中。一旦我们开始像水杯一样执行算法，这里会发生什么？
Dialogue: 0,2:05:57.16,2:06:02.74,英文,,0,0,0,,So if I execute the first line of code, temp equals a, TEMP gets a copy of A. What happens next?
Dialogue: 0,2:05:57.16,2:06:02.74,中文,,0,0,0,,如果我执行第一行代码，temp = a，temp 获得 A 的副本。接下来会发生什么？
Dialogue: 0,2:06:02.74,2:06:07.92,英文,,0,0,0,,A equals B. So A takes on a copy of B. And now we do the final swap in the glasses.
Dialogue: 0,2:06:02.74,2:06:07.92,中文,,0,0,0,,a = b。所以 a 获得 b 的副本。现在我们进行最后一次交换。
Dialogue: 0,2:06:07.92,2:06:09.18,英文,,0,0,0,,B equals TEMP.
Dialogue: 0,2:06:07.92,2:06:09.18,中文,,0,0,0,,b = temp。
Dialogue: 0,2:06:09.18,2:06:11.06,英文,,0,0,0,,B gets a copy of TEMP.
Dialogue: 0,2:06:09.18,2:06:11.06,中文,,0,0,0,,b 获得 temp 的副本。
Dialogue: 0,2:06:11.06,2:06:15.62,英文,,0,0,0,,Now, we don't have to change TEMP because it's essentially empty, although there's the garbage value.
Dialogue: 0,2:06:11.06,2:06:15.62,中文,,0,0,0,,现在，我们不需要更改 temp，因为它本质上是空的，尽管其中有垃圾值。
Dialogue: 0,2:06:15.62,2:06:18.39,英文,,0,0,0,,1 is always now going to be there until we reuse that memory.
Dialogue: 0,2:06:15.62,2:06:18.39,中文,,0,0,0,,1 将始终在那里，直到我们重新使用该内存。
Dialogue: 0,2:06:18.39,2:06:21.45,英文,,0,0,0,,The important thing, though, is that A and B have been swapped.
Dialogue: 0,2:06:18.39,2:06:21.45,中文,,0,0,0,,重要的是，a 和 b 已经交换了。
Dialogue: 0,2:06:21.45,2:06:29.91,英文,,0,0,0,,But what obviously has not been swapped, as is manifest as when swap returns, x and y are untouched, because copies thereof were passed in.
Dialogue: 0,2:06:21.45,2:06:29.91,中文,,0,0,0,,但显然没有交换的是，当 swap 返回时，x 和 y 没有改变，因为传入的是它们的副本。
Dialogue: 0,2:06:29.91,2:06:31.58,英文,,0,0,0,,So we need a solution to this problem.
Dialogue: 0,2:06:29.91,2:06:31.58,中文,,0,0,0,,所以我们需要一个解决方案。
Dialogue: 0,2:06:31.58,2:06:35.92,英文,,0,0,0,,And if we advance one more time, if you don't mind, let me step over here, but then call you back in a second.
Dialogue: 0,2:06:31.58,2:06:35.92,中文,,0,0,0,,如果再往前一步，如果你不介意的话，让我在这里跳过，稍后再回来。
Dialogue: 0,2:06:35.92,2:06:38.28,英文,,0,0,0,,This code here is logically correct.
Dialogue: 0,2:06:35.92,2:06:38.28,中文,,0,0,0,,这段代码逻辑上是正确的。
Dialogue: 0,2:06:38.28,2:06:46.29,英文,,0,0,0,,This is what you did, but this is now a detail of C. You can't just swap the things by value, because you're only changing it in the scope of the swap function.
Dialogue: 0,2:06:38.28,2:06:46.29,中文,,0,0,0,,这是你所做的，但这现在是 C 语言的细节。你不能只按值交换东西，因为你只是在 swap 函数的范围内更改它。
Dialogue: 0,2:06:46.29,2:06:52.64,英文,,0,0,0,,But I think. If we change it to this and add some annoying syntax, we can solve the problem.
Dialogue: 0,2:06:46.29,2:06:52.64,中文,,0,0,0,,但我认为，如果我们把它改成这样，并添加一些烦人的语法，我们就能解决这个问题。
Dialogue: 0,2:06:52.64,2:07:00.57,英文,,0,0,0,,Just like you can declare variables as storing addresses, you can declare arguments to functions, a.k.a. parameters, as taking addresses.
Dialogue: 0,2:06:52.64,2:07:00.57,中文,,0,0,0,,就像你可以声明变量来存储地址一样，你也可以声明函数的参数（也就是形参）来接收地址。
Dialogue: 0,2:07:00.57,2:07:05.13,英文,,0,0,0,,This new version of swap means that a shall be the address of an integer.
Dialogue: 0,2:07:00.57,2:07:05.13,中文,,0,0,0,,这个新版本的 swap 意味着 a 将是一个整数的地址。
Dialogue: 0,2:07:05.13,2:07:07.20,英文,,0,0,0,,B shall be the address of an integer.
Dialogue: 0,2:07:05.13,2:07:07.20,中文,,0,0,0,,b 将是一个整数的地址。
Dialogue: 0,2:07:07.20,2:07:09.26,英文,,0,0,0,,And now it gets a little cryptic here.
Dialogue: 0,2:07:07.20,2:07:09.26,中文,,0,0,0,,现在这里有点难懂了。
Dialogue: 0,2:07:09.26,2:07:12.30,英文,,0,0,0,,Temp is the same, because it's just an integer like it was in week one.
Dialogue: 0,2:07:09.26,2:07:12.30,中文,,0,0,0,,Temp 是一样的，因为它只是一个整数，就像第一周一样。
Dialogue: 0,2:07:12.30,2:07:14.26,英文,,0,0,0,,Nothing special about temp.
Dialogue: 0,2:07:12.30,2:07:14.26,中文,,0,0,0,,temp 没什么特别的。
Dialogue: 0,2:07:14.26,2:07:21.31,英文,,0,0,0,,But if you want to get the value at A, you do star A. And that goes to the address, grabs the number 1, presumably.
Dialogue: 0,2:07:14.26,2:07:21.31,中文,,0,0,0,,但如果要获取 a 中的值，可以使用 *a。它会访问地址，获取数字 1（可能）。
Dialogue: 0,2:07:21.31,2:07:31.10,英文,,0,0,0,,If you want to change the value of a, you go to that address, you follow the treasure map to the other mailbox, and you set it equal to whatever's at the value of b. You go to b as well.
Dialogue: 0,2:07:21.31,2:07:31.10,中文,,0,0,0,,如果要更改 a 的值，请转到该地址，沿着藏宝图找到另一个邮箱，并将其设置为 b 的值。你也需要访问 b。
Dialogue: 0,2:07:31.10,2:07:39.46,英文,,0,0,0,,Last line, you go to b now and change it to be whatever the temporary variable was, which happened to be the same as a. So that's where the final value gets swapped.
Dialogue: 0,2:07:31.10,2:07:39.46,中文,,0,0,0,,最后一行，现在转到 b，并将其更改为临时变量的值，它恰好与 a 相同。这就是最终值交换的地方。
Dialogue: 0,2:07:39.46,2:07:47.03,英文,,0,0,0,,But here, there's a lot more like crisscrossing metaphorically across the stage where you're going to all of these different addresses in the swap function to make these changes.
Dialogue: 0,2:07:39.46,2:07:47.03,中文,,0,0,0,,但是在这里，有很多像是在舞台上交叉穿梭的比喻，你需要访问 swap 函数中的所有这些不同地址来进行这些更改。
Dialogue: 0,2:07:47.03,2:07:51.63,英文,,0,0,0,,So if we advance now to the pictorial version of this, here's the same story as before with main.
Dialogue: 0,2:07:47.03,2:07:51.63,中文,,0,0,0,,如果我们现在进入它的图形版本，这里和之前的 main 函数一样。
Dialogue: 0,2:07:51.63,2:07:53.79,英文,,0,0,0,,And x and y are 1 and 2, respectively.
Dialogue: 0,2:07:51.63,2:07:53.79,中文,,0,0,0,,x 和 y 分别是 1 和 2。
Dialogue: 0,2:07:53.79,2:08:04.26,英文,,0,0,0,,When swap gets called now, notice, and I'll do it with arrows here, a is effectively pointing to x. b is effectively pointing to y. If we really get into the weeds, these are actually like addresses.
Dialogue: 0,2:07:53.79,2:08:04.26,中文,,0,0,0,,现在调用 swap 时，请注意，我将在这里用箭头表示，a 实际上指向 x。 b 实际上指向 y。如果我们真的要深入了解细节，这些实际上就像地址。
Dialogue: 0,2:08:04.26,2:08:06.06,英文,,0,0,0,,But who cares about the specifics?
Dialogue: 0,2:08:04.26,2:08:06.06,中文,,0,0,0,,但谁在乎细节呢？
Dialogue: 0,2:08:06.06,2:08:07.46,英文,,0,0,0,,It's really just the concept here.
Dialogue: 0,2:08:06.06,2:08:07.46,中文,,0,0,0,,这真的只是一个概念。
Dialogue: 0,2:08:07.46,2:08:08.97,英文,,0,0,0,,So now what happens?
Dialogue: 0,2:08:07.46,2:08:08.97,中文,,0,0,0,,那么现在会发生什么？
Dialogue: 0,2:08:08.97,2:08:13.03,英文,,0,0,0,,int temp gets star a. Star a means start at a and go there.
Dialogue: 0,2:08:08.97,2:08:13.03,中文,,0,0,0,,int temp 获取 *a。 *a 表示从 a 开始并前往那里。
Dialogue: 0,2:08:13.03,2:08:15.77,英文,,0,0,0,,Follow the arrow, if you will, sort of chutes and ladders style.
Dialogue: 0,2:08:13.03,2:08:15.77,中文,,0,0,0,,沿着箭头走，就像玩滑梯和梯子一样。
Dialogue: 0,2:08:15.77,2:08:18.17,英文,,0,0,0,,And then that's 1, so we put 1 in temp.
Dialogue: 0,2:08:15.77,2:08:18.17,中文,,0,0,0,,那是 1，所以我们将 1 放入 temp 中。
Dialogue: 0,2:08:18.17,2:08:21.56,英文,,0,0,0,,All right, star a equals star b. So let's do it from right to left.
Dialogue: 0,2:08:18.17,2:08:21.56,中文,,0,0,0,,*a = *b。让我们从右到左进行操作。
Dialogue: 0,2:08:21.56,2:08:23.28,英文,,0,0,0,,Star b means follow the arrow.
Dialogue: 0,2:08:21.56,2:08:23.28,中文,,0,0,0,,*b 表示沿着箭头走。
Dialogue: 0,2:08:23.28,2:08:24.28,英文,,0,0,0,,It's 2.
Dialogue: 0,2:08:23.28,2:08:24.28,中文,,0,0,0,,它是 2。
Dialogue: 0,2:08:24.28,2:08:25.18,英文,,0,0,0,,And then what do you do?
Dialogue: 0,2:08:24.28,2:08:25.18,中文,,0,0,0,,然后你要做什么？
Dialogue: 0,2:08:25.18,2:08:26.12,英文,,0,0,0,,Follow the arrow.
Dialogue: 0,2:08:25.18,2:08:26.12,中文,,0,0,0,,沿着箭头走。
Dialogue: 0,2:08:26.12,2:08:29.93,英文,,0,0,0,,It's now 2, because you copy one to the other from right to left.
Dialogue: 0,2:08:26.12,2:08:29.93,中文,,0,0,0,,现在它是 2，因为你从右到左复制了一个到另一个。
Dialogue: 0,2:08:29.93,2:08:31.73,英文,,0,0,0,,And then lastly, star b gets temp.
Dialogue: 0,2:08:29.93,2:08:31.73,中文,,0,0,0,,最后，*b 获取 temp 的值。
Dialogue: 0,2:08:31.73,2:08:36.55,英文,,0,0,0,,So start at b, go to b, and now store whatever the value is in temp.
Dialogue: 0,2:08:31.73,2:08:36.55,中文,,0,0,0,,从 b 开始，到 b，现在将值存储在 temp 中。
Dialogue: 0,2:08:36.55,2:08:50.71,英文,,0,0,0,,So just by having this basic new syntax of, like, ampersands and stars and so forth, we can actually now go to places and circumvent what is otherwise a feature of C, that these variables are locally scoped, but you can still access things in other functions as well.
Dialogue: 0,2:08:36.55,2:08:50.71,中文,,0,0,0,,只需使用这种基本的语法，像 & 和 * 等等，我们就可以访问到这些地方，\N并绕过 C 语言的一个特性，即这些变量是局部作用域的，但你仍然可以访问其他函数中的东西。
Dialogue: 0,2:08:50.71,2:08:59.76,英文,,0,0,0,,So thank you so much for helping step through this. So we now have an application of this that explains why now in this version of the C code, this would actually now work.
Dialogue: 0,2:08:50.71,2:08:59.76,中文,,0,0,0,,非常感谢你帮我完成了这些步骤。现在我们有一个应用程序可以解释为什么在这个版本的 C 代码中，这实际上可以工作了。
Dialogue: 0,2:08:59.76,2:09:03.16,英文,,0,0,0,,So in fact, let me go back to my swap code here.
Dialogue: 0,2:08:59.76,2:09:03.16,中文,,0,0,0,,事实上，让我回到我的 swap 代码这里。
Dialogue: 0,2:09:03.16,2:09:06.22,英文,,0,0,0,,And let me change the function ever so slightly in VS Code.
Dialogue: 0,2:09:03.16,2:09:06.22,中文,,0,0,0,,让我在 VS Code 中稍微修改一下函数。
Dialogue: 0,2:09:06.22,2:09:08.86,英文,,0,0,0,,So let me scroll down, leaving main the same.
Dialogue: 0,2:09:06.22,2:09:08.86,中文,,0,0,0,,让我向下滚动，保持 main 不变。
Dialogue: 0,2:09:08.86,2:09:13.45,英文,,0,0,0,,And let me change swap's prototype to taking in addresses.
Dialogue: 0,2:09:08.86,2:09:13.45,中文,,0,0,0,,让我把 swap 的原型改为接收地址。
Dialogue: 0,2:09:13.45,2:09:16.23,英文,,0,0,0,,Let me go to a here.
Dialogue: 0,2:09:13.45,2:09:16.23,中文,,0,0,0,,让我转到 a 这里。
Dialogue: 0,2:09:16.23,2:09:17.79,英文,,0,0,0,,Let me go to b here.
Dialogue: 0,2:09:16.23,2:09:17.79,中文,,0,0,0,,让我转到 b 这里。
Dialogue: 0,2:09:17.79,2:09:19.49,英文,,0,0,0,,And let me go to b here as well.
Dialogue: 0,2:09:17.79,2:09:19.49,中文,,0,0,0,,也让我转到 b 这里。
Dialogue: 0,2:09:19.49,2:09:21.11,英文,,0,0,0,,But nothing else changes.
Dialogue: 0,2:09:19.49,2:09:21.11,中文,,0,0,0,,但其他都没有改变。
Dialogue: 0,2:09:21.11,2:09:31.28,英文,,0,0,0,,This change here in particular is enough of a clue to see that means when you call swap and pass in two values, I'm expecting addresses now, not integers.
Dialogue: 0,2:09:21.11,2:09:31.28,中文,,0,0,0,,这里的这个变化足以说明，当你调用 swap 并传入两个值时，我现在期望的是地址，而不是整数。
Dialogue: 0,2:09:31.28,2:09:37.46,英文,,0,0,0,,But now that I've made this change, I do need to go up to main and make one change.
Dialogue: 0,2:09:31.28,2:09:37.46,中文,,0,0,0,,但是，既然我已经做了这个改变，我需要回到 main 函数并做一个改变。
Dialogue: 0,2:09:37.46,2:09:48.31,英文,,0,0,0,,Does anyone have the intuition for what now need change in main so that I pass in x and y by reference, that is, by address, rather than by value or copy?
Dialogue: 0,2:09:37.46,2:09:48.31,中文,,0,0,0,,有没有人知道现在需要在 main 函数中做什么改变，以便我通过引用（即通过地址）而不是通过值或副本来传递 x 和 y？
Dialogue: 0,2:09:48.31,2:09:52.79,英文,,0,0,0,,Yeah, in back?
Dialogue: 0,2:09:48.31,2:09:52.79,中文,,0,0,0,,后面那位同学？
Dialogue: 0,2:09:52.79,2:10:00.74,英文,,0,0,0,,So close. So on the swap line, it's not star that I want in front of the x and the y. It's instead?
Dialogue: 0,2:09:52.79,2:10:00.74,中文,,0,0,0,,很接近了。在 swap 那一行，我不需要在 x 和 y 前面加 *，而是加什么？
Dialogue: 0,2:10:00.74,2:10:03.26,英文,,0,0,0,,What's the other one? It's the ampersand.
Dialogue: 0,2:10:00.74,2:10:03.26,中文,,0,0,0,,另一个是什么？是 &。
Dialogue: 0,2:10:03.26,2:10:03.82,英文,,0,0,0,,Why?
Dialogue: 0,2:10:03.26,2:10:03.82,中文,,0,0,0,,为什么？
Dialogue: 0,2:10:03.82,2:10:16.75,英文,,0,0,0,,Because if I want to enable swap to go somewhere, just like Carter and I played this game with the mailboxes, I need to inform swap of the address of x and the address of y. And again, per the beginning of today's class, ampersand is the syntax via which we do that.
Dialogue: 0,2:10:03.82,2:10:16.75,中文,,0,0,0,,因为如果我想让 swap 函数能够访问到某个地方，就像我和 Carter 玩邮箱游戏一样，\N我需要告诉 swap 函数 x 的地址和 y 的地址。同样，根据今天课程开始的内容，& 就是我们用来实现这一点的语法。
Dialogue: 0,2:10:16.75,2:10:25.17,英文,,0,0,0,,So I add an ampersand here to get the address of x, ampersand here to get the address of y. And now this code lines up with the picture that Carter just helped us walk through.
Dialogue: 0,2:10:16.75,2:10:25.17,中文,,0,0,0,,这里加个“&”符号来获取 x 的地址，这里也加个“&”来获取 y 的地址。现在这段代码就和 Carter 刚才带我们看的那张图对应起来了。
Dialogue: 0,2:10:25.17,2:10:29.25,英文,,0,0,0,,And so when I run make swap here, I have a mistake.
Dialogue: 0,2:10:25.17,2:10:29.25,中文,,0,0,0,,当我运行 make swap 时，报错了。
Dialogue: 0,2:10:29.25,2:10:30.87,英文,,0,0,0,,Oh, what did I do wrong?
Dialogue: 0,2:10:29.25,2:10:30.87,中文,,0,0,0,,我做错了什么？
Dialogue: 0,2:10:30.87,2:10:34.40,英文,,0,0,0,,Not intentional, but I guess worth pointing out.
Dialogue: 0,2:10:30.87,2:10:34.40,中文,,0,0,0,,不是故意的，不过我觉得值得指出来。
Dialogue: 0,2:10:34.40,2:10:35.22,英文,,0,0,0,,I screwed up here.
Dialogue: 0,2:10:34.40,2:10:35.22,中文,,0,0,0,,我这里搞砸了。
Dialogue: 0,2:10:35.22,2:10:43.23,英文,,0,0,0,,It doesn't like ampersand x because of something on line 3, which is way early in the code.
Dialogue: 0,2:10:35.22,2:10:43.23,中文,,0,0,0,,它不喜欢“&x”，因为第三行有错误，而这行代码在很前面。
Dialogue: 0,2:10:43.23,2:10:47.92,英文,,0,0,0,,What did I screw up? Yeah, in the middle?
Dialogue: 0,2:10:43.23,2:10:47.92,中文,,0,0,0,,我搞砸了什么？ 是的，在中间吗？
Dialogue: 0,2:10:47.92,2:10:52.84,英文,,0,0,0,,Yeah, so this is why you should not copy-paste, even though it's necessary for things like function prototypes.
Dialogue: 0,2:10:47.92,2:10:52.84,中文,,0,0,0,,是的，这就是为什么不应该复制粘贴，即使对于函数原型之类的东西是必要的。
Dialogue: 0,2:10:52.84,2:10:56.24,英文,,0,0,0,,If I change swap at the bottom, I need to change its prototype.
Dialogue: 0,2:10:52.84,2:10:56.24,中文,,0,0,0,,如果我改变了底部的 swap，我需要改变它的原型。
Dialogue: 0,2:10:56.24,2:11:00.72,英文,,0,0,0,,So let me add the star there, add the star there, or just recopy-paste it at the top of the file.
Dialogue: 0,2:10:56.24,2:11:00.72,中文,,0,0,0,,所以让我在这里添加星号，在那里也添加星号，或者直接在文件顶部重新复制粘贴它。
Dialogue: 0,2:11:00.72,2:11:02.52,英文,,0,0,0,,Now let me do make swap again.
Dialogue: 0,2:11:00.72,2:11:02.52,中文,,0,0,0,,现在让我再次执行 make swap。
Dialogue: 0,2:11:02.52,2:11:03.98,英文,,0,0,0,,Let me now do dot slash swap.
Dialogue: 0,2:11:02.52,2:11:03.98,中文,,0,0,0,,现在让我执行 ./swap。
Dialogue: 0,2:11:03.98,2:11:06.63,英文,,0,0,0,,And I should now see x is 1, y is 2.
Dialogue: 0,2:11:03.98,2:11:06.63,中文,,0,0,0,,我现在应该看到 x 是 1，y 是 2。
Dialogue: 0,2:11:06.63,2:11:09.65,英文,,0,0,0,,And hopefully, x is 2, y is 1.
Dialogue: 0,2:11:06.63,2:11:09.65,中文,,0,0,0,,希望 x 是 2，y 是 1。
Dialogue: 0,2:11:09.65,2:11:10.81,英文,,0,0,0,,Which I now do.
Dialogue: 0,2:11:09.65,2:11:10.81,中文,,0,0,0,,现在确实如此。
Dialogue: 0,2:11:10.81,2:11:11.99,英文,,0,0,0,,So the logic is the same.
Dialogue: 0,2:11:10.81,2:11:11.99,中文,,0,0,0,,所以逻辑是一样的。
Dialogue: 0,2:11:11.99,2:11:13.09,英文,,0,0,0,,The algorithm is the same.
Dialogue: 0,2:11:11.99,2:11:13.09,中文,,0,0,0,,算法也是一样的。
Dialogue: 0,2:11:13.09,2:11:24.22,英文,,0,0,0,,All the week 0 stuff is the same, except now in week 4, you just have a bit more expressiveness via which you can tell the computer exactly what you want to manipulate and how.
Dialogue: 0,2:11:13.09,2:11:24.22,中文,,0,0,0,,所有第 0 周的内容都是一样的，只是现在在第 4 周，你可以通过更多的方式来告诉计算机你想要操作什么以及如何操作。
Dialogue: 0,2:11:24.22,2:11:29.50,英文,,0,0,0,,Any questions, then, on this technique here?
Dialogue: 0,2:11:24.22,2:11:29.50,中文,,0,0,0,,对这里的技术有什么问题吗？
Dialogue: 0,2:11:29.50,2:11:30.20,英文,,0,0,0,,No? All right.
Dialogue: 0,2:11:29.50,2:11:30.20,中文,,0,0,0,,没有？好的。
Dialogue: 0,2:11:30.20,2:11:33.12,英文,,0,0,0,,Well, when we fix this, there's still going to be problems.
Dialogue: 0,2:11:30.20,2:11:33.12,中文,,0,0,0,,即使我们修复了这个问题，仍然会有其他问题。
Dialogue: 0,2:11:33.12,2:11:40.52,英文,,0,0,0,,And just so you've seen some terms of art here, this is bad whenever you have two arrows pointing at one another, certainly if you might use and reuse more and more memory.
Dialogue: 0,2:11:33.12,2:11:40.52,中文,,0,0,0,,这里有一些专业术语，当你看到两个箭头互相指向时，这就不妙了，尤其是在你可能会反复使用更多内存的情况下。
Dialogue: 0,2:11:40.52,2:11:44.90,英文,,0,0,0,,And it turns out there's some terms of art that might suddenly now make sense, especially if you've programmed before.
Dialogue: 0,2:11:40.52,2:11:44.90,中文,,0,0,0,,事实证明，有些专业术语你可能突然就明白了，特别是如果你以前写过程序。
Dialogue: 0,2:11:44.90,2:11:50.58,英文,,0,0,0,,Bad things can happen by this design, but there's really only this kind of design because it's a finite amount of memory.
Dialogue: 0,2:11:44.90,2:11:50.58,中文,,0,0,0,,这种设计可能会导致问题，但实际上只有这种设计，因为内存是有限的。
Dialogue: 0,2:11:50.58,2:11:54.21,英文,,0,0,0,,So at some point, bad things are going to happen no matter what if a computer runs out of memory.
Dialogue: 0,2:11:50.58,2:11:54.21,中文,,0,0,0,,如果计算机内存耗尽，无论如何，在某些情况下都会出现问题。
Dialogue: 0,2:11:54.21,2:11:55.79,英文,,0,0,0,,So it's not that this was a poor decision.
Dialogue: 0,2:11:54.21,2:11:55.79,中文,,0,0,0,,这并不是一个糟糕的决定。
Dialogue: 0,2:11:55.79,2:11:59.65,英文,,0,0,0,,It's just sort of a necessary one, given finite amounts of memory in a computer.
Dialogue: 0,2:11:55.79,2:11:59.65,中文,,0,0,0,,考虑到计算机内存有限，这只是一个必要的选择。
Dialogue: 0,2:11:59.65,2:12:05.43,英文,,0,0,0,,But a heap overflow, so to speak, is when you actually overflow the heap and touch memory that you shouldn't up there.
Dialogue: 0,2:11:59.65,2:12:05.43,中文,,0,0,0,,但是，堆溢出，可以这么说，是当你真正溢出堆并触及到你不应该触及的内存时发生的。
Dialogue: 0,2:12:05.43,2:12:09.95,英文,,0,0,0,,Stack overflow is when you somehow overflow the stack and touch memory that you shouldn't down there.
Dialogue: 0,2:12:05.43,2:12:09.95,中文,,0,0,0,,栈溢出是指你以某种方式溢出栈并触及到你下面不应该触及的内存。
Dialogue: 0,2:12:09.95,2:12:12.69,英文,,0,0,0,,So with that said, these are really just problems that can happen.
Dialogue: 0,2:12:09.95,2:12:12.69,中文,,0,0,0,,也就是说，这些都只是可能发生的问题。
Dialogue: 0,2:12:12.69,2:12:16.61,英文,,0,0,0,,And they're specific incarnations of what are generally called buffer overflows.
Dialogue: 0,2:12:12.69,2:12:16.61,中文,,0,0,0,,它们是通常所说的缓冲区溢出的具体表现形式。
Dialogue: 0,2:12:16.61,2:12:23.15,英文,,0,0,0,,A buffer, like in the YouTube sense, is just like a chunk of memory that, in the case of YouTube, stores the next few seconds or minutes of video.
Dialogue: 0,2:12:16.61,2:12:23.15,中文,,0,0,0,,缓冲区，就像 YouTube 中的缓冲区一样，只是一块内存，在 YouTube 的情况下，它存储着接下来的几秒或几分钟的视频。
Dialogue: 0,2:12:23.15,2:12:31.62,英文,,0,0,0,,But generally speaking, a buffer is just a chunk of memory that the computer is using for some purpose, be it the stack, be it the heap, be it an array in the computer.
Dialogue: 0,2:12:23.15,2:12:31.62,中文,,0,0,0,,但一般来说，缓冲区只是一块计算机用于某种目的的内存，可以是栈、堆，也可以是计算机中的数组。
Dialogue: 0,2:12:31.62,2:12:37.27,英文,,0,0,0,,And so buffer overflows are what happens when you just have logical bugs in your code.
Dialogue: 0,2:12:31.62,2:12:37.27,中文,,0,0,0,,缓冲区溢出是指你的代码中存在逻辑错误时发生的情况。
Dialogue: 0,2:12:37.27,2:12:42.09,英文,,0,0,0,,But with these primitives now in mind, we wanted to conclude with the final revelations.
Dialogue: 0,2:12:37.27,2:12:42.09,中文,,0,0,0,,但考虑到这些基本概念，我们想以最终的启示来结束。
Dialogue: 0,2:12:42.09,2:12:44.91,英文,,0,0,0,,And that's how some functions like these here work.
Dialogue: 0,2:12:42.09,2:12:44.91,中文,,0,0,0,,这就是像这里的一些函数是如何工作的。
Dialogue: 0,2:12:44.91,2:12:50.27,英文,,0,0,0,,The other thing in the CS50 library, besides the typedef first quote unquote string, is, of course, all of these functions.
Dialogue: 0,2:12:44.91,2:12:50.27,中文,,0,0,0,,除了 typedef 中第一个用引号括起来的“string”之外，cs50 库中的另一个东西当然是所有这些函数。
Dialogue: 0,2:12:50.27,2:12:53.83,英文,,0,0,0,,And we give you these functions because, honestly, in C, it is hard.
Dialogue: 0,2:12:50.27,2:12:53.83,中文,,0,0,0,,我们给你提供这些函数是因为，说实话，在 C 语言中，这很难。
Dialogue: 0,2:12:53.83,2:12:54.65,英文,,0,0,0,,It's annoying.
Dialogue: 0,2:12:53.83,2:12:54.65,中文,,0,0,0,,这很烦人。
Dialogue: 0,2:12:54.65,2:12:55.35,英文,,0,0,0,,It's painful.
Dialogue: 0,2:12:54.65,2:12:55.35,中文,,0,0,0,,这很痛苦。
Dialogue: 0,2:12:55.35,2:12:58.53,英文,,0,0,0,,It's difficult to get user input correctly.
Dialogue: 0,2:12:55.35,2:12:58.53,中文,,0,0,0,,正确获取用户输入并非易事。
Dialogue: 0,2:12:58.53,2:13:04.43,英文,,0,0,0,,It's very easy, when you don't know how much the human's going to type, to write buggy code when it comes to it.
Dialogue: 0,2:12:58.53,2:13:04.43,中文,,0,0,0,,当你不知道用户会输入多少内容时，很容易写出有 bug 的代码。
Dialogue: 0,2:13:04.43,2:13:09.86,英文,,0,0,0,,And indeed, it's really hard to store it correctly without accidentally having some kind of buffer overflow.
Dialogue: 0,2:13:04.43,2:13:09.86,中文,,0,0,0,,而且，要正确存储输入内容而不意外地导致缓冲区溢出真的很难。
Dialogue: 0,2:13:09.86,2:13:12.70,英文,,0,0,0,,So for instance, let me show you a program here.
Dialogue: 0,2:13:09.86,2:13:12.70,中文,,0,0,0,,例如，让我给你看一个程序。
Dialogue: 0,2:13:12.70,2:13:14.30,英文,,0,0,0,,I'm going to go ahead and write this one from scratch.
Dialogue: 0,2:13:12.70,2:13:14.30,中文,,0,0,0,,我要从头开始写这个程序。
Dialogue: 0,2:13:14.30,2:13:17.20,英文,,0,0,0,,So let me go ahead and open a file called get.c.
Dialogue: 0,2:13:14.30,2:13:17.20,中文,,0,0,0,,让我打开一个名为 get.c 的文件。
Dialogue: 0,2:13:17.20,2:13:22.08,英文,,0,0,0,,Wherein I'm going to go ahead and mimic the idea of getting integers manually without the CS50 library.
Dialogue: 0,2:13:17.20,2:13:22.08,中文,,0,0,0,,在其中，我要模拟在没有 cs50 库的情况下手动获取整数的过程。
Dialogue: 0,2:13:22.08,2:13:24.59,英文,,0,0,0,,So I'm going to include standard io.h only.
Dialogue: 0,2:13:22.08,2:13:24.59,中文,,0,0,0,,所以我只包含 stdio.h。
Dialogue: 0,2:13:24.59,2:13:27.77,英文,,0,0,0,,I'm going to define main as not taking any command line arguments.
Dialogue: 0,2:13:24.59,2:13:27.77,中文,,0,0,0,,我要定义 main 函数，它不接受任何命令行参数。
Dialogue: 0,2:13:27.77,2:13:29.37,英文,,0,0,0,,And then I'm going to do something like this.
Dialogue: 0,2:13:27.77,2:13:29.37,中文,,0,0,0,,然后我会做这样的事情。
Dialogue: 0,2:13:29.37,2:13:32.11,英文,,0,0,0,,Give me a variable x with no value yet.
Dialogue: 0,2:13:29.37,2:13:32.11,中文,,0,0,0,,给我一个没有值的变量 x。
Dialogue: 0,2:13:32.11,2:13:34.37,英文,,0,0,0,,And normally, I would do something like get int.
Dialogue: 0,2:13:32.11,2:13:34.37,中文,,0,0,0,,通常，我会使用 get_int 函数。
Dialogue: 0,2:13:34.37,2:13:35.49,英文,,0,0,0,,But let me take that away.
Dialogue: 0,2:13:34.37,2:13:35.49,中文,,0,0,0,,但让我把它去掉。
Dialogue: 0,2:13:35.49,2:13:37.64,英文,,0,0,0,,No more training wheels for get int either.
Dialogue: 0,2:13:35.49,2:13:37.64,中文,,0,0,0,,get_int 函数也不再需要了。
Dialogue: 0,2:13:37.64,2:13:43.66,英文,,0,0,0,,So let me just define the int x. Let me then just print out something like,
Dialogue: 0,2:13:37.64,2:13:43.66,中文,,0,0,0,,让我只定义 int x。然后让我打印一些内容，
Dialogue: 0,2:13:43.66,2:13:48.46,英文,,0,0,0,,a prompt, and I'll just do x colon, just to make it obvious to the human what we're waiting for.
Dialogue: 0,2:13:43.66,2:13:48.46,中文,,0,0,0,,一个提示，我会写成 x:，这样用户就能清楚地知道我们在等待什么。
Dialogue: 0,2:13:48.46,2:13:51.88,英文,,0,0,0,,And now I'm going to use a built-in C function to get user input.
Dialogue: 0,2:13:48.46,2:13:51.88,中文,,0,0,0,,现在我将使用一个内置的 C 函数来获取用户输入。
Dialogue: 0,2:13:51.88,2:13:56.76,英文,,0,0,0,,I'm going to call a function called scanf, which sort of scans the user's keyboard for input.
Dialogue: 0,2:13:51.88,2:13:56.76,中文,,0,0,0,,我将调用一个名为 scanf 的函数，它会扫描用户的键盘输入。
Dialogue: 0,2:13:56.76,2:13:58.47,英文,,0,0,0,,I'm going to scan it for an integer.
Dialogue: 0,2:13:56.76,2:13:58.47,中文,,0,0,0,,我要扫描它以查找整数。
Dialogue: 0,2:13:58.47,2:14:02.09,英文,,0,0,0,,So just like printf, I'm going to use %i, because I expect an int.
Dialogue: 0,2:13:58.47,2:14:02.09,中文,,0,0,0,,所以就像 printf 一样，我将使用 %i，因为我期望一个 int 类型。
Dialogue: 0,2:14:02.09,2:14:07.87,英文,,0,0,0,,And then I want to tell scanf where to put the human's integer from the keyboard.
Dialogue: 0,2:14:02.09,2:14:07.87,中文,,0,0,0,,然后我想要告诉 scanf 从键盘输入的整数要存放在哪里。
Dialogue: 0,2:14:07.87,2:14:10.09,英文,,0,0,0,,It is not correct, though, to say x.
Dialogue: 0,2:14:07.87,2:14:10.09,中文,,0,0,0,,然而，说 x 是不正确的。
Dialogue: 0,2:14:10.09,2:14:12.91,英文,,0,0,0,,Because if I say x, I run into the same swap problem.
Dialogue: 0,2:14:10.09,2:14:12.91,中文,,0,0,0,,因为如果我说 x，我会遇到相同的交换问题。
Dialogue: 0,2:14:12.91,2:14:20.25,英文,,0,0,0,,scanf, no function, can change the value of x unless I pass it not by value but by reference.
Dialogue: 0,2:14:12.91,2:14:20.25,中文,,0,0,0,,scanf，任何函数，都不能改变 x 的值，除非我不是通过值传递，而是通过引用传递。
Dialogue: 0,2:14:20.25,2:14:22.06,英文,,0,0,0,,So we're back to our ampersand friend.
Dialogue: 0,2:14:20.25,2:14:22.06,中文,,0,0,0,,所以我们又回到了我们的“与”朋友这里。
Dialogue: 0,2:14:22.06,2:14:28.18,英文,,0,0,0,,And now it has a treasure map to the actual location of x and can therefore change it.
Dialogue: 0,2:14:22.06,2:14:28.18,中文,,0,0,0,,现在它有了一张藏宝图，可以找到 x 的实际位置，因此可以改变它。
Dialogue: 0,2:14:28.18,2:14:30.80,英文,,0,0,0,,And so now at the very end of this program, let me do something simple.
Dialogue: 0,2:14:28.18,2:14:30.80,中文,,0,0,0,,现在，在这个程序的最后，让我做一个简单的事情。
Dialogue: 0,2:14:30.80,2:14:34.94,英文,,0,0,0,,Let's just go ahead and print out with printf.
Dialogue: 0,2:14:30.80,2:14:34.94,中文,,0,0,0,,让我们继续用 printf 打印出来。
Dialogue: 0,2:14:34.94,2:14:41.71,英文,,0,0,0,,The value of x using %i, as always, plugging in x, not ampersand x. This is now week one stuff.
Dialogue: 0,2:14:34.94,2:14:41.71,中文,,0,0,0,,使用 %i 的 x 的值，一如既往地插入 x，而不是 &x。这已经是第一周的内容了。
Dialogue: 0,2:14:41.71,2:14:51.81,英文,,0,0,0,,I want to print the actual integer value of x. So the only change here is that instead of using getint, I'm now using this new function that, as of today, exists called scanf.
Dialogue: 0,2:14:41.71,2:14:51.81,中文,,0,0,0,,我想打印出 x 的实际整数值。 所以这里唯一的变化是，我没有使用 getint，而是使用了这个从今天开始存在的新函数 scanf。
Dialogue: 0,2:14:51.81,2:14:54.78,英文,,0,0,0,,So let me go ahead and run get.
Dialogue: 0,2:14:51.81,2:14:54.78,中文,,0,0,0,,让我继续运行 get。
Dialogue: 0,2:14:54.78,2:14:57.72,英文,,0,0,0,,Make get to create this program, dot slash get.
Dialogue: 0,2:14:54.78,2:14:57.72,中文,,0,0,0,,使用 make get 创建这个程序，./get。
Dialogue: 0,2:14:57.72,2:15:01.22,英文,,0,0,0,,And let's go ahead and type in a value for x, 50, Enter.
Dialogue: 0,2:14:57.72,2:15:01.22,中文,,0,0,0,,让我们继续输入 x 的值，50，回车。
Dialogue: 0,2:15:01.22,2:15:02.34,英文,,0,0,0,,And it just works.
Dialogue: 0,2:15:01.22,2:15:02.34,中文,,0,0,0,,它就能正常工作。
Dialogue: 0,2:15:02.34,2:15:05.62,英文,,0,0,0,,So it turns out, get int is pretty simple to implement.
Dialogue: 0,2:15:02.34,2:15:05.62,中文,,0,0,0,,所以事实证明，实现 getint 非常简单。
Dialogue: 0,2:15:05.62,2:15:07.37,英文,,0,0,0,,However, notice what does not work.
Dialogue: 0,2:15:05.62,2:15:07.37,中文,,0,0,0,,但是，请注意什么不起作用。
Dialogue: 0,2:15:07.37,2:15:11.03,英文,,0,0,0,,If I type in cat, for instance, cat gets converted to 0.
Dialogue: 0,2:15:07.37,2:15:11.03,中文,,0,0,0,,例如，如果我输入 cat，cat 会被转换为 0。
Dialogue: 0,2:15:11.03,2:15:14.61,英文,,0,0,0,,And meanwhile, get int, recall, will re-prompt the user.
Dialogue: 0,2:15:11.03,2:15:14.61,中文,,0,0,0,,同时，回想一下，getint 会重新提示用户。
Dialogue: 0,2:15:14.61,2:15:18.35,英文,,0,0,0,,If a human does not type an actual integer, you get automatically re-prompted.
Dialogue: 0,2:15:14.61,2:15:18.35,中文,,0,0,0,,如果用户没有输入实际的整数，你会被自动重新提示。
Dialogue: 0,2:15:18.35,2:15:22.98,英文,,0,0,0,,So that's one of the features we, for CS50, added to get int, just to make your programs more user-friendly.
Dialogue: 0,2:15:18.35,2:15:22.98,中文,,0,0,0,,所以这是我们为 cs50 添加到 getint 的功能之一，只是为了让你的程序更加用户友好。
Dialogue: 0,2:15:22.98,2:15:27.80,英文,,0,0,0,,But otherwise, getInt is pretty straightforward to re-implement using scanf.
Dialogue: 0,2:15:22.98,2:15:27.80,中文,,0,0,0,,但除此之外，用 scanf 重新实现 getInt 相当简单。
Dialogue: 0,2:15:27.80,2:15:30.24,英文,,0,0,0,,Unfortunately, that's not true for strings.
Dialogue: 0,2:15:27.80,2:15:30.24,中文,,0,0,0,,不幸的是，字符串却不行。
Dialogue: 0,2:15:30.24,2:15:37.88,英文,,0,0,0,,Because how do you know when you write your code what word the human is going to eventually type in, how long they're greeting, like hi is?
Dialogue: 0,2:15:30.24,2:15:37.88,中文,,0,0,0,,因为当你写代码的时候，你怎么知道用户最终会输入什么词，他们的问候语会有多长，比如“hi”？
Dialogue: 0,2:15:37.88,2:15:42.83,英文,,0,0,0,,If their name is David or Carter or anything else, you just don't know in advance how much memory you need.
Dialogue: 0,2:15:37.88,2:15:42.83,中文,,0,0,0,,如果他们的名字是 David 或 Carter 或其他任何东西，你事先根本不知道你需要多少内存。
Dialogue: 0,2:15:42.83,2:15:45.49,英文,,0,0,0,,So how might we do this with strings?
Dialogue: 0,2:15:42.83,2:15:45.49,中文,,0,0,0,,那么我们如何用字符串来做到这一点呢？
Dialogue: 0,2:15:45.49,2:15:49.15,英文,,0,0,0,,Well, let me go ahead and declare a string s. Although, you know what?
Dialogue: 0,2:15:45.49,2:15:49.15,中文,,0,0,0,,让我来声明一个string s。不过，你知道吗？
Dialogue: 0,2:15:49.15,2:15:53.39,英文,,0,0,0,,There's no CS50 library, so we do char star s today instead.
Dialogue: 0,2:15:49.15,2:15:53.39,中文,,0,0,0,,没有 cs50 库，所以我们今天用 char *s 代替。
Dialogue: 0,2:15:53.39,2:15:59.82,英文,,0,0,0,,And that gives me not a string per se, but a pointer that will point, presumably, to a string.
Dialogue: 0,2:15:53.39,2:15:59.82,中文,,0,0,0,,这给我的不是一个字符串本身，而是一个指针，它可能会指向一个字符串。
Dialogue: 0,2:15:59.82,2:16:01.90,英文,,0,0,0,,Ideally, I would use this, get string.
Dialogue: 0,2:15:59.82,2:16:01.90,中文,,0,0,0,,理想情况下，我会使用 get_string。
Dialogue: 0,2:16:01.90,2:16:04.18,英文,,0,0,0,,But again, we've taken that training wheel away.
Dialogue: 0,2:16:01.90,2:16:04.18,中文,,0,0,0,,但是，我们已经去掉了那个辅助轮了。
Dialogue: 0,2:16:04.18,2:16:09.26,英文,,0,0,0,,So now that I have a pointer s, suppose I prompt the human for a value for s, just like before.
Dialogue: 0,2:16:04.18,2:16:09.26,中文,,0,0,0,,所以现在我有一个指针 s，假设我像之前一样提示用户输入 s 的值。
Dialogue: 0,2:16:09.26,2:16:16.51,英文,,0,0,0,,Let me use scanf now and tell the user that I expect to read a string, percent s from the keyboard.
Dialogue: 0,2:16:09.26,2:16:16.51,中文,,0,0,0,,让我现在使用 scanf 并告诉用户我期望从键盘读取一个字符串，%s。
Dialogue: 0,2:16:16.51,2:16:19.61,英文,,0,0,0,,And store it in s. Now, this is subtle.
Dialogue: 0,2:16:16.51,2:16:19.61,中文,,0,0,0,,并将其存储在 s 中，这很微妙。
Dialogue: 0,2:16:19.61,2:16:28.20,英文,,0,0,0,,I don't technically need an ampersand here, even though I did for an int, and I would for a float, and a double, and a long, and a bool, and a char.
Dialogue: 0,2:16:19.61,2:16:28.20,中文,,0,0,0,,从技术上讲，我不需要在这里使用“&”符号，即使我之前对 int、float、double、long、bool 和 char 使用过。
Dialogue: 0,2:16:28.20,2:16:34.38,英文,,0,0,0,,Why do I not need an ampersand in this story to pass by reference?
Dialogue: 0,2:16:28.20,2:16:34.38,中文,,0,0,0,,为什么在这个例子中，我不需要用“&”符号来传递引用呢？
Dialogue: 0,2:16:34.38,2:16:36.22,英文,,0,0,0,,Because s is?
Dialogue: 0,2:16:34.38,2:16:36.22,中文,,0,0,0,,因为 s 是？
Dialogue: 0,2:16:36.22,2:16:37.30,英文,,0,0,0,,It's already an address.
Dialogue: 0,2:16:36.22,2:16:37.30,中文,,0,0,0,,它已经是一个地址了。
Dialogue: 0,2:16:37.30,2:16:38.82,英文,,0,0,0,,Again, strings are just special.
Dialogue: 0,2:16:37.30,2:16:38.82,中文,,0,0,0,,再说一次，字符串很特殊。
Dialogue: 0,2:16:38.82,2:16:41.01,英文,,0,0,0,,Strings now are always addresses.
Dialogue: 0,2:16:38.82,2:16:41.01,中文,,0,0,0,,字符串现在总是地址。
Dialogue: 0,2:16:41.01,2:16:43.87,英文,,0,0,0,,So you don't need to additionally add an ampersand here.
Dialogue: 0,2:16:41.01,2:16:43.87,中文,,0,0,0,,所以你不需要在这里额外添加“&”符号。
Dialogue: 0,2:16:43.87,2:16:45.77,英文,,0,0,0,,That's the only subtle difference here.
Dialogue: 0,2:16:43.87,2:16:45.77,中文,,0,0,0,,这是唯一细微的区别。
Dialogue: 0,2:16:45.77,2:16:55.22,英文,,0,0,0,,But now if I go ahead and print out at the very end what the value of s is using %s as before, this program looks like it's almost the same as the int version.
Dialogue: 0,2:16:45.77,2:16:55.22,中文,,0,0,0,,但现在，如果我在最后用 %s 打印出 s 的值，就像之前一样，这个程序看起来几乎和 int 版本一样。
Dialogue: 0,2:16:55.22,2:16:57.46,英文,,0,0,0,,But let's do make get.
Dialogue: 0,2:16:55.22,2:16:57.46,中文,,0,0,0,,但让我们来 `make get`。
Dialogue: 0,2:16:57.46,2:16:59.44,英文,,0,0,0,,And OK, so this is not good.
Dialogue: 0,2:16:57.46,2:16:59.44,中文,,0,0,0,,这可不太妙。
Dialogue: 0,2:16:59.44,2:17:01.80,英文,,0,0,0,,All right, so it doesn't like an initialized value.
Dialogue: 0,2:16:59.44,2:17:01.80,中文,,0,0,0,,看来它不喜欢未初始化的值。
Dialogue: 0,2:17:01.80,2:17:03.10,英文,,0,0,0,,So let me make it happy.
Dialogue: 0,2:17:01.80,2:17:03.10,中文,,0,0,0,,那我就让它满意。
Dialogue: 0,2:17:03.10,2:17:05.33,英文,,0,0,0,,I said earlier to always initialize my variable.
Dialogue: 0,2:17:03.10,2:17:05.33,中文,,0,0,0,,我之前说过，要始终初始化变量。
Dialogue: 0,2:17:05.33,2:17:07.99,英文,,0,0,0,,So let's initialize it to null so that at least something is there.
Dialogue: 0,2:17:05.33,2:17:07.99,中文,,0,0,0,,所以我们把它初始化为 null，至少要有个东西在那儿。
Dialogue: 0,2:17:07.99,2:17:10.09,英文,,0,0,0,,That's your good default value nowadays.
Dialogue: 0,2:17:07.99,2:17:10.09,中文,,0,0,0,,这就是现在默认的好方法。
Dialogue: 0,2:17:10.09,2:17:12.59,英文,,0,0,0,,Now if I do dot slash get, now we're good.
Dialogue: 0,2:17:10.09,2:17:12.59,中文,,0,0,0,,现在，如果我执行 `./get`，就没问题了。
Dialogue: 0,2:17:12.59,2:17:16.04,英文,,0,0,0,,And let me type in something like cat.
Dialogue: 0,2:17:12.59,2:17:16.04,中文,,0,0,0,,让我输入 `cat` 试试。
Dialogue: 0,2:17:16.04,2:17:19.10,英文,,0,0,0,,OK, cat is not x. Well, let me try another word.
Dialogue: 0,2:17:16.04,2:17:19.10,中文,,0,0,0,,`cat` 不等于 x。好吧，我试试别的词。
Dialogue: 0,2:17:19.10,2:17:20.46,英文,,0,0,0,,Maybe it's just cat is wrong.
Dialogue: 0,2:17:19.10,2:17:20.46,中文,,0,0,0,,也许 `cat` 就是不对。
Dialogue: 0,2:17:20.46,2:17:21.36,英文,,0,0,0,,Dog.
Dialogue: 0,2:17:20.46,2:17:21.36,中文,,0,0,0,,`dog`。
Dialogue: 0,2:17:21.36,2:17:22.94,英文,,0,0,0,,OK, let me try David.
Dialogue: 0,2:17:21.36,2:17:22.94,中文,,0,0,0,,我试试 `David`。
Dialogue: 0,2:17:22.94,2:17:24.40,英文,,0,0,0,,It just doesn't seem to be working.
Dialogue: 0,2:17:22.94,2:17:24.40,中文,,0,0,0,,好像就是不行。
Dialogue: 0,2:17:24.40,2:17:27.32,英文,,0,0,0,,Moreover, it's printing it as a zero.
Dialogue: 0,2:17:24.40,2:17:27.32,中文,,0,0,0,,而且，它打印出来是 0。
Dialogue: 0,2:17:27.32,2:17:30.79,英文,,0,0,0,,What, logically, though, is the bug here?
Dialogue: 0,2:17:27.32,2:17:30.79,中文,,0,0,0,,那么，逻辑上来说，这里的 bug 是什么呢？
Dialogue: 0,2:17:30.79,2:17:34.29,英文,,0,0,0,,scanf worked a moment ago for integers, but it's not working for strings.
Dialogue: 0,2:17:30.79,2:17:34.29,中文,,0,0,0,,`scanf` 刚才对整数有效，但对字符串就无效了。
Dialogue: 0,2:17:34.29,2:17:36.13,英文,,0,0,0,,And it seems to be forgetting c-a-t.
Dialogue: 0,2:17:34.29,2:17:36.13,中文,,0,0,0,,而且它似乎忘记了 c-a-t。
Dialogue: 0,2:17:36.13,2:17:37.19,英文,,0,0,0,,It's forgetting d-o-g.
Dialogue: 0,2:17:36.13,2:17:37.19,中文,,0,0,0,,它忘记 d-o-g 了。
Dialogue: 0,2:17:37.19,2:17:38.95,英文,,0,0,0,,It's forgetting d-a-v-i-d.
Dialogue: 0,2:17:37.19,2:17:38.95,中文,,0,0,0,,它忘记 d-a-v-i-d 了。
Dialogue: 0,2:17:38.95,2:17:40.97,英文,,0,0,0,,Why?
Dialogue: 0,2:17:38.95,2:17:40.97,中文,,0,0,0,,为什么？
Dialogue: 0,2:17:40.97,2:17:44.08,英文,,0,0,0,,What's happening here?
Dialogue: 0,2:17:40.97,2:17:44.08,中文,,0,0,0,,这里发生了什么？
Dialogue: 0,2:17:44.08,2:17:48.19,英文,,0,0,0,,Think back to our yellow pictures of memory.
Dialogue: 0,2:17:44.08,2:17:48.19,中文,,0,0,0,,回想一下我们之前看到的内存黄色图片。
Dialogue: 0,2:17:48.19,2:17:50.69,英文,,0,0,0,,Yeah?
Dialogue: 0,2:17:48.19,2:17:50.69,中文,,0,0,0,,是吗？
Dialogue: 0,2:17:50.69,2:17:54.81,英文,,0,0,0,,It might be reading just the null itself, because s is being initialized to null.
Dialogue: 0,2:17:50.69,2:17:54.81,中文,,0,0,0,,它可能只是在读取 null 本身，因为 s 被初始化为 null。
Dialogue: 0,2:17:54.81,2:17:58.29,英文,,0,0,0,,And what step have I forgotten from just a few minutes ago?
Dialogue: 0,2:17:54.81,2:17:58.29,中文,,0,0,0,,而我忘记了几分钟前讲过的哪一步？
Dialogue: 0,2:17:58.29,2:18:01.56,英文,,0,0,0,,What did I not actually request of the computer?
Dialogue: 0,2:17:58.29,2:18:01.56,中文,,0,0,0,,我没有向计算机请求什么？
Dialogue: 0,2:18:01.56,2:18:06.26,英文,,0,0,0,,like actual memory to store the CAT, the DOG, the DAVID, right?
Dialogue: 0,2:18:01.56,2:18:06.26,中文,,0,0,0,,比如实际内存来存储 CAT、DOG、DAVID，对吧？
Dialogue: 0,2:18:06.26,2:18:10.19,英文,,0,0,0,,There's nowhere have I asked the computer for some amount of memory.
Dialogue: 0,2:18:06.26,2:18:10.19,中文,,0,0,0,,我从来没有要求计算机分配内存。
Dialogue: 0,2:18:10.19,2:18:14.61,英文,,0,0,0,,And so technically, it might be reading it into some garbage location.
Dialogue: 0,2:18:10.19,2:18:14.61,中文,,0,0,0,,因此，从技术上讲，它可能正在将数据读入某个垃圾位置。
Dialogue: 0,2:18:14.61,2:18:16.25,英文,,0,0,0,,And that's really the problem here.
Dialogue: 0,2:18:14.61,2:18:16.25,中文,,0,0,0,,这就是问题所在。
Dialogue: 0,2:18:16.25,2:18:18.15,英文,,0,0,0,,S is initialized to null now.
Dialogue: 0,2:18:16.25,2:18:18.15,中文,,0,0,0,,现在 s 被初始化为 null。
Dialogue: 0,2:18:18.15,2:18:20.44,英文,,0,0,0,,And so in fact, it is printing 0 as null.
Dialogue: 0,2:18:18.15,2:18:20.44,中文,,0,0,0,,所以实际上，它打印 0 表示 null。
Dialogue: 0,2:18:20.44,2:18:23.40,英文,,0,0,0,,But I'm not seeing any of the other letters, because there was nowhere to put them.
Dialogue: 0,2:18:20.44,2:18:23.40,中文,,0,0,0,,但我没有看到任何其他字母，因为没有地方放它们。
Dialogue: 0,2:18:23.40,2:18:28.68,英文,,0,0,0,,C-A-T, D-O-G, D-A-V-I-D, because I didn't ask for 3 bytes, 4 bytes, 5 bytes, 100 bytes.
Dialogue: 0,2:18:23.40,2:18:28.68,中文,,0,0,0,,C-A-T、D-O-G、D-A-V-I-D，因为我没有要求分配 3 个字节、4 个字节、5 个字节、100 个字节。
Dialogue: 0,2:18:28.68,2:18:29.81,英文,,0,0,0,,There's no use of malloc.
Dialogue: 0,2:18:28.68,2:18:29.81,中文,,0,0,0,,没有使用 malloc。
Dialogue: 0,2:18:29.81,2:18:31.21,英文,,0,0,0,,There's no use of an array.
Dialogue: 0,2:18:29.81,2:18:31.21,中文,,0,0,0,,没有使用数组。
Dialogue: 0,2:18:31.21,2:18:35.45,英文,,0,0,0,,There's no memory allocated for anything other than the pointer itself.
Dialogue: 0,2:18:31.21,2:18:35.45,中文,,0,0,0,,除了指针本身之外，没有为任何东西分配内存。
Dialogue: 0,2:18:35.45,2:18:38.21,英文,,0,0,0,,And this is where, honestly, life gets hard with SCANIF.
Dialogue: 0,2:18:35.45,2:18:38.21,中文,,0,0,0,,老实说，这就是 SCANIF 困难的地方。
Dialogue: 0,2:18:38.21,2:18:40.74,英文,,0,0,0,,Like, I could solve this problem in a couple of ways.
Dialogue: 0,2:18:38.21,2:18:40.74,中文,,0,0,0,,比如，我可以通过几种方法解决这个问题。
Dialogue: 0,2:18:40.74,2:18:41.88,英文,,0,0,0,,Let me go ahead and do this.
Dialogue: 0,2:18:40.74,2:18:41.88,中文,,0,0,0,,让我继续，这样做。
Dialogue: 0,2:18:41.88,2:18:44.00,英文,,0,0,0,,Instead of declaring s to be a pointer,
Dialogue: 0,2:18:41.88,2:18:44.00,中文,,0,0,0,,不声明 s 为指针，
Dialogue: 0,2:18:44.00,2:18:48.64,英文,,0,0,0,,Let me declare s to actually be an array of four chars.
Dialogue: 0,2:18:44.00,2:18:48.64,中文,,0,0,0,,让我声明 s 实际上是一个包含四个字符的数组。
Dialogue: 0,2:18:48.64,2:18:51.62,英文,,0,0,0,,And now, let me go ahead and recompile the code.
Dialogue: 0,2:18:48.64,2:18:51.62,中文,,0,0,0,,现在，让我继续重新编译代码。
Dialogue: 0,2:18:51.62,2:18:55.64,英文,,0,0,0,,So make get dot slash get, and I'll type in cat now.
Dialogue: 0,2:18:51.62,2:18:55.64,中文,,0,0,0,,make get， ./get，然后输入 cat。
Dialogue: 0,2:18:55.64,2:18:56.84,英文,,0,0,0,,That now works.
Dialogue: 0,2:18:55.64,2:18:56.84,中文,,0,0,0,,现在可以了。
Dialogue: 0,2:18:56.84,2:18:57.78,英文,,0,0,0,,Why?
Dialogue: 0,2:18:56.84,2:18:57.78,中文,,0,0,0,,为什么？
Dialogue: 0,2:18:57.78,2:19:04.09,英文,,0,0,0,,Well, I'm allocating an explicit array of size 4, enough for a 1, 2, 3 letters plus a null character.
Dialogue: 0,2:18:57.78,2:19:04.09,中文,,0,0,0,,我分配了一个大小为 4 的显式数组，足以容纳 1、2、3 个字母和一个空字符。
Dialogue: 0,2:19:04.09,2:19:11.87,英文,,0,0,0,,Here's where, to someone's question earlier, it turns out that in some contexts, you can treat arrays as though they are pointers themselves.
Dialogue: 0,2:19:04.09,2:19:11.87,中文,,0,0,0,,对于之前有人提出的问题，事实证明，在某些情况下，可以将数组视为指针本身。
Dialogue: 0,2:19:11.87,2:19:14.06,英文,,0,0,0,,C will sort of do the conversion for you.
Dialogue: 0,2:19:11.87,2:19:14.06,中文,,0,0,0,,C 语言会帮你进行转换。
Dialogue: 0,2:19:14.06,2:19:17.68,英文,,0,0,0,,But for now, just assume that S is just an array of size 4.
Dialogue: 0,2:19:14.06,2:19:17.68,中文,,0,0,0,,但现在，假设 S 只是一个大小为 4 的数组。
Dialogue: 0,2:19:17.68,2:19:22.24,英文,,0,0,0,,And if you pass it into scanf, that's like a treasure map that leads to those 4 bytes.
Dialogue: 0,2:19:17.68,2:19:22.24,中文,,0,0,0,,如果将它传递给 scanf，它就像一张藏宝图，指向那 4 个字节。
Dialogue: 0,2:19:22.24,2:19:27.61,英文,,0,0,0,,So scanf can now successfully fill it with CAT, DOG, but,
Dialogue: 0,2:19:22.24,2:19:27.61,中文,,0,0,0,,所以 scanf 现在可以用 CAT、DOG 成功填充它，
Dialogue: 0,2:19:27.61,2:19:29.27,英文,,0,0,0,,But let's try this again.
Dialogue: 0,2:19:27.61,2:19:29.27,中文,,0,0,0,,但是，让我们再试一次。
Dialogue: 0,2:19:29.27,2:19:30.67,英文,,0,0,0,,Let's type in David.
Dialogue: 0,2:19:29.27,2:19:30.67,中文,,0,0,0,,让我们输入 David。
Dialogue: 0,2:19:30.67,2:19:32.93,英文,,0,0,0,,And here, OK, we got lucky.
Dialogue: 0,2:19:30.67,2:19:32.93,中文,,0,0,0,,这里，我们很幸运。
Dialogue: 0,2:19:32.93,2:19:35.79,英文,,0,0,0,,But I technically touched memory that I should not.
Dialogue: 0,2:19:32.93,2:19:35.79,中文,,0,0,0,,但严格来说，我触碰了我不应该触碰的内存。
Dialogue: 0,2:19:35.79,2:19:44.05,英文,,0,0,0,,And in fact, if I typed in a long enough string, and I don't think I could do it very easily without typing this thousands or hundreds of times, still OK.
Dialogue: 0,2:19:35.79,2:19:44.05,中文,,0,0,0,,事实上，如果我输入一个足够长的字符串，我认为我不可能轻易地做到这一点，除非输入成百上千次，但仍然可以。
Dialogue: 0,2:19:44.05,2:19:47.37,英文,,0,0,0,,But you'll notice that it's forgotten the rest of it now.
Dialogue: 0,2:19:44.05,2:19:47.37,中文,,0,0,0,,但你会注意到它现在已经忘记了剩下的内容。
Dialogue: 0,2:19:47.37,2:19:52.24,英文,,0,0,0,,So somewhere we went beyond the boundary of the array, and we just don't have enough storage space for that entire thing.
Dialogue: 0,2:19:47.37,2:19:52.24,中文,,0,0,0,,所以我们在某个地方超出了数组的边界，我们没有足够的存储空间来存放整个东西。
Dialogue: 0,2:19:52.24,2:19:53.40,英文,,0,0,0,,So what do you do in your program?
Dialogue: 0,2:19:52.24,2:19:53.40,中文,,0,0,0,,那你在你的程序中怎么做？
Dialogue: 0,2:19:53.40,2:20:00.59,英文,,0,0,0,,If you don't know how long the person's name or the animal name is going to be, what do you do? 40, 400, 4,000, 40,000?
Dialogue: 0,2:19:53.40,2:20:00.59,中文,,0,0,0,,如果你不知道这个人的名字或动物的名字会有多长，你要怎么做？40、400、4000、40000？
Dialogue: 0,2:20:00.59,2:20:03.01,英文,,0,0,0,,At some point, you have to draw a line in the sand.
Dialogue: 0,2:20:00.59,2:20:03.01,中文,,0,0,0,,在某个时候，你必须划清界限。
Dialogue: 0,2:20:03.01,2:20:08.91,英文,,0,0,0,,And that's why getting user input is so annoying in a language like C. And that's why getString exists.
Dialogue: 0,2:20:03.01,2:20:08.91,中文,,0,0,0,,这就是为什么在 C 语言中获取用户输入是如此烦人的原因。这也是 get_string 存在的原因。
Dialogue: 0,2:20:08.91,2:20:14.84,英文,,0,0,0,,What we do, if you're curious, is we look at the user's input, and we take baby steps. We look at it one, two, three.
Dialogue: 0,2:20:08.91,2:20:14.84,中文,,0,0,0,,如果你好奇的话，我们会查看用户的输入，然后慢慢地进行。我们一个一个地看，两个，三个。
Dialogue: 0,2:20:14.84,2:20:35.73,英文,,0,0,0,,I'm going to show you how to do that in a minute. Honestly, if you all had to do that in week one, my god, like, we couldn't even write hello world anymore.
Dialogue: 0,2:20:14.84,2:20:35.73,中文,,0,0,0,,我马上就告诉你 چطور 做。老实说，如果你们第一周就要做这个，我的天哪，我们就不能写“hello world”了。
Dialogue: 0,2:20:35.73,2:20:38.57,英文,,0,0,0,,And so that's why these training wheels exist, at least early on.
Dialogue: 0,2:20:35.73,2:20:38.57,中文,,0,0,0,,所以这就是为什么这些辅助轮至少在早期存在的原因。
Dialogue: 0,2:20:38.57,2:20:43.81,英文,,0,0,0,,And that's why in higher level languages, like in Python, you don't have to do this at all.
Dialogue: 0,2:20:38.57,2:20:43.81,中文,,0,0,0,,这就是为什么在更高级的语言中，比如 Python，你根本不需要这样做。
Dialogue: 0,2:20:43.81,2:20:46.03,英文,,0,0,0,,It just works as you'd expect.
Dialogue: 0,2:20:43.81,2:20:46.03,中文,,0,0,0,,它就像你期望的那样工作。
Dialogue: 0,2:20:46.03,2:20:47.50,英文,,0,0,0,,So what more can we do?
Dialogue: 0,2:20:46.03,2:20:47.50,中文,,0,0,0,,那么我们还能做些什么呢？
Dialogue: 0,2:20:47.50,2:20:57.92,英文,,0,0,0,,Well, you'll see in problem set 4 this coming week, if I open up an example like this, phonebook.c, you'll see that you can manipulate files now, that you have a vocabulary for pointers.
Dialogue: 0,2:20:47.50,2:20:57.92,中文,,0,0,0,,在本周的问题集 4 中你将会看到，如果我打开像这样的例子 phonebook.c，你会看到你现在可以操作文件了，你有了指针的词汇表。
Dialogue: 0,2:20:57.92,2:21:02.13,英文,,0,0,0,,It's going to be new quickly, but here we have an example of how.
Dialogue: 0,2:20:57.92,2:21:02.13,中文,,0,0,0,,这将很快成为新的内容，但这里我们有一个如何做到的例子。
Dialogue: 0,2:21:02.13,2:21:07.95,英文,,0,0,0,,I have a program using some familiar libraries here. But as I claim in my comment, this saves names and numbers to a CSV file.
Dialogue: 0,2:21:02.13,2:21:07.95,中文,,0,0,0,,我这里有一个程序使用了一些熟悉的库。但正如我在注释中所说的，这会将姓名和电话号码保存到 CSV 文件中。
Dialogue: 0,2:21:07.95,2:21:14.57,英文,,0,0,0,,All of my examples thus far, I type in some words, I type in some names and some phone numbers, and they disappear because we only store them in memory.
Dialogue: 0,2:21:07.95,2:21:14.57,中文,,0,0,0,,到目前为止，在我所有的例子中，我输入一些单词，一些姓名和一些电话号码，然后它们就消失了，因为我们只将它们存储在内存中。
Dialogue: 0,2:21:14.57,2:21:23.81,英文,,0,0,0,,But if you want to store data in like a CSV file, comma, separated values, which is like a simple spreadsheet like Excel and Apple Numbers and Google Sheets can open, you can actually do this yourself.
Dialogue: 0,2:21:14.57,2:21:23.81,中文,,0,0,0,,但是如果你想把数据存储在像 CSV 文件、逗号分隔值这样的文件中，\N就像 Excel、Apple Numbers 和 Google Sheets 这样的简单电子表格可以打开一样，你实际上可以自己做。
Dialogue: 0,2:21:23.81,2:21:28.79,英文,,0,0,0,,So just as a teaser for this week, here on line 9, I'm using a new data type, not a CS50 thing.
Dialogue: 0,2:21:23.81,2:21:28.79,中文,,0,0,0,,所以作为本周的预告，在第 9 行，我使用了一种新的数据类型，不是 cs50 的东西。
Dialogue: 0,2:21:28.79,2:21:30.85,英文,,0,0,0,,This is a C thing called file.
Dialogue: 0,2:21:28.79,2:21:30.85,中文,,0,0,0,,这是一个 C 语言中的东西，叫做 file。
Dialogue: 0,2:21:30.85,2:21:34.44,英文,,0,0,0,,But if you want to manipulate files, you need to use addresses, that is pointers.
Dialogue: 0,2:21:30.85,2:21:34.44,中文,,0,0,0,,但是如果你想操作文件，你需要使用地址，也就是指针。
Dialogue: 0,2:21:34.44,2:21:42.30,英文,,0,0,0,,So here is me creating a variable called file that's going to point to an actual file on the hard drive, on the server, or your Mac, or PC.
Dialogue: 0,2:21:34.44,2:21:42.30,中文,,0,0,0,,这里我创建了一个叫做 file 的变量，它指向硬盘、服务器、Mac 或 PC 上的一个实际文件。
Dialogue: 0,2:21:42.30,2:21:45.66,英文,,0,0,0,,fopen is going to be a new function you'll use that will open a file.
Dialogue: 0,2:21:42.30,2:21:45.66,中文,,0,0,0,,fopen 是一个你会用到的新函数，它可以打开一个文件。
Dialogue: 0,2:21:45.66,2:21:49.26,英文,,0,0,0,,And it will return, effectively, a pointer thereto in memory.
Dialogue: 0,2:21:45.66,2:21:49.26,中文,,0,0,0,,它会返回一个指向内存中该文件的指针。
Dialogue: 0,2:21:49.26,2:21:51.58,英文,,0,0,0,,The file name I want to open is phonebook.csv.
Dialogue: 0,2:21:49.26,2:21:51.58,中文,,0,0,0,,我要打开的文件名是 phonebook.csv。
Dialogue: 0,2:21:51.58,2:21:54.22,英文,,0,0,0,,And in this example, it's going to be append mode.
Dialogue: 0,2:21:51.58,2:21:54.22,中文,,0,0,0,,在这个例子中，它将使用追加模式。
Dialogue: 0,2:21:54.22,2:21:57.94,英文,,0,0,0,,It will keep allowing me to add more and more names and numbers to this file.
Dialogue: 0,2:21:54.22,2:21:57.94,中文,,0,0,0,,它可以让我在这个文件中不断添加越来越多的姓名和号码。
Dialogue: 0,2:21:57.94,2:22:01.62,英文,,0,0,0,,Here's some old getString stuff, because I'm not going to reinvent getString with scanf.
Dialogue: 0,2:21:57.94,2:22:01.62,中文,,0,0,0,,这里有一些旧的 get_string 的东西，因为我不打算用 scanf 来重新发明 get_string。
Dialogue: 0,2:22:01.62,2:22:03.90,英文,,0,0,0,,But down here is a slightly new function.
Dialogue: 0,2:22:01.62,2:22:03.90,中文,,0,0,0,,但下面是一个稍微有点新的函数。
Dialogue: 0,2:22:03.90,2:22:05.54,英文,,0,0,0,,It's not printf, but fprintf.
Dialogue: 0,2:22:03.90,2:22:05.54,中文,,0,0,0,,它不是 printf，而是 fprintf。
Dialogue: 0,2:22:05.54,2:22:09.79,英文,,0,0,0,,And it turns out it's very easy to print things not to the screen, but to a file with fprintf.
Dialogue: 0,2:22:05.54,2:22:09.79,中文,,0,0,0,,事实证明，用 fprintf 将内容打印到文件而不是屏幕上非常容易。
Dialogue: 0,2:22:09.79,2:22:11.55,英文,,0,0,0,,And it takes an additional argument.
Dialogue: 0,2:22:09.79,2:22:11.55,中文,,0,0,0,,它需要一个额外的参数。
Dialogue: 0,2:22:11.55,2:22:16.45,英文,,0,0,0,,Instead of starting with the quoted string, you'll have to say what file you want to write to.
Dialogue: 0,2:22:11.55,2:22:16.45,中文,,0,0,0,,你必须先说明要写入哪个文件，而不是以带引号的字符串开头。
Dialogue: 0,2:22:16.45,2:22:23.57,英文,,0,0,0,,And fprintf will figure out how to get the bits into that file, passing in something like name, comma, number.
Dialogue: 0,2:22:16.45,2:22:23.57,中文,,0,0,0,,fprintf 会算出如何将数据传入该文件，传入类似姓名、逗号、号码之类的内容。
Dialogue: 0,2:22:23.57,2:22:25.91,英文,,0,0,0,,So if I run this somewhat quickly here.
Dialogue: 0,2:22:23.57,2:22:25.91,中文,,0,0,0,,如果我快速运行一下这个程序。
Dialogue: 0,2:22:25.91,2:22:26.97,英文,,0,0,0,,Let me do this.
Dialogue: 0,2:22:25.91,2:22:26.97,中文,,0,0,0,,让我这样做。
Dialogue: 0,2:22:26.97,2:22:31.62,英文,,0,0,0,,Let me pre-create a file called phonebook.csv.
Dialogue: 0,2:22:26.97,2:22:31.62,中文,,0,0,0,,让我预先创建一个名为 phonebook.csv 的文件。
Dialogue: 0,2:22:31.62,2:22:38.06,英文,,0,0,0,,And in phonebook.csv, I'm going to create a temporary row here, name, comma, number, just so that there's something in this file.
Dialogue: 0,2:22:31.62,2:22:38.06,中文,,0,0,0,,在 phonebook.csv 中，我要创建一个临时的行，姓名、逗号、号码，这样这个文件里就有点东西了。
Dialogue: 0,2:22:38.06,2:22:42.08,英文,,0,0,0,,And now let me go ahead and do this and split my screen here.
Dialogue: 0,2:22:38.06,2:22:42.08,中文,,0,0,0,,现在让我继续，把屏幕分开。
Dialogue: 0,2:22:42.08,2:22:48.89,英文,,0,0,0,,If I have phonebook.csv on the right and phonebook.c on the left, let me compile, make phonebook,
Dialogue: 0,2:22:42.08,2:22:48.89,中文,,0,0,0,,如果右边是 phonebook.csv，左边是 phonebook.c，让我编译一下，make phonebook，
Dialogue: 0,2:22:48.89,2:22:51.59,英文,,0,0,0,,which is the C version, dot slash phonebook.
Dialogue: 0,2:22:48.89,2:22:51.59,中文,,0,0,0,,这是 C 语言版本，./phonebook。
Dialogue: 0,2:22:51.59,2:22:54.41,英文,,0,0,0,,And now I'm prompted for a name and a number. So I'll type in David.
Dialogue: 0,2:22:51.59,2:22:54.41,中文,,0,0,0,,它现在提示我输入姓名和号码，我输入 David。
Dialogue: 0,2:22:54.41,2:23:03.18,英文,,0,0,0,,And then, for instance, plus 1, 949, what is it, 4682750, Enter.
Dialogue: 0,2:22:54.41,2:23:03.18,中文,,0,0,0,,然后，比如，加 1, 949，是多少来着，468-2750，回车。
Dialogue: 0,2:23:03.18,2:23:04.12,英文,,0,0,0,,Bug.
Dialogue: 0,2:23:03.18,2:23:04.12,中文,,0,0,0,,出错了。
Dialogue: 0,2:23:04.12,2:23:05.16,英文,,0,0,0,,Pretend that didn't happen.
Dialogue: 0,2:23:04.12,2:23:05.16,中文,,0,0,0,,假装没发生过。
Dialogue: 0,2:23:05.16,2:23:07.10,英文,,0,0,0,,I forgot to hit Enter in the file.
Dialogue: 0,2:23:05.16,2:23:07.10,中文,,0,0,0,,我忘了在文件中按回车键。
Dialogue: 0,2:23:07.10,2:23:08.81,英文,,0,0,0,,So let's do this again.
Dialogue: 0,2:23:07.10,2:23:08.81,中文,,0,0,0,,我们再来一遍。
Dialogue: 0,2:23:08.81,2:23:21.06,英文,,0,0,0,,If I run the program again, David, and plus 1, 9, 4, 9, 4, 6, 8, 2, 7, 5, 0, Enter, it's been saved now to the file.
Dialogue: 0,2:23:08.81,2:23:21.06,中文,,0,0,0,,如果我再次运行程序，David，加 1, 9, 4, 9, 4, 6, 8, 2, 7, 5, 0，回车，它现在已经保存到文件中了。
Dialogue: 0,2:23:21.06,2:23:23.44,英文,,0,0,0,,And if I close this file.
Dialogue: 0,2:23:21.06,2:23:23.44,中文,,0,0,0,,如果我关闭这个文件。
Dialogue: 0,2:23:23.44,2:23:29.96,英文,,0,0,0,,And I reopen code of phonebook.csv, you'll see that the file is persisting.
Dialogue: 0,2:23:23.44,2:23:29.96,中文,,0,0,0,,然后我重新打开 phonebook.csv，你会看到文件是持久的。
Dialogue: 0,2:23:29.96,2:23:36.32,英文,,0,0,0,,And if I downloaded this to my Mac or my PC, I could double-click the CSV file, and voila, Excel would open up, or Apple Numbers, or the like.
Dialogue: 0,2:23:29.96,2:23:36.32,中文,,0,0,0,,如果我把它下载到我的 Mac 或 PC 上，我可以双击 CSV 文件，然后，Excel 或 Apple Numbers 类似程序就会打开它。
Dialogue: 0,2:23:36.32,2:23:39.12,英文,,0,0,0,,And I've actually created an actual CSV file.
Dialogue: 0,2:23:36.32,2:23:39.12,中文,,0,0,0,,我实际上创建了一个真实的 CSV 文件。
Dialogue: 0,2:23:39.12,2:23:43.90,英文,,0,0,0,,If you're smiling because I keep repeating my phone number out loud, I would encourage you to call or text that number sometime.
Dialogue: 0,2:23:39.12,2:23:43.90,中文,,0,0,0,,如果你因为我一直大声重复我的电话号码而笑，我鼓励你找个时间打这个号码或发短信。
Dialogue: 0,2:23:43.90,2:23:46.12,英文,,0,0,0,,It might very well be an Easter egg of sorts.
Dialogue: 0,2:23:43.90,2:23:46.12,中文,,0,0,0,,它很可能是一个彩蛋之类的。
Dialogue: 0,2:23:46.12,2:23:52.29,英文,,0,0,0,,But via these functions here do we have now the ability to write files, input and output.
Dialogue: 0,2:23:46.12,2:23:52.29,中文,,0,0,0,,但是通过这些函数，我们现在就可以读写文件了，输入和输出。
Dialogue: 0,2:23:52.29,2:23:58.75,英文,,0,0,0,,And among the goals, then, for this week, as we'll see, are to actually play with images in the spirit of something like Instagram filters or the like.
Dialogue: 0,2:23:52.29,2:23:58.75,中文,,0,0,0,,我们这周的目标之一是，就像我们会看到的，用类似 Instagram 滤镜的方式来处理图像。
Dialogue: 0,2:23:58.75,2:24:10.49,英文,,0,0,0,,And we'll introduce you, for instance, to a file format called BMPs, which, to come full circle to the start of class, are just maps of bits, but more than just single bits for white and black, but rather colorful patterns as well.
Dialogue: 0,2:23:58.75,2:24:10.49,中文,,0,0,0,,我们会向你介绍一种叫做 BMP 的文件格式，\N它就像我们在课程开始时说的那样，只是比特的映射，但不仅仅是表示黑白的单个比特，还有彩色图案。
Dialogue: 0,2:24:10.49,2:24:13.79,英文,,0,0,0,,And we'll give you images like this of the Weeks Bridge here across the river at Harvard.
Dialogue: 0,2:24:10.49,2:24:13.79,中文,,0,0,0,,我们会给你看一些像这样的图片，哈佛河对岸的 Weeks Bridge。
Dialogue: 0,2:24:13.79,2:24:18.32,英文,,0,0,0,,And you've run, after writing your own code in C and understanding how
Dialogue: 0,2:24:13.79,2:24:18.32,中文,,0,0,0,,在你用 C 语言编写了自己的代码，并了解了
Dialogue: 0,2:24:18.32,2:24:20.10,英文,,0,0,0,,The data is stored in the computer's memory.
Dialogue: 0,2:24:18.32,2:24:20.10,中文,,0,0,0,,数据是如何存储在计算机内存中之后。
Dialogue: 0,2:24:20.10,2:24:25.72,英文,,0,0,0,,You'll be able to apply your own Instagram-like filters to make things grayscale instead, or sepia in this case.
Dialogue: 0,2:24:20.10,2:24:25.72,中文,,0,0,0,,你就可以应用你自己的类似 Instagram 的滤镜，让图片变成灰度，或者像这样变成棕褐色。
Dialogue: 0,2:24:25.72,2:24:28.90,英文,,0,0,0,,You can even flip the bits around so that the thing is a mirror image.
Dialogue: 0,2:24:25.72,2:24:28.90,中文,,0,0,0,,你甚至可以翻转这些位，使图像成为镜像。
Dialogue: 0,2:24:28.90,2:24:30.65,英文,,0,0,0,,You can blur things further.
Dialogue: 0,2:24:28.90,2:24:30.65,中文,,0,0,0,,你还可以进一步模糊图像。
Dialogue: 0,2:24:30.65,2:24:37.57,英文,,0,0,0,,Or if you really are feeling more comfortable, you can even write code that finds the edges of the image and creates works of art like these.
Dialogue: 0,2:24:30.65,2:24:37.57,中文,,0,0,0,,或者，如果你真的觉得更舒服，你甚至可以编写代码来查找图像的边缘并创作像这样的艺术作品。
Dialogue: 0,2:24:37.57,2:24:39.87,英文,,0,0,0,,So all that and more in problem set four.
Dialogue: 0,2:24:37.57,2:24:39.87,中文,,0,0,0,,所有这些以及更多内容都在问题集四中。
Dialogue: 0,2:24:39.87,2:24:41.13,英文,,0,0,0,,We will see you next time.
Dialogue: 0,2:24:39.87,2:24:41.13,中文,,0,0,0,,我们下次再见。
