[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1920
PlayResY: 1080

[Aegisub Project Garbage]
Audio File: D:/python_code/video_tool/result/CS50x 2023 - Lecture 3 - Algorithms.mp4
Video File: D:/python_code/video_tool/result/CS50x 2023 - Lecture 3 - Algorithms.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.500000
Scroll Position: 3556
Active Line: 3563
Video Position: 170334

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.99999,1.99999,2,11,11,11,1
Style: 英文,Arial,29,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1.33333,1.33333,2,11,11,11,1
Style: 中文,微软雅黑,38,&H0029EEF1,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1.99999,1.99999,2,11,11,45,1
Style: 中文大字幕,Arial,38,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.99999,1.99999,2,11,11,11,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:01:13.05,0:01:15.43,英文,,0,0,0,,All right, this is CS50.
Dialogue: 0,0:01:15.43,0:01:21.40,英文,,0,0,0,,And this is week three already, wherein we'll take a look back, actually, at week zero, where we first began.
Dialogue: 0,0:01:21.40,0:01:24.92,英文,,0,0,0,,And in week zero, recall that everything was very intuitive, in a sense.
Dialogue: 0,0:01:24.92,0:01:28.04,英文,,0,0,0,,We talked not just about representation of information, but algorithms.
Dialogue: 0,0:01:28.04,0:01:30.44,英文,,0,0,0,,And we talked about tearing a phone book again and again.
Dialogue: 0,0:01:30.44,0:01:32.76,英文,,0,0,0,,And that somehow got us to a better solution.
Dialogue: 0,0:01:32.76,0:01:41.69,英文,,0,0,0,,But today, we'll try to start formalizing some of those ideas and capturing some of those same ideas, not in pseudocode just yet, but in actual code as well.
Dialogue: 0,0:01:41.69,0:01:48.37,英文,,0,0,0,,But we'll also consider the efficiency of those algorithms, like just how good, how well-designed our algorithms actually are.
Dialogue: 0,0:01:48.37,0:02:01.84,英文,,0,0,0,,And if you recall, when we did the phone book example, wherein I first had an algorithm searching one page at a time, and then second went two pages at a time, and then third started tearing the thing in half, recall that we, with a wave of the hand, kind of analyzed it as follows.
Dialogue: 0,0:02:01.84,0:02:13.43,英文,,0,0,0,,We propose that if the x-axis here is the size of the problem, like number of pages in a phone book, and the y-axis is the time required to solve the problem in seconds, minutes, page tears, whatever your unit of measure is, recall that the first algorithm was this straight line,
Dialogue: 0,0:02:13.43,0:02:23.43,英文,,0,0,0,,such that if you had n pages in the phone book, it might have this slope of n. And there's this one-to-one relationship between pages and tears.
Dialogue: 0,0:02:23.43,0:02:31.15,英文,,0,0,0,,Two pages at a time, of course, was twice as fast, but still really the same shape, the yellow line here indicating that, yeah, it's n over 2.
Dialogue: 0,0:02:31.15,0:02:33.57,英文,,0,0,0,,Maybe plus 1 if you have to double back, as we discussed.
Dialogue: 0,0:02:33.57,0:02:38.51,英文,,0,0,0,,But it's really still fundamentally the same algorithm, one or two pages at a time.
Dialogue: 0,0:02:38.51,0:02:45.66,英文,,0,0,0,,But the third algorithm, recall, was this one here in green, where we called it logarithmic in terms of how fast or how slow it was.
Dialogue: 0,0:02:45.66,0:02:56.67,英文,,0,0,0,,And indeed, the implication of this algorithm was that we could even double the size of the phone book, and no big deal, one additional page tear, and we take yet another 1,000-page byte out of the phone book.
Dialogue: 0,0:02:56.67,0:03:01.71,英文,,0,0,0,,We'll revisit some of these ideas, formalize them a bit, but also translate some of them ultimately to code.
Dialogue: 0,0:03:01.71,0:03:07.57,英文,,0,0,0,,And all of that now is possible because we have this lower level understanding, perhaps, of what's actually inside of your computer.
Dialogue: 0,0:03:07.57,0:03:10.33,英文,,0,0,0,,This, of course, is your computer's RAM, or memory.
Dialogue: 0,0:03:10.33,0:03:15.41,英文,,0,0,0,,And recall that if we kind of start to abstract this away, your computer's memory is really just a grid of bytes.
Dialogue: 0,0:03:15.41,0:03:17.85,英文,,0,0,0,,In fact, we don't have to look at the hardware anymore.
Dialogue: 0,0:03:17.85,0:03:22.75,英文,,0,0,0,,And we looked at a grid of bytes like this, whereby each of these bytes could be used to store
Dialogue: 0,0:03:22.75,0:03:27.52,英文,,0,0,0,,A char, an int, a long, or even an entire string at that.
Dialogue: 0,0:03:27.52,0:03:30.30,英文,,0,0,0,,But let's focus perhaps just on a subset of this.
Dialogue: 0,0:03:30.30,0:03:34.82,英文,,0,0,0,,Because last week, of course, we emphasized really arrays, storing things in arrays.
Dialogue: 0,0:03:34.82,0:03:44.78,英文,,0,0,0,,And that allowed us to start storing entire strings, sequences of characters, and even arrays of integers if we wanted to have multiple ones and not just Multiple variables as well.
Dialogue: 0,0:03:44.78,0:03:55.89,英文,,0,0,0,,But the catch is that if you look inside of an array in the computer's memory, and for instance, suppose these integers here are stored, it's pretty easy for us humans to glance at this and immediately find the number 50.
Dialogue: 0,0:03:55.89,0:03:59.70,英文,,0,0,0,,You sort of have this bird's eye view from where you're seated of everything on the screen.
Dialogue: 0,0:03:59.70,0:04:02.62,英文,,0,0,0,,And so it's pretty obvious how you get to the number 50.
Dialogue: 0,0:04:02.62,0:04:06.70,英文,,0,0,0,,But in the world of computers, of course, it turns out that this is hardware.
Dialogue: 0,0:04:06.70,0:04:10.41,英文,,0,0,0,,And computers, for today's purposes, can only do one thing at a time.
Dialogue: 0,0:04:10.41,0:04:14.99,英文,,0,0,0,,They can't just take it all in and find instantly some number like 50.
Dialogue: 0,0:04:14.99,0:04:22.60,英文,,0,0,0,,So perhaps a decent metaphor is to consider the array of memory inside of your computer really is a sequence of closed doors.
Dialogue: 0,0:04:22.60,0:04:30.63,英文,,0,0,0,,And if the computer wants to find some value in an array, it has to do the digital equivalent of opening each of these doors one at a time.
Dialogue: 0,0:04:30.63,0:04:32.43,英文,,0,0,0,,Now, how can code do that?
Dialogue: 0,0:04:32.43,0:04:39.96,英文,,0,0,0,,Well, of course, we introduced indices, or indexes, last week, whereby we, by convention, call the first element of an array, location 0.
Dialogue: 0,0:04:39.96,0:04:45.35,英文,,0,0,0,,the second location, 1, the third location, 2, and so forth, so-called zero-indexed.
Dialogue: 0,0:04:45.35,0:04:56.00,英文,,0,0,0,,And this allowed us to now bridge this conceptual world of what's going on in memory with actual code, because now we had this square bracket syntax via which we could go searching for something if we so choose.
Dialogue: 0,0:04:56.00,0:05:10.29,英文,,0,0,0,,And it turns out, if I now paint these red instead of yellow, it would seem that we actually have a pretty good physical metaphor here standing in place for what would be a computer's array of memory if, for instance, you're storing some seven numbers like that.
Dialogue: 0,0:05:10.29,0:05:13.67,英文,,0,0,0,,And so today, we begin with the look of a specific type of algorithm.
Dialogue: 0,0:05:13.67,0:05:14.91,英文,,0,0,0,,That is for searching.
Dialogue: 0,0:05:14.91,0:05:16.21,英文,,0,0,0,,Searching is all over the place.
Dialogue: 0,0:05:16.21,0:05:21.23,英文,,0,0,0,,All of us have probably gone to google.com or some equivalent already multiple times per day.
Dialogue: 0,0:05:21.23,0:05:25.37,英文,,0,0,0,,And getting back answers fast is what companies like Google are really good at.
Dialogue: 0,0:05:25.37,0:05:26.71,英文,,0,0,0,,So how are they doing that?
Dialogue: 0,0:05:26.71,0:05:30.07,英文,,0,0,0,,How are they storing information in computers' memory?
Dialogue: 0,0:05:30.07,0:05:31.59,英文,,0,0,0,,Well, let's consider what this really is.
Dialogue: 0,0:05:31.59,0:05:34.64,英文,,0,0,0,,It's really just a problem, as it was back in week 0.
Dialogue: 0,0:05:34.64,0:05:38.54,英文,,0,0,0,,The input, though, to the problem for now might be this array of seven lockers.
Dialogue: 0,0:05:38.54,0:05:41.04,英文,,0,0,0,,So that's the input to the problem, inside of which is a number.
Dialogue: 0,0:05:41.04,0:05:49.62,英文,,0,0,0,,And maybe for simplicity now, we just want a yes-no, a true-false answer, a bool, that is to say, of whether or not some number, like 50,
Dialogue: 0,0:05:49.62,0:05:51.14,英文,,0,0,0,,is in that array.
Dialogue: 0,0:05:51.14,0:05:52.66,英文,,0,0,0,,It's not quite as fancy as Google.
Dialogue: 0,0:05:52.66,0:05:55.50,英文,,0,0,0,,That doesn't just tell you, yes, we have search results.
Dialogue: 0,0:05:55.50,0:05:57.30,英文,,0,0,0,,It actually gives you the search results.
Dialogue: 0,0:05:57.30,0:06:06.29,英文,,0,0,0,,But for now, we'll keep it simple and just output as part of this problem, yes or no, true or false, we have found the number we're looking for given an input like that array.
Dialogue: 0,0:06:06.29,0:06:12.39,英文,,0,0,0,,But it turns out, inside of this black box that we keep coming back to, there's all sorts of possible algorithms.
Dialogue: 0,0:06:12.39,0:06:15.91,英文,,0,0,0,,And we talked about this at a high level conceptually in week zero with the phone book.
Dialogue: 0,0:06:15.91,0:06:22.72,英文,,0,0,0,,But today, let's consider it a little more concretely by way of a game that some of you might have grown up with, namely Monopoly.
Dialogue: 0,0:06:22.72,0:06:26.92,英文,,0,0,0,,And so behind these doors, it turns out, will be hidden some denominations of Monopoly money.
Dialogue: 0,0:06:26.92,0:06:30.70,英文,,0,0,0,,But for this, we now have two volunteers, if you'd like to greet the world.
Dialogue: 0,0:06:30.70,0:06:35.49,英文,,0,0,0,,Hi, I'm Jackson.
Dialogue: 0,0:06:35.49,0:06:37.23,英文,,0,0,0,,Hi, my name is Stephanie.
Dialogue: 0,0:06:37.23,0:06:40.48,英文,,0,0,0,,And do you want to say a little something about yourselves, years, house, dorm?
Dialogue: 0,0:06:40.48,0:06:43.42,英文,,0,0,0,,I'm a first year living in Matthews.
Dialogue: 0,0:06:43.42,0:06:43.80,英文,,0,0,0,,Nice.
Dialogue: 0,0:06:43.80,0:06:45.64,英文,,0,0,0,,And I'm a first year in Canada.
Dialogue: 0,0:06:45.64,0:06:48.86,英文,,0,0,0,,Nice. Well, welcome to our two volunteers.
Dialogue: 0,0:06:48.86,0:06:50.68,英文,,0,0,0,,So why don't we do this?
Dialogue: 0,0:06:50.68,0:06:55.91,英文,,0,0,0,,Would one of you like to volunteer the other to go first?
Dialogue: 0,0:06:55.91,0:06:58.31,英文,,0,0,0,,OK, all right, so Stephanie's up first.
Dialogue: 0,0:06:58.31,0:07:02.58,英文,,0,0,0,,And behind one of these doors here, we've hidden the Monopoly money 50.
Dialogue: 0,0:07:02.58,0:07:04.34,英文,,0,0,0,,And so we'd like you to find the 50.
Dialogue: 0,0:07:04.34,0:07:06.48,英文,,0,0,0,,We'll tell you nothing more about the lockers.
Dialogue: 0,0:07:06.48,0:07:08.80,英文,,0,0,0,,But we would like you to execute a certain algorithm.
Dialogue: 0,0:07:08.80,0:07:11.14,英文,,0,0,0,,And in fact, I'm going to give you some pseudocode for this.
Dialogue: 0,0:07:11.14,0:07:12.30,英文,,0,0,0,,And I'm going to give you the name for it.
Dialogue: 0,0:07:12.30,0:07:14.10,英文,,0,0,0,,It's called linear search.
Dialogue: 0,0:07:14.10,0:07:17.96,英文,,0,0,0,,And as the name implies, you're pretty much going to end up walking in sort of a straight line.
Dialogue: 0,0:07:17.96,0:07:19.12,英文,,0,0,0,,But how are you going to do this?
Dialogue: 0,0:07:19.12,0:07:25.64,英文,,0,0,0,,Well, let me propose that in a moment, your first step will be to think kind of like a loop for each door from left to right.
Dialogue: 0,0:07:25.64,0:07:27.31,英文,,0,0,0,,What do we want you to do on each iteration?
Dialogue: 0,0:07:27.31,0:07:36.05,英文,,0,0,0,,Well, if 50 is behind that door, then we want to go ahead and have you return true and sort of hold up the 50 proudly, if you will, for the group.
Dialogue: 0,0:07:36.05,0:07:43.17,英文,,0,0,0,,Otherwise, if you get through that whole loop and you haven't found the number 50, you can just throw up your hands in disappointment. False.
Dialogue: 0,0:07:43.17,0:07:45.37,英文,,0,0,0,,You've not found the number 50.
Dialogue: 0,0:07:45.37,0:07:51.40,英文,,0,0,0,,So to be clear, step one is going to be for each door from left to right, how would you like to begin?
Dialogue: 0,0:07:56.81,0:08:00.35,英文,,0,0,0,,Oh, and then, yep, there we go, yep.
Dialogue: 0,0:08:00.35,0:08:04.23,英文,,0,0,0,,And if you'd like to at least tell, oh, good, good acting here.
Dialogue: 0,0:08:04.23,0:08:06.15,英文,,0,0,0,,What have you found instead?
Dialogue: 0,0:08:06.15,0:08:08.29,英文,,0,0,0,,It's not 50, but 20.
Dialogue: 0,0:08:08.29,0:08:08.93,英文,,0,0,0,,Oh, OK.
Dialogue: 0,0:08:08.93,0:08:10.27,英文,,0,0,0,,So step one was a fail.
Dialogue: 0,0:08:10.27,0:08:12.11,英文,,0,0,0,,So let's move on to step two.
Dialogue: 0,0:08:12.11,0:08:14.63,英文,,0,0,0,,Inside of this loop, what are you going to do next?
Dialogue: 0,0:08:14.63,0:08:16.43,英文,,0,0,0,,I'm going to move to the next door.
Dialogue: 0,0:08:16.43,0:08:20.87,英文,,0,0,0,,OK.
Dialogue: 0,0:08:20.87,0:08:22.03,英文,,0,0,0,,Almost.
Dialogue: 0,0:08:22.03,0:08:24.27,英文,,0,0,0,,OK, almost, sort of.
Dialogue: 0,0:08:24.27,0:08:25.19,英文,,0,0,0,,A 500 instead.
Dialogue: 0,0:08:25.19,0:08:30.49,英文,,0,0,0,,Next locker. I would rather take.
Dialogue: 0,0:08:30.49,0:08:33.85,英文,,0,0,0,,No.
Dialogue: 0,0:08:33.85,0:08:34.91,英文,,0,0,0,,OK, we're not telling the audience.
Dialogue: 0,0:08:34.91,0:08:38.37,英文,,0,0,0,,It was a 10.
Dialogue: 0,0:08:38.37,0:08:39.77,英文,,0,0,0,,OK, so keep going.
Dialogue: 0,0:08:39.77,0:08:45.61,英文,,0,0,0,,This is step three now.
Dialogue: 0,0:08:45.61,0:08:49.92,英文,,0,0,0,,Oh, man.
Dialogue: 0,0:08:49.92,0:08:50.80,英文,,0,0,0,,Five, OK.
Dialogue: 0,0:08:50.80,0:08:52.58,英文,,0,0,0,,A few more lockers to check.
Dialogue: 0,0:08:57.77,0:09:03.16,英文,,0,0,0,,A little sad, guys.
Dialogue: 0,0:09:03.16,0:09:07.68,英文,,0,0,0,,All right, second to last step.
Dialogue: 0,0:09:07.68,0:09:10.12,英文,,0,0,0,,This one, kind of close.
Dialogue: 0,0:09:10.12,0:09:11.26,英文,,0,0,0,,All right.
Dialogue: 0,0:09:11.26,0:09:12.76,英文,,0,0,0,,And finally, the last step.
Dialogue: 0,0:09:12.76,0:09:15.92,英文,,0,0,0,,Clearly, you've been perhaps set up here.
Dialogue: 0,0:09:15.92,0:09:17.23,英文,,0,0,0,,Let's go.
Dialogue: 0,0:09:17.23,0:09:23.59,英文,,0,0,0,,All right. So the number 50. And Stephanie, if I may, let me ask you a question here.
Dialogue: 0,0:09:23.59,0:09:29.13,英文,,0,0,0,,So on the screen, this is the pseudocode you just executed.
Dialogue: 0,0:09:29.13,0:09:34.78,英文,,0,0,0,,Suppose, though, I had done what many of us have gotten to the habit of doing when you have a if condition.
Dialogue: 0,0:09:34.78,0:09:36.80,英文,,0,0,0,,You often have an else branch as well.
Dialogue: 0,0:09:36.80,0:09:38.74,英文,,0,0,0,,Suppose that I had done this now.
Dialogue: 0,0:09:38.74,0:09:41.78,英文,,0,0,0,,And I'm marking it in red to be clear this is wrong.
Dialogue: 0,0:09:41.78,0:09:47.29,英文,,0,0,0,,But what would have been bad about this code using an if and an else, might you say?
Dialogue: 0,0:09:47.29,0:09:47.91,英文,,0,0,0,,Any instincts?
Dialogue: 0,0:09:55.69,0:09:59.77,英文,,0,0,0,,Then you would end up canceling the code before you found the 50.
Dialogue: 0,0:09:59.77,0:10:00.39,英文,,0,0,0,,Yeah, exactly.
Dialogue: 0,0:10:00.39,0:10:02.15,英文,,0,0,0,,And it would just be eternally sad.
Dialogue: 0,0:10:02.15,0:10:05.53,英文,,0,0,0,,Indeed. When Stephanie had opened the first locker, she had found 20.
Dialogue: 0,0:10:05.53,0:10:08.03,英文,,0,0,0,,20, of course, is not 50. She would have decreed false.
Dialogue: 0,0:10:08.03,0:10:10.30,英文,,0,0,0,,But of course, she hadn't checked all of the rest of the locker.
Dialogue: 0,0:10:10.30,0:10:18.76,英文,,0,0,0,,So that would seem to be a key detail that with this implementation of the pseudocode, we actually do go through as we did and only return false,
Dialogue: 0,0:10:18.76,0:10:25.76,英文,,0,0,0,, not even with an else, but just at the end of the loop such that we only reach that line if we don't return truer earlier than that.
Dialogue: 0,0:10:25.76,0:10:28.84,英文,,0,0,0,,Well, let's go ahead and do this. Let me take the mic from you, if you'd like to take a seat next to Jackson.
Dialogue: 0,0:10:28.84,0:10:30.48,英文,,0,0,0,,Jackson, in just a moment, we'll have you come up.
Dialogue: 0,0:10:30.48,0:10:34.29,英文,,0,0,0,,Carter, if you don't mind reorganizing the lockers for us.
Dialogue: 0,0:10:34.29,0:10:38.03,英文,,0,0,0,,But in the meantime, let me point out how we might now translate that same idea to code.
Dialogue: 0,0:10:38.03,0:10:41.09,英文,,0,0,0,,Pretty high level, pretty English-oriented with that pseudocode.
Dialogue: 0,0:10:41.09,0:10:43.64,英文,,0,0,0,,But really now, as of last week, we have syntax
Dialogue: 0,0:10:43.64,0:10:51.32,英文,,0,0,0,,Via which Stephanie and soon Jackson could treat this locker, this set of lockers, as really indeed an array using bracket notation.
Dialogue: 0,0:10:51.32,0:10:54.62,英文,,0,0,0,,So we can now get a little closer in our pseudocode to actual code.
Dialogue: 0,0:10:54.62,0:11:06.60,英文,,0,0,0,,And the way a computer scientist, for instance, would translate fairly high-level English pseudocode like this to something that's a little closer to C or any language that supports arrays would be a little more cryptically like this.
Dialogue: 0,0:11:06.60,0:11:09.26,英文,,0,0,0,,But you'll see more of this syntax in the coming days.
Dialogue: 0,0:11:09.26,0:11:12.10,英文,,0,0,0,,For i from 0 to n minus 1.
Dialogue: 0,0:11:12.10,0:11:17.95,英文,,0,0,0,,This is still pseudocode, but that's kind of like the English-like way of expressing what we've come to know as a for loop.
Dialogue: 0,0:11:17.95,0:11:26.67,英文,,0,0,0,,If 50 is behind doors bracket i, so I'm assuming for the sake of discussion that doors now is the name of my variable, this array of seven doors.
Dialogue: 0,0:11:26.67,0:11:30.35,英文,,0,0,0,,But then the rest of the logic, the rest of the pseudocode, really is the same way.
Dialogue: 0,0:11:30.35,0:11:40.81,英文,,0,0,0,,And so you'll find in time that programmers, computer scientists more generally, when you start expressing ideas, algorithms to someone else, instead of maybe operating at this level here,
Dialogue: 0,0:11:40.81,0:11:51.81,英文,,0,0,0,, you now have in your vocabulary really a new syntax that you can be a little more specific, not getting so into the weeds of writing actual C code, but at least now doing something that's a little closer to manipulating an array like this.
Dialogue: 0,0:11:51.81,0:11:55.17,英文,,0,0,0,,So Jackson, would you like to stand on up?
Dialogue: 0,0:11:55.17,0:11:56.75,英文,,0,0,0,,All right.
Dialogue: 0,0:11:56.75,0:11:58.75,英文,,0,0,0,,Yes, yes, support for Jackson here too.
Dialogue: 0,0:11:58.75,0:12:00.91,英文,,0,0,0,,Nice.
Dialogue: 0,0:12:00.91,0:12:04.47,英文,,0,0,0,,And here now, I'm going to allow you an assumption that Stephanie did not have.
Dialogue: 0,0:12:04.47,0:12:10.23,英文,,0,0,0,,Stephanie clearly was really doing her best, searching from left to right, using linear search, as we'll now call it.
Dialogue: 0,0:12:10.23,0:12:12.13,英文,,0,0,0,,But they were pretty much in random order, right?
Dialogue: 0,0:12:12.13,0:12:15.13,英文,,0,0,0,,There was a 20 over there, there was a 1 over there, and then a 50.
Dialogue: 0,0:12:15.13,0:12:19.27,英文,,0,0,0,,So we deliberately jumbled things up and did not sort the numbers for her.
Dialogue: 0,0:12:19.27,0:12:24.70,英文,,0,0,0,,Carter kindly has just come up to give you a leg up, Jackson, by sorting the numbers in advance.
Dialogue: 0,0:12:24.70,0:12:32.24,英文,,0,0,0,,And we'd like you this time, much like in week 0, to do something again and again, but this time using what we'll now call binary search.
Dialogue: 0,0:12:32.24,0:12:40.35,英文,,0,0,0,,It's exactly the same algorithm conceptually as we did in week 0, but if we translate it to the context of this array, we now might say something like this.
Dialogue: 0,0:12:40.35,0:12:43.23,英文,,0,0,0,,The first step for Jackson might be to ask the question,
Dialogue: 0,0:12:43.23,0:12:50.60,英文,,0,0,0,,If 50 is behind the middle door, where presumably he's done some mental math to figure out what the middle is, then he's going to just return true.
Dialogue: 0,0:12:50.60,0:12:53.20,英文,,0,0,0,,And hopefully we'll get lucky, and 50 will be right there.
Dialogue: 0,0:12:53.20,0:12:58.65,英文,,0,0,0,,Of course, there's two other possibilities at least, which would be what?
Dialogue: 0,0:12:58.65,0:13:01.42,英文,,0,0,0,,50 is with respect to these doors.
Dialogue: 0,0:13:01.42,0:13:03.93,英文,,0,0,0,,Yeah, so to the left or to the right, alternatively.
Dialogue: 0,0:13:03.93,0:13:09.29,英文,,0,0,0,,So if 50 is less than the middle door, then presumably Jackson's going to want to go left.
Dialogue: 0,0:13:09.29,0:13:18.05,英文,,0,0,0,,Else, if 50 is greater than the middle door, he's going to want to go right, much like I did physically last week with the phone book, dividing and conquering left to right.
Dialogue: 0,0:13:18.05,0:13:19.94,英文,,0,0,0,,But there's actually a fourth case.
Dialogue: 0,0:13:19.94,0:13:21.76,英文,,0,0,0,,Let's put it on the board first.
Dialogue: 0,0:13:21.76,0:13:27.83,英文,,0,0,0,,What else might happen here that Jackson should consider?
Dialogue: 0,0:13:27.83,0:13:28.49,英文,,0,0,0,,It's not there.
Dialogue: 0,0:13:28.49,0:13:42.39,英文,,0,0,0,,So let me actually go back and amend my pseudocode here and just say, Jackson, if we don't hand you any doors at all, or eventually, as he's dividing and conquering, if he's left with no more doors, we have to handle that situation so that the behavior is defined.
Dialogue: 0,0:13:42.39,0:13:43.03,英文,,0,0,0,,All right.
Dialogue: 0,0:13:43.03,0:13:48.69,英文,,0,0,0,,So with that said, Jackson, do you want to go ahead and find us the number 50 and walk us through verbally what you're doing and finding?
Dialogue: 0,0:13:48.69,0:13:49.20,英文,,0,0,0,,All right.
Dialogue: 0,0:13:49.20,0:13:52.76,英文,,0,0,0,,So it looks like this one is the middle door.
Dialogue: 0,0:13:52.76,0:13:55.28,英文,,0,0,0,,So I'm going to open it.
Dialogue: 0,0:13:55.28,0:13:58.16,英文,,0,0,0,,But it's 20, not 50.
Dialogue: 0,0:13:58.16,0:13:59.28,英文,,0,0,0,,Sad.
Dialogue: 0,0:13:59.28,0:13:59.78,英文,,0,0,0,,OK.
Dialogue: 0,0:13:59.78,0:14:01.08,英文,,0,0,0,,What's going through your head now?
Dialogue: 0,0:14:01.08,0:14:06.44,英文,,0,0,0,,So now I'm looking, because 50 is higher than 20, I want to look to the right.
Dialogue: 0,0:14:06.44,0:14:07.54,英文,,0,0,0,,Good.
Dialogue: 0,0:14:07.54,0:14:10.28,英文,,0,0,0,,And look for the new middle door, which would be here.
Dialogue: 0,0:14:10.28,0:14:12.16,英文,,0,0,0,,Nice. And it's 100.
Dialogue: 0,0:14:12.16,0:14:14.28,英文,,0,0,0,,Sad.
Dialogue: 0,0:14:14.28,0:14:16.56,英文,,0,0,0,,But 50 is less than 100.
Dialogue: 0,0:14:16.56,0:14:20.55,英文,,0,0,0,,So now we know to look left, which would be here.
Dialogue: 0,0:14:20.55,0:14:21.43,英文,,0,0,0,,And ta-da.
Dialogue: 0,0:14:21.43,0:14:21.99,英文,,0,0,0,,Nice.
Dialogue: 0,0:14:21.99,0:14:25.82,英文,,0,0,0,,Very well done this time around, too.
Dialogue: 0,0:14:25.82,0:14:29.57,英文,,0,0,0,,So thank you first to our volunteers here.
Dialogue: 0,0:14:29.57,0:14:37.37,英文,,0,0,0,,And in fact, since you're a fan of Monopoly, as we're so informed, we have the Cambridge edition of Monopoly with all your Harvard favorites.
Dialogue: 0,0:14:37.37,0:14:37.98,英文,,0,0,0,,Here you go.
Dialogue: 0,0:14:37.98,0:14:38.94,英文,,0,0,0,,Thank you so much.
Dialogue: 0,0:14:38.94,0:14:40.94,英文,,0,0,0,,Thank you to our volunteers for finding us 50.
Dialogue: 0,0:14:40.94,0:14:46.87,英文,,0,0,0,,So. That was more popular than we expected.
Dialogue: 0,0:14:46.87,0:14:52.15,英文,,0,0,0,,So here we can translate this one more time into something a little closer to code.
Dialogue: 0,0:14:52.15,0:15:01.77,英文,,0,0,0,,And again, still pseudocode, but here now might be another formulation of exactly what Jackson just did, just using the nomenclature now of arrays, where you can be a little more precise with your instructions.
Dialogue: 0,0:15:01.77,0:15:04.55,英文,,0,0,0,,And still leave it to someone else to translate this finally to code.
Dialogue: 0,0:15:04.55,0:15:06.47,英文,,0,0,0,,But here we have same question at the beginning.
Dialogue: 0,0:15:06.47,0:15:08.83,英文,,0,0,0,,If no doors left, return false.
Dialogue: 0,0:15:08.83,0:15:11.64,英文,,0,0,0,,If 50 is behind doors bracket middle.
Dialogue: 0,0:15:11.64,0:15:19.66,英文,,0,0,0,,So I'm assuming here, because this is pseudocode, that somewhere I've done the mental math or the actual math to figure out what the index of middle is.
Dialogue: 0,0:15:19.66,0:15:27.53,英文,,0,0,0,,For instance, if these are seven doors in an array, this would be location 0, 1, 2, 3. 4, 5, 6.
Dialogue: 0,0:15:27.53,0:15:33.51,英文,,0,0,0,,So somehow, I've taken the total number of doors, 7, divided by 2 to find the middle.
Dialogue: 0,0:15:33.51,0:15:35.69,英文,,0,0,0,,That's 3 and 1 half. We have to deal with rounding.
Dialogue: 0,0:15:35.69,0:15:43.30,英文,,0,0,0,,But suffice it to say, there's a well-defined formula for finding the middle index given the total number of lockers, divide by 2, and then round accordingly.
Dialogue: 0,0:15:43.30,0:15:48.84,英文,,0,0,0,,So that's presumably what Jackson did just by counting in his head to find us door number 3.
Dialogue: 0,0:15:48.84,0:15:52.38,英文,,0,0,0,,Not the third door, the fourth door, but door bracket 3.
Dialogue: 0,0:15:52.38,0:15:56.19,英文,,0,0,0,,So this is just saying, if 50 is behind doors bracket middle, return true.
Dialogue: 0,0:15:56.19,0:15:57.07,英文,,0,0,0,,That was not the case.
Dialogue: 0,0:15:57.07,0:15:59.09,英文,,0,0,0,,He found a $20 bill instead.
Dialogue: 0,0:15:59.09,0:16:03.67,英文,,0,0,0,,Else, if 50 is less than the doors bracket middle, go ahead.
Dialogue: 0,0:16:03.67,0:16:05.39,英文,,0,0,0,,And now it gets interesting.
Dialogue: 0,0:16:05.39,0:16:10.86,英文,,0,0,0,,Search doors 0 through doors middle minus 1.
Dialogue: 0,0:16:10.86,0:16:12.76,英文,,0,0,0,,So it's getting a little more into the weeds now.
Dialogue: 0,0:16:12.76,0:16:15.38,英文,,0,0,0,,But if middle is 3, this one.
Dialogue: 0,0:16:15.38,0:16:24.41,英文,,0,0,0,,Here, what we want to now have Jackson search, if the number had been less, we want to start at bracket 0 and go up through this one.
Dialogue: 0,0:16:24.41,0:16:27.99,英文,,0,0,0,,When we deliberately subtract 1, because what's the point of looking in the same locker again?
Dialogue: 0,0:16:27.99,0:16:31.43,英文,,0,0,0,,We might as well do 0 through middle minus 1.
Dialogue: 0,0:16:31.43,0:16:37.30,英文,,0,0,0,,Else if 50 is greater than doors bracket middle, which it was, what did we then do?
Dialogue: 0,0:16:37.30,0:16:43.38,英文,,0,0,0,,Jackson intuitively searched for doors middle plus 1 through doors n minus 1.
Dialogue: 0,0:16:43.38,0:16:46.40,英文,,0,0,0,,And honestly, it gets a little annoying having the pluses and the minuses here.
Dialogue: 0,0:16:46.40,0:16:47.82,英文,,0,0,0,,But just think of what it means.
Dialogue: 0,0:16:47.82,0:16:49.31,英文,,0,0,0,,This is the middle door.
Dialogue: 0,0:16:49.31,0:16:56.27,英文,,0,0,0,,And Jackson then did proceed to search through doors middle plus 1, because there's no point in searching this one again.
Dialogue: 0,0:16:56.27,0:17:05.53,英文,,0,0,0,,And then the last element in any array of size n, where n is just our go-to number for the size, is always going to be n minus 1.
Dialogue: 0,0:17:05.53,0:17:11.01,英文,,0,0,0,,It's not going to be n. It's going to be n minus 1, because we always start counting it raised at 0.
Dialogue: 0,0:17:11.01,0:17:16.32,英文,,0,0,0,,So here, then, we have a translation into pseudocode that's a little closer to C of this exact same idea.
Dialogue: 0,0:17:16.32,0:17:18.30,英文,,0,0,0,,And here, we come full circle to week 0.
Dialogue: 0,0:17:18.30,0:17:23.46,英文,,0,0,0,,Like, in week 0, it was pretty intuitive to imagine dividing and conquering a problem like this.
Dialogue: 0,0:17:23.46,0:17:34.90,英文,,0,0,0,,But if you now think back to actually your iPhone, your Android phone, or the like, when you're doing autocomplete and searching the list, it's possible, if you don't have many friends or family or colleagues in the phone, you know what?
Dialogue: 0,0:17:34.90,0:17:40.87,英文,,0,0,0,,Linear search, just checking every name for the person you're searching for, might be perfectly fine.
Dialogue: 0,0:17:40.87,0:17:47.93,英文,,0,0,0,,But odds are, your phone's being smarter than that, especially if you start to have dozens, hundreds, thousands of people in your contacts over the years.
Dialogue: 0,0:17:47.93,0:17:49.67,英文,,0,0,0,,What would be better than linear search?
Dialogue: 0,0:17:49.67,0:17:51.37,英文,,0,0,0,,Well, perhaps binary search.
Dialogue: 0,0:17:51.37,0:17:55.37,英文,,0,0,0,,But, but, but, there's an assumption, a requirement, which is what?
Dialogue: 0,0:17:55.37,0:18:04.96,英文,,0,0,0,,Why was Jackson ultimately able to find the 50 in just like three steps instead of a full seven, like Stephanie?
Dialogue: 0,0:18:04.96,0:18:06.56,英文,,0,0,0,,Because the array was sorted.
Dialogue: 0,0:18:06.56,0:18:09.98,英文,,0,0,0,,And so this is sort of a teaser for what we'll have to come back to later today.
Dialogue: 0,0:18:09.98,0:18:12.80,英文,,0,0,0,,Well, how much effort did it take someone like Carter?
Dialogue: 0,0:18:12.80,0:18:17.18,英文,,0,0,0,,How much effort does it take your phone to sort all of those names and numbers in advance?
Dialogue: 0,0:18:17.18,0:18:19.64,英文,,0,0,0,,Because maybe it's not actually worth the amount of time.
Dialogue: 0,0:18:19.64,0:18:24.32,英文,,0,0,0,,Now, someone like Google probably somehow keeps the database of web pages sorted.
Dialogue: 0,0:18:24.32,0:18:35.61,英文,,0,0,0,,You can imagine it being super slow if when you type in cats or something else into google.com, if they searched linearly over their entire data set, ideally, they're doing something a little smarter than that.
Dialogue: 0,0:18:35.61,0:18:38.83,英文,,0,0,0,,So we'll formalize now exactly this kind of analysis.
Dialogue: 0,0:18:38.83,0:18:42.34,英文,,0,0,0,,And it's not going to be so much mathy as it still will be intuitive.
Dialogue: 0,0:18:42.34,0:18:50.58,英文,,0,0,0,,But we'll introduce you to some jargon, some terminology, that most any programmer or computer scientist might use when analyzing their own algorithms.
Dialogue: 0,0:18:50.58,0:18:53.65,英文,,0,0,0,,Let's formalize now what this kind of analysis is.
Dialogue: 0,0:18:53.65,0:18:56.91,英文,,0,0,0,,So right now, I claim binary search better than linear search.
Dialogue: 0,0:18:56.91,0:18:59.07,英文,,0,0,0,,But how much better, and why exactly?
Dialogue: 0,0:18:59.07,0:19:01.03,英文,,0,0,0,,Well, it all comes back to this kind of graph.
Dialogue: 0,0:19:01.03,0:19:05.10,英文,,0,0,0,,So this, recall, is how we analyzed the phone book back in week 0.
Dialogue: 0,0:19:05.10,0:19:07.94,英文,,0,0,0,,And recall that, indeed, we had these formulas.
Dialogue: 0,0:19:07.94,0:19:11.42,英文,,0,0,0,,Rough formulas that describe the running time of those three algorithms.
Dialogue: 0,0:19:11.42,0:19:15.91,英文,,0,0,0,,One page at a time, two pages at a time, and then tearing the thing again and again in half.
Dialogue: 0,0:19:15.91,0:19:26.73,英文,,0,0,0,,And precisely, if you counted up the number of pages I was touching or the number of pages I was tearing, it's fair to say that the first algorithm, in the worst case, might have taken n total pages.
Dialogue: 0,0:19:26.73,0:19:31.40,英文,,0,0,0,,It didn't, because I was searching for John Harvard at the time, which is somewhat early in the alphabet.
Dialogue: 0,0:19:31.40,0:19:38.60,英文,,0,0,0,,But if I were searching for someone with the last name of Z, I would have had to keep going and going, in the worst case, through all n pages.
Dialogue: 0,0:19:38.60,0:19:41.92,英文,,0,0,0,,Not as bad for the second algorithm. And that's why we do n divided by 2.
Dialogue: 0,0:19:41.92,0:19:43.74,英文,,0,0,0,,And even that's a bit of a white lie.
Dialogue: 0,0:19:43.74,0:19:48.28,英文,,0,0,0,,Right, it's probably n divided by 2 plus 1 in case I have to double back.
Dialogue: 0,0:19:48.28,0:19:52.05,英文,,0,0,0,,But again, I'm sort of doing this more generally to capture the essence of these things.
Dialogue: 0,0:19:52.05,0:19:56.93,英文,,0,0,0,,And then we really got into the weeds with log base 2 of n for that third and final algorithm.
Dialogue: 0,0:19:56.93,0:20:04.17,英文,,0,0,0,,And at the time, we claimed any time you're dividing something in half, in half, in half, odds are there's going to be some kind of logarithm involved.
Dialogue: 0,0:20:04.17,0:20:05.51,英文,,0,0,0,,And we'll see that today.
Dialogue: 0,0:20:05.51,0:20:13.60,英文,,0,0,0,,But today, we're going to actually start using computer science terminology. And we're going to sort of formalize this Imprecision, if you will.
Dialogue: 0,0:20:13.60,0:20:24.60,英文,,0,0,0,,We are not going to care generally about exactly how many steps some algorithm takes, because that's not going to be that enlightening, especially if maybe you have a faster computer tomorrow than you did today.
Dialogue: 0,0:20:24.60,0:20:27.61,英文,,0,0,0,,It wouldn't really be fair to compare numbers too precisely.
Dialogue: 0,0:20:27.61,0:20:33.93,英文,,0,0,0,,We really kind of want to, with a wave of the hand, just get a sense of roughly how slow or how fast an algorithm is.
Dialogue: 0,0:20:33.93,0:20:36.01,英文,,0,0,0,,So the notation here is deliberate.
Dialogue: 0,0:20:36.01,0:20:53.51,英文,,0,0,0,,That is literally a capital O, often italicized, referred to as big O. And so the first algorithm is in big O of n. The second algorithm is in big O of n divided by 2. The third algorithm is in big O of log base 2 of n. But even that is kind of, you know,
Dialogue: 0,0:20:53.51,0:21:01.27,英文,,0,0,0,,Unnecessary detail. When using big O notation, you really don't care about, we'll see, the smaller ordered terms, right?
Dialogue: 0,0:21:01.27,0:21:03.73,英文,,0,0,0,,We're not going to care about the divided by 2.
Dialogue: 0,0:21:03.73,0:21:04.57,英文,,0,0,0,,Because you know what?
Dialogue: 0,0:21:04.57,0:21:07.90,英文,,0,0,0,,The shape of these algorithms is almost the same.
Dialogue: 0,0:21:07.90,0:21:11.12,英文,,0,0,0,,And really, the idea, the algorithm itself is sort of fundamentally the same.
Dialogue: 0,0:21:11.12,0:21:13.76,英文,,0,0,0,,OK, instead of one page at a time, I'm doing two.
Dialogue: 0,0:21:13.76,0:21:22.17,英文,,0,0,0,,But if you throw millions of pages, billions of pages at me, those algorithms are really going to kind of perform the same as n gets really large, goes off toward infinity.
Dialogue: 0,0:21:22.17,0:21:23.55,英文,,0,0,0,,And the same is true for logarithms.
Dialogue: 0,0:21:23.55,0:21:33.04,英文,,0,0,0,,Even if you're a little rusty, it turns out that whether you do the math with log base 2, log base 3, log base 10, you can just multiply one by the other to really get the same formula.
Dialogue: 0,0:21:33.04,0:21:39.39,英文,,0,0,0,,Which is only to say, a computer scientist would generally say that the first two algorithms are on the order of n steps.
Dialogue: 0,0:21:39.39,0:21:42.69,英文,,0,0,0,,The third algorithm is on the order of log n steps.
Dialogue: 0,0:21:42.69,0:21:46.39,英文,,0,0,0,,And we don't really care precisely what we mean beyond that.
Dialogue: 0,0:21:46.39,0:21:49.78,英文,,0,0,0,,And this big O notation, as we'll see, and actually, let me zoom out.
Dialogue: 0,0:21:49.78,0:21:55.96,英文,,0,0,0,,If you can imagine suddenly making the x-axis much longer, so more pages on the screen at once.
Dialogue: 0,0:21:55.96,0:21:58.84,英文,,0,0,0,,It is indeed going to be the shapes of these curves that matter.
Dialogue: 0,0:21:58.84,0:22:11.54,英文,,0,0,0,,Because imagine in your mind's eye, as you zoom out, zoom out, zoom out, zoom out, and as n gets much, much, much bigger on the x-axis, the red and the yellow line are essentially going to look the same once n is sufficiently large.
Dialogue: 0,0:22:11.54,0:22:14.56,英文,,0,0,0,,But the green line is never going to look the same.
Dialogue: 0,0:22:14.56,0:22:16.34,英文,,0,0,0,,It's going to be a fundamentally different shape.
Dialogue: 0,0:22:16.34,0:22:23.29,英文,,0,0,0,,And so that's the intuition of Big O, to get a sense of these rates. of performance like this.
Dialogue: 0,0:22:23.29,0:22:32.47,英文,,0,0,0,,So here, then, is big O. Here is perhaps a cheat sheet of the common formulas that a computer scientist, certainly in an introductory context, might use when analyzing algorithms.
Dialogue: 0,0:22:32.47,0:22:38.95,英文,,0,0,0,,And let's consider for a moment which of our first two algorithms, linear search and binary search, fall into these categories.
Dialogue: 0,0:22:38.95,0:22:42.55,英文,,0,0,0,,So I've ordered them from slowest to fastest.
Dialogue: 0,0:22:42.55,0:22:48.41,英文,,0,0,0,,So order of n squared, it's not something we've actually seen yet, but it tends to be slow, because it's quadratic.
Dialogue: 0,0:22:48.41,0:22:51.27,英文,,0,0,0,,You're doing n times n. That's got to add up to a lot of steps.
Dialogue: 0,0:22:51.27,0:23:08.38,英文,,0,0,0,,Better today is going to be n log n. Even better is going to be n. Even better than that is log n. And best is so-called order of 1, like one step, or maybe two steps, maybe even 1,000 steps, but a fixed, finite number of steps that never changes, no matter how big n is.
Dialogue: 0,0:23:08.38,0:23:13.62,英文,,0,0,0,,So given this chart, just to be clear, Linear search, let's consider the worst case.
Dialogue: 0,0:23:13.62,0:23:23.67,英文,,0,0,0,,In the worst case, how many steps did it take someone like Stephanie to find the solution to the problem, assuming not seven doors, but n doors?
Dialogue: 0,0:23:23.67,0:23:25.32,英文,,0,0,0,,Yeah?
Dialogue: 0,0:23:25.32,0:23:29.24,英文,,0,0,0,,So on the order of n. And in this case, it's exactly n. But you know what?
Dialogue: 0,0:23:29.24,0:23:31.40,英文,,0,0,0,,You know, maybe it's arguably 2n, right?
Dialogue: 0,0:23:31.40,0:23:33.38,英文,,0,0,0,,Because it took Stephanie a couple of steps.
Dialogue: 0,0:23:33.38,0:23:34.46,英文,,0,0,0,,Like, she had to lift the latch.
Dialogue: 0,0:23:34.46,0:23:35.43,英文,,0,0,0,,She had to open the door.
Dialogue: 0,0:23:35.43,0:23:36.25,英文,,0,0,0,,Maybe it's three steps.
Dialogue: 0,0:23:36.25,0:23:37.45,英文,,0,0,0,,She had to show the money.
Dialogue: 0,0:23:37.45,0:23:39.35,英文,,0,0,0,,So now it's 3n, 2n.
Dialogue: 0,0:23:39.35,0:23:42.13,英文,,0,0,0,,But there, we don't really care about that level of precision.
Dialogue: 0,0:23:42.13,0:23:45.57,英文,,0,0,0,,We really just care about the fundamental number of operations.
Dialogue: 0,0:23:45.57,0:23:51.31,英文,,0,0,0,,So we'll say yes on the order of n. So that might be an upper bound, we'll call this, for linear search.
Dialogue: 0,0:23:51.31,0:23:53.23,英文,,0,0,0,,And how about binary search?
Dialogue: 0,0:23:53.23,0:24:03.05,英文,,0,0,0,,In Jackson's case, or in general, me in week zero, if there's n doors, how many steps did it take Jackson or me using binary search?
Dialogue: 0,0:24:03.05,0:24:07.38,英文,,0,0,0,,In this case, it was literally three, but that's not a formula.
Dialogue: 0,0:24:07.38,0:24:14.22,英文,,0,0,0,,Yeah, so it's on the order of log n. And indeed, if there's seven doors, well, that's almost eight if you just do a little bit of rounding.
Dialogue: 0,0:24:14.22,0:24:18.63,英文,,0,0,0,,And indeed, if you take log base 2 of 8, OK, so that does actually give us 3.
Dialogue: 0,0:24:18.63,0:24:19.79,英文,,0,0,0,,So the math actually checks out.
Dialogue: 0,0:24:19.79,0:24:21.59,英文,,0,0,0,,And if you're not comfy with logarithms, no big deal.
Dialogue: 0,0:24:21.59,0:24:23.71,英文,,0,0,0,,Just think about it intuitively.
Dialogue: 0,0:24:23.71,0:24:27.03,英文,,0,0,0,,Logarithm of base 2 is just dividing something again and again.
Dialogue: 0,0:24:27.03,0:24:40.18,英文,,0,0,0,,So on this chart, when we consider big O, which, to be clear, allows you to describe the order of an algorithm's running time, like the magnitude of it, but it also describes more specifically an upper bound.
Dialogue: 0,0:24:40.18,0:24:45.63,英文,,0,0,0,,So in the worst case, for instance, these are pretty good measures of how good
Dialogue: 0,0:24:45.63,0:24:49.75,英文,,0,0,0,,Or rather, of how bad linear search and binary search might be. Why?
Dialogue: 0,0:24:49.75,0:24:56.35,英文,,0,0,0,,Well, suppose you're searching a 1,000-page phone book, and the person's name starts with Z. The algorithm's still going to be on the order of n steps.
Dialogue: 0,0:24:56.35,0:24:56.87,英文,,0,0,0,,Why?
Dialogue: 0,0:24:56.87,0:25:01.25,英文,,0,0,0,,Because it might take you as many as all n steps to find it.
Dialogue: 0,0:25:01.25,0:25:05.27,英文,,0,0,0,,Now, that's not necessarily going to be the case in practice.
Dialogue: 0,0:25:05.27,0:25:16.28,英文,,0,0,0,,If I use big O as an upper bound, well, it would be nice if there's sort of a corresponding lower bound, especially if you want to consider not just worst cases, but maybe best cases.
Dialogue: 0,0:25:16.28,0:25:17.88,英文,,0,0,0,,So what might we use here?
Dialogue: 0,0:25:17.88,0:25:20.10,英文,,0,0,0,,Well, so this is a capital Greek omega symbol.
Dialogue: 0,0:25:20.10,0:25:28.88,英文,,0,0,0,,So omega is the symbol that a computer scientist uses generally to describe a lower bound on an algorithm, often in the context of best case, though not necessarily.
Dialogue: 0,0:25:28.88,0:25:32.62,英文,,0,0,0,,So a lower bound means how few steps might an algorithm take.
Dialogue: 0,0:25:32.62,0:25:33.98,英文,,0,0,0,,And here, too, same formulas.
Dialogue: 0,0:25:33.98,0:25:36.44,英文,,0,0,0,,And we'll fill in these blanks over time.
Dialogue: 0,0:25:36.44,0:25:41.54,英文,,0,0,0,,Some algorithms might always take a minimum of n squared steps, or on the order of n steps.
Dialogue: 0,0:25:41.54,0:25:45.98,英文,,0,0,0,,Some might only take n log n, or n, or log n, or 1.
Dialogue: 0,0:25:45.98,0:25:49.33,英文,,0,0,0,,So something like linear search.
Dialogue: 0,0:25:49.33,0:25:52.97,英文,,0,0,0,,When Stephanie started with linear search, she didn't get lucky this time on stage.
Dialogue: 0,0:25:52.97,0:25:57.92,英文,,0,0,0,,But what if she had, and the first door she opened were 50?
Dialogue: 0,0:25:57.92,0:26:09.65,英文,,0,0,0,,How might you then describe the lower bound on linear search in this so-called best case using this list of possible answers?
Dialogue: 0,0:26:09.65,0:26:11.11,英文,,0,0,0,,Yeah, so omega of 1.
Dialogue: 0,0:26:11.11,0:26:19.48,英文,,0,0,0,,So in the best case, the lower bound on how many steps it might take linear search to find something might just be one step. Why?
Dialogue: 0,0:26:19.48,0:26:28.60,英文,,0,0,0,,Because maybe Stephanie had gotten lucky and we had pre-filled these lockers with the numbers in some other order, such that she might have opened the first locker, and voila.
Dialogue: 0,0:26:28.60,0:26:29.98,英文,,0,0,0,,The number 50 could have been there.
Dialogue: 0,0:26:29.98,0:26:34.74,英文,,0,0,0,,So a lower bound arguably could indeed be omega of 1 for linear search.
Dialogue: 0,0:26:34.74,0:26:35.96,英文,,0,0,0,,And how about now for Jackson?
Dialogue: 0,0:26:35.96,0:26:37.49,英文,,0,0,0,,He used binary search.
Dialogue: 0,0:26:37.49,0:26:41.13,英文,,0,0,0,,So he dived right into the middle of the problem.
Dialogue: 0,0:26:41.13,0:26:45.03,英文,,0,0,0,,But what would be a lower bound on binary search using this logic?
Dialogue: 0,0:26:45.03,0:26:46.14,英文,,0,0,0,,Yeah?
Dialogue: 0,0:26:46.14,0:26:47.64,英文,,0,0,0,,Yeah, so again, omega of 1.
Dialogue: 0,0:26:47.64,0:26:47.88,英文,,0,0,0,,Why?
Dialogue: 0,0:26:47.88,0:26:52.99,英文,,0,0,0,,Because maybe he just gets lucky. And indeed, right in the middle of the lockers could have been the number 50.
Dialogue: 0,0:26:52.99,0:26:54.15,英文,,0,0,0,,It wasn't.
Dialogue: 0,0:26:54.15,0:27:00.20,英文,,0,0,0,,And so more germane in Jackson's actual practice would have been the big O discussion.
Dialogue: 0,0:27:00.20,0:27:08.77,英文,,0,0,0,,But big O and omega. Upper bound and lower bound just allow a computer scientist to kind of wrestle with what could happen maybe in the worst case, what can happen in the best case.
Dialogue: 0,0:27:08.77,0:27:12.39,英文,,0,0,0,,And you can even get even more precise, like the average case or the like.
Dialogue: 0,0:27:12.39,0:27:24.34,英文,,0,0,0,,And this is indeed what engineers might do at a whiteboard in a company, in a university, when designing an algorithm and trying to make arguments as to why their algorithm is better than someone else's by way of these kinds of analyses.
Dialogue: 0,0:27:24.34,0:27:35.75,英文,,0,0,0,,And just so you've seen it, it turns out that if some algorithm happens to have an identical upper bound and lower bound, you can actually use a capital Greek theta as well.
Dialogue: 0,0:27:35.75,0:27:38.33,英文,,0,0,0,,And this is the last of the Greek symbols today.
Dialogue: 0,0:27:38.33,0:27:43.10,英文,,0,0,0,,But a Greek theta indicates a coincidence of both upper bound and lower bound.
Dialogue: 0,0:27:43.10,0:27:45.12,英文,,0,0,0,,That is, they are one and the same.
Dialogue: 0,0:27:45.12,0:27:49.38,英文,,0,0,0,,That was not the case for our discussion a second ago of linear search, not the case for binary search.
Dialogue: 0,0:27:49.38,0:27:57.08,英文,,0,0,0,,But you could use the same kinds of formulas if it turns out that your upper bound and lower bound are the same.
Dialogue: 0,0:27:57.08,0:28:09.09,英文,,0,0,0,,So for instance, if I were to count everyone literally in this room, 1, 2, 3, 4, 5, 6, and so forth, you could actually say that counting in that way is in theta of n, right?
Dialogue: 0,0:28:09.09,0:28:13.97,英文,,0,0,0,,Because in the best case, it's going to take me n points at the people in the audience.
Dialogue: 0,0:28:13.97,0:28:18.49,英文,,0,0,0,,In the worst case, it's going to take me n. It's always going to take me n steps if I want to count everyone in the room.
Dialogue: 0,0:28:18.49,0:28:21.07,英文,,0,0,0,,You can't really do better than that unless you skip people.
Dialogue: 0,0:28:21.07,0:28:26.27,英文,,0,0,0,,So that would be an example off the cuff of something where theta is instead germane.
Dialogue: 0,0:28:26.27,0:28:38.86,英文,,0,0,0,,Are any questions now on big O, on omega, or theta, which are now just more formal tools in the toolkit for talking about the design of our algorithms?
Dialogue: 0,0:28:38.86,0:28:42.24,英文,,0,0,0,,Any questions?
Dialogue: 0,0:28:42.24,0:28:43.30,英文,,0,0,0,,No?
Dialogue: 0,0:28:43.30,0:28:44.54,英文,,0,0,0,,Seeing none.
Dialogue: 0,0:28:44.54,0:28:45.62,英文,,0,0,0,,Oh, is this yes?
Dialogue: 0,0:28:45.62,0:28:46.87,英文,,0,0,0,,No?
Dialogue: 0,0:28:46.87,0:28:48.27,英文,,0,0,0,,OK, so we're good.
Dialogue: 0,0:28:48.27,0:28:51.99,英文,,0,0,0,,So let's go ahead and translate this, perhaps, to some actual code.
Dialogue: 0,0:28:51.99,0:28:53.97,英文,,0,0,0,,Let me go over to VS Code here.
Dialogue: 0,0:28:53.97,0:29:00.36,英文,,0,0,0,,And let's see if we can't now translate some of these ideas to some actual code, not so much using new syntax yet.
Dialogue: 0,0:29:00.36,0:29:03.20,英文,,0,0,0,,We're going to still operate in this world of arrays like last week.
Dialogue: 0,0:29:03.20,0:29:09.40,英文,,0,0,0,,So let me go ahead and create a program called search.c by executing code space search.c in my terminal.
Dialogue: 0,0:29:09.40,0:29:11.82,英文,,0,0,0,,And then up here, let's go ahead and include our usual.
Dialogue: 0,0:29:11.82,0:29:14.90,英文,,0,0,0,,So include CS50.h so I can get some input.
Dialogue: 0,0:29:14.90,0:29:18.49,英文,,0,0,0,,Include standard IO.h so I can print some output.
Dialogue: 0,0:29:18.49,0:29:23.19,英文,,0,0,0,,We'll do int main void, the meaning of which we did start to tease apart last week.
Dialogue: 0,0:29:23.19,0:29:26.84,英文,,0,0,0,,The fact that it's void again today just means no command line arguments.
Dialogue: 0,0:29:26.84,0:29:28.55,英文,,0,0,0,,And let me go ahead and do this.
Dialogue: 0,0:29:28.55,0:29:34.83,英文,,0,0,0,,Let me go ahead and declare, just for discussion's sake, a static array, like an array that never changes.
Dialogue: 0,0:29:34.83,0:29:41.42,英文,,0,0,0,,And the syntax for this is going to be give me an array called numbers using the square bracket notation.
Dialogue: 0,0:29:41.42,0:29:50.06,英文,,0,0,0,,And I'm going to immediately initialize it to 20, 500, 10, 5, 100, 1, and 50, reminiscent of those same denominations as before.
Dialogue: 0,0:29:50.06,0:29:54.15,英文,,0,0,0,,So this is a slightly new syntax that we've perhaps not seen.
Dialogue: 0,0:29:54.15,0:30:05.50,英文,,0,0,0,,And the curly braces here, which are different from for loops and while loops and functions, just tell the compiler, please give me an array of whatever size this is containing those numbers left to right.
Dialogue: 0,0:30:05.50,0:30:10.12,英文,,0,0,0,,I could alternatively use last week's syntax of saying something like this.
Dialogue: 0,0:30:10.12,0:30:13.24,英文,,0,0,0,,Let's see, 1, 2, 3, 4, 5, 6, 7 denominations.
Dialogue: 0,0:30:13.24,0:30:15.52,英文,,0,0,0,,I could alternatively do this.
Dialogue: 0,0:30:15.52,0:30:25.17,英文,,0,0,0,,And then I could say numbers bracket. 0, numbers bracket 0, equals 20, numbers bracket 1, equals 500.
Dialogue: 0,0:30:25.17,0:30:27.71,英文,,0,0,0,,And I could do this five more times.
Dialogue: 0,0:30:27.71,0:30:28.77,英文,,0,0,0,,That's just a little tedious.
Dialogue: 0,0:30:28.77,0:30:32.61,英文,,0,0,0,,If you know the numbers in advance, you don't have to tell the compiler how many there are.
Dialogue: 0,0:30:32.61,0:30:42.66,英文,,0,0,0,,You can just let it figure it out that your numbers will be 20, 500, 10, 5, 100, 1, and 50. So this is how you statically define an array.
Dialogue: 0,0:30:42.66,0:30:45.26,英文,,0,0,0,,All right, let me just go ahead and ask the user now for a number.
Dialogue: 0,0:30:45.26,0:30:48.92,英文,,0,0,0,,We'll call it n by using getInt and prompting them for a number.
Dialogue: 0,0:30:48.92,0:30:50.18,英文,,0,0,0,,So nothing new there.
Dialogue: 0,0:30:50.18,0:30:53.87,英文,,0,0,0,,And now let me go ahead and implement linear search.
Dialogue: 0,0:30:53.87,0:30:57.67,英文,,0,0,0,,And the pseudocode we had for this before used some array-like notation.
Dialogue: 0,0:30:57.67,0:31:00.83,英文,,0,0,0,,Let me go ahead then and start similarly, for.
Dialogue: 0,0:31:00.83,0:31:06.58,英文,,0,0,0,,Int i, and you almost always start counting at i by convention, so that's perhaps a good starting point.
Dialogue: 0,0:31:06.58,0:31:09.84,英文,,0,0,0,,I'm going to do this so long as i is less than 7.
Dialogue: 0,0:31:09.84,0:31:15.66,英文,,0,0,0,,Not the best design to hard code the 7, but this is just for demonstration's sake for now, because I know how many numbers I put in there.
Dialogue: 0,0:31:15.66,0:31:17.06,英文,,0,0,0,,And then I'm going to do i plus plus.
Dialogue: 0,0:31:17.06,0:31:21.68,英文,,0,0,0,,So now I have the beginnings of a loop that will just allow me to iterate over the entire array.
Dialogue: 0,0:31:21.68,0:31:25.39,英文,,0,0,0,,And let me ask this, if the current number at location i equals equals n,
Dialogue: 0,0:31:25.39,0:31:42.85,英文,,0,0,0,,which is the number the human typed in, then let's go ahead and do something simple like printf quote unquote found backslash n. And then per our discussion last week, to indicate that this is successful, I'm going to return 0 if I found it.
Dialogue: 0,0:31:42.85,0:31:55.54,英文,,0,0,0,,And if I don't find it, I'm just going to go down here and by default say, not found, backslash n. And just for convention, whoops, just for good measure, per convention, I'll return 1, or really any value other than 0.
Dialogue: 0,0:31:55.54,0:31:57.26,英文,,0,0,0,,0, recall, means success.
Dialogue: 0,0:31:57.26,0:32:02.80,英文,,0,0,0,,And any other integer tends to mean error of some sort, irrespective of the number I'm looking for.
Dialogue: 0,0:32:02.80,0:32:10.05,英文,,0,0,0,,So just to revisit, the only thing that's new here is this syntax for creating an array of seven numbers, these numbers.
Dialogue: 0,0:32:10.05,0:32:16.09,英文,,0,0,0,,And then after that, we have really highlighted here an implementation of linear search.
Dialogue: 0,0:32:16.09,0:32:22.67,英文,,0,0,0,,I mean, this is the C version, I dare say, of what Stephanie did on the board, whereas now the array is called numbers instead of doors.
Dialogue: 0,0:32:22.67,0:32:25.49,英文,,0,0,0,,But I think it's pretty much the same.
Dialogue: 0,0:32:25.49,0:32:30.62,英文,,0,0,0,,Let me go ahead and open my terminal window and run make search.
Dialogue: 0,0:32:30.62,0:32:33.02,英文,,0,0,0,,Seems to compile OK, dot slash search.
Dialogue: 0,0:32:33.02,0:32:36.44,英文,,0,0,0,,And let's go ahead and search for a number. We'll start with what we did before, 50.
Dialogue: 0,0:32:36.44,0:32:37.50,英文,,0,0,0,,And it's found.
Dialogue: 0,0:32:37.50,0:32:39.80,英文,,0,0,0,,Let's go ahead and run it again, dot slash search.
Dialogue: 0,0:32:39.80,0:32:42.66,英文,,0,0,0,,Let's search for maybe 20 at the beginning.
Dialogue: 0,0:32:42.66,0:32:43.64,英文,,0,0,0,,That one, too, is found.
Dialogue: 0,0:32:43.64,0:32:50.94,英文,,0,0,0,,Let's run it one more time, searching for 1,000, which is not among the denominations.
Dialogue: 0,0:32:50.94,0:32:53.02,英文,,0,0,0,,And that one, indeed, is not found.
Dialogue: 0,0:32:53.02,0:32:58.01,英文,,0,0,0,,So we've taken that idea from week 0, now formalized in week 3, and just translated it now
Dialogue: 0,0:32:58.01,0:33:05.49,英文,,0,0,0,,To code, questions on this implementation of linear search?
Dialogue: 0,0:33:05.49,0:33:08.84,英文,,0,0,0,,Linear search, nothing.
Dialogue: 0,0:33:08.84,0:33:11.38,英文,,0,0,0,,Oh, so successful so far today.
Dialogue: 0,0:33:11.38,0:33:17.26,英文,,0,0,0,,OK, so let's see if we can't maybe make this a little more interesting and see if we can't trip over
Dialogue: 0,0:33:17.26,0:33:23.18,英文,,0,0,0,,A detail that's going to be important in C. Instead of doing numbers, let me go ahead and do this.
Dialogue: 0,0:33:23.18,0:33:25.03,英文,,0,0,0,,We'll stay on theme with Monopoly.
Dialogue: 0,0:33:25.03,0:33:31.51,英文,,0,0,0,,And I went down the rabbit hole of reading the Wikipedia article on Monopoly and the original pieces or tokens that came with Monopoly.
Dialogue: 0,0:33:31.51,0:33:33.67,英文,,0,0,0,,And it turns out we can represent those with strings.
Dialogue: 0,0:33:33.67,0:33:37.09,英文,,0,0,0,,So I'm going to create an array called strings, plural.
Dialogue: 0,0:33:37.09,0:33:39.16,英文,,0,0,0,,of whatever size I defined here.
Dialogue: 0,0:33:39.16,0:33:51.73,英文,,0,0,0,,And the very first Monopoly pieces back in the day were a battleship that you could play with, a boot, a cannon, an iron, a thimble.
Dialogue: 0,0:33:51.73,0:33:54.69,英文,,0,0,0,,And a top hat, some of which you might know from the game nowadays.
Dialogue: 0,0:33:54.69,0:33:57.80,英文,,0,0,0,,Turns out they've been changing these, had no idea, over the years.
Dialogue: 0,0:33:57.80,0:34:00.18,英文,,0,0,0,,So here is now an array of strings.
Dialogue: 0,0:34:00.18,0:34:03.98,英文,,0,0,0,,Let me go ahead and prompt the user now, not for an integer anymore.
Dialogue: 0,0:34:03.98,0:34:08.03,英文,,0,0,0,,I want to now search for one of these strings, still using linear search.
Dialogue: 0,0:34:08.03,0:34:14.07,英文,,0,0,0,,So let me create a string s, set it equal to get string, prompt the user for a string to search for.
Dialogue: 0,0:34:14.07,0:34:19.74,英文,,0,0,0,,And then I think my code here is almost the same, except for one detail.
Dialogue: 0,0:34:19.74,0:34:22.02,英文,,0,0,0,,I now have an array called strings.
Dialogue: 0,0:34:22.02,0:34:31.29,英文,,0,0,0,,I now have a variable called s. But it turns out, for reasons we'll explore in more detail next week, this line of code is not going to work.
Dialogue: 0,0:34:31.29,0:34:36.90,英文,,0,0,0,,And it turns out the reason has to do with what we discussed last week of what a string really is.
Dialogue: 0,0:34:36.90,0:34:39.68,英文,,0,0,0,,And what is a string again?
Dialogue: 0,0:34:39.68,0:34:41.22,英文,,0,0,0,,A string is an array.
Dialogue: 0,0:34:41.22,0:34:52.07,英文,,0,0,0,,And it turns out, though, that equals equals is not going to generously compare all of the characters in an array for you just because you use equal equals.
Dialogue: 0,0:34:52.07,0:34:54.83,英文,,0,0,0,,It turns out it's not going to compare every letter.
Dialogue: 0,0:34:54.83,0:35:03.17,英文,,0,0,0,,And so thankfully, there is in the string library that we introduced last week a solution to this problem.
Dialogue: 0,0:35:03.17,0:35:06.80,英文,,0,0,0,,The reason for the problem we'll explore in more detail next week, but for now,
Dialogue: 0,0:35:06.80,0:35:15.70,英文,,0,0,0,,Just know that when you want to compare strings in C, especially if you've come into the class knowing a bit of Java or Python or some other language, you cannot use equals equals.
Dialogue: 0,0:35:15.70,0:35:21.79,英文,,0,0,0,,Even though you could in Scratch, you cannot in C. So what I have to actually do here is this.
Dialogue: 0,0:35:21.79,0:35:29.19,英文,,0,0,0,,I have to ask the question, does the return value of a function called strcmp,
Dialogue: 0,0:35:29.19,0:35:36.15,英文,,0,0,0,,equal 0 when passed in the current string and that user input.
Dialogue: 0,0:35:36.15,0:35:44.76,英文,,0,0,0,,So if you read the documentation for this function called strcmp, you'll see that it takes two strings as input, first one and second one.
Dialogue: 0,0:35:44.76,0:35:52.10,英文,,0,0,0,,It then, someone decades ago wrote the code that probably uses a for loop or a while loop to compare every character in each of those strings.
Dialogue: 0,0:35:52.10,0:35:56.50,英文,,0,0,0,,And it turns out it returns 0 if they are, in fact, equal.
Dialogue: 0,0:35:56.50,0:36:02.55,英文,,0,0,0,,Turns out, too, it will return a positive number or a negative number in other situations.
Dialogue: 0,0:36:02.55,0:36:10.93,英文,,0,0,0,,Any intuition for why it might actually be useful to have a function that allows you to check if two strings are equal?
Dialogue: 0,0:36:10.93,0:36:18.70,英文,,0,0,0,,If they're not equal, what else might be interesting to know when comparing two strings?
Dialogue: 0,0:36:18.70,0:36:23.66,英文,,0,0,0,,If certain values are?
Dialogue: 0,0:36:23.66,0:36:24.43,英文,,0,0,0,,OK, possibly.
Dialogue: 0,0:36:24.43,0:36:30.46,英文,,0,0,0,,Maybe you want to know just how similar they are. And that's indeed an algorithm unto itself. But strcmp is a little simpler than that.
Dialogue: 0,0:36:36.05,0:36:44.83,英文,,0,0,0,,Exactly. If you're trying to alphabetize a whole list of strings, just like your phone probably is for your contacts or address book, it turns out that
Dialogue: 0,0:36:44.83,0:36:53.83,英文,,0,0,0,,strcmp will actually return a positive number or a negative number or a zero based on whether maybe it comes alphabetically first or later or are, in fact, equal.
Dialogue: 0,0:36:53.83,0:36:58.77,英文,,0,0,0,,So that can be a useful thing. And that's just a teaser for a lower level explanation that we'll see next week.
Dialogue: 0,0:36:58.77,0:37:01.81,英文,,0,0,0,,So now let me cross my fingers and see if I got this right.
Dialogue: 0,0:37:01.81,0:37:05.50,英文,,0,0,0,,Let me go ahead and do make search.
Dialogue: 0,0:37:05.50,0:37:09.50,英文,,0,0,0,,Did compile, OK, albeit slowly, dot slash search.
Dialogue: 0,0:37:09.50,0:37:12.24,英文,,0,0,0,,And let's search for something like the thimble.
Dialogue: 0,0:37:12.24,0:37:14.32,英文,,0,0,0,,And we see that that's indeed found.
Dialogue: 0,0:37:14.32,0:37:19.27,英文,,0,0,0,,Otherwise, let's search for something that I know isn't there, like a race car, which was there when I grew up.
Dialogue: 0,0:37:19.27,0:37:23.35,英文,,0,0,0,,But, huh, segmentation fault. Core dumped.
Dialogue: 0,0:37:23.35,0:37:25.85,英文,,0,0,0,,And actually, some of you have tripped over this error before.
Dialogue: 0,0:37:25.85,0:37:27.21,英文,,0,0,0,,Anyone want to admit seeing this?
Dialogue: 0,0:37:27.21,0:37:29.62,英文,,0,0,0,,So yeah, not something we've talked about.
Dialogue: 0,0:37:29.62,0:37:32.22,英文,,0,0,0,,And honestly, not something I intended just now.
Dialogue: 0,0:37:32.22,0:37:34.64,英文,,0,0,0,,But that, too, we'll see next week.
Dialogue: 0,0:37:34.64,0:37:40.11,英文,,0,0,0,,Any intuition for why my program just broke?
Dialogue: 0,0:37:40.11,0:37:41.85,英文,,0,0,0,,I didn't really change the logic.
Dialogue: 0,0:37:41.85,0:37:43.54,英文,,0,0,0,,It's still linear search.
Dialogue: 0,0:37:43.54,0:37:46.36,英文,,0,0,0,,Let me hide the terminal so you can see all of the code at once.
Dialogue: 0,0:37:46.36,0:37:49.85,英文,,0,0,0,,The only thing I did was switch from integers to strings.
Dialogue: 0,0:37:49.85,0:37:52.49,英文,,0,0,0,,And I switched to str compare here.
Dialogue: 0,0:37:52.49,0:37:54.51,英文,,0,0,0,,But segmentation fault happened.
Dialogue: 0,0:37:54.51,0:38:01.56,英文,,0,0,0,,And the teaser is that that somehow relates to the computer's memory.
Dialogue: 0,0:38:01.56,0:38:03.54,英文,,0,0,0,,Yeah, and this is subtle, but spot on.
Dialogue: 0,0:38:03.54,0:38:12.91,英文,,0,0,0,,So 1, 2, 3, 4, 5, 6 elements total in this array versus the 7 numbers of monopoly denominations that we had earlier.
Dialogue: 0,0:38:12.91,0:38:15.91,英文,,0,0,0,,And this is where, sort of case in point, this came back to bite me.
Dialogue: 0,0:38:15.91,0:38:26.78,英文,,0,0,0,,The fact that I hardcoded this value as opposed to maybe separating it out as a constant or declaring it higher up kind of bit me here, because now I'm iterating over an array of size 6,
Dialogue: 0,0:38:26.78,0:38:32.44,英文,,0,0,0,,But clearly, I'm going one step too far, because I'm literally going to iterate seven times, not six.
Dialogue: 0,0:38:32.44,0:38:35.61,英文,,0,0,0,,So it's as though I'm looking at memory that's over here.
Dialogue: 0,0:38:35.61,0:38:37.53,英文,,0,0,0,,And indeed, next week, we'll focus on memory.
Dialogue: 0,0:38:37.53,0:38:38.77,英文,,0,0,0,,And that's just a bad thing.
Dialogue: 0,0:38:38.77,0:38:44.23,英文,,0,0,0,,So odds are, not even seeing your code from this past week, if any of you have had segmentation faults,
Dialogue: 0,0:38:44.23,0:38:47.28,英文,,0,0,0,,Odds are you touched memory that you shouldn't have.
Dialogue: 0,0:38:47.28,0:38:49.42,英文,,0,0,0,,You maybe looped too many times.
Dialogue: 0,0:38:49.42,0:38:52.80,英文,,0,0,0,,You might have used a negative number to get into your array.
Dialogue: 0,0:38:52.80,0:38:55.40,英文,,0,0,0,,In general, you touched memory that you shouldn't have.
Dialogue: 0,0:38:55.40,0:38:57.82,英文,,0,0,0,,And you touched a segment of memory that you shouldn't have.
Dialogue: 0,0:38:57.82,0:39:00.12,英文,,0,0,0,,The fix, though, at least in my case, is simple.
Dialogue: 0,0:39:00.12,0:39:01.38,英文,,0,0,0,,Just don't do that.
Dialogue: 0,0:39:01.38,0:39:03.33,英文,,0,0,0,,So let me go ahead and recompile this.
Dialogue: 0,0:39:03.33,0:39:05.86,英文,,0,0,0,,Make search.
Dialogue: 0,0:39:05.86,0:39:09.70,英文,,0,0,0,,Dot slash search, and I'll search again for race car.
Dialogue: 0,0:39:09.70,0:39:10.54,英文,,0,0,0,,Enter.
Dialogue: 0,0:39:10.54,0:39:13.55,英文,,0,0,0,,And now it does not crash, but it does tell me it's not found.
Dialogue: 0,0:39:13.55,0:39:17.11,英文,,0,0,0,,So subtle, but something you might yourself have tripped over already.
Dialogue: 0,0:39:17.11,0:39:23.13,英文,,0,0,0,,Questions, then, on what I just did, intentionally or otherwise?
Dialogue: 0,0:39:23.13,0:39:33.24,英文,,0,0,0,,Yeah, in front. AUDIENCE 1 One thing is, the program still works if you don't do return 0, return 1.
Dialogue: 0,0:39:33.24,0:39:34.14,英文,,0,0,0,,A really good question.
Dialogue: 0,0:39:34.14,0:39:38.94,英文,,0,0,0,,So the program will still work even if I don't return 0 or return 1.
Dialogue: 0,0:39:38.94,0:39:44.08,英文,,0,0,0,,In fact, let me go ahead and do that and just hide my terminal window for a second.
Dialogue: 0,0:39:44.08,0:39:48.23,英文,,0,0,0,,Let's get rid of the return here.
Dialogue: 0,0:39:48.23,0:39:50.81,英文,,0,0,0,,However, watch what happens here.
Dialogue: 0,0:39:50.81,0:39:53.75,英文,,0,0,0,,Let me go ahead and recompile this, make search.
Dialogue: 0,0:39:53.75,0:39:55.69,英文,,0,0,0,,Let me scroll up in my code here.
Dialogue: 0,0:39:55.69,0:39:57.50,英文,,0,0,0,,Let me go ahead and do dot slash search.
Dialogue: 0,0:39:57.50,0:40:00.32,英文,,0,0,0,,And let me go ahead and search for the first thing in the list.
Dialogue: 0,0:40:00.32,0:40:02.92,英文,,0,0,0,,Battleship, so I know that this should be found.
Dialogue: 0,0:40:02.92,0:40:04.67,英文,,0,0,0,,I hit Enter.
Dialogue: 0,0:40:04.67,0:40:06.15,英文,,0,0,0,,Huh, interesting.
Dialogue: 0,0:40:06.15,0:40:07.13,英文,,0,0,0,,So it's saying found, not found.
Dialogue: 0,0:40:07.13,0:40:13.06,英文,,0,0,0,,But do you see why, logically, in this case?
Dialogue: 0,0:40:13.06,0:40:14.08,英文,,0,0,0,,Exactly.
Dialogue: 0,0:40:14.08,0:40:15.22,英文,,0,0,0,,So the loop is still running.
Dialogue: 0,0:40:15.22,0:40:16.98,英文,,0,0,0,,So there's a couple of solutions to this.
Dialogue: 0,0:40:16.98,0:40:21.08,英文,,0,0,0,,I could, for instance, somehow break out of the code here.
Dialogue: 0,0:40:21.08,0:40:24.35,英文,,0,0,0,,But that's going to still result in line 18 executing.
Dialogue: 0,0:40:24.35,0:40:26.73,英文,,0,0,0,,I could then instead just return here.
Dialogue: 0,0:40:26.73,0:40:29.39,英文,,0,0,0,,I don't strictly need to return 1 down at the bottom.
Dialogue: 0,0:40:29.39,0:40:37.58,英文,,0,0,0,,But I made this claim last week that it tends to be helpful, as your programs get more sophisticated, to at least signify, just like a real-world programmer,
Dialogue: 0,0:40:37.58,0:40:39.22,英文,,0,0,0,,Error codes, when something goes wrong.
Dialogue: 0,0:40:39.22,0:40:44.18,英文,,0,0,0,,So returning 0 in main is the easiest way to signify my code is done.
Dialogue: 0,0:40:44.18,0:40:45.68,英文,,0,0,0,,I'm ready to exit successfully.
Dialogue: 0,0:40:45.68,0:40:46.50,英文,,0,0,0,,That's it.
Dialogue: 0,0:40:46.50,0:40:50.17,英文,,0,0,0,,But down here, I could absolutely still return 0, because it's not a huge deal.
Dialogue: 0,0:40:50.17,0:40:55.25,英文,,0,0,0,,It's not really an error that deserves annoying the user with some kind of pop-up that something went wrong.
Dialogue: 0,0:40:55.25,0:41:00.25,英文,,0,0,0,,But return 1 is just a lower-level way of signaling, eh, it didn't really find what I was looking for.
Dialogue: 0,0:41:00.25,0:41:03.46,英文,,0,0,0,,And remember from last week, you can see this as follows.
Dialogue: 0,0:41:03.46,0:41:05.52,英文,,0,0,0,,If I recompile this again.
Dialogue: 0,0:41:05.52,0:41:08.30,英文,,0,0,0,,Now that I've reverted those changes, so make search.
Dialogue: 0,0:41:08.30,0:41:23.01,英文,,0,0,0,,And if I do dot slash search and search for battleship, which is indeed found, recall I can execute this magical command, echo $?, which you're not going to often execute, but it shows you What main returned?
Dialogue: 0,0:41:23.01,0:41:32.35,英文,,0,0,0,,If I run search again and search for race car, which is not found, I see not found, but I can also run this command again and see that, oh, it returned one.
Dialogue: 0,0:41:32.35,0:41:40.10,英文,,0,0,0,,So now, if you fast forward a few months, a few years, when you're actually writing code in a company or for larger projects, you might want to be automating software.
Dialogue: 0,0:41:40.10,0:41:43.28,英文,,0,0,0,,You might not want the human to necessarily be running it manually.
Dialogue: 0,0:41:43.28,0:41:50.48,英文,,0,0,0,,You might want code to be automated by some nightly process or something like that, using these exit codes
Dialogue: 0,0:41:50.48,0:41:56.04,英文,,0,0,0,,Can a program determine yes or no that other code succeeded or failed?
Dialogue: 0,0:41:56.04,0:42:02.29,英文,,0,0,0,,Other questions on linear search in this way?
Dialogue: 0,0:42:02.29,0:42:11.58,英文,,0,0,0,,All right, well, let's translate this to one other feature of C here by incorporating these two ideas now into one other program.
Dialogue: 0,0:42:11.58,0:42:16.75,英文,,0,0,0,,So I'm going to create a phone book in C by doing code space phonebook.c.
Dialogue: 0,0:42:16.75,0:42:23.07,英文,,0,0,0,,And let's combine some of these ideas and implement this notion of searching a phone book for an actual name and getting back a number.
Dialogue: 0,0:42:23.07,0:42:31.02,英文,,0,0,0,,So I'm going to go ahead and quickly include some of the same things, cs50.h so we can get input, standardio.h so we can print output.
Dialogue: 0,0:42:31.02,0:42:35.46,英文,,0,0,0,,And I'm going to preemptively include string.h in case we need that one as well.
Dialogue: 0,0:42:35.46,0:42:39.24,英文,,0,0,0,,Int main void, no need for command line arguments today.
Dialogue: 0,0:42:39.24,0:42:42.54,英文,,0,0,0,,And let me give myself now. an array of names for this phone book.
Dialogue: 0,0:42:42.54,0:42:50.79,英文,,0,0,0,,So string names equals, and then in curly braces, how about Carter will be one person in the phone book, and David, myself, will be the other.
Dialogue: 0,0:42:50.79,0:42:53.19,英文,,0,0,0,,So we'll keep it short so we don't have to type too many names.
Dialogue: 0,0:42:53.19,0:42:55.87,英文,,0,0,0,,But this is a phone book with two people thus far.
Dialogue: 0,0:42:55.87,0:42:59.68,英文,,0,0,0,,Suppose now we want to also store Carter's phone number in mine.
Dialogue: 0,0:42:59.68,0:43:01.42,英文,,0,0,0,,So it's not just saying found or not found.
Dialogue: 0,0:43:01.42,0:43:05.50,英文,,0,0,0,,It's literally looking up our phone numbers like a proper phone book.
Dialogue: 0,0:43:05.50,0:43:09.36,英文,,0,0,0,,Well, at the moment, there's really no way to do this.
Dialogue: 0,0:43:09.36,0:43:13.56,英文,,0,0,0,,I could do something hackish, like I could put a number like 6174951000 after Carter.
Dialogue: 0,0:43:13.56,0:43:22.49,英文,,0,0,0,,I could maybe do something like 9494682750 after me.
Dialogue: 0,0:43:22.49,0:43:25.09,英文,,0,0,0,,But now you're kind of doing the whole apples and oranges thing, right?
Dialogue: 0,0:43:25.09,0:43:26.45,英文,,0,0,0,,Like, now it's not strings.
Dialogue: 0,0:43:26.45,0:43:28.52,英文,,0,0,0,,It's a string, int, string, int.
Dialogue: 0,0:43:28.52,0:43:31.42,英文,,0,0,0,,All right, so maybe I could just make all of these strings.
Dialogue: 0,0:43:31.42,0:43:34.58,英文,,0,0,0,,But now it's just a conceptual mixing of apples and oranges.
Dialogue: 0,0:43:34.58,0:43:36.50,英文,,0,0,0,,Like, yes, that's an array of four strings.
Dialogue: 0,0:43:36.50,0:43:43.17,英文,,0,0,0,,But now you're on the honor system to know that the first string is a name, the second string is a number, the third string is a, like, you can do it.
Dialogue: 0,0:43:43.17,0:43:45.13,英文,,0,0,0,,But it's a bit of a hack, so to speak.
Dialogue: 0,0:43:45.13,0:43:47.47,英文,,0,0,0,,So what might be cleaner than this?
Dialogue: 0,0:43:47.47,0:43:55.56,英文,,0,0,0,,Instead of combining our phone numbers into the same array as our names, what else might we do that's perhaps a little better?
Dialogue: 0,0:43:55.56,0:43:59.02,英文,,0,0,0,,Say a little louder?
Dialogue: 0,0:43:59.02,0:44:01.82,英文,,0,0,0,,A 2D array, possibly something we could do.
Dialogue: 0,0:44:01.82,0:44:08.15,英文,,0,0,0,,I'm going to keep it even simpler now, because we haven't used those by name, even though that is, we saw last week, technically what argv is.
Dialogue: 0,0:44:08.15,0:44:10.25,英文,,0,0,0,,What else could I do if I want to store names and numbers?
Dialogue: 0,0:44:10.25,0:44:12.35,英文,,0,0,0,,Yeah?
Dialogue: 0,0:44:12.35,0:44:13.47,英文,,0,0,0,,Yeah, let me go with this suggestion.
Dialogue: 0,0:44:13.47,0:44:14.51,英文,,0,0,0,,Just it's a little simpler.
Dialogue: 0,0:44:14.51,0:44:19.17,英文,,0,0,0,,Rather than complicate things in literally different dimensions, let me go ahead and do string.
Dialogue: 0,0:44:19.17,0:44:21.91,英文,,0,0,0,,Well, I could do int numbers.
Dialogue: 0,0:44:21.91,0:44:22.75,英文,,0,0,0,,But you know what?
Dialogue: 0,0:44:22.75,0:44:29.21,英文,,0,0,0,,So that we can support punctuation like dashes or even parentheses or country codes, I'm going to do this instead.
Dialogue: 0,0:44:29.21,0:44:37.43,英文,,0,0,0,,I'm going to do string numbers so that I can represent Carter's number as quote, unquote, plus 1 for the US, 617495.
Dialogue: 0,0:44:37.43,0:44:40.56,英文,,0,0,0,,1,000, complete with hyphens, as is US convention.
Dialogue: 0,0:44:40.56,0:44:47.90,英文,,0,0,0,,And then for mine, I'll go ahead and do plus one, nine, four, nine, how about four, six, eight, two, seven, five, zero, semicolon.
Dialogue: 0,0:44:47.90,0:44:54.09,英文,,0,0,0,,And now down below, let's actually enable the user to search this phone book, just like in week zero we did.
Dialogue: 0,0:44:54.09,0:44:55.95,英文,,0,0,0,,String name equals getString.
Dialogue: 0,0:44:55.95,0:45:00.03,英文,,0,0,0,,And let's ask the user for a name, presumably David or Carter or someone else.
Dialogue: 0,0:45:00.03,0:45:01.76,英文,,0,0,0,,And now let's re-implement linear search.
Dialogue: 0,0:45:01.76,0:45:05.90,英文,,0,0,0,,So for int i gets 0, i is less than 2.
Dialogue: 0,0:45:05.90,0:45:07.54,英文,,0,0,0,,And do as I say, not as I do.
Dialogue: 0,0:45:07.54,0:45:13.22,英文,,0,0,0,,I think we should beware this hard coding, but we'll keep it simple for now. I plus plus.
Dialogue: 0,0:45:13.22,0:45:17.04,英文,,0,0,0,,And then in this for loop, I think we have all of the ingredients to solve this.
Dialogue: 0,0:45:17.04,0:45:27.97,英文,,0,0,0,,So if the return value of str compare of all of the names, bracket i, comparing against the name that the human typed in, if all of that equals equals 0,
Dialogue: 0,0:45:27.97,0:45:36.97,英文,,0,0,0,, that is, all of the characters in those two strings are equal, then I think we can go ahead and say found, just like last time.
Dialogue: 0,0:45:36.97,0:45:40.05,英文,,0,0,0,,But you know what? Let's actually print Carter's or my phone number.
Dialogue: 0,0:45:40.05,0:45:41.51,英文,,0,0,0,,So found percent s.
Dialogue: 0,0:45:41.51,0:45:48.81,英文,,0,0,0,,And we'll plug in numbers, bracket i. And then just for consistency, I'll return 0 here and down here.
Dialogue: 0,0:45:48.81,0:45:53.72,英文,,0,0,0,,How about I'll say something like printf not found, just to be clear.
Dialogue: 0,0:45:53.72,0:45:56.30,英文,,0,0,0,,And then I'll return 1 as well.
Dialogue: 0,0:45:56.30,0:45:58.14,英文,,0,0,0,,So just to recap, here's all of the code.
Dialogue: 0,0:45:58.14,0:46:00.18,英文,,0,0,0,,It's almost the same as before.
Dialogue: 0,0:46:00.18,0:46:01.50,英文,,0,0,0,,Except now it's useful.
Dialogue: 0,0:46:01.50,0:46:03.44,英文,,0,0,0,,I'm not just saying found or not found.
Dialogue: 0,0:46:03.44,0:46:07.32,英文,,0,0,0,,I found a number in Monopoly, or I found a piece in Monopoly.
Dialogue: 0,0:46:07.32,0:46:12.87,英文,,0,0,0,,I'm looking up in one array one of the strings, and then I'm printing from the other array the answer.
Dialogue: 0,0:46:12.87,0:46:19.61,英文,,0,0,0,,So let me go ahead here and run the compiler, make phonebook, Enter.
Dialogue: 0,0:46:19.61,0:46:20.55,英文,,0,0,0,,OK, that's promising.
Dialogue: 0,0:46:20.55,0:46:21.09,英文,,0,0,0,,No errors.
Dialogue: 0,0:46:21.09,0:46:22.90,英文,,0,0,0,,Dot slash phonebook now.
Dialogue: 0,0:46:22.90,0:46:25.42,英文,,0,0,0,,And let's search for, for instance, Carter.
Dialogue: 0,0:46:25.42,0:46:28.04,英文,,0,0,0,,Enter. All right, so we found Carter's number.
Dialogue: 0,0:46:28.04,0:46:29.00,英文,,0,0,0,,All right, let me do that again.
Dialogue: 0,0:46:29.00,0:46:31.32,英文,,0,0,0,,Phonebook, let's search for David.
Dialogue: 0,0:46:31.32,0:46:32.90,英文,,0,0,0,,All right, we seem to have found David's number.
Dialogue: 0,0:46:32.90,0:46:34.06,英文,,0,0,0,,All right, let's do it one last time.
Dialogue: 0,0:46:34.06,0:46:35.54,英文,,0,0,0,,Phonebook, Enter.
Dialogue: 0,0:46:35.54,0:46:37.53,英文,,0,0,0,,And now we'll search for, like, John Harvard.
Dialogue: 0,0:46:37.53,0:46:38.63,英文,,0,0,0,,Enter.
Dialogue: 0,0:46:38.63,0:46:40.15,英文,,0,0,0,,Not found.
Dialogue: 0,0:46:40.15,0:46:45.63,英文,,0,0,0,,All right, so I dare say, albeit with minimal testing, this code is correct.
Dialogue: 0,0:46:45.63,0:46:48.23,英文,,0,0,0,,Would anyone now like to critique the design?
Dialogue: 0,0:46:48.23,0:46:55.23,英文,,0,0,0,,Does something rub you the wrong way, perhaps, about this approach here?
Dialogue: 0,0:46:55.23,0:47:01.49,英文,,0,0,0,,And as always, think about how, if the program maybe gets longer, more complicated, how decisions like this might unfold.
Dialogue: 0,0:47:01.49,0:47:04.47,英文,,0,0,0,,Yeah?
Dialogue: 0,0:47:04.47,0:47:13.18,英文,,0,0,0,,OK, so if i is less than 2, so technically, if I change the number of people in this phone book, I'm going to have to update i. And we've already seen that I get myself into trouble.
Dialogue: 0,0:47:13.18,0:47:14.08,英文,,0,0,0,,So that's bad design.
Dialogue: 0,0:47:14.08,0:47:14.30,英文,,0,0,0,,Good.
Dialogue: 0,0:47:14.30,0:47:21.89,英文,,0,0,0,,Say you add someone's name to the phone book, but you don't have a corresponding number.
Dialogue: 0,0:47:21.89,0:47:24.89,英文,,0,0,0,,So then when you go to hold their number,
Dialogue: 0,0:47:24.89,0:47:28.18,英文,,0,0,0,,Yeah, so again, I'm sort of trusting myself not to screw up.
Dialogue: 0,0:47:28.18,0:47:36.60,英文,,0,0,0,,If I add John or anyone else to the first array, but I forget to add their number to the second array, you know, eventually things are going to drift and be inconsistent.
Dialogue: 0,0:47:36.60,0:47:38.98,英文,,0,0,0,,And then the code will be incorrect at that point.
Dialogue: 0,0:47:38.98,0:47:43.52,英文,,0,0,0,,So sort of a poor design setting me up for future failure, if you will.
Dialogue: 0,0:47:43.52,0:47:45.00,英文,,0,0,0,,Other thoughts?
Dialogue: 0,0:47:45.00,0:47:53.32,英文,,0,0,0,,Yeah? AUDIENCE MEMBER 2 Yeah.
Dialogue: 0,0:47:53.32,0:47:54.10,英文,,0,0,0,,Yeah, really good.
Dialogue: 0,0:47:54.10,0:47:55.56,英文,,0,0,0,,We're assuming the same order.
Dialogue: 0,0:47:55.56,0:47:57.54,英文,,0,0,0,,From left to right, the names go.
Dialogue: 0,0:47:57.54,0:47:59.56,英文,,0,0,0,,And from left to right, the numbers go.
Dialogue: 0,0:47:59.56,0:48:01.15,英文,,0,0,0,,But that's kind of just the honor system.
Dialogue: 0,0:48:01.15,0:48:07.07,英文,,0,0,0,,Like, there's literally nothing in code preventing me from reversing the order, for whatever reason, or maybe sorting the names.
Dialogue: 0,0:48:07.07,0:48:10.13,英文,,0,0,0,,Like, they're sorted now, and maybe that's deliberate, but maybe it's not.
Dialogue: 0,0:48:10.13,0:48:12.95,英文,,0,0,0,,So this honor system here, too, is just not good, right?
Dialogue: 0,0:48:12.95,0:48:16.11,英文,,0,0,0,,I could put a comment in here to remind myself
Dialogue: 0,0:48:16.11,0:48:19.50,英文,,0,0,0,,Note to self, always update arrays the same way.
Dialogue: 0,0:48:19.50,0:48:26.22,英文,,0,0,0,,But something's going to happen eventually, especially when we have not two, but three, but 30, 300 names and numbers.
Dialogue: 0,0:48:26.22,0:48:29.59,英文,,0,0,0,,It would be nice to keep all of the related data together.
Dialogue: 0,0:48:29.59,0:48:38.07,英文,,0,0,0,,And so in fact, the one new feature of C we'll introduce today is one that actually allows us to implement our very own data structures.
Dialogue: 0,0:48:38.07,0:48:45.82,英文,,0,0,0,,You can think of arrays as a very lightweight data structure in that it allows you to cluster related data back to back to back to back.
Dialogue: 0,0:48:45.82,0:48:48.16,英文,,0,0,0,,And this is how strings are implemented.
Dialogue: 0,0:48:48.16,0:48:51.77,英文,,0,0,0,,They are a data structure effectively implemented with an array.
Dialogue: 0,0:48:51.77,0:48:59.69,英文,,0,0,0,,But with C and with other languages, it turns out you can invent your own data types, whether they're one-dimensional, two-dimensional, even, or beyond.
Dialogue: 0,0:48:59.69,0:49:07.10,英文,,0,0,0,,And with C, can you specifically Create your own types that have their own name.
Dialogue: 0,0:49:07.10,0:49:16.45,英文,,0,0,0,,So for instance, wouldn't it have been nice if C came with not just char, and int, and float, and long, and others.
Dialogue: 0,0:49:16.45,0:49:20.09,英文,,0,0,0,,Wouldn't it be nice if C came with a data type called person?
Dialogue: 0,0:49:20.09,0:49:22.87,英文,,0,0,0,,And ideally, a person would have a name and a number.
Dialogue: 0,0:49:22.87,0:49:24.83,英文,,0,0,0,,Now, that's a little naive and unrealistic.
Dialogue: 0,0:49:24.83,0:49:28.46,英文,,0,0,0,,Like, why would they define a person to have just those two fields?
Dialogue: 0,0:49:28.46,0:49:32.12,英文,,0,0,0,,Certainly, people could have disagreed what a person is. So they leave it to us.
Dialogue: 0,0:49:32.12,0:49:36.92,英文,,0,0,0,,Like, the authors of C gave us all of these primitives, ints and floats and strings and so forth.
Dialogue: 0,0:49:36.92,0:49:43.45,英文,,0,0,0,,But it's up to us now to use those in a more interesting way so that we can create an array of person
Dialogue: 0,0:49:43.45,0:49:48.07,英文,,0,0,0,,Variables, if you will, inside of an array called people, just to pluralize it here.
Dialogue: 0,0:49:48.07,0:49:49.63,英文,,0,0,0,,So how are we going to do this?
Dialogue: 0,0:49:49.63,0:49:58.00,英文,,0,0,0,,Well, for now, let's just stipulate that a person in the world will have a name and a number, that we could argue all day long what else a person should have.
Dialogue: 0,0:49:58.00,0:49:58.50,英文,,0,0,0,,And that's fine.
Dialogue: 0,0:49:58.50,0:50:01.93,英文,,0,0,0,,You can invent your own person eventually.
Dialogue: 0,0:50:01.93,0:50:06.49,英文,,0,0,0,,At the moment, I'm using just two variables to define a person's name and number.
Dialogue: 0,0:50:06.49,0:50:14.84,英文,,0,0,0,,But wouldn't it be nice to encapsulate, that is, combine these two data types into a new and improved data type called person?
Dialogue: 0,0:50:14.84,0:50:17.52,英文,,0,0,0,,And the syntax for that is going to be this.
Dialogue: 0,0:50:17.52,0:50:18.96,英文,,0,0,0,,So it's a bit of a mouthful.
Dialogue: 0,0:50:18.96,0:50:21.88,英文,,0,0,0,,But you can perhaps infer what some of this is doing here.
Dialogue: 0,0:50:21.88,0:50:24.63,英文,,0,0,0,,So it turns out C has a keyword called typedef.
Dialogue: 0,0:50:24.63,0:50:28.61,英文,,0,0,0,,As the name kind of suggests, this allows you to define your own type.
Dialogue: 0,0:50:28.61,0:50:31.59,英文,,0,0,0,,Struct is an indication that it's a structure.
Dialogue: 0,0:50:31.59,0:50:36.89,英文,,0,0,0,,It's like a structure that has multiple values inside of it that you are trying to define.
Dialogue: 0,0:50:36.89,0:50:42.38,英文,,0,0,0,,And then at the very bottom here, outside of the curly braces, is the name of the type that you want to create.
Dialogue: 0,0:50:42.38,0:50:46.80,英文,,0,0,0,,So you don't have discretion over using typedef or struct in this particular case.
Dialogue: 0,0:50:46.80,0:50:48.66,英文,,0,0,0,,But you can name the thing whatever you want.
Dialogue: 0,0:50:48.66,0:50:52.70,英文,,0,0,0,,And you can put anything in the structure that you want as well.
Dialogue: 0,0:50:52.70,0:50:56.77,英文,,0,0,0,,And as soon as this semicolon is executed at the bottom of the code,
Dialogue: 0,0:50:56.77,0:51:05.85,英文,,0,0,0,,Every line thereafter can now have access to a person data type, whether as a single variable or as an entire array.
Dialogue: 0,0:51:05.85,0:51:10.17,英文,,0,0,0,,So if I want to build on this then, let me go ahead and do this.
Dialogue: 0,0:51:10.17,0:51:12.47,英文,,0,0,0,,Let me go back to my C code here.
Dialogue: 0,0:51:12.47,0:51:17.53,英文,,0,0,0,,And I'm going to go ahead and change just a couple of things.
Dialogue: 0,0:51:17.53,0:51:19.06,英文,,0,0,0,,Let's go ahead and do this.
Dialogue: 0,0:51:19.06,0:51:23.48,英文,,0,0,0,,I'm going to go ahead and first get rid of those two hard-coded arrays.
Dialogue: 0,0:51:23.48,0:51:27.34,英文,,0,0,0,,And let me go ahead and at the top of my file,
Dialogue: 0,0:51:27.34,0:51:30.42,英文,,0,0,0,,Invent this type, so typedef struct.
Dialogue: 0,0:51:30.42,0:51:34.70,英文,,0,0,0,,Inside of it will be a string name and then a string number.
Dialogue: 0,0:51:34.70,0:51:36.81,英文,,0,0,0,,And then the name of this structure will be person.
Dialogue: 0,0:51:36.81,0:51:44.61,英文,,0,0,0,,And best practice would have me define it at the very top of my file so that any of my functions, in fact, could use it, even though I just have main in this case.
Dialogue: 0,0:51:44.61,0:51:50.48,英文,,0,0,0,,Now, if I wanted, I could do this, like person p1 and person p2.
Dialogue: 0,0:51:50.48,0:51:53.04,英文,,0,0,0,,But we know from last week, like, that already is bad design.
Dialogue: 0,0:51:53.04,0:52:01.69,英文,,0,0,0,,If you want to have multiple instances of the same type of variable, we should probably use what instead?
Dialogue: 0,0:52:01.69,0:52:03.48,英文,,0,0,0,,And yeah, an array.
Dialogue: 0,0:52:03.48,0:52:05.24,英文,,0,0,0,,So let me not even go down that road.
Dialogue: 0,0:52:05.24,0:52:06.84,英文,,0,0,0,,Let me instead just do this.
Dialogue: 0,0:52:06.84,0:52:09.84,英文,,0,0,0,,Person will be the type of the array.
Dialogue: 0,0:52:09.84,0:52:12.00,英文,,0,0,0,,But I'm going to call it, I could call it persons.
Dialogue: 0,0:52:12.00,0:52:13.74,英文,,0,0,0,,But in English, we typically say people.
Dialogue: 0,0:52:13.74,0:52:15.33,英文,,0,0,0,,So I'll call the array people.
Dialogue: 0,0:52:15.33,0:52:21.12,英文,,0,0,0,,And I want two people to exist in this array, though I could certainly change that number to be anything I want.
Dialogue: 0,0:52:21.12,0:52:27.16,英文,,0,0,0,,How now do you put a name inside of a person and then put the number inside of that same person?
Dialogue: 0,0:52:27.16,0:52:29.10,英文,,0,0,0,,Well, slightly new syntax today.
Dialogue: 0,0:52:29.10,0:52:30.64,英文,,0,0,0,,I'm going to go ahead and say this.
Dialogue: 0,0:52:30.64,0:52:34.45,英文,,0,0,0,,People bracket 0 just gives me the first person in the array.
Dialogue: 0,0:52:34.45,0:52:35.69,英文,,0,0,0,,That's not new.
Dialogue: 0,0:52:35.69,0:52:43.39,英文,,0,0,0,,But if you want to go inside of that person in memory, you use a dot, and then you just specify the name.
Dialogue: 0,0:52:43.39,0:52:44.79,英文,,0,0,0,,of the attribute they're in.
Dialogue: 0,0:52:44.79,0:52:49.50,英文,,0,0,0,,So if I want to set the first person's name to Carter, I just use that so-called dot notation.
Dialogue: 0,0:52:49.50,0:52:56.20,英文,,0,0,0,,And then if I want to set Carter's number using dot notation, I would do this, plus 1, 617, 495, 1,000.
Dialogue: 0,0:52:56.20,0:53:01.53,英文,,0,0,0,,And then if I want to do the same for myself, I would now do people bracket 1.
Dialogue: 0,0:53:01.53,0:53:03.93,英文,,0,0,0,,Dot name equals, quote unquote, David.
Dialogue: 0,0:53:03.93,0:53:13.25,英文,,0,0,0,,And then people bracket 1, still, dot number equals, quote unquote, plus 1, 9494682750.
Dialogue: 0,0:53:13.25,0:53:18.78,英文,,0,0,0,,And now, at the bottom of my file, I think my logic can pretty much stay the same.
Dialogue: 0,0:53:18.78,0:53:24.58,英文,,0,0,0,,I can still, on this line here, prompt the user for the name of the person they want to look up.
Dialogue: 0,0:53:24.58,0:53:28.10,英文,,0,0,0,,For now, even though I admit it's not the best design, I'm just doing this for demonstration's sake.
Dialogue: 0,0:53:28.10,0:53:31.52,英文,,0,0,0,,I'm going to leave the two there, because I know I have two people.
Dialogue: 0,0:53:31.52,0:53:34.18,英文,,0,0,0,,But down here, this is going to have to change.
Dialogue: 0,0:53:34.18,0:53:37.01,英文,,0,0,0,,I don't want to compare names bracket i anymore.
Dialogue: 0,0:53:37.01,0:53:42.23,英文,,0,0,0,,What do I want to type here as the first argument to str compare?
Dialogue: 0,0:53:42.23,0:53:44.07,英文,,0,0,0,,What do I want to do here?
Dialogue: 0,0:53:44.07,0:53:46.98,英文,,0,0,0,,Yeah.
Dialogue: 0,0:53:46.98,0:53:49.16,英文,,0,0,0,,So people i dot name, yeah.
Dialogue: 0,0:53:49.16,0:53:54.44,英文,,0,0,0,,So I want to go into the people array at the i-th location, because that's what my loop is doing.
Dialogue: 0,0:53:54.44,0:53:56.04,英文,,0,0,0,,It's updating i again and again.
Dialogue: 0,0:53:56.04,0:53:57.56,英文,,0,0,0,,And then look at name.
Dialogue: 0,0:53:57.56,0:53:58.16,英文,,0,0,0,,And that's good.
Dialogue: 0,0:53:58.16,0:53:59.66,英文,,0,0,0,,I think now I need to change this, too.
Dialogue: 0,0:53:59.66,0:54:01.91,英文,,0,0,0,,What do I want to print if the person is found?
Dialogue: 0,0:54:01.91,0:54:05.09,英文,,0,0,0,,Someone else?
Dialogue: 0,0:54:05.09,0:54:08.93,英文,,0,0,0,,What do I want to print here if I found the person's name?
Dialogue: 0,0:54:08.93,0:54:11.29,英文,,0,0,0,,Yeah.
Dialogue: 0,0:54:11.29,0:54:14.31,英文,,0,0,0,,Say a little louder.
Dialogue: 0,0:54:14.31,0:54:20.35,英文,,0,0,0,,Perfect, so people bracket i dot number, if indeed I want to print the corresponding number to this person.
Dialogue: 0,0:54:20.35,0:54:22.96,英文,,0,0,0,,And then I think the rest of my code can stay the same.
Dialogue: 0,0:54:22.96,0:54:27.36,英文,,0,0,0,,So let me go ahead and rerun make phonebook to recompile this version.
Dialogue: 0,0:54:27.36,0:54:28.18,英文,,0,0,0,,So far, so good.
Dialogue: 0,0:54:28.18,0:54:29.51,英文,,0,0,0,,Dot slash phonebook.
Dialogue: 0,0:54:29.51,0:54:31.47,英文,,0,0,0,,Let's go ahead and type in Carter's name.
Dialogue: 0,0:54:31.47,0:54:32.15,英文,,0,0,0,,Found.
Dialogue: 0,0:54:32.15,0:54:33.45,英文,,0,0,0,,All right, let's go ahead and run it again.
Dialogue: 0,0:54:33.45,0:54:34.69,英文,,0,0,0,,David's name.
Dialogue: 0,0:54:34.69,0:54:36.83,英文,,0,0,0,,Found, let's go ahead and run it one more time.
Dialogue: 0,0:54:36.83,0:54:38.88,英文,,0,0,0,,Type in John Harvard, for instance.
Dialogue: 0,0:54:38.88,0:54:40.46,英文,,0,0,0,,Not found in this case.
Dialogue: 0,0:54:40.46,0:54:43.70,英文,,0,0,0,,So fundamentally, the code isn't all that different.
Dialogue: 0,0:54:43.70,0:54:46.19,英文,,0,0,0,,Linear search is still behaving the same way.
Dialogue: 0,0:54:46.19,0:54:48.47,英文,,0,0,0,,And I admit, this is kind of ugly looking.
Dialogue: 0,0:54:48.47,0:54:52.58,英文,,0,0,0,,Like, we've kind of made a two-line solution, like five lines of code now.
Dialogue: 0,0:54:52.58,0:55:06.77,英文,,0,0,0,,But if we fast forward a week or two, when we start saving information to files, we'll introduce you to files like CSV files, comma-separated values, or spreadsheet files, which you've surely opened on your Mac or PC at some point in the past.
Dialogue: 0,0:55:06.77,0:55:12.01,英文,,0,0,0,,Suffice it to say, we'll soon learn techniques for storing information like names and numbers in files.
Dialogue: 0,0:55:12.01,0:55:19.18,英文,,0,0,0,,And at that point, we're not going to do any of this hackish sort of hard coding of the number 2 and manually typing my name and Carter's name and number into our program.
Dialogue: 0,0:55:19.18,0:55:21.72,英文,,0,0,0,,We'll read the information dynamically from a file.
Dialogue: 0,0:55:21.72,0:55:25.24,英文,,0,0,0,,And in a few weeks, we'll read it dynamically from a database instead.
Dialogue: 0,0:55:25.24,0:55:32.39,英文,,0,0,0,,But this is, for now, just syntactically how we can create an array of size 2 containing one person each.
Dialogue: 0,0:55:32.39,0:55:37.91,英文,,0,0,0,,We can update the name and number of the first person, update the name and the number of the second person, and then later,
Dialogue: 0,0:55:37.91,0:55:41.62,英文,,0,0,0,,Search across those names and print out the corresponding numbers.
Dialogue: 0,0:55:41.62,0:55:44.22,英文,,0,0,0,,And in this sense, this is a better design.
Dialogue: 0,0:55:44.22,0:55:44.86,英文,,0,0,0,,Why?
Dialogue: 0,0:55:44.86,0:55:53.56,英文,,0,0,0,,Because my person data type encapsulates now everything that it means to be a person, at least in this narrow world.
Dialogue: 0,0:55:53.56,0:56:03.81,英文,,0,0,0,,And if I want to add something to the notion of a person, for instance, I could go up to my typedef and tomorrow add an address to every person and start reading that in as well.
Dialogue: 0,0:56:03.81,0:56:05.83,英文,,0,0,0,,And now it's not the honor system.
Dialogue: 0,0:56:05.83,0:56:17.88,英文,,0,0,0,,A names array, a numbers array, an addresses array, and everything else you might imagine related to a person, it's all encapsulated, which is a term of art, inside of the same type.
Dialogue: 0,0:56:17.88,0:56:23.28,英文,,0,0,0,,Reminiscent, if some of you have programmed before, of something called object-oriented programming, but we're not there yet.
Dialogue: 0,0:56:23.28,0:56:24.82,英文,,0,0,0,,C is not that.
Dialogue: 0,0:56:24.82,0:56:35.07,英文,,0,0,0,,Questions on this use of struct or this new syntax, the dot operator being really the juicy part here?
Dialogue: 0,0:56:35.07,0:56:35.59,英文,,0,0,0,,Any questions?
Dialogue: 0,0:56:35.59,0:56:42.96,英文,,0,0,0,,Yeah?
Dialogue: 0,0:56:42.96,0:56:46.59,英文,,0,0,0,,On what line number?
Dialogue: 0,0:56:46.59,0:56:51.29,英文,,0,0,0,,16? So yeah, so syntactically, we introduced the square brackets last week.
Dialogue: 0,0:56:51.29,0:56:55.29,英文,,0,0,0,,So doing people bracket 0 just means go to the first person in the array.
Dialogue: 0,0:56:55.29,0:56:58.47,英文,,0,0,0,,That was like when Stephanie literally opened this door.
Dialogue: 0,0:56:58.47,0:57:00.11,英文,,0,0,0,,That's doors bracket 0.
Dialogue: 0,0:57:00.11,0:57:02.48,英文,,0,0,0,,But this is, of course, people bracket 0 instead.
Dialogue: 0,0:57:02.48,0:57:04.60,英文,,0,0,0,,Today, the dot is a new piece of syntax.
Dialogue: 0,0:57:04.60,0:57:08.72,英文,,0,0,0,,It means go inside of that person in memory.
Dialogue: 0,0:57:08.72,0:57:13.36,英文,,0,0,0,,And look at the name therein, and set it equal to Carter, and do the same for number.
Dialogue: 0,0:57:13.36,0:57:13.88,英文,,0,0,0,,So that's all.
Dialogue: 0,0:57:13.88,0:57:18.61,英文,,0,0,0,,It's like, open the locker door, go inside of it, and check or set the name and the number.
Dialogue: 0,0:57:18.61,0:57:19.77,英文,,0,0,0,,Yeah?
Dialogue: 0,0:57:29.34,0:57:30.86,英文,,0,0,0,,Attributes is fine.
Dialogue: 0,0:57:30.86,0:57:31.70,英文,,0,0,0,,Good question.
Dialogue: 0,0:57:31.70,0:57:34.16,英文,,0,0,0,,In the struct, can you set default values?
Dialogue: 0,0:57:34.16,0:57:35.12,英文,,0,0,0,,Short answer, no.
Dialogue: 0,0:57:35.12,0:57:42.49,英文,,0,0,0,,And this is where C becomes less featureable than more modern languages like Python and Java and others, where you can, in fact, do that.
Dialogue: 0,0:57:42.49,0:57:47.05,英文,,0,0,0,,So when we transition to Python in a few weeks' time, we'll see how we can start solving problems like that.
Dialogue: 0,0:57:47.05,0:57:51.56,英文,,0,0,0,,But for now, it's up to you to initialize name and number to something.
Dialogue: 0,0:58:04.69,0:58:08.55,英文,,0,0,0,,Really good question, how can we adjust or critique the design of what I'm doing?
Dialogue: 0,0:58:08.55,0:58:14.00,英文,,0,0,0,,This is one of the few situations where I would say hypocritically, do as I say, not as I do.
Dialogue: 0,0:58:14.00,0:58:17.88,英文,,0,0,0,,I am using pretty ugly lines like this just to introduce the syntax.
Dialogue: 0,0:58:17.88,0:58:26.22,英文,,0,0,0,,But my claim pedagogically today is that eventually when we start storing names and numbers or other things in files or in databases, you won't have this redundancy.
Dialogue: 0,0:58:26.22,0:58:31.83,英文,,0,0,0,,You'll have one line of code or two lines of code that read the information from the file or database.
Dialogue: 0,0:58:31.83,0:58:34.61,英文,,0,0,0,,And then fill the entire array with that data.
Dialogue: 0,0:58:34.61,0:58:38.28,英文,,0,0,0,,For now, I'm just doing it manually so as to keep our focus only on the new syntax.
Dialogue: 0,0:58:38.28,0:58:39.58,英文,,0,0,0,,But that's it.
Dialogue: 0,0:58:39.58,0:58:42.81,英文,,0,0,0,,So forgive the bad design by design today.
Dialogue: 0,0:58:42.81,0:58:45.83,英文,,0,0,0,,Other questions on this?
Dialogue: 0,0:58:45.83,0:58:47.89,英文,,0,0,0,,All right, that's been a lot already.
Dialogue: 0,0:58:47.89,0:58:50.45,英文,,0,0,0,,Why don't we go ahead and take our 10-minute break with snacks first?
Dialogue: 0,0:58:50.45,0:58:53.45,英文,,0,0,0,,We have some delightful brownies in the lobby.
Dialogue: 0,0:58:53.45,0:58:55.98,英文,,0,0,0,,All right, we are back.
Dialogue: 0,0:58:55.98,0:59:02.34,英文,,0,0,0,,And up until now, it clearly seems to be a good thing if your data is sorted, because you can use binary search.
Dialogue: 0,0:59:02.34,0:59:05.54,英文,,0,0,0,,You know a little something more about the data.
Dialogue: 0,0:59:05.54,0:59:10.79,英文,,0,0,0,,But it turns out that sorting in and of itself is kind of a problem to solve, too.
Dialogue: 0,0:59:10.79,0:59:19.87,英文,,0,0,0,,And you might think, well, if you're If sorting is going to be pretty fast, we absolutely should do it before we start searching, because that'll just speed up all of our searches.
Dialogue: 0,0:59:19.87,0:59:28.08,英文,,0,0,0,,But if sorting is slow, that kind of invites the question, well, should we bother sorting our data if we're only going to search the data maybe once, maybe twice?
Dialogue: 0,0:59:28.08,0:59:30.58,英文,,0,0,0,,And so here is going to be potentially a trade-off.
Dialogue: 0,0:59:30.58,0:59:33.33,英文,,0,0,0,,So let's consider what it means really to sort data.
Dialogue: 0,0:59:33.33,0:59:36.11,英文,,0,0,0,,In our case, it's just going to be simple. And use numbers.
Dialogue: 0,0:59:36.11,0:59:40.93,英文,,0,0,0,,But it might, in the case of the Googles of the world, be actual web pages or persons or the like.
Dialogue: 0,0:59:40.93,0:59:46.31,英文,,0,0,0,,So here is our typical picture for sorting input for solving any problem.
Dialogue: 0,0:59:46.31,0:59:48.27,英文,,0,0,0,,Input it left and output it right.
Dialogue: 0,0:59:48.27,0:59:54.56,英文,,0,0,0,,The input to our sort problem is going to be Some unsorted set of values.
Dialogue: 0,0:59:54.56,0:59:57.94,英文,,0,0,0,,And the output, ideally, will be the same set of values sorted.
Dialogue: 0,0:59:57.94,1:00:05.89,英文,,0,0,0,,And if we do this concretely, let's suppose that we want to go about sorting this list of numbers, 7, 2, 5, 4, 1, 6, 0, 3.
Dialogue: 0,1:00:05.89,1:00:10.11,英文,,0,0,0,,So it's all of the numbers from 0 to 7, but they're somehow jumbled up randomly.
Dialogue: 0,1:00:10.11,1:00:11.57,英文,,0,0,0,,That's going to be the input to the problem.
Dialogue: 0,1:00:11.57,1:00:18.03,英文,,0,0,0,,And the goal is now to sort those so that you indeed get out 0, 1, 2, 3, 4, 5, 6, 7 instead.
Dialogue: 0,1:00:18.03,1:00:23.92,英文,,0,0,0,,So it turns out there's lots of different ways we can actually sort numbers like these here.
Dialogue: 0,1:00:23.92,1:00:32.40,英文,,0,0,0,,And in fact, just to complement our search example earlier, could we perhaps quickly get some eight volunteers to come up, if you're comfortable appearing on the internet?
Dialogue: 0,1:00:32.40,1:00:39.17,英文,,0,0,0,,If you want to do one, OK, two, three, four, five, six, seven, eight, how about?
Dialogue: 0,1:00:39.17,1:00:44.99,英文,,0,0,0,,All right, come on down.
Dialogue: 0,1:00:44.99,1:00:48.06,英文,,0,0,0,,All right.
Dialogue: 0,1:00:48.06,1:00:50.68,英文,,0,0,0,,Come on over here, and I'll give you each a number.
Dialogue: 0,1:00:50.68,1:01:04.69,英文,,0,0,0,,And if you want to start to organize yourselves in the same order you see the numbers on the board, so look up on the overhead and organize yourselves from left to right in that same order.
Dialogue: 0,1:01:04.69,1:01:06.21,英文,,0,0,0,,And let's have the first of you perfect.
Dialogue: 0,1:01:06.21,1:01:07.91,英文,,0,0,0,,If you want to come right over here.
Dialogue: 0,1:01:07.91,1:01:10.41,英文,,0,0,0,,How about right in line with this?
Dialogue: 0,1:01:10.41,1:01:13.97,英文,,0,0,0,,All right, and a few more numbers.
Dialogue: 0,1:01:13.97,1:01:19.91,英文,,0,0,0,,All right, number 2, 6, and perfect.
Dialogue: 0,1:01:19.91,1:01:20.83,英文,,0,0,0,,Just the right number.
Dialogue: 0,1:01:20.83,1:01:21.81,英文,,0,0,0,,All right.
Dialogue: 0,1:01:21.81,1:01:22.97,英文,,0,0,0,,Uh-oh.
Dialogue: 0,1:01:22.97,1:01:23.63,英文,,0,0,0,,All right, there we go.
Dialogue: 0,1:01:23.63,1:01:24.52,英文,,0,0,0,,Number 3.
Dialogue: 0,1:01:24.52,1:01:26.26,英文,,0,0,0,,All right, so let's just do a quick check.
Dialogue: 0,1:01:26.26,1:01:30.54,英文,,0,0,0,,We have 7, 2, 5, 4, 1, 6, 0, 3.
Dialogue: 0,1:01:30.54,1:01:31.40,英文,,0,0,0,,Very good so far.
Dialogue: 0,1:01:31.40,1:01:34.60,英文,,0,0,0,,Do you want to just scooch a little this way just to make a little more room?
Dialogue: 0,1:01:34.60,1:01:37.96,英文,,0,0,0,,All right, and let's consider now who we have here on stage.
Dialogue: 0,1:01:37.96,1:01:40.58,英文,,0,0,0,,You want to each say a quick hello to the audience?
Dialogue: 0,1:01:40.58,1:01:42.10,英文,,0,0,0,,Hi, my name is Ryan.
Dialogue: 0,1:01:42.10,1:01:45.85,英文,,0,0,0,,I'm a first year from Pennypacker.
Dialogue: 0,1:01:45.85,1:01:46.91,英文,,0,0,0,,Hi, my name's Itzel.
Dialogue: 0,1:01:46.91,1:01:49.23,英文,,0,0,0,,I'm a first-year at Strauss.
Dialogue: 0,1:01:49.23,1:01:50.23,英文,,0,0,0,,Hi, my name is Lucy.
Dialogue: 0,1:01:50.23,1:01:52.67,英文,,0,0,0,,I'm a first-year from Greeno.
Dialogue: 0,1:01:52.67,1:01:53.63,英文,,0,0,0,,Hi, my name is Shiloh.
Dialogue: 0,1:01:53.63,1:01:54.95,英文,,0,0,0,,I'm a first-year in Wigglesworth.
Dialogue: 0,1:01:54.95,1:02:00.26,英文,,0,0,0,,Hi, my name's Jack, and I'm a first-year in Strauss.
Dialogue: 0,1:02:00.26,1:02:01.20,英文,,0,0,0,,Hi, my name's Catherine.
Dialogue: 0,1:02:01.20,1:02:03.16,英文,,0,0,0,,I'm a first-year in Strauss.
Dialogue: 0,1:02:03.16,1:02:06.46,英文,,0,0,0,,Hi, my name is Michael, and I'm a first-year at Pennypacker.
Dialogue: 0,1:02:06.46,1:02:07.46,英文,,0,0,0,,Hi, my name is Muhammad.
Dialogue: 0,1:02:07.46,1:02:09.17,英文,,0,0,0,,I'm a first-year in Masseuse.
Dialogue: 0,1:02:09.17,1:02:10.67,英文,,0,0,0,,Nice, welcome aboard.
Dialogue: 0,1:02:10.67,1:02:24.14,英文,,0,0,0,,All right, so let's consider now how we might go about sorting our kind volunteers here, the goal being to get them into order from smallest to largest so that presumably then we can use something smarter than just linear search.
Dialogue: 0,1:02:24.14,1:02:25.86,英文,,0,0,0,,We could actually use binary search.
Dialogue: 0,1:02:25.86,1:02:28.03,英文,,0,0,0,,Assuming that they are already then sorted.
Dialogue: 0,1:02:28.03,1:02:32.67,英文,,0,0,0,,So let me propose that we first consider an algorithm that actually has a name called SelectionSort.
Dialogue: 0,1:02:32.67,1:02:43.56,英文,,0,0,0,,And SelectionSort is going to be one that literally has me, or really you as the programmer, selecting the smallest element again and again, and then putting them into the appropriate place.
Dialogue: 0,1:02:43.56,1:02:47.24,英文,,0,0,0,,So let me go ahead and start this here, starting with the number 7.
Dialogue: 0,1:02:47.24,1:02:49.23,英文,,0,0,0,,At the moment, 7 is the smallest number I've found.
Dialogue: 0,1:02:49.23,1:02:50.59,英文,,0,0,0,,So I'm going to make mental note of that.
Dialogue: 0,1:02:50.59,1:02:52.59,英文,,0,0,0,,With a mental variable, if you will.
Dialogue: 0,1:02:52.59,1:02:53.57,英文,,0,0,0,,I'm going to move on now.
Dialogue: 0,1:02:53.57,1:02:55.03,英文,,0,0,0,,Oh, number 2 is obviously smaller.
Dialogue: 0,1:02:55.03,1:02:58.41,英文,,0,0,0,,So I'm just going to update my mental reminder that 2 is now the smallest.
Dialogue: 0,1:02:58.41,1:03:01.58,英文,,0,0,0,,Effectively forgetting, for now, number 7.
Dialogue: 0,1:03:01.58,1:03:02.76,英文,,0,0,0,,5, not smaller.
Dialogue: 0,1:03:02.76,1:03:03.70,英文,,0,0,0,,4, not smaller.
Dialogue: 0,1:03:03.70,1:03:04.42,英文,,0,0,0,,1, smaller.
Dialogue: 0,1:03:04.42,1:03:06.36,英文,,0,0,0,,And I'm going to make mental note of that.
Dialogue: 0,1:03:06.36,1:03:07.00,英文,,0,0,0,,6, not smaller.
Dialogue: 0,1:03:07.00,1:03:08.16,英文,,0,0,0,,0, even smaller.
Dialogue: 0,1:03:08.16,1:03:11.32,英文,,0,0,0,,I'll make mental note of that, having forgotten now everything else.
Dialogue: 0,1:03:11.32,1:03:13.16,英文,,0,0,0,,And now number 3 is not smaller.
Dialogue: 0,1:03:13.16,1:03:14.74,英文,,0,0,0,,So what's your name again?
Dialogue: 0,1:03:14.74,1:03:16.41,英文,,0,0,0,,So Michael is number 0.
Dialogue: 0,1:03:16.41,1:03:18.35,英文,,0,0,0,,He belongs, of course, way down there.
Dialogue: 0,1:03:18.35,1:03:20.92,英文,,0,0,0,,But unfortunately, you are?
Dialogue: 0,1:03:20.92,1:03:21.74,英文,,0,0,0,,Ryan?
Dialogue: 0,1:03:21.74,1:03:24.57,英文,,0,0,0,,Ryan is in the way, so what should we do?
Dialogue: 0,1:03:24.57,1:03:27.73,英文,,0,0,0,,How should we start to sort this list?
Dialogue: 0,1:03:27.73,1:03:30.66,英文,,0,0,0,,Where should number 0 go?
Dialogue: 0,1:03:30.66,1:03:35.25,英文,,0,0,0,,Yeah, do you want to say it louder?
Dialogue: 0,1:03:35.25,1:03:36.63,英文,,0,0,0,,Yeah, so let's just go ahead and swap.
Dialogue: 0,1:03:36.63,1:03:39.31,英文,,0,0,0,,So if you want to go ahead and 0, go on where 7 is.
Dialogue: 0,1:03:39.31,1:03:41.27,英文,,0,0,0,,We need to make room for number 7.
Dialogue: 0,1:03:41.27,1:03:45.70,英文,,0,0,0,,It would kind of be cheating if maybe everyone kind of politely stepped over to the side.
Dialogue: 0,1:03:45.70,1:03:46.04,英文,,0,0,0,,Why?
Dialogue: 0,1:03:46.04,1:03:54.26,英文,,0,0,0,,Because if we imagine all of our volunteers here to be an array, that's a crazy amount of work to have every element in the array shift to the left just to make room.
Dialogue: 0,1:03:54.26,1:03:57.14,英文,,0,0,0,,So we're going to keep it simple and just evict whoever is there.
Dialogue: 0,1:03:57.14,1:04:01.01,英文,,0,0,0,,Now, maybe we get lucky and number 7 is actually closer to its destination.
Dialogue: 0,1:04:01.01,1:04:05.25,英文,,0,0,0,,Maybe we get unlucky and it goes farther away, but we've at least solved one problem.
Dialogue: 0,1:04:05.25,1:04:10.35,英文,,0,0,0,,If we had n problems at first, now we have n minus 1, because number 0 is indeed in the right place.
Dialogue: 0,1:04:10.35,1:04:15.46,英文,,0,0,0,,So if I continue to act this out, let me go ahead and say 2, OK, currently the smallest.
Dialogue: 0,1:04:15.46,1:04:16.20,英文,,0,0,0,,5, no.
Dialogue: 0,1:04:16.20,1:04:16.76,英文,,0,0,0,,4, no.
Dialogue: 0,1:04:16.76,1:04:18.00,英文,,0,0,0,,1, currently the smallest.
Dialogue: 0,1:04:18.00,1:04:20.50,英文,,0,0,0,,I'll make mental note.
Dialogue: 0,1:04:20.50,1:04:21.74,英文,,0,0,0,,6, 7, 3.
Dialogue: 0,1:04:21.74,1:04:23.02,英文,,0,0,0,,And now let me pause.
Dialogue: 0,1:04:23.02,1:04:26.07,英文,,0,0,0,,1 is obviously the now smallest element.
Dialogue: 0,1:04:26.07,1:04:27.79,英文,,0,0,0,,So did I need to keep going?
Dialogue: 0,1:04:27.79,1:04:31.89,英文,,0,0,0,,Well, it turns out, at least as I've defined selection sort, I do need to keep going.
Dialogue: 0,1:04:31.89,1:04:36.67,英文,,0,0,0,,Because I only claim that I'm using one variable in my mind to remember the then smallest element.
Dialogue: 0,1:04:36.67,1:04:41.43,英文,,0,0,0,,I'm not smart enough, like us humans, to remember, oh, wait a minute, 1 is definitely the smallest.
Dialogue: 0,1:04:41.43,1:04:43.11,英文,,0,0,0,,Now, I don't have that whole recollection.
Dialogue: 0,1:04:43.11,1:04:45.47,英文,,0,0,0,,So I just am keeping track of the now smallest.
Dialogue: 0,1:04:45.47,1:04:47.11,英文,,0,0,0,,So number 1, your name was?
Dialogue: 0,1:04:47.11,1:04:47.77,英文,,0,0,0,,Jack.
Dialogue: 0,1:04:47.77,1:04:49.44,英文,,0,0,0,,Where should Jack go?
Dialogue: 0,1:04:49.44,1:04:51.48,英文,,0,0,0,,Probably there, and what's your name?
Dialogue: 0,1:04:51.48,1:04:51.95,英文,,0,0,0,,Itzel?
Dialogue: 0,1:04:51.95,1:04:57.41,英文,,0,0,0,,OK, so Jack and Itzel, if you want to swap places, we've now solved two of the n total problems.
Dialogue: 0,1:04:57.41,1:05:02.49,英文,,0,0,0,,And now we'll do it a little faster if each of you want to sort of start to swap as I find the right person.
Dialogue: 0,1:05:02.49,1:05:04.29,英文,,0,0,0,,So 5, smallest.
Dialogue: 0,1:05:04.29,1:05:05.43,英文,,0,0,0,,4 is smaller.
Dialogue: 0,1:05:05.43,1:05:06.41,英文,,0,0,0,,2 is smaller.
Dialogue: 0,1:05:06.41,1:05:07.85,英文,,0,0,0,,Got to keep checking.
Dialogue: 0,1:05:07.85,1:05:09.84,英文,,0,0,0,,OK, 2 was smaller.
Dialogue: 0,1:05:09.84,1:05:11.72,英文,,0,0,0,,All right, now I'm going to go back to the beginning.
Dialogue: 0,1:05:11.72,1:05:13.44,英文,,0,0,0,,All right, 4 is small.
Dialogue: 0,1:05:13.44,1:05:14.28,英文,,0,0,0,,5 is not.
Dialogue: 0,1:05:14.28,1:05:14.74,英文,,0,0,0,,6 is not.
Dialogue: 0,1:05:14.74,1:05:15.04,英文,,0,0,0,,7 is not.
Dialogue: 0,1:05:15.04,1:05:16.16,英文,,0,0,0,,Ooh, 3 is small.
Dialogue: 0,1:05:16.16,1:05:17.88,英文,,0,0,0,,Where do you want to go?
Dialogue: 0,1:05:17.88,1:05:18.76,英文,,0,0,0,,OK, good.
Dialogue: 0,1:05:18.76,1:05:19.92,英文,,0,0,0,,I'm going to go back here.
Dialogue: 0,1:05:19.92,1:05:21.18,英文,,0,0,0,,And I can be a little smart.
Dialogue: 0,1:05:21.18,1:05:24.87,英文,,0,0,0,,I don't have to go all the way to the end, because I know these folks are already sorted.
Dialogue: 0,1:05:24.87,1:05:26.67,英文,,0,0,0,,So I can at least optimize slightly.
Dialogue: 0,1:05:26.67,1:05:29.17,英文,,0,0,0,,So now 5 is small, 6 is small, 7 is 4.
Dialogue: 0,1:05:29.17,1:05:33.19,英文,,0,0,0,,4 is smaller if you want to go in place there.
Dialogue: 0,1:05:33.19,1:05:34.85,英文,,0,0,0,,And now here things get interesting.
Dialogue: 0,1:05:34.85,1:05:39.51,英文,,0,0,0,,I can optimize by not looking at these folks anymore, because they're obviously problem solved.
Dialogue: 0,1:05:39.51,1:05:42.96,英文,,0,0,0,,But now 5 is small, 6 is not, 7 is not.
Dialogue: 0,1:05:42.96,1:05:45.14,英文,,0,0,0,,OK, 5, you can stay where you are.
Dialogue: 0,1:05:45.14,1:05:49.58,英文,,0,0,0,,Now, a human in the room is obviously going to question why I'm wasting any more time.
Dialogue: 0,1:05:49.58,1:05:52.20,英文,,0,0,0,,But with selection sort, as I've defined it thus far,
Dialogue: 0,1:05:52.20,1:05:55.99,英文,,0,0,0,,I still have to now check six is smallest, not seven.
Dialogue: 0,1:05:55.99,1:05:58.55,英文,,0,0,0,,And now my final step, OK, they're all in place.
Dialogue: 0,1:05:58.55,1:06:05.11,英文,,0,0,0,,So here, too, is this dichotomy between what we all have is this bird's eye view of the whole problem, where it's obvious where everyone needs to go.
Dialogue: 0,1:06:05.11,1:06:09.19,英文,,0,0,0,,But a computer implementing this with an array really has to be more methodical.
Dialogue: 0,1:06:09.19,1:06:10.69,英文,,0,0,0,,And we're actually saving a step here.
Dialogue: 0,1:06:10.69,1:06:13.84,英文,,0,0,0,,If we were really doing this, none of these numbers would be visible.
Dialogue: 0,1:06:13.84,1:06:16.84,英文,,0,0,0,,All eight of our volunteers would be inside of a locked door.
Dialogue: 0,1:06:16.84,1:06:19.28,英文,,0,0,0,,And only then could we see them one at a time.
Dialogue: 0,1:06:19.28,1:06:21.84,英文,,0,0,0,,But we're focusing now just on the sorting aspect.
Dialogue: 0,1:06:21.84,1:06:29.70,英文,,0,0,0,,So let me just, before we do one other demonstration here, propose that what I really just did here in pseudocode was something like this.
Dialogue: 0,1:06:29.70,1:06:38.31,英文,,0,0,0,,For i from 0 to n minus 1, keeping in mind that 0 is always the left of the array, n minus 1 is always the right end of the array.
Dialogue: 0,1:06:38.31,1:06:45.73,英文,,0,0,0,,For i from 0 to n minus 1, I found the smallest number between numbers bracket i and numbers bracket n minus 1.
Dialogue: 0,1:06:45.73,1:06:48.61,英文,,0,0,0,,And that's the very geeky way of expressing this optimization.
Dialogue: 0,1:06:48.61,1:06:51.61,英文,,0,0,0,,I'm always starting from numbers bracket i, wherever I am.
Dialogue: 0,1:06:51.61,1:06:53.35,英文,,0,0,0,,and then everything else to the right.
Dialogue: 0,1:06:53.35,1:06:57.11,英文,,0,0,0,,And that's what was allowing me to ignore the already sorted volunteers.
Dialogue: 0,1:06:57.11,1:07:05.58,英文,,0,0,0,,If, though, my last line says, swap smallest number with numbers i, I think that implements what our humans were doing by physically walking to another spot.
Dialogue: 0,1:07:05.58,1:07:09.38,英文,,0,0,0,,All right, so that then would be what we'll call selection sort.
Dialogue: 0,1:07:09.38,1:07:13.36,英文,,0,0,0,,Let's go ahead and take a second approach here using an algorithm that I'm going to call bubble sort.
Dialogue: 0,1:07:13.36,1:07:16.08,英文,,0,0,0,,But to do this, we need you all to reset to your original locations.
Dialogue: 0,1:07:16.08,1:07:20.00,英文,,0,0,0,,We have a little cheat sheet on the board if you'd like to go back to this position here.
Dialogue: 0,1:07:20.00,1:07:26.67,英文,,0,0,0,,And let me take a fundamentally different approach, because I'm not really liking selection sort as is, because it's kind of a lot of walking back and forth.
Dialogue: 0,1:07:26.67,1:07:30.71,英文,,0,0,0,,And a lot of walking suggests a lot of steps again and again.
Dialogue: 0,1:07:30.71,1:07:31.99,英文,,0,0,0,,So what might I do instead?
Dialogue: 0,1:07:31.99,1:07:38.15,英文,,0,0,0,,Well, bubble sort is going to have me focus a little more intuitively on just smaller problems. And let's see if this gets me somewhere else.
Dialogue: 0,1:07:38.15,1:07:43.61,英文,,0,0,0,,So if I just look at this list without looking at everyone else, 7 and 2, this is obviously a problem.
Dialogue: 0,1:07:43.61,1:07:44.29,英文,,0,0,0,,Why?
Dialogue: 0,1:07:44.29,1:07:45.41,英文,,0,0,0,,Because you're out of order.
Dialogue: 0,1:07:45.41,1:07:49.75,英文,,0,0,0,,So let's just solve one tiny problem first. So 7 and 2, why don't you swap?
Dialogue: 0,1:07:49.75,1:07:54.26,英文,,0,0,0,,I know 2 is in a better place now, because she's definitely less than 7.
Dialogue: 0,1:07:54.26,1:07:55.78,英文,,0,0,0,,So I think I can now move on.
Dialogue: 0,1:07:55.78,1:07:57.26,英文,,0,0,0,,7 and 5, problem.
Dialogue: 0,1:07:57.26,1:07:58.82,英文,,0,0,0,,So let's solve that.
Dialogue: 0,1:07:58.82,1:07:59.84,英文,,0,0,0,,7 and 4, problem.
Dialogue: 0,1:07:59.84,1:08:00.98,英文,,0,0,0,,Let's solve that.
Dialogue: 0,1:08:00.98,1:08:02.82,英文,,0,0,0,,7 and 1, let's solve that.
Dialogue: 0,1:08:02.82,1:08:03.92,英文,,0,0,0,,7 and 6, let's solve that.
Dialogue: 0,1:08:03.92,1:08:05.30,英文,,0,0,0,,7 and 0, solve that.
Dialogue: 0,1:08:05.30,1:08:06.60,英文,,0,0,0,,7 and 3, solve that.
Dialogue: 0,1:08:06.60,1:08:07.42,英文,,0,0,0,,OK, done.
Dialogue: 0,1:08:07.42,1:08:09.21,英文,,0,0,0,,Sorted, right?
Dialogue: 0,1:08:09.21,1:08:11.81,英文,,0,0,0,,All right, obviously not, if you just glance at these numbers here.
Dialogue: 0,1:08:11.81,1:08:15.08,英文,,0,0,0,,But we have fundamentally taken a bite out of the problem.
Dialogue: 0,1:08:15.08,1:08:17.02,英文,,0,0,0,,7 is indeed in the right place.
Dialogue: 0,1:08:17.02,1:08:21.38,英文,,0,0,0,,So we maximally have n minus 1 other problems to solve.
Dialogue: 0,1:08:21.38,1:08:23.64,英文,,0,0,0,,So how do I do this?
Dialogue: 0,1:08:23.64,1:08:37.05,英文,,0,0,0,,I think I can just repeat the same logic. Let me go over here. 2 and 5, good. 5 and 4, no. 5 and 1, no. 5 and 6, yes. 6 and 0, no. 6 and 3, no.
Dialogue: 0,1:08:37.05,1:08:39.37,英文,,0,0,0,,So now we've solved two of the problems.
Dialogue: 0,1:08:39.37,1:08:42.60,英文,,0,0,0,,And what's nice about bubble sort, at least at a glance, it's nice and simple.
Dialogue: 0,1:08:42.60,1:08:46.70,英文,,0,0,0,,It's nice and local. And you just keep incrementally solving more and more problems.
Dialogue: 0,1:08:46.70,1:08:47.98,英文,,0,0,0,,So let's go ahead and do this again.
Dialogue: 0,1:08:47.98,1:08:50.38,英文,,0,0,0,,And we can do it faster.
Dialogue: 0,1:08:50.38,1:08:51.72,英文,,0,0,0,,2 and 4 we know are good.
Dialogue: 0,1:08:51.72,1:08:56.15,英文,,0,0,0,,4 and 1. 4 and 5. 5 and 0. 5 and 3. 5 and 6. 6 and 7. Good. So we go back. 2 and 1.
Dialogue: 0,1:08:56.15,1:08:58.49,英文,,0,0,0,,Ah, now another problem solved.
Dialogue: 0,1:08:58.49,1:09:09.93,英文,,0,0,0,,2 and 4. 4 and 0, 4 and 3, 4 and 5, 5 and 6, 6 and 7.
Dialogue: 0,1:09:09.93,1:09:15.28,英文,,0,0,0,,And so notice, too, as per its name, the largest elements have bubbled their way up to the top.
Dialogue: 0,1:09:15.28,1:09:18.34,英文,,0,0,0,,And that's what seems to be happening just as we're fixing some remaining problems.
Dialogue: 0,1:09:18.34,1:09:26.19,英文,,0,0,0,,So almost done. 1 and 2, 2 and 0. 2 and 3, 3 and 4, 4 and 5, 5 and 6, 6 and 7.
Dialogue: 0,1:09:26.19,1:09:27.71,英文,,0,0,0,,Almost done.
Dialogue: 0,1:09:27.71,1:09:29.99,英文,,0,0,0,,Obviously, to us humans, it looks done.
Dialogue: 0,1:09:29.99,1:09:32.73,英文,,0,0,0,,How do I know as the computer for sure?
Dialogue: 0,1:09:32.73,1:09:34.77,英文,,0,0,0,,What would be the most surefire way for me to now?
Dialogue: 0,1:09:34.77,1:09:35.59,英文,,0,0,0,,Oh, it's not done.
Dialogue: 0,1:09:35.59,1:09:36.51,英文,,0,0,0,,Sorry.
Dialogue: 0,1:09:36.51,1:09:38.00,英文,,0,0,0,,That's a bug.
Dialogue: 0,1:09:38.00,1:09:40.38,英文,,0,0,0,,OK, 1 and 0.
Dialogue: 0,1:09:40.38,1:09:43.36,英文,,0,0,0,,OK, 1 and 2, 2 and 3, 3 and 4, 4 and 5, 5 and 6, 6 and 7.
Dialogue: 0,1:09:43.36,1:09:48.07,英文,,0,0,0,,OK, so now it's obviously sorted to the rest of us on stage.
Dialogue: 0,1:09:48.07,1:09:50.29,英文,,0,0,0,,How could I confirm as much as code?
Dialogue: 0,1:09:50.29,1:09:52.69,英文,,0,0,0,,You're doing it with your mind, just glancing at this.
Dialogue: 0,1:09:52.69,1:09:56.17,英文,,0,0,0,,How would the computer, the code, know for sure that this list is now sorted?
Dialogue: 0,1:09:56.17,1:09:58.45,英文,,0,0,0,,Yeah?
Dialogue: 0,1:09:58.45,1:10:05.63,英文,,0,0,0,,Let's do it one more time and draw what conclusion?
Dialogue: 0,1:10:05.63,1:10:08.91,英文,,0,0,0,,Yeah, let's do it one more time, even though it's a little wasteful.
Dialogue: 0,1:10:08.91,1:10:18.46,英文,,0,0,0,,But logically, if I go through the whole list comparing pairs again and again and again, and I don't do any work that time, now it's obviously logically safe to just stop.
Dialogue: 0,1:10:18.46,1:10:23.30,英文,,0,0,0,,Because otherwise, I'm wasting my time doing the same thing again and again if no one's actually moving.
Dialogue: 0,1:10:23.30,1:10:26.66,英文,,0,0,0,,So I'm afraid we don't have Monopoly games for all of you, but we do have eight stress balls.
Dialogue: 0,1:10:26.66,1:10:30.10,英文,,0,0,0,,And a round of applause, if we could, for our volunteers.
Dialogue: 0,1:10:30.10,1:10:33.97,英文,,0,0,0,,If you want to put your numbers on the shelf there.
Dialogue: 0,1:10:33.97,1:10:36.70,英文,,0,0,0,,So if we consider for a moment, thank you.
Dialogue: 0,1:10:36.70,1:10:39.26,英文,,0,0,0,,Thank you so much.
Dialogue: 0,1:10:39.26,1:10:42.14,英文,,0,0,0,,Sure.
Dialogue: 0,1:10:42.14,1:10:44.44,英文,,0,0,0,,Thank you. Thanks.
Dialogue: 0,1:10:44.44,1:10:48.93,英文,,0,0,0,,Sure, so if we consider now these two algorithms, which one is better?
Dialogue: 0,1:10:48.93,1:10:56.07,英文,,0,0,0,,Any intuition for whether selection sort the first is better or worse than bubble sort the second?
Dialogue: 0,1:10:56.07,1:10:58.17,英文,,0,0,0,,Any thoughts?
Dialogue: 0,1:10:58.17,1:11:03.02,英文,,0,0,0,,Yeah?
Dialogue: 0,1:11:03.02,1:11:09.00,英文,,0,0,0,,OK, so bubble sort seems like less work, especially since I was focusing on those localized problems.
Dialogue: 0,1:11:09.00,1:11:11.57,英文,,0,0,0,,Other intuition?
Dialogue: 0,1:11:11.57,1:11:14.72,英文,,0,0,0,,Selection sort versus bubble sort.
Dialogue: 0,1:11:14.72,1:11:19.30,英文,,0,0,0,,Well, let me propose that we try to quantize this so we can actually analyze it in some way.
Dialogue: 0,1:11:19.30,1:11:22.58,英文,,0,0,0,,And this is not an exercise we'll do constantly for lots of algorithms.
Dialogue: 0,1:11:22.58,1:11:24.84,英文,,0,0,0,,But these are pretty representative of algorithms.
Dialogue: 0,1:11:24.84,1:11:28.86,英文,,0,0,0,,So we can wrap our minds around, indeed, the performance or the design of these things.
Dialogue: 0,1:11:28.86,1:11:34.40,英文,,0,0,0,,So here is my pseudocode for SelectionSort, whereby, as per its name,
Dialogue: 0,1:11:34.40,1:11:38.63,英文,,0,0,0,,I just iteratively select the next smallest element again and again.
Dialogue: 0,1:11:38.63,1:11:41.79,英文,,0,0,0,,So how can we go about analyzing something like this?
Dialogue: 0,1:11:41.79,1:11:48.15,英文,,0,0,0,,Well, we could just do it on paper pencil and count up the number of steps that seem to be implied logically by the code.
Dialogue: 0,1:11:48.15,1:11:53.04,英文,,0,0,0,,We could literally count the number of steps I was taking again and again left to right.
Dialogue: 0,1:11:53.04,1:11:55.98,英文,,0,0,0,,We could also just count the number of comparisons.
Dialogue: 0,1:11:55.98,1:11:58.58,英文,,0,0,0,,I was making with each of the persons involved.
Dialogue: 0,1:11:58.58,1:12:00.66,英文,,0,0,0,,And I was doing it kind of quickly in selection sort.
Dialogue: 0,1:12:00.66,1:12:11.87,英文,,0,0,0,,But every time I was looking at a person trying to decide, do I want to remember that number as smallest, that number, I was comparing two values with an equals equals or less than or greater than sign, at least if we had done this in code.
Dialogue: 0,1:12:11.87,1:12:16.65,英文,,0,0,0,,So that tends to be the norm when analyzing algorithms like these, counting the number of comparisons.
Dialogue: 0,1:12:16.65,1:12:23.70,英文,,0,0,0,,Because it's kind of a global unit of measure we can use to compare different algorithms entirely.
Dialogue: 0,1:12:23.70,1:12:37.79,英文,,0,0,0,,So think two. That in the general case, when we have more than eight volunteers, more than seven doors, we can generalize our array in general as this is the first element at bracket 0, and the end of it is always n minus 1.
Dialogue: 0,1:12:37.79,1:12:47.32,英文,,0,0,0,,So arrays, or doors in this case, or volunteers, are always numerically indexed from 0 on up to n minus 1, if there's n of them in total.
Dialogue: 0,1:12:47.32,1:12:51.14,英文,,0,0,0,,So how do we analyze the code of selection sort?
Dialogue: 0,1:12:51.14,1:12:56.43,英文,,0,0,0,,Well, how many steps did it take me to find the first smallest element?
Dialogue: 0,1:12:56.43,1:13:06.19,英文,,0,0,0,,Or more precisely, how many comparisons did I need to make when I walked left to right to find our first smallest person, which ended up being 0?
Dialogue: 0,1:13:06.19,1:13:09.35,英文,,0,0,0,,How many comparisons did I do when walking left to right?
Dialogue: 0,1:13:09.35,1:13:15.93,英文,,0,0,0,,If there were eight people on stage, how many total comparisons did I do?
Dialogue: 0,1:13:15.93,1:13:22.40,英文,,0,0,0,,Like if there's eight people, I compared these folks, then this person, this person, yeah.
Dialogue: 0,1:13:22.40,1:13:23.72,英文,,0,0,0,,Yeah, so seven total, right?
Dialogue: 0,1:13:23.72,1:13:29.89,英文,,0,0,0,,Because if there's eight people on stage, you can only do seven comparisons total, because otherwise you'd be comparing one number to itself.
Dialogue: 0,1:13:29.89,1:13:38.55,英文,,0,0,0,,So it seems like in the general case, if you've got n numbers that you're trying to sort, finding the smallest element first takes n minus 1 comparisons.
Dialogue: 0,1:13:38.55,1:13:46.18,英文,,0,0,0,,Maybe n total steps left to right, but the number of comparisons, which I claim is just a useful unit of measure, is n minus 1.
Dialogue: 0,1:13:46.18,1:13:48.70,英文,,0,0,0,,How about finding the next smallest person?
Dialogue: 0,1:13:48.70,1:13:53.10,英文,,0,0,0,,How many steps did it take me to find the next smallest number, which ended up being the number 1?
Dialogue: 0,1:13:53.10,1:13:58.40,英文,,0,0,0,,Yeah?
Dialogue: 0,1:13:58.40,1:13:59.58,英文,,0,0,0,,Yeah, so just n minus 2.
Dialogue: 0,1:13:59.58,1:14:01.63,英文,,0,0,0,,Why? Because I'd already solved one problem.
Dialogue: 0,1:14:01.63,1:14:03.07,英文,,0,0,0,,Someone was already in the right position.
Dialogue: 0,1:14:03.07,1:14:05.53,英文,,0,0,0,,It would be silly to keep counting them again and again.
Dialogue: 0,1:14:05.53,1:14:09.33,英文,,0,0,0,,So I can whittle down my number of comparisons for the next pass to n minus 2.
Dialogue: 0,1:14:09.33,1:14:12.33,英文,,0,0,0,,The third pass to find the third smallest number would be n minus 3.
Dialogue: 0,1:14:12.33,1:14:13.65,英文,,0,0,0,,And then dot, dot, dot.
Dialogue: 0,1:14:13.65,1:14:17.63,英文,,0,0,0,,Presumably this story, this formula, ends when you have just one final
Dialogue: 0,1:14:17.63,1:14:19.73,英文,,0,0,0,,Pair, the people at the end to compare.
Dialogue: 0,1:14:19.73,1:14:33.64,英文,,0,0,0,,So if this is looking a little reminiscent of some kind of recurrence from high school or high school math or physics or the like, let me just stipulate that if you actually do out this math and generalize it, that is the same thing as n times n minus 1 divided by 2.
Dialogue: 0,1:14:33.64,1:14:35.00,英文,,0,0,0,,And if you're rusty on that, no big deal.
Dialogue: 0,1:14:35.00,1:14:37.82,英文,,0,0,0,,Just kind of commit to memory that any time you add up
Dialogue: 0,1:14:37.82,1:14:46.64,英文,,0,0,0,,This kind of series, something plus something slightly smaller plus something slightly smaller, each of which differs by 1, you're going to get this formula, n times n minus 1 over 2.
Dialogue: 0,1:14:46.64,1:14:51.68,英文,,0,0,0,,If we, of course, multiply that out, that's really n squared minus n all divided by 2.
Dialogue: 0,1:14:51.68,1:14:56.69,英文,,0,0,0,,If we keep multiplying it out, that's n squared divided by 2 minus n over 2.
Dialogue: 0,1:14:56.69,1:15:00.43,英文,,0,0,0,,And now we have kind of a vocabulary with which we can
Dialogue: 0,1:15:00.43,1:15:03.27,英文,,0,0,0,,Talk about the efficiency, the design of this algorithm.
Dialogue: 0,1:15:03.27,1:15:09.55,英文,,0,0,0,,But honestly, I don't really care about this level of precision, like n squared divided by 2 minus n divided by 2.
Dialogue: 0,1:15:09.55,1:15:20.54,英文,,0,0,0,,As n gets really large, which of these symbols, which of these terms is really going to dominate, become the biggest influencer on the total value of steps?
Dialogue: 0,1:15:20.54,1:15:21.70,英文,,0,0,0,,Right, it's the square, right?
Dialogue: 0,1:15:21.70,1:15:23.38,英文,,0,0,0,,Like, it's definitely not n divided by 2.
Dialogue: 0,1:15:23.38,1:15:24.58,英文,,0,0,0,,That's shaving some time off.
Dialogue: 0,1:15:24.58,1:15:27.80,英文,,0,0,0,,But n squared, as n gets big, is going to get really big.
Dialogue: 0,1:15:27.80,1:15:29.98,英文,,0,0,0,,If n is 100, then n squared is bigger.
Dialogue: 0,1:15:29.98,1:15:32.66,英文,,0,0,0,,If n is a million, n squared is really bigger.
Dialogue: 0,1:15:32.66,1:15:45.91,英文,,0,0,0,,And so at the end of the day, when we are really just talking about sort of a wave of the hand analysis, an upper bound, if you will, let's just say that selection sort, as analyzed here, it's on the order of n squared steps.
Dialogue: 0,1:15:45.91,1:15:47.85,英文,,0,0,0,,It's not precisely n squared steps.
Dialogue: 0,1:15:47.85,1:15:48.71,英文,,0,0,0,,But you know what?
Dialogue: 0,1:15:48.71,1:15:55.48,英文,,0,0,0,,n squared divided by 2, the intuition here might be that, well, it's half of that.
Dialogue: 0,1:15:55.48,1:15:58.76,英文,,0,0,0,,n squared is what really matters as n gets really, really large.
Dialogue: 0,1:15:58.76,1:16:02.23,英文,,0,0,0,,And that's when you start thinking about and trying to solve the Google problems of the world.
Dialogue: 0,1:16:02.23,1:16:07.71,英文,,0,0,0,,When n gets large, that's when you have to be smarter than just sort of naive implementations of any algorithm.
Dialogue: 0,1:16:07.71,1:16:12.38,英文,,0,0,0,,So where, then, does this algorithm fall into this categorization here?
Dialogue: 0,1:16:12.38,1:16:19.84,英文,,0,0,0,,Well, n squared, it turns out, is on the order of n squared steps, in the worst case, whether it's sorted or not.
Dialogue: 0,1:16:19.84,1:16:24.29,英文,,0,0,0,,It turns out, though, lower bound, if we consider this same code,
Dialogue: 0,1:16:24.29,1:16:42.84,英文,,0,0,0,,Suppose the best case scenario, like our eight volunteers came up on stage, and just because they already sorted themselves, 0 through 7, suppose they just happen to be in that state, how many steps would selection sort take to sort an already sorted list of volunteers?
Dialogue: 0,1:16:42.84,1:16:47.96,英文,,0,0,0,,Any intuition? Yeah?
Dialogue: 0,1:16:47.96,1:16:51.34,英文,,0,0,0,,Would it still be n?
Dialogue: 0,1:16:51.34,1:17:04.00,英文,,0,0,0,,So for the first pass, it would still be 7 for the first pass across the humans, because even though, yeah, I'm claiming 0 is here, I don't know that 0 is the smallest until I make my way all the way over there, doing all seven comparisons.
Dialogue: 0,1:17:04.00,1:17:04.90,英文,,0,0,0,,OK, fine.
Dialogue: 0,1:17:04.90,1:17:08.36,英文,,0,0,0,,First pass took 7, or more generally, n minus 1 steps.
Dialogue: 0,1:17:08.36,1:17:14.54,英文,,0,0,0,,What if I look for the next smallest element, and the humans in this story are already sorted 0 through 7?
Dialogue: 0,1:17:14.54,1:17:17.73,英文,,0,0,0,,Well, yes, the number one's here, and I see them first.
Dialogue: 0,1:17:17.73,1:17:23.93,英文,,0,0,0,,But I don't know they're the smallest until I compare against everyone else, get to the end of the list, and realize, oh, well, that was stupid.
Dialogue: 0,1:17:23.93,1:17:26.69,英文,,0,0,0,,I already had the smallest person in hand then.
Dialogue: 0,1:17:26.69,1:17:31.62,英文,,0,0,0,,And so this pseudocode, this implementation of selection sort, is sort of fixed like this.
Dialogue: 0,1:17:31.62,1:17:35.66,英文,,0,0,0,,There's no special case that says, if already sorted, quit early.
Dialogue: 0,1:17:35.66,1:17:37.86,英文,,0,0,0,,It's always going to take n squared steps.
Dialogue: 0,1:17:37.86,1:17:44.03,英文,,0,0,0,,And so in this case, if we borrow our jargon from earlier using omega notation,
Dialogue: 0,1:17:44.03,1:17:50.78,英文,,0,0,0,,Just to be clear, selection sort is also going to be, in this incarnation, an omega of n squared.
Dialogue: 0,1:17:50.78,1:18:01.85,英文,,0,0,0,,Because even in the best case, where the list is already sorted, you're going to waste a huge amount of time essentially verifying as much or discovering as much, even though we humans, of course, could see it right away.
Dialogue: 0,1:18:01.85,1:18:08.76,英文,,0,0,0,,So selection sort would seem to take both n squared steps in the worst case, n squared steps in the best case.
Dialogue: 0,1:18:08.76,1:18:11.42,英文,,0,0,0,,And so you know what? We can use our theta terminology for that.
Dialogue: 0,1:18:11.42,1:18:19.67,英文,,0,0,0,,Here would be an algorithm, just like counting earlier, that always takes n squared steps, no matter whether the array is sorted or not from the get-go.
Dialogue: 0,1:18:19.67,1:18:21.35,英文,,0,0,0,,All right, so hopefully we can do better.
Dialogue: 0,1:18:21.35,1:18:25.65,英文,,0,0,0,,And someone proposed earlier that bubble sort felt like it was using fewer steps.
Dialogue: 0,1:18:25.65,1:18:28.39,英文,,0,0,0,,Well, let's consider that next. With bubble sort,
Dialogue: 0,1:18:28.39,1:18:33.86,英文,,0,0,0,,We had this pseudocode, I claim, whereby, let's focus on the inside of the code first.
Dialogue: 0,1:18:33.86,1:18:36.24,英文,,0,0,0,,Down here, what was I doing?
Dialogue: 0,1:18:36.24,1:18:40.18,英文,,0,0,0,,For i from 0 to n minus 2.
Dialogue: 0,1:18:40.18,1:18:40.72,英文,,0,0,0,,That's curious.
Dialogue: 0,1:18:40.72,1:18:42.38,英文,,0,0,0,,We've never seen n minus 2 before.
Dialogue: 0,1:18:42.38,1:18:44.06,英文,,0,0,0,,But I asked this question.
Dialogue: 0,1:18:44.06,1:18:50.41,英文,,0,0,0,,If numbers bracket i and numbers bracket i plus 1 are out of order, swap them.
Dialogue: 0,1:18:50.41,1:18:53.67,英文,,0,0,0,,So that was when I was pointing at our first two volunteers here.
Dialogue: 0,1:18:53.67,1:18:57.30,英文,,0,0,0,,I saw that they were out of order, so I swapped them.
Dialogue: 0,1:18:57.30,1:19:09.83,英文,,0,0,0,,How come I'm doing that again and again up to n minus 2, though, instead of n minus 1, which we've always used up until now as our rightmost boundary?
Dialogue: 0,1:19:09.83,1:19:14.20,英文,,0,0,0,,Any intuition for why I'm doing this from 0 to n minus 2?
Dialogue: 0,1:19:14.20,1:19:15.38,英文,,0,0,0,,Yeah?
Dialogue: 0,1:19:21.28,1:19:31.45,英文,,0,0,0,,Exactly, because I'm looking at the i-th person, per this pseudocode here, and the i-th plus 1 person, I better make sure I don't step beyond the boundaries of my array.
Dialogue: 0,1:19:31.45,1:19:41.50,英文,,0,0,0,,So if you think of my left hand, when my back was to here, pointing at the current person at the first position, my right hand, for this if condition, is essentially pointing at the person next to them.
Dialogue: 0,1:19:41.50,1:19:44.75,英文,,0,0,0,,And you want to iterate with your left hand all through these people.
Dialogue: 0,1:19:44.75,1:19:47.73,英文,,0,0,0,,But you don't want your left hand to point at the last person.
Dialogue: 0,1:19:47.73,1:19:50.03,英文,,0,0,0,,You want it to point at the second-to-last person.
Dialogue: 0,1:19:50.03,1:19:54.47,英文,,0,0,0,,But we know that the last person is always at n minus 1.
Dialogue: 0,1:19:54.47,1:19:57.81,英文,,0,0,0,,So the second-to-last person, just mathematically, is at n minus 2.
Dialogue: 0,1:19:57.81,1:19:58.89,英文,,0,0,0,,So it's a subtlety.
Dialogue: 0,1:19:58.89,1:20:00.87,英文,,0,0,0,,But this is like a segfault waiting to happen.
Dialogue: 0,1:20:00.87,1:20:04.40,英文,,0,0,0,,If you implemented bubble sort using n minus 1, you will.
Dialogue: 0,1:20:04.40,1:20:07.26,英文,,0,0,0,,My right hand would go beyond the boundaries of the array.
Dialogue: 0,1:20:07.26,1:20:08.26,英文,,0,0,0,,So just bad.
Dialogue: 0,1:20:08.26,1:20:10.38,英文,,0,0,0,,All right, so why am I saying this n times?
Dialogue: 0,1:20:10.38,1:20:13.00,英文,,0,0,0,,Well, we did it very organically with humans.
Dialogue: 0,1:20:13.00,1:20:23.10,英文,,0,0,0,,But each time someone, each pass I did through the array, someone bubbled their way up to the end, number 7, then number 6, then number 5.
Dialogue: 0,1:20:23.10,1:20:34.55,英文,,0,0,0,,So if on each pass through the array of volunteers I was solving at least one problem, it seems like Bubble Sort can just run n times total to solve all n problems.
Dialogue: 0,1:20:34.55,1:20:36.95,英文,,0,0,0,,Because the first pass will get at least one number into place.
Dialogue: 0,1:20:36.95,1:20:38.43,英文,,0,0,0,,Second pass, second number into place.
Dialogue: 0,1:20:38.43,1:20:40.14,英文,,0,0,0,,You might get lucky, and it would do more.
Dialogue: 0,1:20:40.14,1:20:41.76,英文,,0,0,0,,But worst case, this feels like enough.
Dialogue: 0,1:20:41.76,1:20:46.38,英文,,0,0,0,,Just do this blindly n times, and they'll all line up together.
Dialogue: 0,1:20:46.38,1:20:49.86,英文,,0,0,0,,Well, technically, all right, now we're getting into the weeds.
Dialogue: 0,1:20:49.86,1:20:52.10,英文,,0,0,0,,Technically, you can just repeat it n minus 1 times.
Dialogue: 0,1:20:52.10,1:20:58.89,英文,,0,0,0,,Because if you solve all n minus 1 other problems and you're left with 1, literally, that person's where they need to be, just logically.
Dialogue: 0,1:20:58.89,1:21:02.47,英文,,0,0,0,,If you've already sorted everything else and you've got just the 1 left, it's already bubbled up.
Dialogue: 0,1:21:02.47,1:21:03.87,英文,,0,0,0,,So how do we analyze this?
Dialogue: 0,1:21:03.87,1:21:06.84,英文,,0,0,0,,Well, in bubble sort, we might do something like this.
Dialogue: 0,1:21:06.84,1:21:11.56,英文,,0,0,0,,I'm essentially doing n minus 1 things n minus 1 times.
Dialogue: 0,1:21:11.56,1:21:15.16,英文,,0,0,0,,Now, let me back up to the pseudocode, because this one's a little less obvious.
Dialogue: 0,1:21:15.16,1:21:21.03,英文,,0,0,0,,This is where you can actually mathematically infer from your loop how many steps you're taking.
Dialogue: 0,1:21:21.03,1:21:25.01,英文,,0,0,0,,So this first line literally says, repeat the following n minus 1 times.
Dialogue: 0,1:21:25.01,1:21:30.42,英文,,0,0,0,,So that's going to translate very straightforwardly to our mathematical formula. Do something n minus 1 times.
Dialogue: 0,1:21:30.42,1:21:35.90,英文,,0,0,0,,This loop, just because I'm using for loop terminology, it's framed a little differently.
Dialogue: 0,1:21:35.90,1:21:40.08,英文,,0,0,0,,But if you're iterating from 0 to n minus 2,
Dialogue: 0,1:21:40.08,1:21:43.69,英文,,0,0,0,,you're iterating a total of n minus 1 times.
Dialogue: 0,1:21:43.69,1:21:48.57,英文,,0,0,0,,And again, the arithmetic is getting a little annoying, but this just means do the following n minus 1 times.
Dialogue: 0,1:21:48.57,1:21:54.51,英文,,0,0,0,,So do n minus 1 things n minus 1 times, we can now run out the math as follows.
Dialogue: 0,1:21:54.51,1:21:57.95,英文,,0,0,0,,We have the formula n minus 1 times n minus 1.
Dialogue: 0,1:21:57.95,1:22:03.26,英文,,0,0,0,,We do our little FOIL method here, n squared minus 1 times n minus 1 times n plus 1.
Dialogue: 0,1:22:03.26,1:22:06.66,英文,,0,0,0,,We can combine like terms, n squared minus 2n plus 1.
Dialogue: 0,1:22:06.66,1:22:10.89,英文,,0,0,0,,But at this point, when n gets really large, which term are we really going to care about?
Dialogue: 0,1:22:10.89,1:22:13.46,英文,,0,0,0,,This is on the order of.
Dialogue: 0,1:22:13.46,1:22:14.92,英文,,0,0,0,,Yeah, n squared.
Dialogue: 0,1:22:14.92,1:22:25.39,英文,,0,0,0,,So at least asymptotically, asymptotically means as n approaches infinity, gets really large, turns out that the upper bound on selection sort and bubble sort are essentially the same.
Dialogue: 0,1:22:25.39,1:22:29.81,英文,,0,0,0,,Now, if we really nitpicked and compared the total number of comparisons, they might differ slightly.
Dialogue: 0,1:22:29.81,1:22:36.48,英文,,0,0,0,,But as n gets large, honestly, you're barely going to notice the difference, it would seem, between these two algorithms.
Dialogue: 0,1:22:36.48,1:22:38.50,英文,,0,0,0,,But what about?
Dialogue: 0,1:22:38.50,1:22:39.66,英文,,0,0,0,,The lower bound.
Dialogue: 0,1:22:39.66,1:22:45.38,英文,,0,0,0,,If the upper bound on bubble sort is also big O of n, what about the lower bound here?
Dialogue: 0,1:22:45.38,1:22:50.25,英文,,0,0,0,,Well, with this pseudocode, what would the lower bound be on bubble sort?
Dialogue: 0,1:22:50.25,1:22:54.05,英文,,0,0,0,,Even in the best case, when all of the volunteers are sorted.
Dialogue: 0,1:22:54.05,1:22:56.89,英文,,0,0,0,,Any intuition?
Dialogue: 0,1:22:56.89,1:22:59.09,英文,,0,0,0,,In this pseudocode. Yeah, in the middle.
Dialogue: 0,1:23:06.36,1:23:12.93,英文,,0,0,0,,Good question, isn't bubble sorts designed such that you wouldn't need to compare numbers that have already bubbled up?
Dialogue: 0,1:23:12.93,1:23:17.11,英文,,0,0,0,,That's what's happening here in the middle implicitly.
Dialogue: 0,1:23:17.11,1:23:19.39,英文,,0,0,0,,I'm always going from left to right.
Dialogue: 0,1:23:19.39,1:23:26.24,英文,,0,0,0,,But remember that even when I screwed up at the end and the last two people were out of order, I do always need to restart at the beginning.
Dialogue: 0,1:23:26.24,1:23:33.37,英文,,0,0,0,,Because the big numbers are going that way and the small numbers are coming this way.
Dialogue: 0,1:23:33.37,1:23:34.07,英文,,0,0,0,,So that is true.
Dialogue: 0,1:23:34.07,1:23:37.54,英文,,0,0,0,,There are some slight optimizations that I'm kind of glossing over here.
Dialogue: 0,1:23:37.54,1:23:40.70,英文,,0,0,0,,Let me stipulate that it would still end up being on the order of n squared.
Dialogue: 0,1:23:40.70,1:23:44.12,英文,,0,0,0,,But that would definitely shave off some actual running time here.
Dialogue: 0,1:23:44.12,1:23:46.44,英文,,0,0,0,,But what if the list is already sorted?
Dialogue: 0,1:23:46.44,1:23:51.18,英文,,0,0,0,,Our pseudocode at the moment has no allowance for if list is already sorted, quit early.
Dialogue: 0,1:23:51.18,1:23:58.91,英文,,0,0,0,,So we're going to blindly do n minus 1 things n minus 1 times unless we modify our pseudocode, as I did verbally earlier.
Dialogue: 0,1:23:58.91,1:24:00.17,英文,,0,0,0,,I propose this.
Dialogue: 0,1:24:00.17,1:24:10.51,英文,,0,0,0,,Inside of that outer loop, if you make a pass across all of the volunteers and your mental counter has made no swaps, you have to keep track with some kind of variable, well, then you might as well stop.
Dialogue: 0,1:24:10.51,1:24:17.91,英文,,0,0,0,,Because if you do a whole pass and make no swaps, why would you waste time doing it again expecting different behavior?
Dialogue: 0,1:24:17.91,1:24:20.62,英文,,0,0,0,,So to help visualize these.
Dialogue: 0,1:24:20.62,1:24:26.64,英文,,0,0,0,,Whereby, now, bubble sort can be advantageous if the data is already sorted or mostly sorted.
Dialogue: 0,1:24:26.64,1:24:27.24,英文,,0,0,0,,Why?
Dialogue: 0,1:24:27.24,1:24:31.54,英文,,0,0,0,,Because it does have this short circuit detail, at least if we implement it like that.
Dialogue: 0,1:24:31.54,1:24:36.41,英文,,0,0,0,,How can we go about visualizing these things a little more clearly?
Dialogue: 0,1:24:36.41,1:24:37.57,英文,,0,0,0,,Well, let me go ahead and do this.
Dialogue: 0,1:24:37.57,1:24:47.03,英文,,0,0,0,,Let me pull up here a visualization of exactly these algorithms, thanks to a third-party tool here that's going to help us visualize these sorting algorithms as follows.
Dialogue: 0,1:24:47.03,1:24:48.83,英文,,0,0,0,,Small bars represent small numbers.
Dialogue: 0,1:24:48.83,1:24:50.49,英文,,0,0,0,,Big bars represent big numbers.
Dialogue: 0,1:24:50.49,1:24:56.83,英文,,0,0,0,,And so the idea now is when I hit a button here to get all of the small bars this way, all of the big bars this way.
Dialogue: 0,1:24:56.83,1:25:02.47,英文,,0,0,0,,So just like our volunteers, but instead of holding lighted numbers, it's bars representing their magnitude.
Dialogue: 0,1:25:02.47,1:25:07.32,英文,,0,0,0,,So let's go ahead and start with, for instance, selection sort.
Dialogue: 0,1:25:07.32,1:25:14.79,英文,,0,0,0,,And you'll see in pink is being highlighted the current number that is being selected and then pulled all the way to the left.
Dialogue: 0,1:25:14.79,1:25:16.47,英文,,0,0,0,,So this is selection sort.
Dialogue: 0,1:25:16.47,1:25:18.01,英文,,0,0,0,,And again.
Dialogue: 0,1:25:18.01,1:25:20.57,英文,,0,0,0,,It's selecting the next smallest element.
Dialogue: 0,1:25:20.57,1:25:32.36,英文,,0,0,0,,But you can see here all the more visibly that, just like my human feet were taking a lot of steps, so is this algorithm touching these elements again and again and again.
Dialogue: 0,1:25:32.36,1:25:35.06,英文,,0,0,0,,And this is why the n squared is really a thing.
Dialogue: 0,1:25:35.06,1:25:37.38,英文,,0,0,0,,There's got to be some inherent redundancy here.
Dialogue: 0,1:25:37.38,1:25:40.40,英文,,0,0,0,,Like, why do we keep looking at the same darn elements again and again?
Dialogue: 0,1:25:40.40,1:25:43.26,英文,,0,0,0,,We do, in terms of our pseudocode, need to do so.
Dialogue: 0,1:25:43.26,1:25:48.79,英文,,0,0,0,,But it's this redundant comparisons that kind of explains Yn squared is indeed the case.
Dialogue: 0,1:25:48.79,1:25:49.53,英文,,0,0,0,,So now it's done.
Dialogue: 0,1:25:49.53,1:25:51.11,英文,,0,0,0,,Small bars here, big bars there.
Dialogue: 0,1:25:51.11,1:25:54.75,英文,,0,0,0,,And I had to just keep talking there to kill time, because it's relatively slow.
Dialogue: 0,1:25:54.75,1:25:58.77,英文,,0,0,0,,Well, let me re-randomize the array, just so we start with a different order.
Dialogue: 0,1:25:58.77,1:26:00.52,英文,,0,0,0,,And now let me click on Bubble Sort.
Dialogue: 0,1:26:00.52,1:26:03.16,英文,,0,0,0,,And you'll see similar idea, but different algorithms.
Dialogue: 0,1:26:03.16,1:26:10.06,英文,,0,0,0,,So now the two bars in pink are the two that are being compared and fixed, potentially, if they're out of order.
Dialogue: 0,1:26:10.06,1:26:14.60,英文,,0,0,0,,And you can see already that the biggest bars are bubbling their way up to the top.
Dialogue: 0,1:26:14.60,1:26:17.66,英文,,0,0,0,,But now you can also see this redundancy.
Dialogue: 0,1:26:17.66,1:26:22.85,英文,,0,0,0,,We keep swooping through the list again and again, just like I kept walking back and forth.
Dialogue: 0,1:26:22.85,1:26:23.75,英文,,0,0,0,,And this is n squared.
Dialogue: 0,1:26:23.75,1:26:24.91,英文,,0,0,0,,This is not that many bars.
Dialogue: 0,1:26:24.91,1:26:27.96,英文,,0,0,0,,What, 10, 20? This is like 40 or something bars, I'm guessing.
Dialogue: 0,1:26:27.96,1:26:31.98,英文,,0,0,0,,That's pretty slow already, just to sort 40 numbers.
Dialogue: 0,1:26:31.98,1:26:37.59,英文,,0,0,0,,And I think it's going to get tedious if I keep talking over this. So let's just assume that this, too, is relatively slow.
Dialogue: 0,1:26:37.59,1:26:43.37,英文,,0,0,0,,Had I gotten lucky and the list were almost sorted already, bubble sort would have been pretty fast.
Dialogue: 0,1:26:43.37,1:26:46.05,英文,,0,0,0,,But this was a truly random array, so we did not get lucky.
Dialogue: 0,1:26:46.05,1:26:50.07,英文,,0,0,0,,So indeed, the worst case might be what's kicking in here.
Dialogue: 0,1:26:50.07,1:26:55.91,英文,,0,0,0,,So I feel like it'll be anticlimactic, like holding in a sneeze, if I don't let you see the end of this.
Dialogue: 0,1:26:55.91,1:26:58.05,英文,,0,0,0,,So here we go.
Dialogue: 0,1:26:58.05,1:27:00.22,英文,,0,0,0,,Nothing interesting is about to happen.
Dialogue: 0,1:27:00.22,1:27:02.37,英文,,0,0,0,,Almost done.
Dialogue: 0,1:27:02.37,1:27:03.19,英文,,0,0,0,,OK, done.
Dialogue: 0,1:27:03.19,1:27:06.79,英文,,0,0,0,,All right, so thank you.
Dialogue: 0,1:27:06.79,1:27:09.29,英文,,0,0,0,,Thank you.
Dialogue: 0,1:27:09.29,1:27:15.83,英文,,0,0,0,,So still somewhat slow, though, how, though, can we perhaps do a little better fundamentally?
Dialogue: 0,1:27:15.83,1:27:19.05,英文,,0,0,0,,So we can do so if we introduce yet another technique.
Dialogue: 0,1:27:19.05,1:27:22.09,英文,,0,0,0,,And this one isn't so much a function of code as it is concept.
Dialogue: 0,1:27:22.09,1:27:27.53,英文,,0,0,0,,And it's something that you might have seen in the real world, but perhaps not so obviously so.
Dialogue: 0,1:27:27.53,1:27:35.02,英文,,0,0,0,,So it turns out, in programming, Recursion refers to the ability of a function to call itself.
Dialogue: 0,1:27:35.02,1:27:43.82,英文,,0,0,0,,In the world of mathematics, if you have a function f, if f appears on both the left side and the right side of a formula, that would be a recursive function in the math world, too.
Dialogue: 0,1:27:43.82,1:27:53.77,英文,,0,0,0,,Whenever f is defined in terms of itself, or in our case, in programming, any time a function calls itself, that function is said to be recursive.
Dialogue: 0,1:27:53.77,1:27:57.01,英文,,0,0,0,,And this is actually something we've seen already in class, even though we didn't call it as much.
Dialogue: 0,1:27:57.01,1:28:06.58,英文,,0,0,0,,So for instance, consider this pseudocode from earlier, whereby this was the pseudocode for searching via binary search.
Dialogue: 0,1:28:06.58,1:28:07.90,英文,,0,0,0,,A whole bunch of doors.
Dialogue: 0,1:28:07.90,1:28:09.88,英文,,0,0,0,,If no doors are left, return false.
Dialogue: 0,1:28:09.88,1:28:12.66,英文,,0,0,0,,That was the additional conditional we added.
Dialogue: 0,1:28:12.66,1:28:15.05,英文,,0,0,0,,But then if number behind middle door, return true.
Dialogue: 0,1:28:15.05,1:28:16.59,英文,,0,0,0,,And here's the interesting part.
Dialogue: 0,1:28:16.59,1:28:20.89,英文,,0,0,0,,If number is less than middle door, search the left half.
Dialogue: 0,1:28:20.89,1:28:24.11,英文,,0,0,0,,Else, if number is greater than middle door, search the right half.
Dialogue: 0,1:28:24.11,1:28:27.80,英文,,0,0,0,,This pseudocode earlier was itself recursive.
Dialogue: 0,1:28:27.80,1:28:28.46,英文,,0,0,0,,Why?
Dialogue: 0,1:28:28.46,1:28:30.72,英文,,0,0,0,,Because here is an algorithm for searching.
Dialogue: 0,1:28:30.72,1:28:32.44,英文,,0,0,0,,But what's the algorithm telling us?
Dialogue: 0,1:28:32.44,1:28:37.44,英文,,0,0,0,,Well, on this line and this line, it's telling us to search something else.
Dialogue: 0,1:28:37.44,1:28:47.83,英文,,0,0,0,,So even though it's not explicitly defined in code as having a name, if this is a search algorithm, and yet the search algorithm is using a search algorithm, this pseudocode is recursive.
Dialogue: 0,1:28:47.83,1:28:53.60,英文,,0,0,0,,Now, that could quickly get you into trouble if a function just calls itself again and again and again.
Dialogue: 0,1:28:53.60,1:29:01.97,英文,,0,0,0,,But why, intuitively, is it not problematic that this code, this pseudocode, calls itself?
Dialogue: 0,1:29:01.97,1:29:03.49,英文,,0,0,0,,Why will the algorithm still stop?
Dialogue: 0,1:29:03.49,1:29:07.97,英文,,0,0,0,,Yeah.
Dialogue: 0,1:29:07.97,1:29:10.87,英文,,0,0,0,,Exactly, it has some exit condition, like if no door is less.
Dialogue: 0,1:29:10.87,1:29:17.34,英文,,0,0,0,,And more importantly, any time you search the left half, you're searching a smaller version of the problem.
Dialogue: 0,1:29:17.34,1:29:22.42,英文,,0,0,0,,Any time you search the right half, you're searching a smaller version of the problem, literally half the size.
Dialogue: 0,1:29:22.42,1:29:29.61,英文,,0,0,0,,So this is why in the phone book, obviously, I couldn't tear the phone book in half infinitely many times, because it was literally getting smaller each time.
Dialogue: 0,1:29:29.61,1:29:33.53,英文,,0,0,0,,So recursion is this ability to call yourself, if you will,
Dialogue: 0,1:29:33.53,1:29:42.11,英文,,0,0,0,,But what's important is that you do it on a smaller, smaller problem, so that eventually you have no more problems to solve, or no more data, no more doors at all.
Dialogue: 0,1:29:42.11,1:29:46.20,英文,,0,0,0,,So these two lines here would be the recursive elements here.
Dialogue: 0,1:29:46.20,1:29:49.60,英文,,0,0,0,,But if we go back to week 0, we could have used recursion in some other way.
Dialogue: 0,1:29:49.60,1:29:52.00,英文,,0,0,0,,So this was our pseudocode for the phone book.
Dialogue: 0,1:29:52.00,1:29:59.12,英文,,0,0,0,,back in week 0, and recall that we described these yellow lines as really representing a loop, some kind of cycle again and again.
Dialogue: 0,1:29:59.12,1:30:01.08,英文,,0,0,0,,But there was a missed opportunity here.
Dialogue: 0,1:30:01.08,1:30:05.92,英文,,0,0,0,,What if I had re-implemented this code to do this instead?
Dialogue: 0,1:30:05.92,1:30:13.01,英文,,0,0,0,,Instead of saying, open to middle of left half of book and then go back to line 3, like literally inducing a loop, or open to middle of right half of book
Dialogue: 0,1:30:13.01,1:30:21.01,英文,,0,0,0,,and go back to line 3, inducing another loop, why don't I just recognize that what I'm staring at now is a algorithm
Dialogue: 0,1:30:21.01,1:30:23.95,英文,,0,0,0,,for searching a phone book.
Dialogue: 0,1:30:23.95,1:30:30.75,英文,,0,0,0,,And if you want to search a smaller phone book, like A through M or N through Z, we'll just use this same algorithm.
Dialogue: 0,1:30:30.75,1:30:35.09,英文,,0,0,0,,So I can replace these yellow lines with just this, casually speaking.
Dialogue: 0,1:30:35.09,1:30:36.45,英文,,0,0,0,,Search left half a book.
Dialogue: 0,1:30:36.45,1:30:37.45,英文,,0,0,0,,Search right half a book.
Dialogue: 0,1:30:37.45,1:30:43.85,英文,,0,0,0,,This would be implicitly, and now I can shorten the whole thing, a recursive implementation of the phone book pseudocode from week 0.
Dialogue: 0,1:30:43.85,1:30:48.92,英文,,0,0,0,,And it's recursive because if this is a search algorithm and you're saying, go search something else, that's fine.
Dialogue: 0,1:30:48.92,1:30:50.06,英文,,0,0,0,,That's recursive.
Dialogue: 0,1:30:50.06,1:30:55.90,英文,,0,0,0,,But because you're searching half of the phone book, it's indeed going to get smaller and smaller.
Dialogue: 0,1:30:55.90,1:31:03.68,英文,,0,0,0,,Even in the real world, or the real virtual world, you can see recursive data structures in the wild, or at least in Super Mario Brothers like this.
Dialogue: 0,1:31:03.68,1:31:10.98,英文,,0,0,0,,Let me get rid of all the distractions here and focus on this pyramid, where you have one block, then two, then three, then four.
Dialogue: 0,1:31:10.98,1:31:16.73,英文,,0,0,0,,Well, this itself is technically recursively defined in the sense that, well, what is a pyramid of height four?
Dialogue: 0,1:31:16.73,1:31:19.23,英文,,0,0,0,,Well, it's really... What?
Dialogue: 0,1:31:19.23,1:31:30.73,英文,,0,0,0,,How would you describe a pyramid of height 4 is actually the same thing as a pyramid of? of height 3 plus one additional layer.
Dialogue: 0,1:31:30.73,1:31:31.89,英文,,0,0,0,,Well, what's a pyramid of height 3?
Dialogue: 0,1:31:31.89,1:31:36.15,英文,,0,0,0,,Well, it's technically a pyramid of height 2 plus one additional layer.
Dialogue: 0,1:31:36.15,1:31:40.63,英文,,0,0,0,,And so even physical structures can be recursive if you can define them in terms of itself.
Dialogue: 0,1:31:40.63,1:31:45.97,英文,,0,0,0,,Now, at some point, you have to say that if the pyramid is of height 1, there's just one block.
Dialogue: 0,1:31:45.97,1:31:49.03,英文,,0,0,0,,You can't forever say it's defined in terms of a height negative 1.
Dialogue: 0,1:31:49.03,1:31:50.47,英文,,0,0,0,,Negative 2, you would never stop.
Dialogue: 0,1:31:50.47,1:31:52.95,英文,,0,0,0,,So you have to kind of have a special case there.
Dialogue: 0,1:31:52.95,1:31:55.71,英文,,0,0,0,,But let's go ahead and translate something like this, in fact, to code.
Dialogue: 0,1:31:55.71,1:31:58.03,英文,,0,0,0,,Let me go back to VS Code here.
Dialogue: 0,1:31:58.03,1:32:03.24,英文,,0,0,0,,And let me implement a program called iteration that refers to a loop iterating.
Dialogue: 0,1:32:03.24,1:32:08.44,英文,,0,0,0,,And let me implement a very simple pyramid like that. So let me go ahead and include the CS50 library.
Dialogue: 0,1:32:08.44,1:32:11.62,英文,,0,0,0,,I'll include our standard io.h.
Dialogue: 0,1:32:11.62,1:32:13.36,英文,,0,0,0,,Int main void.
Dialogue: 0,1:32:13.36,1:32:16.12,英文,,0,0,0,,No command line arguments today. And let's go ahead and do this.
Dialogue: 0,1:32:16.12,1:32:21.43,英文,,0,0,0,,Let's declare a variable called height. Ask the human for the height of this pyramid.
Dialogue: 0,1:32:21.43,1:32:25.29,英文,,0,0,0,,And then let's go ahead and draw a pyramid of that height.
Dialogue: 0,1:32:25.29,1:32:27.63,英文,,0,0,0,,Now, of course, draw does not yet exist.
Dialogue: 0,1:32:27.63,1:32:30.20,英文,,0,0,0,,So I'm going to need to invent the draw function.
Dialogue: 0,1:32:30.20,1:32:33.20,英文,,0,0,0,,Let me go ahead and define a function that doesn't have a return value.
Dialogue: 0,1:32:33.20,1:32:34.36,英文,,0,0,0,,It's just going to have side effects.
Dialogue: 0,1:32:34.36,1:32:36.34,英文,,0,0,0,,It's just going to print bricks on the screen.
Dialogue: 0,1:32:36.34,1:32:40.39,英文,,0,0,0,,Call draw, and it takes in an integer n as its input.
Dialogue: 0,1:32:40.39,1:32:41.85,英文,,0,0,0,,And how am I going to implement this?
Dialogue: 0,1:32:41.85,1:32:46.57,英文,,0,0,0,,Well, again, I want to print one block, then two, then three, then four.
Dialogue: 0,1:32:46.57,1:32:49.65,英文,,0,0,0,,That's pretty straightforward, at least once you're comfortable with loops.
Dialogue: 0,1:32:49.65,1:32:51.47,英文,,0,0,0,,Let me go back to the code here.
Dialogue: 0,1:32:51.47,1:32:58.48,英文,,0,0,0,,Let me go ahead and say for int i gets 0, i is less than n, i plus plus.
Dialogue: 0,1:32:58.48,1:33:01.36,英文,,0,0,0,,And that's going to iterate, essentially, row by row.
Dialogue: 0,1:33:01.36,1:33:06.06,英文,,0,0,0,,And on each row, I want to print out 1, then 2, then 3, then 4 bricks.
Dialogue: 0,1:33:06.06,1:33:08.88,英文,,0,0,0,,But I'm iterating from 0 to 1 to 2 to 3.
Dialogue: 0,1:33:08.88,1:33:09.70,英文,,0,0,0,,So I think that's OK.
Dialogue: 0,1:33:09.70,1:33:19.65,英文,,0,0,0,,I can just say something like for int j gets 0, j, let's be clever about this, is less than i, j plus plus.
Dialogue: 0,1:33:19.65,1:33:27.15,英文,,0,0,0,,And now let me go ahead and inside of this loop, I think I can get away with just printing out a single hash sign.
Dialogue: 0,1:33:27.15,1:33:33.03,英文,,0,0,0,,But then outside of that loop, similar to last week, I'm going to print my new line separately.
Dialogue: 0,1:33:33.03,1:33:38.94,英文,,0,0,0,,So a little non-obvious at first, but this outer loop iterates row by row, line by line, if you will.
Dialogue: 0,1:33:38.94,1:33:45.68,英文,,0,0,0,,And then the inner loop just makes sure that when i equals 0, let's see.
Dialogue: 0,1:33:45.68,1:33:49.16,英文,,0,0,0,,Nope, there's a bug.
Dialogue: 0,1:33:49.16,1:33:52.28,英文,,0,0,0,,I need to make sure that it's j is less than i plus 1.
Dialogue: 0,1:33:52.28,1:33:57.76,英文,,0,0,0,,So when i is 0 on my first line of output, I'm going to print out one brick.
Dialogue: 0,1:33:57.76,1:34:02.27,英文,,0,0,0,,When i is 1, I'm going to print out two bricks, and so forth.
Dialogue: 0,1:34:02.27,1:34:05.51,英文,,0,0,0,,So let me go ahead and run make iteration.
Dialogue: 0,1:34:05.51,1:34:06.09,英文,,0,0,0,,All right.
Dialogue: 0,1:34:06.09,1:34:08.95,英文,,0,0,0,,And now seems to compile.
Dialogue: 0,1:34:08.95,1:34:10.41,英文,,0,0,0,,Uh-oh.
Dialogue: 0,1:34:10.41,1:34:10.85,英文,,0,0,0,,Huh.
Dialogue: 0,1:34:10.85,1:34:12.83,英文,,0,0,0,,Implicit declaration of function draw.
Dialogue: 0,1:34:12.83,1:34:14.47,英文,,0,0,0,,So I'm making week 1 mistakes again.
Dialogue: 0,1:34:14.47,1:34:18.53,英文,,0,0,0,,Say again?
Dialogue: 0,1:34:18.53,1:34:20.21,英文,,0,0,0,,Yeah, the prototype is missing.
Dialogue: 0,1:34:20.21,1:34:25.64,英文,,0,0,0,,I didn't declare it at the top. That's an easy fix. And the only time really it's OK and necessary to copy-paste.
Dialogue: 0,1:34:25.64,1:34:29.07,英文,,0,0,0,,Let me copy the functions declaration there, end it with a semicolon.
Dialogue: 0,1:34:29.07,1:34:32.51,英文,,0,0,0,,So that Clang now knows that draw will exist.
Dialogue: 0,1:34:32.51,1:34:33.91,英文,,0,0,0,,Make iteration. Now it works.
Dialogue: 0,1:34:33.91,1:34:34.71,英文,,0,0,0,,Thank you.
Dialogue: 0,1:34:34.71,1:34:36.19,英文,,0,0,0,,Dot slash iteration.
Dialogue: 0,1:34:36.19,1:34:37.99,英文,,0,0,0,,We'll type in something like 4.
Dialogue: 0,1:34:37.99,1:34:43.87,英文,,0,0,0,,And there we have it, our pyramid of height 1, 2, 3, 4 that looks pretty similar to this, albeit using hashes.
Dialogue: 0,1:34:43.87,1:34:49.30,英文,,0,0,0,,So that's how we would have implemented this like two weeks ago in week one, maybe last week, but just using arrays.
Dialogue: 0,1:34:49.30,1:34:51.20,英文,,0,0,0,,But let me propose that.
Dialogue: 0,1:34:51.20,1:34:53.68,英文,,0,0,0,,We could do something recursively instead.
Dialogue: 0,1:34:53.68,1:34:55.58,英文,,0,0,0,,Let me close this version of the code.
Dialogue: 0,1:34:55.58,1:35:01.78,英文,,0,0,0,,And let me go back to VS Code and open up recursion.c just to demonstrate something recursively.
Dialogue: 0,1:35:01.78,1:35:04.34,英文,,0,0,0,,And I'll do it incorrectly, deliberately the first time.
Dialogue: 0,1:35:04.34,1:35:06.65,英文,,0,0,0,,So let me include CS50.h.
Dialogue: 0,1:35:06.65,1:35:09.05,英文,,0,0,0,,Let me include standard io.h.
Dialogue: 0,1:35:09.05,1:35:12.21,英文,,0,0,0,,Let me do int main void.
Dialogue: 0,1:35:12.21,1:35:18.09,英文,,0,0,0,,And let me just blindly draw a pyramid initially of height 1.
Dialogue: 0,1:35:18.09,1:35:22.01,英文,,0,0,0,,But now in my draw function, let me re-implement it a little differently.
Dialogue: 0,1:35:22.01,1:35:26.78,英文,,0,0,0,,So my draw function this time is still going to take a number n, but that's how many hashes it's going to print.
Dialogue: 0,1:35:26.78,1:35:34.28,英文,,0,0,0,,So let's do 4 int i get 0, i is less than n, i plus plus.
Dialogue: 0,1:35:34.28,1:35:38.60,英文,,0,0,0,,Then let's go ahead and print out a single hash mark here.
Dialogue: 0,1:35:38.60,1:35:44.38,英文,,0,0,0,,And then after that, Let's print out the end of the line, just as before.
Dialogue: 0,1:35:44.38,1:35:49.80,英文,,0,0,0,,But now this, of course, is only going to draw a single row.
Dialogue: 0,1:35:49.80,1:35:54.89,英文,,0,0,0,,It's going to print out one hash, or two hashes, or three hashes, but only on one line.
Dialogue: 0,1:35:54.89,1:36:05.07,英文,,0,0,0,,Let me now incorrectly, but just kind of curiously say, all right, well, if this draws a pyramid of height 1, let's just use ourselves to draw a pyramid of height n plus 1.
Dialogue: 0,1:36:05.07,1:36:08.57,英文,,0,0,0,,So the first time I call draw, it will print out one hash.
Dialogue: 0,1:36:08.57,1:36:13.86,英文,,0,0,0,,Then the second time I call draw, it will print out two hashes, then three, then four.
Dialogue: 0,1:36:13.86,1:36:18.15,英文,,0,0,0,,So we're kind of laying these bricks down from top to bottom.
Dialogue: 0,1:36:18.15,1:36:20.66,英文,,0,0,0,,Make recursion.
Dialogue: 0,1:36:20.66,1:36:22.50,英文,,0,0,0,,Whoops, I screwed up again.
Dialogue: 0,1:36:22.50,1:36:24.70,英文,,0,0,0,,So let's copy the prototype here.
Dialogue: 0,1:36:24.70,1:36:27.20,英文,,0,0,0,,Let's put this down over here, semicolon.
Dialogue: 0,1:36:27.20,1:36:28.70,英文,,0,0,0,,Let's do this again.
Dialogue: 0,1:36:28.70,1:36:30.07,英文,,0,0,0,,Make recursion.
Dialogue: 0,1:36:30.07,1:36:32.59,英文,,0,0,0,,All right, all good, .slash recursion.
Dialogue: 0,1:36:32.59,1:36:39.56,英文,,0,0,0,,And now let me increase the size of my terminal window just so you can see more of the output. And here we have.
Dialogue: 0,1:36:39.56,1:36:41.39,英文,,0,0,0,,OK, bad, but thank you.
Dialogue: 0,1:36:41.39,1:36:43.85,英文,,0,0,0,,So we have an infinitely tall pyramid.
Dialogue: 0,1:36:43.85,1:36:47.17,英文,,0,0,0,,And it's just flying across the screen, which is why it looks kind of like a mess.
Dialogue: 0,1:36:47.17,1:36:51.67,英文,,0,0,0,,But I printed out a pyramid of height 1, and then 2, and then 3, and then 4.
Dialogue: 0,1:36:51.67,1:36:53.67,英文,,0,0,0,,And unfortunately, what am I lacking?
Dialogue: 0,1:36:53.67,1:37:00.52,英文,,0,0,0,,Any sort of quick condition, any kind of condition that says, wait a minute, when it's too tall, stop altogether. So this is an infinite loop.
Dialogue: 0,1:37:00.52,1:37:03.34,英文,,0,0,0,,But it's not a loop. It's a recursive call.
Dialogue: 0,1:37:03.34,1:37:05.64,英文,,0,0,0,,And actually, doing this in general is very bad.
Dialogue: 0,1:37:05.64,1:37:14.18,英文,,0,0,0,,We'll see next week that if you call a function too many times, you can actually trigger yet another of those segmentation faults because you're using too much memory, essentially.
Dialogue: 0,1:37:14.18,1:37:16.30,英文,,0,0,0,,But for now, I haven't triggered that yet.
Dialogue: 0,1:37:16.30,1:37:18.44,英文,,0,0,0,,Control-C is your friend to cancel.
Dialogue: 0,1:37:18.44,1:37:22.76,英文,,0,0,0,,And as an aside, if you're playing along at home or play with this code later, I actually cheated here.
Dialogue: 0,1:37:22.76,1:37:25.49,英文,,0,0,0,,We have a special Clang configuration feature.
Dialogue: 0,1:37:25.49,1:37:29.37,英文,,0,0,0,,That prevents you from calling a function like that and creating a problem.
Dialogue: 0,1:37:29.37,1:37:31.71,英文,,0,0,0,,I overrode it just for demonstration's sake.
Dialogue: 0,1:37:31.71,1:37:34.67,英文,,0,0,0,,But odds are, at home, you wouldn't be able to compile this code yourself.
Dialogue: 0,1:37:34.67,1:37:39.06,英文,,0,0,0,,But let me do a proper version recursively of this code as follows.
Dialogue: 0,1:37:39.06,1:37:46.54,英文,,0,0,0,,Let me go back into. The code here, let me go ahead and not just blindly start drawing one, then two, then three layers of bricks.
Dialogue: 0,1:37:46.54,1:37:53.51,英文,,0,0,0,,Let me prompt the human as before for the height of the pyramid they want using our getInt function.
Dialogue: 0,1:37:53.51,1:37:55.59,英文,,0,0,0,,And now let me call draw of height again.
Dialogue: 0,1:37:55.59,1:37:58.53,英文,,0,0,0,,So now I'm going back to the loop-like version.
Dialogue: 0,1:37:58.53,1:38:04.25,英文,,0,0,0,,But instead of using a loop now, this is where recursion gets rather elegant, if you will.
Dialogue: 0,1:38:04.25,1:38:07.72,英文,,0,0,0,,Let me go ahead and execute a code.
Dialogue: 0,1:38:07.72,1:38:10.81,英文,,0,0,0,,The draw function as follows.
Dialogue: 0,1:38:10.81,1:38:18.52,英文,,0,0,0,,Per your definition, if a pyramid of height 4 is really just a pyramid of height 3 plus another row, well, let's take that literally.
Dialogue: 0,1:38:18.52,1:38:20.20,英文,,0,0,0,,Let me go back to my code.
Dialogue: 0,1:38:20.20,1:38:26.91,英文,,0,0,0,,And if you want to draw a pyramid of height 4, well, go right ahead and draw a pyramid of height x.
Dialogue: 0,1:38:26.91,1:38:29.53,英文,,0,0,0,,3 first, or more generally, n minus 1.
Dialogue: 0,1:38:29.53,1:38:30.63,英文,,0,0,0,,But what's the second step?
Dialogue: 0,1:38:30.63,1:38:34.63,英文,,0,0,0,,Well, once you've drawn a pyramid of height 3, draw an extra row.
Dialogue: 0,1:38:34.63,1:38:37.09,英文,,0,0,0,,So I at least have to bite off that part of the problem myself.
Dialogue: 0,1:38:37.09,1:38:50.58,英文,,0,0,0,,So let me just do for int i gets 0, i is less than n, i plus plus, and let me, the programmer of this function, print out my hashes, and then at the very bottom, print out a new line so the cursor moves to the next line.
Dialogue: 0,1:38:50.58,1:39:02.13,英文,,0,0,0,,But this is kind of elegant now, I dare say, in that draw is recursive, because I'm literally translating from English to C code this idea that a pyramid of height 4 is really just a pyramid of height 3.
Dialogue: 0,1:39:02.13,1:39:03.79,英文,,0,0,0,,So I do that first.
Dialogue: 0,1:39:03.79,1:39:06.63,英文,,0,0,0,,And I'm sort of trusting that this will work.
Dialogue: 0,1:39:06.63,1:39:09.69,英文,,0,0,0,,Then I just have to lay one more layer of bricks, four of them.
Dialogue: 0,1:39:09.69,1:39:15.73,英文,,0,0,0,,So if n is 4, this is just a simple for loop a la week 1 that will print out an additional layer.
Dialogue: 0,1:39:15.73,1:39:18.59,英文,,0,0,0,,But this, of course, is going to be problematic eventually.
Dialogue: 0,1:39:18.59,1:39:20.14,英文,,0,0,0,,Why?
Dialogue: 0,1:39:20.14,1:39:22.81,英文,,0,0,0,,It's not done yet, this program.
Dialogue: 0,1:39:22.81,1:39:28.82,英文,,0,0,0,,How many times will draw call itself in this model?
Dialogue: 0,1:39:28.82,1:39:29.72,英文,,0,0,0,,Infinitely many times.
Dialogue: 0,1:39:29.72,1:39:34.34,英文,,0,0,0,,Why?
Dialogue: 0,1:39:34.34,1:39:36.48,英文,,0,0,0,,Yeah, there's no equivalent of quit.
Dialogue: 0,1:39:36.48,1:39:39.62,英文,,0,0,0,,Like, if you've printed enough already, then quit.
Dialogue: 0,1:39:39.62,1:39:40.96,英文,,0,0,0,,Well, how do we capture that?
Dialogue: 0,1:39:40.96,1:39:43.31,英文,,0,0,0,,Well, I don't think we want this to go negative, right?
Dialogue: 0,1:39:43.31,1:39:46.69,英文,,0,0,0,,It would make no sense to draw a negative height pyramid.
Dialogue: 0,1:39:46.69,1:39:53.85,英文,,0,0,0,,So I think we can just pluck off, as the programmer, an easy case, an easy answer, a so-called base case.
Dialogue: 0,1:39:53.85,1:39:54.91,英文,,0,0,0,,And I'm just going to do this.
Dialogue: 0,1:39:54.91,1:40:01.93,英文,,0,0,0,,At the top of my draw function, let me just say if n
Dialogue: 0,1:40:01.93,1:40:02.86,英文,,0,0,0,,That's it.
Dialogue: 0,1:40:02.86,1:40:04.52,英文,,0,0,0,,Go ahead and just return.
Dialogue: 0,1:40:04.52,1:40:06.20,英文,,0,0,0,,There's nothing more to do.
Dialogue: 0,1:40:06.20,1:40:13.31,英文,,0,0,0,,And that simple condition, technically known as a base case, will ensure that the code doesn't run forever.
Dialogue: 0,1:40:13.31,1:40:13.91,英文,,0,0,0,,Why?
Dialogue: 0,1:40:13.91,1:40:18.17,英文,,0,0,0,,Well, suppose that draw is called with an argument of 4.
Dialogue: 0,1:40:18.17,1:40:20.71,英文,,0,0,0,,4 is, of course, not less than 0, so we don't return.
Dialogue: 0,1:40:20.71,1:40:22.59,英文,,0,0,0,,But we do draw a pyramid of height 3.
Dialogue: 0,1:40:22.59,1:40:25.03,英文,,0,0,0,,And here's where things get a little mentally tricky.
Dialogue: 0,1:40:25.03,1:40:28.35,英文,,0,0,0,,You don't move on to line 20 until draw has been called.
Dialogue: 0,1:40:28.35,1:40:34.57,英文,,0,0,0,,So when draw is called with an argument of 3, it's as though you're executing from the top of this function again.
Dialogue: 0,1:40:34.57,1:40:36.40,英文,,0,0,0,,3 is not less than 0, so what do you do?
Dialogue: 0,1:40:36.40,1:40:38.22,英文,,0,0,0,,You draw 2.
Dialogue: 0,1:40:38.22,1:40:39.54,英文,,0,0,0,,OK, how do you draw 2?
Dialogue: 0,1:40:39.54,1:40:41.86,英文,,0,0,0,,Well, 2 is not less than 0, so you don't return.
Dialogue: 0,1:40:41.86,1:40:42.94,英文,,0,0,0,,So you draw 1.
Dialogue: 0,1:40:42.94,1:40:44.36,英文,,0,0,0,,Got to be careful here.
Dialogue: 0,1:40:44.36,1:40:45.38,英文,,0,0,0,,Draw 1.
Dialogue: 0,1:40:45.38,1:40:47.22,英文,,0,0,0,,And now we go ahead back to the beginning.
Dialogue: 0,1:40:47.22,1:40:48.06,英文,,0,0,0,,How do you draw 1?
Dialogue: 0,1:40:48.06,1:40:50.52,英文,,0,0,0,,Well, 1 is not less than 0, so you don't return.
Dialogue: 0,1:40:50.52,1:40:53.35,英文,,0,0,0,,You draw height 0.
Dialogue: 0,1:40:53.35,1:40:54.51,英文,,0,0,0,,How do you draw height 0?
Dialogue: 0,1:40:54.51,1:40:55.61,英文,,0,0,0,,Wait a minute.
Dialogue: 0,1:40:55.61,1:40:59.25,英文,,0,0,0,,0 is less than or equal to 0, and you return.
Dialogue: 0,1:40:59.25,1:41:02.08,英文,,0,0,0,,And so it's kind of like this mental stack, this to-do list.
Dialogue: 0,1:41:02.08,1:41:09.40,英文,,0,0,0,,You keep postponing executing these lower lines of code because you keep restarting, restarting, restarting the draw function until.
Dialogue: 0,1:41:09.40,1:41:12.83,英文,,0,0,0,,Finally, one of those function calls says, there's nothing to do.
Dialogue: 0,1:41:12.83,1:41:13.71,英文,,0,0,0,,Return.
Dialogue: 0,1:41:13.71,1:41:16.51,英文,,0,0,0,,And now the whole thing starts to unravel, if you will.
Dialogue: 0,1:41:16.51,1:41:18.45,英文,,0,0,0,,And you pick back up where you left off.
Dialogue: 0,1:41:18.45,1:41:21.29,英文,,0,0,0,,And this is perhaps the best scenario. We won't do it in class.
Dialogue: 0,1:41:21.29,1:41:31.54,英文,,0,0,0,,But if you'd like to wrestle through this on your own, using debug50 to keep stepping into, step into, step into each of those lines logically, you'll see exactly what's actually happening.
Dialogue: 0,1:41:31.54,1:41:37.85,英文,,0,0,0,,So let me go to my terminal and do make recursion, which is now this correct version of the code, dot slash recursion.
Dialogue: 0,1:41:37.85,1:41:39.43,英文,,0,0,0,,Let's type in a height of 4.
Dialogue: 0,1:41:39.43,1:41:48.04,英文,,0,0,0,,And voila, now we have that same pyramid, not using iteration per se, though admittedly, we're using iteration to print the additional layer.
Dialogue: 0,1:41:48.04,1:41:58.45,英文,,0,0,0,,We're now using draw recursively to print all of the smaller pyramids that need come before it.
Dialogue: 0,1:41:58.45,1:42:01.10,英文,,0,0,0,,No, question is, can you only use recursion with a void function?
Dialogue: 0,1:42:01.10,1:42:01.84,英文,,0,0,0,,No, not at all.
Dialogue: 0,1:42:01.84,1:42:11.55,英文,,0,0,0,,In fact, it's very common to have a return value, like an integer or something else, so that you can actually do something constructively with that actual value.
Dialogue: 0,1:42:11.55,1:42:15.41,英文,,0,0,0,,Other questions on this?
Dialogue: 0,1:42:15.41,1:42:18.92,英文,,0,0,0,,Say a little louder.
Dialogue: 0,1:42:18.92,1:42:20.98,英文,,0,0,0,,When is line 21 getting executed?
Dialogue: 0,1:42:20.98,1:42:26.85,英文,,0,0,0,,So if you continue to unwrap, let me scroll down a bit more so you can see the top of the code.
Dialogue: 0,1:42:26.85,1:42:35.41,英文,,0,0,0,,So line 21 will be executed once line 19 is done executing itself.
Dialogue: 0,1:42:35.41,1:42:40.91,英文,,0,0,0,,Now, in the story I told, we kept calling draw again, again, again.
Dialogue: 0,1:42:40.91,1:42:48.58,英文,,0,0,0,,But as soon as one of those function calls, where n equals 0, returns immediately, then we don't keep drawing again and again.
Dialogue: 0,1:42:48.58,1:42:59.96,英文,,0,0,0,,So now if you kind of think of the process as reversing, then you continue to line 21, then line 21 again, then line 21 again, and as the sort of logic unravels.
Dialogue: 0,1:42:59.96,1:43:03.72,英文,,0,0,0,,And next week, we'll actually paint a picture of what's actually happening in the computer's memory.
Dialogue: 0,1:43:03.72,1:43:07.91,英文,,0,0,0,,But for now, it's very similar to the pseudocode for the phone book.
Dialogue: 0,1:43:07.91,1:43:09.72,英文,,0,0,0,,You're just searching again and again.
Dialogue: 0,1:43:09.72,1:43:14.45,英文,,0,0,0,,But you're waiting until the very end to get back the final result.
Dialogue: 0,1:43:14.45,1:43:18.99,英文,,0,0,0,,Google now, whom I keep mentioning by coincidence today, is full of programmers, of course.
Dialogue: 0,1:43:18.99,1:43:20.61,英文,,0,0,0,,Here's a fun exercise.
Dialogue: 0,1:43:20.61,1:43:23.67,英文,,0,0,0,,Let me go back to a browser.
Dialogue: 0,1:43:23.67,1:43:28.08,英文,,0,0,0,,I'm going to go ahead and search for recursion, because I want to learn a little something about recursion.
Dialogue: 0,1:43:28.08,1:43:30.22,英文,,0,0,0,,Here is kind of an internet meme or joke.
Dialogue: 0,1:43:30.22,1:43:35.38,英文,,0,0,0,,If I zoom in here, the engineers at Google are kind of funny.
Dialogue: 0,1:43:35.38,1:43:39.52,英文,,0,0,0,,See why?
Dialogue: 0,1:43:39.52,1:43:40.70,英文,,0,0,0,,Ah, there we go.
Dialogue: 0,1:43:40.70,1:43:41.87,英文,,0,0,0,,Yes?
Dialogue: 0,1:43:41.87,1:43:43.05,英文,,0,0,0,,Yes, this is recursion.
Dialogue: 0,1:43:43.05,1:43:52.66,英文,,0,0,0,,And there's going to be so many memes you'll come across now where recursion, like if you've ever pointed a camera at the TV that's showing the camera and you sort of see yourself or the image again and again, that's really recursion.
Dialogue: 0,1:43:52.66,1:43:56.38,英文,,0,0,0,,And in that case, it only stops once you hit the base case of a single pixel.
Dialogue: 0,1:43:56.38,1:44:01.80,英文,,0,0,0,,But this is a very funny joke in some circles when it comes to recursion and Google.
Dialogue: 0,1:44:01.80,1:44:08.21,英文,,0,0,0,,So how can we actually use Google, or rather, how can we actually use recursion constructively?
Dialogue: 0,1:44:08.21,1:44:10.33,英文,,0,0,0,,Well, let me propose that.
Dialogue: 0,1:44:10.33,1:44:16.85,英文,,0,0,0,,We actually introduce a third and final algorithm for sorting that hopefully does better than the two sorts thus far.
Dialogue: 0,1:44:16.85,1:44:19.69,英文,,0,0,0,,We've done selection sort and bubble sort.
Dialogue: 0,1:44:19.69,1:44:24.19,英文,,0,0,0,,Bubble sort we liked a little better, at least insofar as in the best case where the list is already sorted.
Dialogue: 0,1:44:24.19,1:44:30.65,英文,,0,0,0,,Bubble sort's at least smarter, and it will actually terminate early, giving us a better lower bound in terms of our omega notation.
Dialogue: 0,1:44:30.65,1:44:40.09,英文,,0,0,0,,But it turns out that recursion, and this is not necessarily a feature of recursion, but something we can now leverage, it turns out using recursion,
Dialogue: 0,1:44:40.09,1:44:49.09,英文,,0,0,0,,we can take a fundamentally different approach to sorting a whole bunch of numbers in such a way that we can do far fewer comparisons and ideally speed up our final results.
Dialogue: 0,1:44:49.09,1:44:54.17,英文,,0,0,0,,So here is the pseudocode for what we're about to see for something called merge sort.
Dialogue: 0,1:44:54.17,1:44:56.53,英文,,0,0,0,,And it really is this terse.
Dialogue: 0,1:44:56.53,1:44:58.63,英文,,0,0,0,,Sort the left half of numbers.
Dialogue: 0,1:44:58.63,1:45:00.71,英文,,0,0,0,,Sort the right half of numbers.
Dialogue: 0,1:45:00.71,1:45:02.94,英文,,0,0,0,,Merge the sorted halves.
Dialogue: 0,1:45:02.94,1:45:14.28,英文,,0,0,0,,This is almost sort of nonsensical because if you're asked for an algorithm to sort and you respond with, well, sort the left half, sort the right half, that's being sort of difficult because, well, I'm asking for a sorting algorithm.
Dialogue: 0,1:45:14.28,1:45:16.82,英文,,0,0,0,,You're just telling me to sort the left half and the right half.
Dialogue: 0,1:45:16.82,1:45:21.78,英文,,0,0,0,,But implicit in that last line, merging, is a pretty powerful feature of this sort.
Dialogue: 0,1:45:21.78,1:45:24.68,英文,,0,0,0,,Now, we do need another base case at the top. So let me add this.
Dialogue: 0,1:45:24.68,1:45:29.84,英文,,0,0,0,,If we find ourselves with a list, an array of size 1, well, that array is obviously sorted.
Dialogue: 0,1:45:29.84,1:45:32.44,英文,,0,0,0,,If there's only one element in it, there's no work to be done.
Dialogue: 0,1:45:32.44,1:45:40.89,英文,,0,0,0,,So that's going to be our base case, but allowing us now in just these, what, four, six lines of pseudocode to actually sort some elements.
Dialogue: 0,1:45:40.89,1:45:43.67,英文,,0,0,0,,But let's focus first on just a subset of this.
Dialogue: 0,1:45:43.67,1:45:46.37,英文,,0,0,0,,Let's consider for a moment what it means to merge sorted halves.
Dialogue: 0,1:45:46.37,1:45:50.41,英文,,0,0,0,,So Carter has wonderfully come up to volunteer here just to help us reset these numbers.
Dialogue: 0,1:45:50.41,1:45:56.05,英文,,0,0,0,,Suppose that in the middle of the story we're about to tell, we have two sorted halves.
Dialogue: 0,1:45:56.05,1:45:58.29,英文,,0,0,0,,I've already sorted the left half of these numbers.
Dialogue: 0,1:45:58.29,1:46:01.77,英文,,0,0,0,,And indeed, 2, 4, 5, 7 is sorted from smallest to largest.
Dialogue: 0,1:46:01.77,1:46:06.29,英文,,0,0,0,,And the right half appears to be already sorted, 0, 1, 3, 6, already sorted.
Dialogue: 0,1:46:06.29,1:46:10.63,英文,,0,0,0,,So in my pseudocode, we're already done sorting the left half and the right half somehow.
Dialogue: 0,1:46:10.63,1:46:12.35,英文,,0,0,0,,But we'll see how in a moment.
Dialogue: 0,1:46:12.35,1:46:14.99,英文,,0,0,0,,Well, how do I go about merging these two halves?
Dialogue: 0,1:46:14.99,1:46:20.10,英文,,0,0,0,,Well, because they're sorted already and you want to merge them in order, I think we can flip down.
Dialogue: 0,1:46:20.10,1:46:25.22,英文,,0,0,0,,We can hide all but the first numbers in each of these sublists.
Dialogue: 0,1:46:25.22,1:46:27.54,英文,,0,0,0,,So here we have a half.
Dialogue: 0,1:46:27.54,1:46:28.52,英文,,0,0,0,,That starts with 2.
Dialogue: 0,1:46:28.52,1:46:31.98,英文,,0,0,0,,And I don't really care what the other numbers are, because they're clearly larger than 2.
Dialogue: 0,1:46:31.98,1:46:33.51,英文,,0,0,0,,I can focus only on 2.
Dialogue: 0,1:46:33.51,1:46:35.27,英文,,0,0,0,,And 0, too. 0 also.
Dialogue: 0,1:46:35.27,1:46:36.81,英文,,0,0,0,,We know that 0 is the smallest there.
Dialogue: 0,1:46:36.81,1:46:39.39,英文,,0,0,0,,So let's just ignore the numbers that Carter kindly flipped down.
Dialogue: 0,1:46:39.39,1:46:44.25,英文,,0,0,0,,So how do I merge these two lists into a new sorted larger list?
Dialogue: 0,1:46:44.25,1:46:48.24,英文,,0,0,0,,Well, I compare the 2 on my left with the 0 on my right.
Dialogue: 0,1:46:48.24,1:46:49.74,英文,,0,0,0,,Obviously, which comes first?
Dialogue: 0,1:46:49.74,1:46:50.62,英文,,0,0,0,,The 0.
Dialogue: 0,1:46:50.62,1:46:52.14,英文,,0,0,0,,So let me put this down here.
Dialogue: 0,1:46:52.14,1:46:54.34,英文,,0,0,0,,And Carter, if you want to give us the next element.
Dialogue: 0,1:46:54.34,1:46:57.70,英文,,0,0,0,,Now I have two sorted halves. But I've already plucked 1 off.
Dialogue: 0,1:46:57.70,1:47:00.30,英文,,0,0,0,,So now I compare the 2 against the 1.
Dialogue: 0,1:47:00.30,1:47:01.60,英文,,0,0,0,,1 obviously comes next.
Dialogue: 0,1:47:01.60,1:47:05.11,英文,,0,0,0,,So I'm going to take out the 1 and put it in place here.
Dialogue: 0,1:47:05.11,1:47:06.95,英文,,0,0,0,,Now I'm going to compare the two halves again.
Dialogue: 0,1:47:06.95,1:47:08.97,英文,,0,0,0,,2 and 3, which do I merge first?
Dialogue: 0,1:47:08.97,1:47:10.87,英文,,0,0,0,,Obviously, the 2 comes next.
Dialogue: 0,1:47:10.87,1:47:15.21,英文,,0,0,0,,And now notice, each time I do this, my hands are theoretically making forward progress.
Dialogue: 0,1:47:15.21,1:47:20.46,英文,,0,0,0,,I'm not doubling back like I kept doing with selection sort or bubble sort, back and forth, back and forth.
Dialogue: 0,1:47:20.46,1:47:27.50,英文,,0,0,0,,My fingers are constantly advancing forward. And that's going to be a key detail. So I compare 4 and 3. 3, obviously.
Dialogue: 0,1:47:27.50,1:47:32.76,英文,,0,0,0,,I compare 4 and 6, 4 obviously.
Dialogue: 0,1:47:32.76,1:47:36.79,英文,,0,0,0,,I compare 5 and 6, 5 obviously.
Dialogue: 0,1:47:36.79,1:47:41.09,英文,,0,0,0,,And then I compare 7 and 6, 6 of course.
Dialogue: 0,1:47:41.09,1:47:42.99,英文,,0,0,0,,And then lastly, we have just one element left.
Dialogue: 0,1:47:42.99,1:47:48.15,英文,,0,0,0,,And even though I'm kind of moving awkwardly as a human, my hands technically were only moving to the right.
Dialogue: 0,1:47:48.15,1:47:51.13,英文,,0,0,0,,I was never looping back, doing something again and again.
Dialogue: 0,1:47:51.13,1:47:54.69,英文,,0,0,0,,And that's perhaps the intuition and just enough room for the 7.
Dialogue: 0,1:47:54.69,1:47:58.22,英文,,0,0,0,,So that, then, is how you would merge two sorted halves.
Dialogue: 0,1:47:58.22,1:48:00.86,英文,,0,0,0,,We started with left half sorted, right half sorted.
Dialogue: 0,1:48:00.86,1:48:02.90,英文,,0,0,0,,And merging is just like what you would do as a human.
Dialogue: 0,1:48:02.90,1:48:08.86,英文,,0,0,0,,And Carter just flipped the numbers down, so our focus was only on the smallest elements in each.
Dialogue: 0,1:48:08.86,1:48:17.13,英文,,0,0,0,,Any questions before we forge ahead with what it means, then, to be merged in this way?
Dialogue: 0,1:48:17.13,1:48:19.13,英文,,0,0,0,,So now, here is an original list.
Dialogue: 0,1:48:19.13,1:48:22.65,英文,,0,0,0,,We deliberately put it at the top because there's one detail of merge sort that's key.
Dialogue: 0,1:48:22.65,1:48:25.40,英文,,0,0,0,,Merge sort is technically going to use a little more space.
Dialogue: 0,1:48:25.40,1:48:32.27,英文,,0,0,0,,And so whereas previously, we just kept moving our humans around and swapping people and making sure they stayed ultimately in the original positions,
Dialogue: 0,1:48:32.27,1:48:36.81,英文,,0,0,0,,With merge sort, pretends that here's our original array of memory.
Dialogue: 0,1:48:36.81,1:48:38.95,英文,,0,0,0,,I'm going to need at least one other array of memory.
Dialogue: 0,1:48:38.95,1:48:41.26,英文,,0,0,0,,And I'm going to cheat, and I'm going to use even more memory.
Dialogue: 0,1:48:41.26,1:48:45.54,英文,,0,0,0,,But technically, I could actually go back and forth between one array and a secondary array.
Dialogue: 0,1:48:45.54,1:48:48.51,英文,,0,0,0,,But it is going to take me more space.
Dialogue: 0,1:48:48.51,1:48:51.03,英文,,0,0,0,,So how do I go about implementing merge sort?
Dialogue: 0,1:48:51.03,1:48:54.99,英文,,0,0,0,,Merge sort on this code, well, let's consider this.
Dialogue: 0,1:48:54.99,1:48:57.21,英文,,0,0,0,,Here is a array of size 8.
Dialogue: 0,1:48:57.21,1:48:59.49,英文,,0,0,0,,If only one number quit, obviously not applicable.
Dialogue: 0,1:48:59.49,1:49:01.41,英文,,0,0,0,,So let's focus on the juicy part there.
Dialogue: 0,1:49:01.41,1:49:03.02,英文,,0,0,0,,Sort the left half of the numbers.
Dialogue: 0,1:49:03.02,1:49:05.12,英文,,0,0,0,,All right, how do I sort the left half of the numbers?
Dialogue: 0,1:49:05.12,1:49:09.28,英文,,0,0,0,,I'm going to just nudge them over just to be clear which is the left half.
Dialogue: 0,1:49:09.28,1:49:11.98,英文,,0,0,0,,Here is now a sub list of size 4.
Dialogue: 0,1:49:11.98,1:49:15.00,英文,,0,0,0,,How do I sort the left half?
Dialogue: 0,1:49:15.00,1:49:18.45,英文,,0,0,0,,Well, do I have an algorithm for sorting? Yeah, what do I do?
Dialogue: 0,1:49:18.45,1:49:22.20,英文,,0,0,0,,Here's a list of size 4. How do I sort it? What's step 1?
Dialogue: 0,1:49:22.20,1:49:23.38,英文,,0,0,0,,Sort the left half.
Dialogue: 0,1:49:23.38,1:49:32.19,英文,,0,0,0,,So I now sort of conceptually, in my mind, take this sublist of size 4, and I sort it by first sorting the left half, focusing now on the 7 and 2.
Dialogue: 0,1:49:32.19,1:49:34.45,英文,,0,0,0,,All right, here's a list of size 2.
Dialogue: 0,1:49:34.45,1:49:38.85,英文,,0,0,0,,How do I sort a list of size 2?
Dialogue: 0,1:49:38.85,1:49:42.38,英文,,0,0,0,,Sorry? I think we just keep following our instructions.
Dialogue: 0,1:49:42.38,1:49:43.72,英文,,0,0,0,,Sort the left half.
Dialogue: 0,1:49:43.72,1:49:45.79,英文,,0,0,0,,All right, here is a list of size 1.
Dialogue: 0,1:49:45.79,1:49:49.95,英文,,0,0,0,,How do I sort a list of size 1?
Dialogue: 0,1:49:49.95,1:49:50.47,英文,,0,0,0,,I'm done.
Dialogue: 0,1:49:50.47,1:49:51.29,英文,,0,0,0,,Like, it's done.
Dialogue: 0,1:49:51.29,1:49:52.85,英文,,0,0,0,,So I leave this alone.
Dialogue: 0,1:49:52.85,1:49:54.75,英文,,0,0,0,,What was the next step in the story?
Dialogue: 0,1:49:54.75,1:49:58.33,英文,,0,0,0,,I've just sorted the left half of the left half of the left half.
Dialogue: 0,1:49:58.33,1:49:59.69,英文,,0,0,0,,What comes next?
Dialogue: 0,1:49:59.69,1:50:03.50,英文,,0,0,0,,I sort the right half of the left half of the left half.
Dialogue: 0,1:50:03.50,1:50:06.54,英文,,0,0,0,,And I'm done, because it's just a list of size 1.
Dialogue: 0,1:50:06.54,1:50:09.35,英文,,0,0,0,,What comes after this?
Dialogue: 0,1:50:09.35,1:50:10.27,英文,,0,0,0,,Merge.
Dialogue: 0,1:50:10.27,1:50:16.27,英文,,0,0,0,,So this is where it gets a little trippy, because you have to remember where we're pausing the story to do things recursively again and again.
Dialogue: 0,1:50:16.27,1:50:20.94,英文,,0,0,0,,But if I've just sorted the left half, and I've just sorted the right half, now I merge them together.
Dialogue: 0,1:50:20.94,1:50:25.06,英文,,0,0,0,,This is a super short list, so we don't need Carter's help here as before.
Dialogue: 0,1:50:25.06,1:50:27.84,英文,,0,0,0,,But I think the first number I take here is the 2.
Dialogue: 0,1:50:27.84,1:50:31.85,英文,,0,0,0,,And then the second number I take, because it's the only option, is the 7.
Dialogue: 0,1:50:31.85,1:50:37.11,英文,,0,0,0,,But what's nice now is that, notice, the left half of the left half is indeed sorted.
Dialogue: 0,1:50:37.11,1:50:42.82,英文,,0,0,0,,Because I trivially sorted the left half of it and the right half of it, but then merging is really where the magic happens.
Dialogue: 0,1:50:42.82,1:50:51.64,英文,,0,0,0,,All right, again, if you rewind now in your mind, if I've just sorted the left half of the left half, what happens next?
Dialogue: 0,1:50:51.64,1:50:55.08,英文,,0,0,0,,Sort the right half of the left half.
Dialogue: 0,1:50:55.08,1:50:56.88,英文,,0,0,0,,So again, you kind of rewind in time.
Dialogue: 0,1:50:56.88,1:50:58.27,英文,,0,0,0,,So how do I do this?
Dialogue: 0,1:50:58.27,1:50:59.55,英文,,0,0,0,,I've got a list of size 2.
Dialogue: 0,1:50:59.55,1:51:00.61,英文,,0,0,0,,I sort the left half.
Dialogue: 0,1:51:00.61,1:51:01.51,英文,,0,0,0,,Adjust the 5.
Dialogue: 0,1:51:01.51,1:51:02.09,英文,,0,0,0,,Done.
Dialogue: 0,1:51:02.09,1:51:03.41,英文,,0,0,0,,Sort the right half.
Dialogue: 0,1:51:03.41,1:51:03.69,英文,,0,0,0,,4.
Dialogue: 0,1:51:03.69,1:51:04.37,英文,,0,0,0,,Done.
Dialogue: 0,1:51:04.37,1:51:05.45,英文,,0,0,0,,Now the interesting part.
Dialogue: 0,1:51:05.45,1:51:11.49,英文,,0,0,0,,I merge the left half and the right half of the right half of the left half.
Dialogue: 0,1:51:11.49,1:51:12.79,英文,,0,0,0,,So what do I do?
Dialogue: 0,1:51:12.79,1:51:14.79,英文,,0,0,0,,4 comes down here.
Dialogue: 0,1:51:14.79,1:51:16.51,英文,,0,0,0,,5 comes down here.
Dialogue: 0,1:51:16.51,1:51:18.45,英文,,0,0,0,,And now?
Dialogue: 0,1:51:18.45,1:51:20.07,英文,,0,0,0,,Notice what I have.
Dialogue: 0,1:51:20.07,1:51:21.81,英文,,0,0,0,,Left half is sorted.
Dialogue: 0,1:51:21.81,1:51:23.19,英文,,0,0,0,,Right half is sorted.
Dialogue: 0,1:51:23.19,1:51:26.03,英文,,0,0,0,,If you rewind in time, where is my next step?
Dialogue: 0,1:51:26.03,1:51:26.79,英文,,0,0,0,,3?
Dialogue: 0,1:51:26.79,1:51:27.83,英文,,0,0,0,,Merge the two halves.
Dialogue: 0,1:51:27.83,1:51:29.71,英文,,0,0,0,,And so this is what Carter helped me do before.
Dialogue: 0,1:51:29.71,1:51:32.69,英文,,0,0,0,,Let's focus only on the smallest elements, just so there's less distraction.
Dialogue: 0,1:51:32.69,1:51:34.32,英文,,0,0,0,,I compare the 2 and the 4.
Dialogue: 0,1:51:34.32,1:51:36.66,英文,,0,0,0,,2 comes first, so let's obviously put that here.
Dialogue: 0,1:51:36.66,1:51:41.56,英文,,0,0,0,,Now I compare the new beginning of this list and the old beginning of this list.
Dialogue: 0,1:51:41.56,1:51:43.32,英文,,0,0,0,,4 obviously comes next.
Dialogue: 0,1:51:43.32,1:51:46.28,英文,,0,0,0,,And now I compare the 7 against the 5.
Dialogue: 0,1:51:46.28,1:51:47.48,英文,,0,0,0,,5 obviously comes next.
Dialogue: 0,1:51:47.48,1:51:49.31,英文,,0,0,0,,And now lastly, I'm left with one number.
Dialogue: 0,1:51:49.31,1:51:51.15,英文,,0,0,0,,So now I'm down to the 7.
Dialogue: 0,1:51:51.15,1:51:58.43,英文,,0,0,0,,So even if you've kind of lost track of some of the nuances here, if you just kind of take a step back, we have the original right half here still untouched.
Dialogue: 0,1:51:58.43,1:52:09.02,英文,,0,0,0,,But the left half of the original input is now indeed sorted, all by way of doing sorting left half, right half, left half, right half, but with those merges in between.
Dialogue: 0,1:52:09.02,1:52:12.20,英文,,0,0,0,,All right, so if we've just sorted the left half,
Dialogue: 0,1:52:12.20,1:52:13.56,英文,,0,0,0,,We rewind all the way to the beginning.
Dialogue: 0,1:52:13.56,1:52:15.70,英文,,0,0,0,,What do I now do?
Dialogue: 0,1:52:15.70,1:52:17.12,英文,,0,0,0,,All right, so sort the right half.
Dialogue: 0,1:52:17.12,1:52:18.39,英文,,0,0,0,,So sort the right half.
Dialogue: 0,1:52:18.39,1:52:20.29,英文,,0,0,0,,How do I sort a list of size 4?
Dialogue: 0,1:52:20.29,1:52:22.65,英文,,0,0,0,,Well, I first sort the left half, the 1 and the 6.
Dialogue: 0,1:52:22.65,1:52:24.65,英文,,0,0,0,,How do I sort a list of size 2?
Dialogue: 0,1:52:24.65,1:52:26.93,英文,,0,0,0,,You sort the left half, just the number 1.
Dialogue: 0,1:52:26.93,1:52:28.47,英文,,0,0,0,,Obviously, there's no work to be done.
Dialogue: 0,1:52:28.47,1:52:30.85,英文,,0,0,0,,Done, sorting the left half.
Dialogue: 0,1:52:30.85,1:52:33.24,英文,,0,0,0,,Six, done, sorting the right half.
Dialogue: 0,1:52:33.24,1:52:34.36,英文,,0,0,0,,Now what do I do?
Dialogue: 0,1:52:34.36,1:52:40.76,英文,,0,0,0,,I merge the left half here with the right half here.
Dialogue: 0,1:52:40.76,1:52:42.30,英文,,0,0,0,,And that one's pretty straightforward.
Dialogue: 0,1:52:42.30,1:52:44.08,英文,,0,0,0,,Now what do I do? I've just merged.
Dialogue: 0,1:52:44.08,1:52:47.10,英文,,0,0,0,,So now I've just sorted the left half of the right half.
Dialogue: 0,1:52:47.10,1:52:49.75,英文,,0,0,0,,So now I sort the right half of the right half.
Dialogue: 0,1:52:49.75,1:52:51.65,英文,,0,0,0,,So I consider the 0, done.
Dialogue: 0,1:52:51.65,1:52:53.41,英文,,0,0,0,,I consider the 3, done.
Dialogue: 0,1:52:53.41,1:52:55.47,英文,,0,0,0,,I now merge these two together.
Dialogue: 0,1:52:55.47,1:52:56.71,英文,,0,0,0,,0, of course, comes first.
Dialogue: 0,1:52:56.71,1:52:58.25,英文,,0,0,0,,Then comes the 3.
Dialogue: 0,1:52:58.25,1:53:05.05,英文,,0,0,0,,And now I'm at the point of the story where I've sorted the left half of the right half and the right half of the right half.
Dialogue: 0,1:53:05.05,1:53:09.47,英文,,0,0,0,,So step 3 is? Merge, and I'll do it again like we did with Carter.
Dialogue: 0,1:53:09.47,1:53:10.69,英文,,0,0,0,,All right, 1 and 0.
Dialogue: 0,1:53:10.69,1:53:12.51,英文,,0,0,0,,Obviously, the 0 comes first.
Dialogue: 0,1:53:12.51,1:53:14.48,英文,,0,0,0,,Now compare the 1 and the 3.
Dialogue: 0,1:53:14.48,1:53:16.22,英文,,0,0,0,,Obviously, the 1 comes first.
Dialogue: 0,1:53:16.22,1:53:17.56,英文,,0,0,0,,Compare the 6 and the 3.
Dialogue: 0,1:53:17.56,1:53:18.74,英文,,0,0,0,,Obviously, the 3.
Dialogue: 0,1:53:18.74,1:53:20.52,英文,,0,0,0,,And then lastly, the 6.
Dialogue: 0,1:53:20.52,1:53:22.04,英文,,0,0,0,,So now where are we?
Dialogue: 0,1:53:22.04,1:53:27.00,英文,,0,0,0,,We've taken the left half of the whole thing and sorted it.
Dialogue: 0,1:53:27.00,1:53:30.18,英文,,0,0,0,,We then took the right half of the whole thing and sorted it.
Dialogue: 0,1:53:30.18,1:53:35.28,英文,,0,0,0,,So now we're at, lastly, step 3 for the last time. What do we do?
Dialogue: 0,1:53:35.28,1:53:39.35,英文,,0,0,0,,Merge, and so just to be consistent, let me push these down.
Dialogue: 0,1:53:39.35,1:53:45.45,英文,,0,0,0,,And let's compare left hand to right hand, noticing that they only make forward progress, none of this back and forth comparisons.
Dialogue: 0,1:53:45.45,1:53:47.43,英文,,0,0,0,,2 and 0, of course, the 0.
Dialogue: 0,1:53:47.43,1:53:49.31,英文,,0,0,0,,So we'll put that in place.
Dialogue: 0,1:53:49.31,1:53:51.15,英文,,0,0,0,,2 and 1, of course, the 1.
Dialogue: 0,1:53:51.15,1:53:53.33,英文,,0,0,0,,So we put that in place.
Dialogue: 0,1:53:53.33,1:53:57.41,英文,,0,0,0,,2 and 3, we merge in, of course, the 2 in this case.
Dialogue: 0,1:53:57.41,1:54:01.25,英文,,0,0,0,,4 and 3, we now merge in the 3 in this case.
Dialogue: 0,1:54:01.25,1:54:05.94,英文,,0,0,0,,4 and 6, we now merge, of course, the 4 in place.
Dialogue: 0,1:54:05.94,1:54:12.72,英文,,0,0,0,,And now we compare 5 and 6. We keep the 5.
Dialogue: 0,1:54:12.72,1:54:15.41,英文,,0,0,0,,Bug.
Dialogue: 0,1:54:15.41,1:54:20.11,英文,,0,0,0,,OK, well, pretend that the 5 is on.
Dialogue: 0,1:54:20.11,1:54:21.57,英文,,0,0,0,,Oh, this is why.
Dialogue: 0,1:54:21.57,1:54:23.39,英文,,0,0,0,,All right, so now we compare the 7 and the 6.
Dialogue: 0,1:54:23.39,1:54:26.73,英文,,0,0,0,,6 is gone.
Dialogue: 0,1:54:26.73,1:54:29.59,英文,,0,0,0,,And lastly, 7 is the last one in place.
Dialogue: 0,1:54:29.59,1:54:41.00,英文,,0,0,0,,And even though I grant that of all the algorithms, this is probably the hardest one to stay on top of, especially when I'm doing it as a voiceover, realize that what we've just done is only those three steps recursively.
Dialogue: 0,1:54:41.00,1:54:42.61,英文,,0,0,0,,We started with a list of size 8.
Dialogue: 0,1:54:42.61,1:54:43.77,英文,,0,0,0,,We sorted the left half.
Dialogue: 0,1:54:43.77,1:54:44.93,英文,,0,0,0,,We sorted the right half.
Dialogue: 0,1:54:44.93,1:54:46.37,英文,,0,0,0,,And then we merged the two together.
Dialogue: 0,1:54:46.37,1:54:54.03,英文,,0,0,0,,But if you go down each of those rabbit holes, so to speak, sorting the left half involves sorting the left half of the left half and the right half of the left half.
Dialogue: 0,1:54:54.03,1:55:02.52,英文,,0,0,0,,And so forth. But this germ of an idea of really dividing and conquering the problem, not such that you're having the problem and only dealing with one half.
Dialogue: 0,1:55:02.52,1:55:07.84,英文,,0,0,0,,Clearly, we're sorting one half and the other half and merging them together, ultimately.
Dialogue: 0,1:55:07.84,1:55:10.91,英文,,0,0,0,,It does still lead us to the same solution.
Dialogue: 0,1:55:10.91,1:55:15.43,英文,,0,0,0,,And if we visualize the remnants of this now, if I depict this as follows, where
Dialogue: 0,1:55:15.43,1:55:20.41,英文,,0,0,0,,On the screen here, you see where the numbers originally started in the top row from left to right.
Dialogue: 0,1:55:20.41,1:55:29.00,英文,,0,0,0,,Essentially, even though this is in a different order, I divided that list of size 8 ultimately into eight lists of size 1.
Dialogue: 0,1:55:29.00,1:55:32.84,英文,,0,0,0,,And that's where the base case kicked in and just said, OK, we're done sorting that.
Dialogue: 0,1:55:32.84,1:55:41.40,英文,,0,0,0,,And after that, logically, I merged two lists of size 1 into many lists of size 2, and those lists of size 2 into the lists of size 4,
Dialogue: 0,1:55:41.40,1:55:47.40,英文,,0,0,0,,and finally, the lists of size 4 into one big list sorted of size 8.
Dialogue: 0,1:55:47.40,1:55:55.82,英文,,0,0,0,,And so I put forth this picture with the little line indicators here, because how many times did I divide, divide, divide in half?
Dialogue: 0,1:55:55.82,1:55:57.34,英文,,0,0,0,,Or really, double, double, double.
Dialogue: 0,1:55:57.34,1:55:59.07,英文,,0,0,0,,So exponent is the opposite.
Dialogue: 0,1:55:59.07,1:56:00.77,英文,,0,0,0,,Oh, spoiler.
Dialogue: 0,1:56:00.77,1:56:02.61,英文,,0,0,0,,How many times did I divide?
Dialogue: 0,1:56:02.61,1:56:04.51,英文,,0,0,0,,So three, concretely.
Dialogue: 0,1:56:04.51,1:56:12.31,英文,,0,0,0,,But if there's eight elements total, and there's n more generally, it really is a matter of dividing and conquering log n times.
Dialogue: 0,1:56:12.31,1:56:15.35,英文,,0,0,0,,You start this, and you can divide 1, 2, 3 times, log n times.
Dialogue: 0,1:56:15.35,1:56:25.68,英文,,0,0,0,,Or conversely, you can start here and exponentially double, double, double three times, which is log n. But on every row, every shelf, literally, I made a fuss about,
Dialogue: 0,1:56:25.68,1:56:34.54,英文,,0,0,0,,Pointing my hands only from the left to the right, constantly advancing them, such that every time I did those merges, I touched every element once and only once.
Dialogue: 0,1:56:34.54,1:56:37.71,英文,,0,0,0,,There was none of this back and forth, back and forth on stage.
Dialogue: 0,1:56:37.71,1:56:49.77,英文,,0,0,0,,So if I'm doing something log n times, or if I'm doing, rather, n things log n times, what would be our big O formula, perhaps?
Dialogue: 0,1:56:49.77,1:56:52.31,英文,,0,0,0,,n things log n times?
Dialogue: 0,1:56:52.31,1:56:58.60,英文,,0,0,0,,Yeah, so n log n, the order of n log n is indeed how we would describe the running time of merge sort.
Dialogue: 0,1:56:58.60,1:57:10.82,英文,,0,0,0,,And so of all of the sorts thus far, we've seen that merge sort here actually is n log n, which is strictly better than n squared, which is where both selection sort and bubble sort landed.
Dialogue: 0,1:57:10.82,1:57:14.12,英文,,0,0,0,,But it's also slower than linear search, for instance.
Dialogue: 0,1:57:14.12,1:57:15.39,英文,,0,0,0,,But you would rather expect that.
Dialogue: 0,1:57:15.39,1:57:21.59,英文,,0,0,0,,If you have to do a lot of work up front sorting some elements versus just searching them, you're going to have to put in more effort.
Dialogue: 0,1:57:21.59,1:57:30.29,英文,,0,0,0,,And so the question of whether or not you should just search something blindly with linear search and not bother sorting it really boils down to, can you afford to spend this amount of time?
Dialogue: 0,1:57:30.29,1:57:35.17,英文,,0,0,0,,And if you're the Googles of the world, odds are you don't want to be searching their database linearly every time.
Dialogue: 0,1:57:35.17,1:57:35.81,英文,,0,0,0,,Why?
Dialogue: 0,1:57:35.81,1:57:46.65,英文,,0,0,0,,Because you can sort it once and then benefit millions, billions of people subsequently using something like binary search or, frankly, in practice, something even fancier and faster than binary search.
Dialogue: 0,1:57:46.65,1:57:48.49,英文,,0,0,0,,But there's always going to be this trade-off.
Dialogue: 0,1:57:48.49,1:57:52.30,英文,,0,0,0,,You can achieve binary search only if the elements are sorted.
Dialogue: 0,1:57:52.30,1:57:53.96,英文,,0,0,0,,How much does it cost you to sort them?
Dialogue: 0,1:57:53.96,1:57:57.10,英文,,0,0,0,,Well, maybe n squared if you use some of the earlier algorithms.
Dialogue: 0,1:57:57.10,1:58:01.00,英文,,0,0,0,,But it turns out n log n is pretty fast as well.
Dialogue: 0,1:58:01.00,1:58:06.25,英文,,0,0,0,,So at the end of the day, these running times involve trade-offs.
Dialogue: 0,1:58:06.25,1:58:17.24,英文,,0,0,0,,And indeed, in merge sort 2, I should note that the lower bound on merge sort is also going to be omega of n log n. As such, we can describe it in terms of our theta notation, saying that merge sort is indeed in theta of,N log N.
Dialogue: 0,1:58:17.24,1:58:28.22,英文,,0,0,0,,So generally speaking, probably better to use something like merge sort or some other algorithm that's in N log N. In practice, most programmers are not implementing these sorting algorithms themselves.
Dialogue: 0,1:58:28.22,1:58:34.33,英文,,0,0,0,,Odds are they're using a library off the shelf that themselves have made the decision as to which of these algorithms to do.
Dialogue: 0,1:58:34.33,1:58:42.83,英文,,0,0,0,,But generally speaking, and we're seeing now this for the first time, if you want to improve time, like use less time, write faster code, you've got to pay a price.
Dialogue: 0,1:58:42.83,1:58:49.44,英文,,0,0,0,,And that might be your human time. It just takes you more time to code up something more sophisticated, more difficult to implement.
Dialogue: 0,1:58:49.44,1:58:52.04,英文,,0,0,0,,Or you need to spend something like space.
Dialogue: 0,1:58:52.04,1:58:55.82,英文,,0,0,0,,And as these shelves suggest, that, too, is one of the key details of merge sort.
Dialogue: 0,1:58:55.82,1:58:58.61,英文,,0,0,0,,You can't just have the elements swapping in place.
Dialogue: 0,1:58:58.61,1:59:04.11,英文,,0,0,0,,You need at least an auxiliary array so that when you do the merging, you have a place to put them.
Dialogue: 0,1:59:04.11,1:59:06.15,英文,,0,0,0,,And this is excessive, this amount of memory.
Dialogue: 0,1:59:06.15,1:59:08.99,英文,,0,0,0,,I could have just gone back and forth between top shelf and bottom shelf.
Dialogue: 0,1:59:08.99,1:59:11.19,英文,,0,0,0,,But it's a little more interesting to go top down.
Dialogue: 0,1:59:11.19,1:59:12.98,英文,,0,0,0,,But you do need more space.
Dialogue: 0,1:59:12.98,1:59:15.78,英文,,0,0,0,,Back in the day, decades ago, space was really expensive.
Dialogue: 0,1:59:15.78,1:59:16.48,英文,,0,0,0,,And so you know what?
Dialogue: 0,1:59:16.48,1:59:23.44,英文,,0,0,0,,It might have been better to not use merge sort, use bubble sort, or selection sort even, or some other algorithm altogether.
Dialogue: 0,1:59:23.44,1:59:25.31,英文,,0,0,0,,Nowadays, space is relatively cheap.
Dialogue: 0,1:59:25.31,1:59:27.19,英文,,0,0,0,,And so these are more acceptable trade-offs.
Dialogue: 0,1:59:27.19,1:59:29.85,英文,,0,0,0,,But it totally depends on the application.
Dialogue: 0,1:59:29.85,1:59:34.45,英文,,0,0,0,,The very last thing we thought we'd do is show you an actual comparison of some of these sorting algorithms.
Dialogue: 0,1:59:34.45,1:59:47.03,英文,,0,0,0,,It's about 60 seconds long, and it will compare for you selection sort, bubble sort, and merge sort in parallel, simultaneously with some fun sorting music,
Dialogue: 0,1:59:47.03,1:59:59.03,英文,,0,0,0,,showing you ultimately what it really means to be an O of n squared, or better yet, big O of n log n. Selection on the top, bubble on the bottom, merge in the middle.
Dialogue: 0,2:00:53.67,2:00:55.70,英文,,0,0,0,,All right, that's it for CS50.
Dialogue: 0,2:00:55.70,2:00:56.64,英文,,0,0,0,,We'll see you next time.
Dialogue: 0,0:01:13.05,0:01:15.43,中文,,0,0,0,,好的，欢迎来到 CS50。
Dialogue: 0,0:01:15.43,0:01:21.40,中文,,0,0,0,,这已经是第三周了，我们将回顾一下第零周的内容，也就是我们最初开始的地方。
Dialogue: 0,0:01:21.40,0:01:24.92,中文,,0,0,0,,回想一下，在第零周，所有内容在某种意义上都是非常直观的。
Dialogue: 0,0:01:24.92,0:01:28.04,中文,,0,0,0,,我们不仅讨论了信息的表示，还讨论了算法。
Dialogue: 0,0:01:28.04,0:01:30.44,中文,,0,0,0,,我们还谈到了如何一遍又一遍地撕电话簿。
Dialogue: 0,0:01:30.44,0:01:32.76,中文,,0,0,0,,这不知何故让我们找到了更好的解决方案。
Dialogue: 0,0:01:32.76,0:01:41.69,中文,,0,0,0,,今天我们将尝试将其中一些想法形式化，并用实际代码来表达其中一些相同的想法，而不仅仅是伪代码。
Dialogue: 0,0:01:41.69,0:01:48.37,中文,,0,0,0,,我们也会考虑这些算法的效率，比如我们的算法实际上有多好，设计得有多好。
Dialogue: 0,0:01:48.37,0:02:01.84,中文,,0,0,0,,回想一下，在我们举电话簿的例子时，\N我首先使用了一种每次搜索一页的算法，然后是每次搜索两页，然后是将电话簿撕成两半，我们只是粗略地分析了一下。
Dialogue: 0,0:02:01.84,0:02:13.43,中文,,0,0,0,,我们假设，如果 x 轴表示问题的规模，比如电话簿中的页数，y 轴表示解决问题所需的时间（以秒、分钟、撕页次数或任何其他度量单位表示），
Dialogue: 0,0:02:13.43,0:02:23.43,中文,,0,0,0,,回想一下，第一个算法是这条直线，这样如果你的电话簿中有 n 页，它的斜率可能是 n。页数和撕页次数之间存在一对一的关系。
Dialogue: 0,0:02:23.43,0:02:31.15,中文,,0,0,0,,当然，每次两页的速度要快一倍，实际上形状还是一样的，这里的黄线表示，是的，它是 n / 2。
Dialogue: 0,0:02:31.15,0:02:33.57,中文,,0,0,0,,如果像我们讨论的那样，你必须来回翻页，可能还要加 1。
Dialogue: 0,0:02:33.57,0:02:38.51,中文,,0,0,0,,从根本上来说，它仍然是相同的算法，一次一页或两页。
Dialogue: 0,0:02:38.51,0:02:45.66,中文,,0,0,0,,回想一下，第三种算法是用绿色表示的，我们称之为对数，用来表示它的速度。
Dialogue: 0,0:02:45.66,0:02:56.67,中文,,0,0,0,,实际上，这种算法的含义是，我们甚至可以将电话簿的大小增加一倍，也没关系，只需再撕一页，我们就可以从电话簿中再删除 1000 页。
Dialogue: 0,0:02:56.67,0:03:01.71,中文,,0,0,0,,我们将回顾其中一些想法，将它们形式化，最终也会将其中一些想法转化为代码。
Dialogue: 0,0:03:01.71,0:03:07.57,中文,,0,0,0,,现在所有这些都是有可能的，因为我们对计算机内部的结构有了更深入的了解。
Dialogue: 0,0:03:07.57,0:03:10.33,中文,,0,0,0,,这就是你电脑的 RAM，或者说内存。
Dialogue: 0,0:03:10.33,0:03:15.41,中文,,0,0,0,,回想一下，如果我们开始将其抽象化，你电脑的内存实际上只是一个字节网格。
Dialogue: 0,0:03:15.41,0:03:17.85,中文,,0,0,0,,事实上，我们不必再去看硬件了。
Dialogue: 0,0:03:17.85,0:03:22.75,中文,,0,0,0,,我们之前看过像这样的字节网格，其中每个字节都可以用来存储
Dialogue: 0,0:03:22.75,0:03:27.52,中文,,0,0,0,,字符、整数、长整数，甚至整个字符串。
Dialogue: 0,0:03:27.52,0:03:30.30,中文,,0,0,0,,我们先关注其中的一部分。
Dialogue: 0,0:03:30.30,0:03:34.82,中文,,0,0,0,,因为上周我们重点学习了数组，如何在数组中存储数据。
Dialogue: 0,0:03:34.82,0:03:44.78,中文,,0,0,0,,这让我们可以开始存储整个字符串、字符序列，甚至整数数组，如果我们想要多个数组，而不仅仅是多个变量的话。
Dialogue: 0,0:03:44.78,0:03:55.89,中文,,0,0,0,,问题是，如果你查看计算机内存中的数组，例如，假设这些整数存储在这里，我们人类很容易就能找到数字 50。
Dialogue: 0,0:03:55.89,0:03:59.70,中文,,0,0,0,,你就像坐在那里，对屏幕上的所有内容都一目了然。
Dialogue: 0,0:03:59.70,0:04:02.62,中文,,0,0,0,,所以找到数字 50 是非常明显的。
Dialogue: 0,0:04:02.62,0:04:06.70,中文,,0,0,0,,在计算机世界中，这些都是硬件。
Dialogue: 0,0:04:06.70,0:04:10.41,中文,,0,0,0,,就今天而言，计算机一次只能做一件事。
Dialogue: 0,0:04:10.41,0:04:14.99,中文,,0,0,0,,它们不能一下子全部接收信息，然后立即找到像 50 这样的数字。
Dialogue: 0,0:04:14.99,0:04:22.60,中文,,0,0,0,,一个比较恰当的比喻是，把计算机内存中的数组想象成一排排关闭的门。
Dialogue: 0,0:04:22.60,0:04:30.63,中文,,0,0,0,,如果计算机想在数组中找到某个值，它必须进行数字化的操作，相当于打开每一扇门。
Dialogue: 0,0:04:30.63,0:04:32.43,中文,,0,0,0,,那么，代码如何做到这一点呢？
Dialogue: 0,0:04:32.43,0:04:39.96,中文,,0,0,0,,当然，我们上周介绍了索引，按照惯例，我们将数组的第一个元素称为位置 0。
Dialogue: 0,0:04:39.96,0:04:45.35,中文,,0,0,0,,第二个位置是 1，第三个位置是 2，以此类推，这就是所谓的零索引。
Dialogue: 0,0:04:45.35,0:04:56.00,中文,,0,0,0,,这让我们可以将内存中正在发生的事情与实际代码联系起来，因为现在我们有了方括号语法，可以通过它来搜索我们想要的东西。
Dialogue: 0,0:04:56.00,0:05:10.29,中文,,0,0,0,,现在我把这些颜色涂成红色而不是黄色，你会发现，如果我们要存储七个这样的数字，那么这个物理比喻就很好地代表了计算机的内存数组。
Dialogue: 0,0:05:10.29,0:05:13.67,中文,,0,0,0,,今天，我们先来看一种特定类型的算法。
Dialogue: 0,0:05:13.67,0:05:14.91,中文,,0,0,0,,那就是搜索算法。
Dialogue: 0,0:05:14.91,0:05:16.21,中文,,0,0,0,,搜索无处不在。
Dialogue: 0,0:05:16.21,0:05:21.23,中文,,0,0,0,,我们所有人可能每天都已经多次访问 google.com 或类似网站。
Dialogue: 0,0:05:21.23,0:05:25.37,中文,,0,0,0,,快速获得答案是 Google 等公司真正擅长的。
Dialogue: 0,0:05:25.37,0:05:26.71,中文,,0,0,0,,那么他们是如何做到的呢？
Dialogue: 0,0:05:26.71,0:05:30.07,中文,,0,0,0,,他们是如何将信息存储在计算机内存中的？
Dialogue: 0,0:05:30.07,0:05:31.59,中文,,0,0,0,,让我们来想想这到底是什么。
Dialogue: 0,0:05:31.59,0:05:34.64,中文,,0,0,0,,就像第 0 周一样，这实际上只是一个问题。
Dialogue: 0,0:05:34.64,0:05:38.54,中文,,0,0,0,,目前，该问题的输入可能是这七个储物柜的数组。
Dialogue: 0,0:05:38.54,0:05:41.04,中文,,0,0,0,,这就是问题的输入，其中包含一个数字。
Dialogue: 0,0:05:41.04,0:05:49.62,中文,,0,0,0,,为了简单起见，我们现在只想要一个“是-否”、一个“真-假”答案，一个布尔值，也就是说，某个数字（比如 50）
Dialogue: 0,0:05:49.62,0:05:51.14,中文,,0,0,0,,是否在该数组中。
Dialogue: 0,0:05:51.14,0:05:52.66,中文,,0,0,0,,它不像 Google 那么花哨。
Dialogue: 0,0:05:52.66,0:05:55.50,中文,,0,0,0,,它不会只告诉你“是的，我们有搜索结果”。
Dialogue: 0,0:05:55.50,0:05:57.30,中文,,0,0,0,,它实际上会给你搜索结果。
Dialogue: 0,0:05:57.30,0:06:06.29,中文,,0,0,0,,我们将保持简单，作为这个问题的一部分，只输出“是”或“否”，“真”或“假”，我们是否找到了我们要找的数字，给定一个像数组这样的输入。
Dialogue: 0,0:06:06.29,0:06:12.39,中文,,0,0,0,,事实证明，在我们不断回到的这个黑匣子里面，有各种各样的算法。
Dialogue: 0,0:06:12.39,0:06:15.91,中文,,0,0,0,,在第 0 周，我们用电话簿从概念上高度概括地讨论了这一点。
Dialogue: 0,0:06:15.91,0:06:22.72,中文,,0,0,0,,今天，让我们通过你们中的一些人可能从小玩过的一个游戏——“大富翁”——来更具体地考虑它。
Dialogue: 0,0:06:22.72,0:06:26.92,中文,,0,0,0,,事实证明，在这些门的后面藏着一些面额的大富翁钱币。
Dialogue: 0,0:06:26.92,0:06:30.70,中文,,0,0,0,,为此，我们现在需要两名志愿者，如果你想问候世界的话。
Dialogue: 0,0:06:30.70,0:06:35.49,中文,,0,0,0,,大家好，我是 Jackson。
Dialogue: 0,0:06:35.49,0:06:37.23,中文,,0,0,0,,嗨，我叫 Stephanie。
Dialogue: 0,0:06:37.23,0:06:40.48,中文,,0,0,0,,你们要不要先自我介绍一下？比如年级、学院、宿舍？
Dialogue: 0,0:06:40.48,0:06:43.42,中文,,0,0,0,,我是一年级新生，住在 Matthews。
Dialogue: 0,0:06:43.42,0:06:43.80,中文,,0,0,0,,不错。
Dialogue: 0,0:06:43.80,0:06:45.64,中文,,0,0,0,,我也是一年级新生，住在 Canada。
Dialogue: 0,0:06:45.64,0:06:48.86,中文,,0,0,0,,好极了！欢迎两位志愿者。
Dialogue: 0,0:06:48.86,0:06:50.68,中文,,0,0,0,,我们来玩个游戏吧！
Dialogue: 0,0:06:50.68,0:06:55.91,中文,,0,0,0,,你们谁先来？
Dialogue: 0,0:06:55.91,0:06:58.31,中文,,0,0,0,,好的，Stephanie 先来。
Dialogue: 0,0:06:58.31,0:07:02.58,中文,,0,0,0,,我们把 50 美元的 Monopoly 钞票藏在这些柜子中的一个后面。
Dialogue: 0,0:07:02.58,0:07:04.34,中文,,0,0,0,,你需要把它找出来。
Dialogue: 0,0:07:04.34,0:07:06.48,中文,,0,0,0,,我们不会告诉你任何关于这些柜子的信息。
Dialogue: 0,0:07:06.48,0:07:08.80,中文,,0,0,0,,你需要按照特定的算法来寻找。
Dialogue: 0,0:07:08.80,0:07:11.14,中文,,0,0,0,,我会给你一些伪代码。
Dialogue: 0,0:07:11.14,0:07:12.30,中文,,0,0,0,,也会告诉你它的名字。
Dialogue: 0,0:07:12.30,0:07:14.10,中文,,0,0,0,,它叫做线性查找。
Dialogue: 0,0:07:14.10,0:07:17.96,中文,,0,0,0,,顾名思义，你最终会沿着一条直线行走。
Dialogue: 0,0:07:17.96,0:07:19.12,中文,,0,0,0,,你要怎么做呢？
Dialogue: 0,0:07:19.12,0:07:25.64,中文,,0,0,0,,我建议你等一下，第一步是像循环一样，从左到右检查每个柜子。
Dialogue: 0,0:07:25.64,0:07:27.31,中文,,0,0,0,,每次迭代中，我们想让你做什么？
Dialogue: 0,0:07:27.31,0:07:36.05,中文,,0,0,0,,如果 50 在那扇门后面，我们希望你继续前进，返回 true，然后自豪地举起 50 给大家看。
Dialogue: 0,0:07:36.05,0:07:43.17,中文,,0,0,0,,否则，如果你遍历了整个循环，也没有找到数字 50，你只能失望地举手。 false。
Dialogue: 0,0:07:43.17,0:07:45.37,中文,,0,0,0,,你没有找到数字 50。
Dialogue: 0,0:07:45.37,0:07:51.40,中文,,0,0,0,,需要明确的是，第一步是从左到右检查每一扇门，你想怎么开始？
Dialogue: 0,0:07:56.81,0:08:00.35,中文,,0,0,0,,然后，是的，就这样，是的。
Dialogue: 0,0:08:00.35,0:08:04.23,中文,,0,0,0,,如果你至少能告诉，很好，演得很好。
Dialogue: 0,0:08:04.23,0:08:06.15,中文,,0,0,0,,你找到了什么？
Dialogue: 0,0:08:06.15,0:08:08.29,中文,,0,0,0,,不是 50，是 20。
Dialogue: 0,0:08:08.29,0:08:08.93,中文,,0,0,0,,哦，好的。
Dialogue: 0,0:08:08.93,0:08:10.27,中文,,0,0,0,,所以第一步失败了。
Dialogue: 0,0:08:10.27,0:08:12.11,中文,,0,0,0,,我们继续第二步。
Dialogue: 0,0:08:12.11,0:08:14.63,中文,,0,0,0,,在这个循环中，你要做什么？
Dialogue: 0,0:08:14.63,0:08:16.43,中文,,0,0,0,,我要移到下一扇门。
Dialogue: 0,0:08:16.43,0:08:20.87,中文,,0,0,0,,好的。
Dialogue: 0,0:08:20.87,0:08:22.03,中文,,0,0,0,,差不多了。
Dialogue: 0,0:08:22.03,0:08:24.27,中文,,0,0,0,,好的，差不多了，有点像。
Dialogue: 0,0:08:24.27,0:08:25.19,中文,,0,0,0,,是 500。
Dialogue: 0,0:08:25.19,0:08:30.49,中文,,0,0,0,,下一个柜子。我宁愿拿。
Dialogue: 0,0:08:30.49,0:08:33.85,中文,,0,0,0,,不是。
Dialogue: 0,0:08:33.85,0:08:34.91,中文,,0,0,0,,我们先不告诉观众。
Dialogue: 0,0:08:34.91,0:08:38.37,中文,,0,0,0,,是 10。
Dialogue: 0,0:08:38.37,0:08:39.77,中文,,0,0,0,,好的，继续。
Dialogue: 0,0:08:39.77,0:08:45.61,中文,,0,0,0,,现在是第三步。
Dialogue: 0,0:08:45.61,0:08:49.92,中文,,0,0,0,,天啊。
Dialogue: 0,0:08:49.92,0:08:50.80,中文,,0,0,0,,5，好的。
Dialogue: 0,0:08:50.80,0:08:52.58,中文,,0,0,0,,还剩几个柜子要检查。
Dialogue: 0,0:08:57.77,0:09:03.16,中文,,0,0,0,,有点惨，伙计们。
Dialogue: 0,0:09:03.16,0:09:07.68,中文,,0,0,0,,倒数第二步了。
Dialogue: 0,0:09:07.68,0:09:10.12,中文,,0,0,0,,这回，有点接近了。
Dialogue: 0,0:09:10.12,0:09:11.26,中文,,0,0,0,,好的。
Dialogue: 0,0:09:11.26,0:09:12.76,中文,,0,0,0,,最后一步。
Dialogue: 0,0:09:12.76,0:09:15.92,中文,,0,0,0,,很明显，你可能被套路了。
Dialogue: 0,0:09:15.92,0:09:17.23,中文,,0,0,0,,开始吧。
Dialogue: 0,0:09:17.23,0:09:23.59,中文,,0,0,0,,好的，数字 50。Stephanie，我可以问你个问题吗？
Dialogue: 0,0:09:23.59,0:09:29.13,中文,,0,0,0,,屏幕上显示的是你刚刚执行的伪代码。
Dialogue: 0,0:09:29.13,0:09:34.78,中文,,0,0,0,,假设，当你有一个 if 条件时，你做了我们很多人养成的习惯。
Dialogue: 0,0:09:34.78,0:09:36.80,中文,,0,0,0,,你通常也会有一个 else 分支。
Dialogue: 0,0:09:36.80,0:09:38.74,中文,,0,0,0,,假设你现在这样做了。
Dialogue: 0,0:09:38.74,0:09:41.78,中文,,0,0,0,,为了表示清楚，我把它标记成红色，这表示它是错的。
Dialogue: 0,0:09:41.78,0:09:47.29,中文,,0,0,0,,你可能会说，这段代码使用 if 和 else 有什么不好呢？
Dialogue: 0,0:09:47.29,0:09:47.91,中文,,0,0,0,,有什么想法吗？
Dialogue: 0,0:09:55.69,0:09:59.77,中文,,0,0,0,,你会在找到 50 之前就终止代码了。
Dialogue: 0,0:09:59.77,0:10:00.39,中文,,0,0,0,,没错。
Dialogue: 0,0:10:00.39,0:10:02.15,中文,,0,0,0,,那可就太可惜了。
Dialogue: 0,0:10:02.15,0:10:05.53,中文,,0,0,0,,没错，Stephanie 打开第一个储物柜时，她发现了 20。
Dialogue: 0,0:10:05.53,0:10:08.03,中文,,0,0,0,,20 当然不是 50，她会判定为 false。
Dialogue: 0,0:10:08.03,0:10:10.30,中文,,0,0,0,,很明显，她还没有检查完剩下的所有储物柜。
Dialogue: 0,0:10:10.30,0:10:18.76,中文,,0,0,0,,因此，这似乎是一个关键细节，在我们实现这段伪代码时，我们实际上会像之前做的那样遍历，并且只返回 false，
Dialogue: 0,0:10:18.76,0:10:25.76,中文,,0,0,0,,甚至没有使用 else 语句，而是在循环结束后才返回，这样我们只有在之前没有返回 true 的情况下才会到达那一行。
Dialogue: 0,0:10:25.76,0:10:28.84,中文,,0,0,0,,让我们继续。如果你愿意坐在 Jackson 旁边，我可以把麦克风给你。
Dialogue: 0,0:10:28.84,0:10:30.48,中文,,0,0,0,,Jackson，稍后我们会请你上来。
Dialogue: 0,0:10:30.48,0:10:34.29,中文,,0,0,0,,Carter，如果你不介意的话，请帮我们重新整理一下储物柜。
Dialogue: 0,0:10:34.29,0:10:38.03,中文,,0,0,0,,与此同时，让我来指出我们现在如何将相同的思想转换成代码。
Dialogue: 0,0:10:38.03,0:10:41.09,中文,,0,0,0,,这段伪代码的级别很高，很接近英语的表达方式。
Dialogue: 0,0:10:41.09,0:10:43.64,中文,,0,0,0,,实际上，从上周开始，我们就有了语法
Dialogue: 0,0:10:43.64,0:10:51.32,中文,,0,0,0,,通过这种语法，Stephanie 和 Jackson 很快就能使用方括号符号将这个储物柜，这组储物柜，真正地视为一个数组。
Dialogue: 0,0:10:51.32,0:10:54.62,中文,,0,0,0,,所以我们现在可以在伪代码中更接近实际的代码了。
Dialogue: 0,0:10:54.62,0:11:06.60,中文,,0,0,0,,例如，计算机科学家会将这种类似英语的高级伪代码转换成更接近 C 语言或任何支持数组的语言的代码，就会像这样更加简洁一些。
Dialogue: 0,0:11:06.60,0:11:09.26,中文,,0,0,0,,在接下来的几天里，你会看到更多这样的语法。
Dialogue: 0,0:11:09.26,0:11:12.10,中文,,0,0,0,,对于 i 从 0 到 n-1。
Dialogue: 0,0:11:12.10,0:11:17.95,中文,,0,0,0,,这仍然是伪代码，它就像用类似英语的方式来表达我们所知的 for 循环。
Dialogue: 0,0:11:17.95,0:11:26.67,中文,,0,0,0,,如果 50 在 doors[i] 后面，为了讨论方便，我假设 doors 现在是我的变量名，这个包含七个门的数组。
Dialogue: 0,0:11:26.67,0:11:30.35,中文,,0,0,0,,剩下的逻辑，剩下的伪代码，实际上是相同的方式。
Dialogue: 0,0:11:30.35,0:11:40.81,中文,,0,0,0,,随着时间的推移，你会发现程序员，更普遍地说，是计算机科学家，当你开始向别人表达想法、算法时，你不会再像这样操作，
Dialogue: 0,0:11:40.81,0:11:51.81,中文,,0,0,0,,而是在你的词汇表中真正有了一种新的语法，你可以更具体一些，\N不用再纠结于编写实际的 C 代码，至少现在可以做一些更接近于操作像这样的数组的事情了。
Dialogue: 0,0:11:51.81,0:11:55.17,中文,,0,0,0,,Jackson，你想站起来吗？
Dialogue: 0,0:11:55.17,0:11:56.75,中文,,0,0,0,,好的。
Dialogue: 0,0:11:56.75,0:11:58.75,中文,,0,0,0,,是的，是的，也支持 Jackson。
Dialogue: 0,0:11:58.75,0:12:00.91,中文,,0,0,0,,好样的。
Dialogue: 0,0:12:00.91,0:12:04.47,中文,,0,0,0,,现在，我将允许你做一个 Stephanie 没有的假设。
Dialogue: 0,0:12:04.47,0:12:10.23,中文,,0,0,0,,Stephanie 显然在尽力而为，从左到右搜索，使用我们现在称之为线性搜索的方法。
Dialogue: 0,0:12:10.23,0:12:12.13,中文,,0,0,0,,它们几乎是随机排列的，对吧？
Dialogue: 0,0:12:12.13,0:12:15.13,中文,,0,0,0,,那边有一个 20，那边有一个 1，然后是一个 50。
Dialogue: 0,0:12:15.13,0:12:19.27,中文,,0,0,0,,所以我们故意把事情搞乱，没有为她排序。
Dialogue: 0,0:12:19.27,0:12:24.70,中文,,0,0,0,,Carter 很好心地走上来帮助 Jackson，提前把数字排好序。
Dialogue: 0,0:12:24.70,0:12:32.24,中文,,0,0,0,,我们希望你这次像第 0 周一样，再次做一些事情，但这次使用我们现在称之为二分搜索的方法。
Dialogue: 0,0:12:32.24,0:12:40.35,中文,,0,0,0,,它在概念上与我们在第 0 周所做的算法完全相同，如果我们把它放到这个数组的上下文中，我们现在可能会这样说。
Dialogue: 0,0:12:40.35,0:12:43.23,中文,,0,0,0,,Jackson 的第一步可能是问这个问题：
Dialogue: 0,0:12:43.23,0:12:50.60,中文,,0,0,0,,如果 50 在中间的门后面，假设他已经做了一些心算，算出了中间的位置，那么他就会返回 true。
Dialogue: 0,0:12:50.60,0:12:53.20,中文,,0,0,0,,希望我们足够幸运，50 就在那扇门的后面。
Dialogue: 0,0:12:53.20,0:12:58.65,中文,,0,0,0,,当然，至少还有两种其他可能性，是什么？
Dialogue: 0,0:12:58.65,0:13:01.42,中文,,0,0,0,,50 在这些门的位置。
Dialogue: 0,0:13:01.42,0:13:03.93,中文,,0,0,0,,对，在左边或者右边。
Dialogue: 0,0:13:03.93,0:13:09.29,中文,,0,0,0,,所以如果 50 比中间这扇门小，Jackson 应该会选择往左走。
Dialogue: 0,0:13:09.29,0:13:18.05,中文,,0,0,0,,否则，如果 50 比中间这扇门大，他会选择往右走，就像我上周用电话簿演示的那样，左右分治。
Dialogue: 0,0:13:18.05,0:13:19.94,中文,,0,0,0,,实际上还有第四种情况。
Dialogue: 0,0:13:19.94,0:13:21.76,中文,,0,0,0,,我们先把它写在黑板上。
Dialogue: 0,0:13:21.76,0:13:27.83,中文,,0,0,0,,Jackson 还应该考虑什么情况？
Dialogue: 0,0:13:27.83,0:13:28.49,中文,,0,0,0,,它不在里面。
Dialogue: 0,0:13:28.49,0:13:42.39,中文,,0,0,0,,让我回去修改一下我的伪代码，跟 Jackson 说，\N如果我们没有给你任何门，或者最终，当他进行分治时，如果没有门剩下，我们必须处理这种情况，以便定义行为。
Dialogue: 0,0:13:42.39,0:13:43.03,中文,,0,0,0,,好的。
Dialogue: 0,0:13:43.03,0:13:48.69,中文,,0,0,0,,那么，Jackson，你愿意继续下去，帮我们找到数字 50，并口头描述一下你在做什么以及如何找到的吗？
Dialogue: 0,0:13:48.69,0:13:49.20,中文,,0,0,0,,好的。
Dialogue: 0,0:13:49.20,0:13:52.76,中文,,0,0,0,,看起来这扇是中间的门。
Dialogue: 0,0:13:52.76,0:13:55.28,中文,,0,0,0,,我要打开它。
Dialogue: 0,0:13:55.28,0:13:58.16,中文,,0,0,0,,但它是 20，不是 50。
Dialogue: 0,0:13:58.16,0:13:59.28,中文,,0,0,0,,太可惜了。
Dialogue: 0,0:13:59.28,0:13:59.78,中文,,0,0,0,,好的。
Dialogue: 0,0:13:59.78,0:14:01.08,中文,,0,0,0,,你现在在想什么？
Dialogue: 0,0:14:01.08,0:14:06.44,中文,,0,0,0,,因为 50 比 20 大，我要看右边。
Dialogue: 0,0:14:06.44,0:14:07.54,中文,,0,0,0,,好的。
Dialogue: 0,0:14:07.54,0:14:10.28,中文,,0,0,0,,找新的中间门，就在这里。
Dialogue: 0,0:14:10.28,0:14:12.16,中文,,0,0,0,,很好，是 100。
Dialogue: 0,0:14:12.16,0:14:14.28,中文,,0,0,0,,太可惜了。
Dialogue: 0,0:14:14.28,0:14:16.56,中文,,0,0,0,, 50 比 100 小。
Dialogue: 0,0:14:16.56,0:14:20.55,中文,,0,0,0,,所以我们要看左边，就在这里。
Dialogue: 0,0:14:20.55,0:14:21.43,中文,,0,0,0,,就是这样。
Dialogue: 0,0:14:21.43,0:14:21.99,中文,,0,0,0,,很好。
Dialogue: 0,0:14:21.99,0:14:25.82,中文,,0,0,0,,这次做得很好。
Dialogue: 0,0:14:25.82,0:14:29.57,中文,,0,0,0,,首先感谢我们的志愿者。
Dialogue: 0,0:14:29.57,0:14:37.37,中文,,0,0,0,,既然你是大富翁的粉丝，我们为你准备了剑桥版的大富翁，里面有你所有喜欢的哈佛元素。
Dialogue: 0,0:14:37.37,0:14:37.98,中文,,0,0,0,,给你。
Dialogue: 0,0:14:37.98,0:14:38.94,中文,,0,0,0,,非常感谢。
Dialogue: 0,0:14:38.94,0:14:40.94,中文,,0,0,0,,感谢我们的志愿者帮我们找到了 50。
Dialogue: 0,0:14:40.94,0:14:46.87,中文,,0,0,0,, 这比我们预想的更受欢迎。
Dialogue: 0,0:14:46.87,0:14:52.15,中文,,0,0,0,,我们可以把这个再翻译成更接近代码的东西。
Dialogue: 0,0:14:52.15,0:15:01.77,中文,,0,0,0,,仍然是伪代码，但这可能是 Jackson 刚才所做的事情的另一种表述，只是现在使用数组的命名法，这样你的指令可以更精确一些。
Dialogue: 0,0:15:01.77,0:15:04.55,中文,,0,0,0,,仍然把它留给其他人最终翻译成代码。
Dialogue: 0,0:15:04.55,0:15:06.47,中文,,0,0,0,,不过我们一开始还是有相同的问题。
Dialogue: 0,0:15:06.47,0:15:08.83,中文,,0,0,0,,如果没有门了，返回 false。
Dialogue: 0,0:15:08.83,0:15:11.64,中文,,0,0,0,,如果 50 在 doors[middle] 后面。
Dialogue: 0,0:15:11.64,0:15:19.66,中文,,0,0,0,,我假设，因为这是伪代码，在某个地方我已经通过心算或实际计算算出了 middle 的索引。
Dialogue: 0,0:15:19.66,0:15:27.53,中文,,0,0,0,,例如，如果数组中有七扇门，这将是位置 0、1、2、3、4、5、6。
Dialogue: 0,0:15:27.53,0:15:33.51,中文,,0,0,0,,我已经取了门的总数 7，除以 2 来找到中间值。
Dialogue: 0,0:15:33.51,0:15:35.69,中文,,0,0,0,,结果是 3.5，我们必须处理舍入问题。
Dialogue: 0,0:15:35.69,0:15:43.30,中文,,0,0,0,,可以肯定的是，有一个定义明确的公式可以根据储物柜的总数找到中间索引，除以 2，然后进行相应的舍入。
Dialogue: 0,0:15:43.30,0:15:48.84,中文,,0,0,0,,所以这大概就是 Jackson 通过心算找到 3 号门的方法。
Dialogue: 0,0:15:48.84,0:15:52.38,中文,,0,0,0,,不是第三扇门，是第四扇门，而是 doors[3]。
Dialogue: 0,0:15:52.38,0:15:56.19,中文,,0,0,0,,所以这只是说，如果 50 在 doors[middle] 后面，返回 true。
Dialogue: 0,0:15:56.19,0:15:57.07,中文,,0,0,0,,事实并非如此。
Dialogue: 0,0:15:57.07,0:15:59.09,中文,,0,0,0,,他找到了一张 20 美元的钞票。
Dialogue: 0,0:15:59.09,0:16:03.67,中文,,0,0,0,,否则，如果 50 小于 doors[middle]，继续。
Dialogue: 0,0:16:03.67,0:16:05.39,中文,,0,0,0,,现在开始有趣了。
Dialogue: 0,0:16:05.39,0:16:10.86,中文,,0,0,0,,搜索 doors[0] 到 doors[middle - 1]。
Dialogue: 0,0:16:10.86,0:16:12.76,中文,,0,0,0,,现在越来越深入细节了。
Dialogue: 0,0:16:12.76,0:16:15.38,中文,,0,0,0,,但如果 middle 是 3，这个。
Dialogue: 0,0:16:15.38,0:16:24.41,中文,,0,0,0,,这里，我们现在希望 Jackson 搜索，如果数字更小，我们希望从 doors[0] 开始，一直到这个。
Dialogue: 0,0:16:24.41,0:16:27.99,中文,,0,0,0,,我们故意减去 1，因为再看同一个储物柜有什么意义？
Dialogue: 0,0:16:27.99,0:16:31.43,中文,,0,0,0,,我们也可以从 0 到中间值减 1。
Dialogue: 0,0:16:31.43,0:16:37.30,中文,,0,0,0,,否则，如果 50 大于 doors[middle]，就像现在这样，我们该怎么做？
Dialogue: 0,0:16:37.30,0:16:43.38,中文,,0,0,0,,Jackson 直觉地从 doors[middle + 1] 搜索到 doors[n - 1]。
Dialogue: 0,0:16:43.38,0:16:46.40,中文,,0,0,0,,说实话，这里有加号和减号有点烦人。
Dialogue: 0,0:16:46.40,0:16:47.82,中文,,0,0,0,,但是想想它的意思。
Dialogue: 0,0:16:47.82,0:16:49.31,中文,,0,0,0,,这是中间的门。
Dialogue: 0,0:16:49.31,0:16:56.27,中文,,0,0,0,,然后 Jackson 继续从 doors[middle + 1] 开始搜索，因为没有必要再次搜索这个。
Dialogue: 0,0:16:56.27,0:17:05.53,中文,,0,0,0,,任何大小为 n 的数组的最后一个元素，其中 n 只是我们用来表示大小的常用数字，始终是 n - 1。
Dialogue: 0,0:17:05.53,0:17:11.01,中文,,0,0,0,,它不会是 n，它将是 n - 1，因为我们总是从 0 开始计数。
Dialogue: 0,0:17:11.01,0:17:16.32,中文,,0,0,0,,所以在这里，我们有一个更接近 C 语言的伪代码翻译，表达了完全相同的思想。
Dialogue: 0,0:17:16.32,0:17:18.30,中文,,0,0,0,,在这里，我们回到了第 0 周的起点。
Dialogue: 0,0:17:18.30,0:17:23.46,中文,,0,0,0,,就像在第 0 周，想象一下分而治之解决这样的问题是很直观的。
Dialogue: 0,0:17:23.46,0:17:34.90,中文,,0,0,0,,但是，如果你现在回想一下你的 iPhone、Android 手机等，\N当你进行自动完成和搜索列表时，如果你手机里没有很多朋友、家人或同事，你知道吗？
Dialogue: 0,0:17:34.90,0:17:40.87,中文,,0,0,0,,线性搜索，只检查每个名字是否是你正在搜索的人，可能就足够了。
Dialogue: 0,0:17:40.87,0:17:47.93,中文,,0,0,0,,但很有可能，你的手机比这更智能，尤其是当你的联系人多年来积累了几十个、几百个、几千个人的时候。
Dialogue: 0,0:17:47.93,0:17:49.67,中文,,0,0,0,,有什么比线性搜索更好的方法吗？
Dialogue: 0,0:17:49.67,0:17:51.37,中文,,0,0,0,,也许是二分搜索。
Dialogue: 0,0:17:51.37,0:17:55.37,中文,,0,0,0,,但是，有一个假设，一个要求，是什么？
Dialogue: 0,0:17:55.37,0:18:04.96,中文,,0,0,0,,为什么 Jackson 最终能够像 Stephanie 一样只用三个步骤就找到 50，而不是完整的七个步骤？
Dialogue: 0,0:18:04.96,0:18:06.56,中文,,0,0,0,,因为数组是排序的。
Dialogue: 0,0:18:06.56,0:18:09.98,中文,,0,0,0,,这算是我们今天晚些时候要讲的内容的一个预告。
Dialogue: 0,0:18:09.98,0:18:12.80,中文,,0,0,0,,像 Carter 这样的人要花多少力气？
Dialogue: 0,0:18:12.80,0:18:17.18,中文,,0,0,0,,你的手机要花多少力气才能提前把所有姓名和号码排序？
Dialogue: 0,0:18:17.18,0:18:19.64,中文,,0,0,0,,因为这可能不值得花费那么多时间。
Dialogue: 0,0:18:19.64,0:18:24.32,中文,,0,0,0,,像 Google 这样公司可能会以某种方式保持网页数据库的排序。
Dialogue: 0,0:18:24.32,0:18:35.61,中文,,0,0,0,,你可以想象，如果你在 google.com 上输入“猫”或其他内容时，\N如果他们在整个数据集中线性搜索，那速度会非常慢，理想情况下，他们会采用更智能的方法。
Dialogue: 0,0:18:35.61,0:18:38.83,中文,,0,0,0,,所以我们现在要将这种分析形式化。
Dialogue: 0,0:18:38.83,0:18:42.34,中文,,0,0,0,,它不会那么多数学化，仍然会很直观。
Dialogue: 0,0:18:42.34,0:18:50.58,中文,,0,0,0,,我们会向你介绍一些术语，一些大多数程序员或计算机科学家在分析他们自己的算法时可能会使用的术语。
Dialogue: 0,0:18:50.58,0:18:53.65,中文,,0,0,0,,现在让我们来形式化这种分析是什么。
Dialogue: 0,0:18:53.65,0:18:56.91,中文,,0,0,0,,现在，我认为二分查找比线性查找好。
Dialogue: 0,0:18:56.91,0:18:59.07,中文,,0,0,0,,但究竟好多少，为什么？
Dialogue: 0,0:18:59.07,0:19:01.03,中文,,0,0,0,,这一切都要回到这张图上来。
Dialogue: 0,0:19:01.03,0:19:05.10,中文,,0,0,0,,回想一下，这就是我们在第 0 周分析电话簿的方式。
Dialogue: 0,0:19:05.10,0:19:07.94,中文,,0,0,0,,回想一下，我们确实有这些公式。
Dialogue: 0,0:19:07.94,0:19:11.42,中文,,0,0,0,,描述这三种算法运行时间的粗略公式。
Dialogue: 0,0:19:11.42,0:19:15.91,中文,,0,0,0,,一次一页，一次两页，然后一次又一次地将它撕成两半。
Dialogue: 0,0:19:15.91,0:19:26.73,中文,,0,0,0,,准确地说，如果算上我翻过的页数或撕过的页数，可以公平地说，第一种算法在最坏的情况下可能要翻 n 页。
Dialogue: 0,0:19:26.73,0:19:31.40,中文,,0,0,0,,它没有，因为我当时在找 John Harvard，他的姓氏在字母表中比较靠前。
Dialogue: 0,0:19:31.40,0:19:38.60,中文,,0,0,0,,如果我要找一个姓氏以 Z 开头的人，我将不得不一直找下去，在最坏的情况下，要翻遍所有 n 页。
Dialogue: 0,0:19:38.60,0:19:41.92,中文,,0,0,0,,第二个算法没那么糟，这就是我们使用 n 除以 2 的原因。
Dialogue: 0,0:19:41.92,0:19:43.74,中文,,0,0,0,,即便如此，这也有点不准确。
Dialogue: 0,0:19:43.74,0:19:48.28,中文,,0,0,0,,对，如果我必须回头找，可能是 n 除以 2 再加 1。
Dialogue: 0,0:19:48.28,0:19:52.05,中文,,0,0,0,,但是，我这样做是为了更概括地抓住这些东西的本质。
Dialogue: 0,0:19:52.05,0:19:56.93,中文,,0,0,0,,然后我们深入探讨了第三个也是最后一个算法的以 2 为底 n 的对数 log₂n。
Dialogue: 0,0:19:56.93,0:20:04.17,中文,,0,0,0,,当时，我们声称，任何时候你将一个东西一分为二、一分为二、一分为二地进行下去，很可能就会涉及某种对数。
Dialogue: 0,0:20:04.17,0:20:05.51,中文,,0,0,0,,我们今天就会看到这一点。
Dialogue: 0,0:20:05.51,0:20:13.60,中文,,0,0,0,,今天，我们将实际开始使用计算机科学术语。我们将把这种不精确性形式化，如果你愿意这样理解的话。
Dialogue: 0,0:20:13.60,0:20:24.60,中文,,0,0,0,,我们不会关心某个算法需要多少步，因为这并不能说明什么，特别是如果你的计算机明天比今天更快。
Dialogue: 0,0:20:24.60,0:20:27.61,中文,,0,0,0,,过于精确地比较数字是不公平的。
Dialogue: 0,0:20:27.61,0:20:33.93,中文,,0,0,0,,我们真正想要的是，大致了解一个算法的快慢。
Dialogue: 0,0:20:33.93,0:20:36.01,中文,,0,0,0,,所以这里的记号是经过仔细考虑的。
Dialogue: 0,0:20:36.01,0:20:53.51,中文,,0,0,0,,它实际上是一个大写的 O，通常是斜体，被称为大 O 记号。\N所以第一个算法是 O(n)，第二个算法是 O(n/2)，第三个算法是 O(log₂n)。即使是这样，你懂的，
Dialogue: 0,0:20:53.51,0:21:01.27,中文,,0,0,0,,细节太多了。当使用大 O 记号时，你真的不关心，我们会看到，较小的阶数项，对吧？
Dialogue: 0,0:21:01.27,0:21:03.73,中文,,0,0,0,,我们不会关心除以 2。
Dialogue: 0,0:21:03.73,0:21:04.57,中文,,0,0,0,,因为你知道吗？
Dialogue: 0,0:21:04.57,0:21:07.90,中文,,0,0,0,,这些算法的形状几乎是一样的。
Dialogue: 0,0:21:07.90,0:21:11.12,中文,,0,0,0,,事实上，这个想法，算法本身在根本上是一样的。
Dialogue: 0,0:21:11.12,0:21:13.76,中文,,0,0,0,,我不是一次看一页，而是一次看两页。
Dialogue: 0,0:21:13.76,0:21:22.17,中文,,0,0,0,,但是，如果你扔给我数百万页、数十亿页，当 n 变得非常大、趋于无穷大时，这些算法的性能实际上是一样的。
Dialogue: 0,0:21:22.17,0:21:23.55,中文,,0,0,0,,对数也是如此。
Dialogue: 0,0:21:23.55,0:21:33.04,中文,,0,0,0,,即使你对数学有点生疏，实际上，无论你使用的是以 2、3 还是 10 为底的对数，你都可以将它们相乘，得到相同的公式。
Dialogue: 0,0:21:33.04,0:21:39.39,中文,,0,0,0,,也就是说，计算机科学家通常会说前两种算法的时间复杂度是 n 阶的。
Dialogue: 0,0:21:39.39,0:21:42.69,中文,,0,0,0,,第三种算法的时间复杂度是对数 n 阶的。
Dialogue: 0,0:21:42.69,0:21:46.39,中文,,0,0,0,,除此之外，我们并不关心具体的含义。
Dialogue: 0,0:21:46.39,0:21:49.78,中文,,0,0,0,,这就是大 O 表示法的含义，实际上，让我把它缩小一点。
Dialogue: 0,0:21:49.78,0:21:55.96,中文,,0,0,0,,想象一下，突然之间 x 轴变得更长了，屏幕上同时显示更多页的内容。
Dialogue: 0,0:21:55.96,0:21:58.84,中文,,0,0,0,,真正重要的是这些曲线的形状。
Dialogue: 0,0:21:58.84,0:22:11.54,中文,,0,0,0,,因为想象一下，当你不断缩小、缩小、再缩小时，当 x 轴上的 n 变得越来越大时，一旦 n 足够大，红色和黄色的线本质上看起来就会一样。
Dialogue: 0,0:22:11.54,0:22:14.56,中文,,0,0,0,,但绿线永远不会看起来一样。
Dialogue: 0,0:22:14.56,0:22:16.34,中文,,0,0,0,,它将是一个根本不同的形状。
Dialogue: 0,0:22:16.34,0:22:23.29,中文,,0,0,0,,这就是大 O 表示法的直观含义，用来理解像这样的性能速率。
Dialogue: 0,0:22:23.29,0:22:32.47,中文,,0,0,0,,所以这就是大 O 表示法。这里列出了一些常见的公式，计算机科学家在分析算法时可能会用到，尤其是在入门阶段。
Dialogue: 0,0:22:32.47,0:22:38.95,中文,,0,0,0,,我们来考虑一下，我们的前两种算法，线性查找和二分查找，属于哪一类。
Dialogue: 0,0:22:38.95,0:22:42.55,中文,,0,0,0,,我把它们按照从慢到快的顺序排列。
Dialogue: 0,0:22:42.55,0:22:48.41,中文,,0,0,0,,n² 阶，我们目前还没有见过，但它往往很慢，因为它是一个二次函数。
Dialogue: 0,0:22:48.41,0:22:51.27,中文,,0,0,0,,你要做 n 乘以 n 次运算。加起来就是很多步。
Dialogue: 0,0:22:51.27,0:23:08.38,中文,,0,0,0,,今天，n log n 会更好一些。n 会更好。log n 会更好。最好的是所谓的 O(1)，\N比如一步，或者两步，甚至 1000 步，但无论 n 有多大，步骤的数量都是固定的、有限的，不会改变。
Dialogue: 0,0:23:08.38,0:23:13.62,中文,,0,0,0,,所以根据这张表， 线性查找，我们来考虑最坏的情况。
Dialogue: 0,0:23:13.62,0:23:23.67,中文,,0,0,0,,在最坏的情况下，假设不是 7 扇门而是 n 扇门，Stephanie 需要多少步才能找到问题的答案？
Dialogue: 0,0:23:23.67,0:23:25.32,中文,,0,0,0,,嗯？
Dialogue: 0,0:23:25.32,0:23:29.24,中文,,0,0,0,,数量级是 n。在这种情况下，正好是 n。但是，你知道吗？
Dialogue: 0,0:23:29.24,0:23:31.40,中文,,0,0,0,,也许可以说是 2n，对吧？
Dialogue: 0,0:23:31.40,0:23:33.38,中文,,0,0,0,,因为 Stephanie 需要好几步。
Dialogue: 0,0:23:33.38,0:23:34.46,中文,,0,0,0,,比如，她得打开门闩。
Dialogue: 0,0:23:34.46,0:23:35.43,中文,,0,0,0,,她得打开门。
Dialogue: 0,0:23:35.43,0:23:36.25,中文,,0,0,0,,也许是三步。
Dialogue: 0,0:23:36.25,0:23:37.45,中文,,0,0,0,,她得展示现金。
Dialogue: 0,0:23:37.45,0:23:39.35,中文,,0,0,0,,所以现在是 3n，2n。
Dialogue: 0,0:23:39.35,0:23:42.13,中文,,0,0,0,,但是，我们并不真的关心这种程度的精确度。
Dialogue: 0,0:23:42.13,0:23:45.57,中文,,0,0,0,,我们只关心基本的操作次数。
Dialogue: 0,0:23:45.57,0:23:51.31,中文,,0,0,0,,所以我们会说，数量级是 n。这可能是线性搜索的上限。
Dialogue: 0,0:23:51.31,0:23:53.23,中文,,0,0,0,,那二分搜索呢？
Dialogue: 0,0:23:53.23,0:24:03.05,中文,,0,0,0,,在 Jackson 的情况下，或者说一般情况下，我在第 0 周，如果有 n 扇门，Jackson 或我使用二分搜索需要多少步？
Dialogue: 0,0:24:03.05,0:24:07.38,中文,,0,0,0,,在这种情况下，实际上是 3 步，但这并不是一个公式。
Dialogue: 0,0:24:07.38,0:24:14.22,中文,,0,0,0,,对，数量级是 log n。事实上，如果有 7 扇门，稍微取整一下就是 8 扇门。
Dialogue: 0,0:24:14.22,0:24:18.63,中文,,0,0,0,,事实上，如果你取 8 的以 2 为底的对数，log₂8，确实等于 3。
Dialogue: 0,0:24:18.63,0:24:19.79,中文,,0,0,0,,所以计算结果是正确的。
Dialogue: 0,0:24:19.79,0:24:21.59,中文,,0,0,0,,如果你对对数不熟悉，没关系。
Dialogue: 0,0:24:21.59,0:24:23.71,中文,,0,0,0,,直观地思考一下。
Dialogue: 0,0:24:23.71,0:24:27.03,中文,,0,0,0,,以 2 为底的对数就是不断地将某个数除以 2。
Dialogue: 0,0:24:27.03,0:24:40.18,中文,,0,0,0,,在这个图表中，当我们考虑大 O 表示法时，需要明确的是，它可以描述算法运行时间的阶，比如它的大小，但它更具体地描述了一个上限。
Dialogue: 0,0:24:40.18,0:24:45.63,中文,,0,0,0,,所以在最坏的情况下，这些都是衡量算法好坏的很好的指标。
Dialogue: 0,0:24:45.63,0:24:49.75,中文,,0,0,0,,或者说，线性查找和二分查找可能有多糟糕？为什么？
Dialogue: 0,0:24:49.75,0:24:56.35,中文,,0,0,0,,假设你在查找一本 1000 页的电话簿，而这个人的名字以 Z 开头。这个算法仍然需要 n 步。
Dialogue: 0,0:24:56.35,0:24:56.87,中文,,0,0,0,,为什么？
Dialogue: 0,0:24:56.87,0:25:01.25,中文,,0,0,0,,因为它可能需要 n 步才能找到。
Dialogue: 0,0:25:01.25,0:25:05.27,中文,,0,0,0,,当然，在实际情况中不一定是这样。
Dialogue: 0,0:25:05.27,0:25:16.28,中文,,0,0,0,,如果我使用大 O 表示法作为上限，那么最好有一个对应的下限，尤其是在你不仅要考虑最坏情况，还要考虑最佳情况的时候。
Dialogue: 0,0:25:16.28,0:25:17.88,中文,,0,0,0,,那么我们在这里可以使用什么呢？
Dialogue: 0,0:25:17.88,0:25:20.10,中文,,0,0,0,,这是一个大写希腊字母 Ω。
Dialogue: 0,0:25:20.10,0:25:28.88,中文,,0,0,0,,Ω 是计算机科学家通常用来描述算法下限的符号，通常是在最佳情况下，但也不一定。
Dialogue: 0,0:25:28.88,0:25:32.62,中文,,0,0,0,,所以下限是指算法可能采取的最少步数。
Dialogue: 0,0:25:32.62,0:25:33.98,中文,,0,0,0,,这里也是一样的公式。
Dialogue: 0,0:25:33.98,0:25:36.44,中文,,0,0,0,,我们会逐渐填补这些空白。
Dialogue: 0,0:25:36.44,0:25:41.54,中文,,0,0,0,,有些算法可能总是需要至少 n² 步，或者说 n 的数量级。
Dialogue: 0,0:25:41.54,0:25:45.98,中文,,0,0,0,,有些可能只需要 n log n 步，或者 n 步，或者 log n 步，或者 1 步。
Dialogue: 0,0:25:45.98,0:25:49.33,中文,,0,0,0,,比如线性查找。
Dialogue: 0,0:25:49.33,0:25:52.97,中文,,0,0,0,,Stephanie 使用线性查找时，这次在台上并不幸运。
Dialogue: 0,0:25:52.97,0:25:57.92,中文,,0,0,0,,如果她确实找到了，并且她打开的第一扇门就是 50 号呢？
Dialogue: 0,0:25:57.92,0:26:09.65,中文,,0,0,0,,在这种情况下，如何用这些可能的答案来描述线性查找在所谓最佳情况下的下界？
Dialogue: 0,0:26:09.65,0:26:11.11,中文,,0,0,0,,对，Ω(1)。
Dialogue: 0,0:26:11.11,0:26:19.48,中文,,0,0,0,,所以在最佳情况下，线性查找找到某个东西可能需要的步数的下界可能只是一步。为什么？
Dialogue: 0,0:26:19.48,0:26:28.60,中文,,0,0,0,,因为也许 Stephanie 很幸运，我们事先用其他顺序在这些储物柜里放好了号码，这样她可能打开第一个储物柜就找到了。
Dialogue: 0,0:26:28.60,0:26:29.98,中文,,0,0,0,,50 号可能就在那里。
Dialogue: 0,0:26:29.98,0:26:34.74,中文,,0,0,0,,因此，线性查找的下界可以说是 Ω(1)。
Dialogue: 0,0:26:34.74,0:26:35.96,中文,,0,0,0,,那 Jackson 呢？
Dialogue: 0,0:26:35.96,0:26:37.49,中文,,0,0,0,,他使用的是二分查找。
Dialogue: 0,0:26:37.49,0:26:41.13,中文,,0,0,0,,所以他直接从问题的中间开始入手。
Dialogue: 0,0:26:41.13,0:26:45.03,中文,,0,0,0,,但是，按照这个逻辑，二分查找的下界是什么？
Dialogue: 0,0:26:45.03,0:26:46.14,中文,,0,0,0,,嗯？
Dialogue: 0,0:26:46.14,0:26:47.64,中文,,0,0,0,,对，还是 Ω(1)。
Dialogue: 0,0:26:47.64,0:26:47.88,中文,,0,0,0,,为什么？
Dialogue: 0,0:26:47.88,0:26:52.99,中文,,0,0,0,,因为他可能也很幸运。事实上，储物柜的正中央可能就是 50 号。
Dialogue: 0,0:26:52.99,0:26:54.15,中文,,0,0,0,,但实际上并不是。
Dialogue: 0,0:26:54.15,0:27:00.20,中文,,0,0,0,,对于 Jackson 实际操作来说，更切合实际的是关于大 O 的讨论。
Dialogue: 0,0:27:00.20,0:27:08.77,中文,,0,0,0,,但大 O 和 Ω，上界和下界，可以让计算机科学家们思考在最坏情况下可能发生什么，在最佳情况下可能发生什么。
Dialogue: 0,0:27:08.77,0:27:12.39,中文,,0,0,0,,你甚至可以更精确地分析，比如平均情况等等。
Dialogue: 0,0:27:12.39,0:27:24.34,中文,,0,0,0,,而这正是工程师们在公司、大学的白板上设计算法时，试图通过这类分析来论证他们的算法比别人的算法更好的原因。
Dialogue: 0,0:27:24.34,0:27:35.75,中文,,0,0,0,,再说一下，如果碰巧某个算法的上界和下界相同，你也可以用大写希腊字母 θ 表示。
Dialogue: 0,0:27:35.75,0:27:38.33,中文,,0,0,0,,这就是今天要讲的最后一个希腊符号了。
Dialogue: 0,0:27:38.33,0:27:43.10,中文,,0,0,0,,希腊字母 θ 表示上界和下界重合。
Dialogue: 0,0:27:43.10,0:27:45.12,中文,,0,0,0,,也就是说，它们是同一个。
Dialogue: 0,0:27:45.12,0:27:49.38,中文,,0,0,0,,我们刚才讨论的线性查找和二分查找就不是这种情况。
Dialogue: 0,0:27:49.38,0:27:57.08,中文,,0,0,0,,如果你的上界和下界相同，你可以使用相同的公式。
Dialogue: 0,0:27:57.08,0:28:09.09,中文,,0,0,0,,例如，如果我要数这个房间里所有的人，1、2、3、4、5、6，等等，你可以说这种计数方式是 θ(n)，对吧？
Dialogue: 0,0:28:09.09,0:28:13.97,中文,,0,0,0,,因为在最好的情况下，我需要数 n 个人，也就是观众的数量。
Dialogue: 0,0:28:13.97,0:28:18.49,中文,,0,0,0,,在最坏的情况下，我需要数 n 个人。如果我想数清房间里所有的人，我总是需要 n 步。
Dialogue: 0,0:28:18.49,0:28:21.07,中文,,0,0,0,,除非你跳过一些人，否则你不可能做得更好。
Dialogue: 0,0:28:21.07,0:28:26.27,中文,,0,0,0,,这是一个即兴想到的例子，说明 θ 在这种情况下是适用的。
Dialogue: 0,0:28:26.27,0:28:38.86,中文,,0,0,0,,现在对大 O 符号、Ω 符号或 θ 符号还有什么问题吗？这些符号只是我们用来讨论算法设计时，工具箱中更正式的工具。
Dialogue: 0,0:28:38.86,0:28:42.24,中文,,0,0,0,,有什么问题吗？
Dialogue: 0,0:28:42.24,0:28:43.30,中文,,0,0,0,,没有吗？
Dialogue: 0,0:28:43.30,0:28:44.54,中文,,0,0,0,,没有看到。
Dialogue: 0,0:28:44.54,0:28:45.62,中文,,0,0,0,,是这个吗？
Dialogue: 0,0:28:45.62,0:28:46.87,中文,,0,0,0,,没有？
Dialogue: 0,0:28:46.87,0:28:48.27,中文,,0,0,0,,我们继续。
Dialogue: 0,0:28:48.27,0:28:51.99,中文,,0,0,0,,让我们继续，把它转换成实际的代码。
Dialogue: 0,0:28:51.99,0:28:53.97,中文,,0,0,0,,让我切换到 VS Code。
Dialogue: 0,0:28:53.97,0:29:00.36,中文,,0,0,0,,我们看看是否可以将这些想法转化为实际代码，暂时不使用新的语法。
Dialogue: 0,0:29:00.36,0:29:03.20,中文,,0,0,0,,我们仍然像上周一样，在数组的世界中操作。
Dialogue: 0,0:29:03.20,0:29:09.40,中文,,0,0,0,,我先在我的终端中输入 `code space search.c` 来创建一个名为 search.c 的程序。
Dialogue: 0,0:29:09.40,0:29:11.82,中文,,0,0,0,,然后在这里，我们继续包含我们常用的内容。
Dialogue: 0,0:29:11.82,0:29:14.90,中文,,0,0,0,,包含 `cs50.h` 这样我就可以获取一些输入。
Dialogue: 0,0:29:14.90,0:29:18.49,中文,,0,0,0,,包含 `stdio.h` 这样我就可以打印一些输出。
Dialogue: 0,0:29:18.49,0:29:23.19,中文,,0,0,0,,我们会写 `int main (void)`，上周我们已经开始分析它的含义了。
Dialogue: 0,0:29:23.19,0:29:26.84,中文,,0,0,0,,今天它又是 `void`，这意味着没有命令行参数。
Dialogue: 0,0:29:26.84,0:29:28.55,中文,,0,0,0,,让我继续做这件事。
Dialogue: 0,0:29:28.55,0:29:34.83,中文,,0,0,0,,为了便于讨论，我先声明一个静态数组，就像一个永不改变的数组。
Dialogue: 0,0:29:34.83,0:29:41.42,中文,,0,0,0,,语法是用方括号表示法给我一个名为 numbers 的数组。
Dialogue: 0,0:29:41.42,0:29:50.06,中文,,0,0,0,,我将立即把它初始化为 20、500、10、5、100、1 和 50，让人想起之前相同的面额。
Dialogue: 0,0:29:50.06,0:29:54.15,中文,,0,0,0,,所以这是一个我们可能从未见过的稍微新的语法。
Dialogue: 0,0:29:54.15,0:30:05.50,中文,,0,0,0,,这里的花括号，与 for 循环、while 循环和函数中的花括号不同，它只是告诉编译器，请给我一个包含从左到右这些数字的任何大小的数组。
Dialogue: 0,0:30:05.50,0:30:10.12,中文,,0,0,0,,我也可以使用上周的语法，像这样说。
Dialogue: 0,0:30:10.12,0:30:13.24,中文,,0,0,0,,我们来看看，1、2、3、4、5、6、7 种面额。
Dialogue: 0,0:30:13.24,0:30:15.52,中文,,0,0,0,,我也可以这样做。
Dialogue: 0,0:30:15.52,0:30:25.17,中文,,0,0,0,,然后我可以说 `numbers[0] = 20`，`numbers[1] = 500`。
Dialogue: 0,0:30:25.17,0:30:27.71,中文,,0,0,0,,我可以再做五次。
Dialogue: 0,0:30:27.71,0:30:28.77,中文,,0,0,0,,这有点乏味。
Dialogue: 0,0:30:28.77,0:30:32.61,中文,,0,0,0,,如果你预先知道数字的数量，你不需要告诉编译器有多少个数字。
Dialogue: 0,0:30:32.61,0:30:42.66,中文,,0,0,0,,你可以让它自己计算出你的数字是 20、500、10、5、100、1 和 50。所以这就是你如何静态地定义一个数组。
Dialogue: 0,0:30:42.66,0:30:45.26,中文,,0,0,0,,现在让我继续并询问用户一个数字。
Dialogue: 0,0:30:45.26,0:30:48.92,中文,,0,0,0,,我们使用 getInt 并提示他们输入一个数字，将其称为 n。
Dialogue: 0,0:30:48.92,0:30:50.18,中文,,0,0,0,,所以这里没有什么新鲜事。
Dialogue: 0,0:30:50.18,0:30:53.87,中文,,0,0,0,,现在让我继续并实现线性搜索。
Dialogue: 0,0:30:53.87,0:30:57.67,中文,,0,0,0,,我们之前为此编写的伪代码使用了一些类似数组的符号。
Dialogue: 0,0:30:57.67,0:31:00.83,中文,,0,0,0,,那么让我继续并以类似的方式开始，for。
Dialogue: 0,0:31:00.83,0:31:06.58,中文,,0,0,0,,int i，按照惯例，你几乎总是从 i 开始计数，所以这可能是一个很好的起点。
Dialogue: 0,0:31:06.58,0:31:09.84,中文,,0,0,0,,只要 i < 7，我就会这样做。
Dialogue: 0,0:31:09.84,0:31:15.66,中文,,0,0,0,,硬编码 7 不是最好的设计，但这仅仅是为了演示，因为我知道我在里面放了多少个数字。
Dialogue: 0,0:31:15.66,0:31:17.06,中文,,0,0,0,,然后我会执行 i++。
Dialogue: 0,0:31:17.06,0:31:21.68,中文,,0,0,0,,所以现在我有一个循环的开头，它将允许我遍历整个数组。
Dialogue: 0,0:31:21.68,0:31:25.39,中文,,0,0,0,,让我问一下，如果当前数字在位置 i 处等于 n，
Dialogue: 0,0:31:25.39,0:31:42.85,中文,,0,0,0,,n 是用户输入的数字，那么让我们继续做一些简单的事情，\N比如 printf "Found\ n"。然后根据我们上周的讨论，为了表明这是成功的，如果我找到了，我将返回 0。
Dialogue: 0,0:31:42.85,0:31:55.54,中文,,0,0,0,,如果我没有找到它，我将默认在这里说 "not Found\ n"。\N为了保持一致性，为了更好的衡量，按照惯例，我将返回 1，或者实际上是除 0 以外的任何值。
Dialogue: 0,0:31:55.54,0:31:57.26,中文,,0,0,0,,回想一下，0 表示成功。
Dialogue: 0,0:31:57.26,0:32:02.80,中文,,0,0,0,,任何其他整数往往意味着某种错误，而与我正在寻找的数字无关。
Dialogue: 0,0:32:02.80,0:32:10.05,中文,,0,0,0,,所以回顾一下，这里唯一的新东西是用这种语法创建一个包含七个数字的数组，这些数字。
Dialogue: 0,0:32:10.05,0:32:16.09,中文,,0,0,0,,在那之后，我们在这里真正强调的是线性搜索的实现。
Dialogue: 0,0:32:16.09,0:32:22.67,中文,,0,0,0,,这可以说就是 Stephanie 在黑板上演示的 C 语言版本，现在这个数组叫做 numbers 而不是 doors。
Dialogue: 0,0:32:22.67,0:32:25.49,中文,,0,0,0,,但我认为两者几乎一样。
Dialogue: 0,0:32:25.49,0:32:30.62,中文,,0,0,0,,我来打开终端窗口，运行 make search。
Dialogue: 0,0:32:30.62,0:32:33.02,中文,,0,0,0,,看起来编译没问题，./search。
Dialogue: 0,0:32:33.02,0:32:36.44,中文,,0,0,0,,然后我们来搜索一个数字，先从之前的 50 开始。
Dialogue: 0,0:32:36.44,0:32:37.50,中文,,0,0,0,,找到了。
Dialogue: 0,0:32:37.50,0:32:39.80,中文,,0,0,0,,我们再运行一次，./search。
Dialogue: 0,0:32:39.80,0:32:42.66,中文,,0,0,0,,这次搜索开头的 20。
Dialogue: 0,0:32:42.66,0:32:43.64,中文,,0,0,0,,也找到了。
Dialogue: 0,0:32:43.64,0:32:50.94,中文,,0,0,0,,再运行一次，搜索 1000，它不在这些面值中。
Dialogue: 0,0:32:50.94,0:32:53.02,中文,,0,0,0,,的确没找到。
Dialogue: 0,0:32:53.02,0:32:58.01,中文,,0,0,0,,我们从第 0 周的想法出发，在第 3 周将其形式化，现在将其转换为代码。
Dialogue: 0,0:32:58.01,0:33:05.49,中文,,0,0,0,,关于线性搜索的实现，大家有什么问题吗？
Dialogue: 0,0:33:05.49,0:33:08.84,中文,,0,0,0,,关于线性搜索，没有问题。
Dialogue: 0,0:33:08.84,0:33:11.38,中文,,0,0,0,,今天到目前为止一切顺利。
Dialogue: 0,0:33:11.38,0:33:17.26,中文,,0,0,0,,我们来看看能不能让它更有趣一点，看看能不能发现一些在 C 语言中很重要的细节。
Dialogue: 0,0:33:17.26,0:33:23.18,中文,,0,0,0,,我们不使用 numbers，而是用这个。
Dialogue: 0,0:33:23.18,0:33:25.03,中文,,0,0,0,,我们继续以大富翁为主题。
Dialogue: 0,0:33:25.03,0:33:31.51,中文,,0,0,0,,我仔细阅读了维基百科上关于大富翁的文章，了解了大富翁最初的棋子或代币。
Dialogue: 0,0:33:31.51,0:33:33.67,中文,,0,0,0,,事实证明，我们可以用字符串来表示它们。
Dialogue: 0,0:33:33.67,0:33:37.09,中文,,0,0,0,,我创建一个名为 strings 的数组，注意是复数。
Dialogue: 0,0:33:37.09,0:33:39.16,中文,,0,0,0,,它的大小在这里定义。
Dialogue: 0,0:33:39.16,0:33:51.73,中文,,0,0,0,,早期的大富翁棋子包括战舰、靴子、大炮、熨斗和顶针，你可以用它们来玩游戏。
Dialogue: 0,0:33:51.73,0:33:54.69,中文,,0,0,0,,还有一个大礼帽，你可能在现在的游戏中见过一些。
Dialogue: 0,0:33:54.69,0:33:57.80,中文,,0,0,0,,事实证明，这些棋子多年来一直在变化，我之前并不知道。
Dialogue: 0,0:33:57.80,0:34:00.18,中文,,0,0,0,,现在这是一个字符串数组。
Dialogue: 0,0:34:00.18,0:34:03.98,中文,,0,0,0,,让我们继续，提示用户输入，不再是整数了。
Dialogue: 0,0:34:03.98,0:34:08.03,中文,,0,0,0,,我现在想搜索其中一个字符串，仍然使用线性搜索。
Dialogue: 0,0:34:08.03,0:34:14.07,中文,,0,0,0,,我创建一个字符串 s，将它设置为 get_string 的结果，提示用户输入要搜索的字符串。
Dialogue: 0,0:34:14.07,0:34:19.74,中文,,0,0,0,,我认为我的代码几乎相同，除了一个细节。
Dialogue: 0,0:34:19.74,0:34:22.02,中文,,0,0,0,,我现在有一个名为 strings 的数组。
Dialogue: 0,0:34:22.02,0:34:31.29,中文,,0,0,0,,我现在有一个名为 s 的变量。事实证明，由于我们将在下周详细探讨的原因，这行代码行不通。
Dialogue: 0,0:34:31.29,0:34:36.90,中文,,0,0,0,,事实证明，原因与我们上周讨论的字符串的本质有关。
Dialogue: 0,0:34:36.90,0:34:39.68,中文,,0,0,0,,字符串是什么？
Dialogue: 0,0:34:39.68,0:34:41.22,中文,,0,0,0,,字符串是一个数组。
Dialogue: 0,0:34:41.22,0:34:52.07,中文,,0,0,0,,事实证明，即使你使用了“等于等于”（==），它也不会好心地为你比较数组中的所有字符。
Dialogue: 0,0:34:52.07,0:34:54.83,中文,,0,0,0,,它不会比较每个字母。
Dialogue: 0,0:34:54.83,0:35:03.17,中文,,0,0,0,,值得庆幸的是，我们在上周介绍的字符串库中有一个解决方案。
Dialogue: 0,0:35:03.17,0:35:06.80,中文,,0,0,0,,这个问题的原因我们将在下周详细探讨，但现在，
Dialogue: 0,0:35:06.80,0:35:15.70,中文,,0,0,0,,只要知道，当你想要在 C 语言中比较字符串时，特别是如果你已经了解 Java、Python 或其他一些语言，你不能使用“等于等于”（==）。
Dialogue: 0,0:35:15.70,0:35:21.79,中文,,0,0,0,,虽然在 Scratch 中可以，但在 C 中你不能这样做。所以我实际上要做的其实是这样的。
Dialogue: 0,0:35:21.79,0:35:29.19,中文,,0,0,0,,我必须问这个问题，调用 strcmp 函数的返回值，
Dialogue: 0,0:35:29.19,0:35:36.15,中文,,0,0,0,,当传入当前字符串和用户输入时是否等于 0。
Dialogue: 0,0:35:36.15,0:35:44.76,中文,,0,0,0,,所以如果你阅读这个叫做 strcmp 的函数的文档，你会看到它需要两个字符串作为输入，第一个和第二个。
Dialogue: 0,0:35:44.76,0:35:52.10,中文,,0,0,0,,然后，几十年前就有人写了代码，可能是用 for 循环或 while 循环来比较每个字符串中的每个字符。
Dialogue: 0,0:35:52.10,0:35:56.50,中文,,0,0,0,,事实证明，如果它们确实相等，它会返回 0。
Dialogue: 0,0:35:56.50,0:36:02.55,中文,,0,0,0,,事实证明，在其他情况下，它也会返回一个正数或负数。
Dialogue: 0,0:36:02.55,0:36:10.93,中文,,0,0,0,,有什么直觉可以解释为什么拥有一个函数来检查两个字符串是否相等可能真的很有用吗？
Dialogue: 0,0:36:10.93,0:36:18.70,中文,,0,0,0,,如果它们不相等，那么在比较两个字符串时，还有什么可能是有趣的呢？
Dialogue: 0,0:36:18.70,0:36:23.66,中文,,0,0,0,,如果某些值是？
Dialogue: 0,0:36:23.66,0:36:24.43,中文,,0,0,0,,好的，有可能。
Dialogue: 0,0:36:24.43,0:36:30.46,中文,,0,0,0,,也许你想知道它们有多相似。这本身就是一个算法。但 strcmp 比这要简单一些。
Dialogue: 0,0:36:36.05,0:36:44.83,中文,,0,0,0,,没错。如果你想按字母顺序排列一整串字符串，就像你的手机可能会对你的联系人或地址簿那样，事实证明，
Dialogue: 0,0:36:44.83,0:36:53.83,中文,,0,0,0,,strcmp 实际上会根据它可能按字母顺序排列在前面还是后面，或者实际上是否相等，返回一个正数、一个负数或零。
Dialogue: 0,0:36:53.83,0:36:58.77,中文,,0,0,0,,所以这可能是一件很有用的事情。这只是一个预告，我们将在下周看到更低级别的解释。
Dialogue: 0,0:36:58.77,0:37:01.81,中文,,0,0,0,,现在让我祈祷一下，看看我是否做对了。
Dialogue: 0,0:37:01.81,0:37:05.50,中文,,0,0,0,,让我继续做 make search。
Dialogue: 0,0:37:05.50,0:37:09.50,中文,,0,0,0,,编译成功了，虽然很慢，./search。
Dialogue: 0,0:37:09.50,0:37:12.24,中文,,0,0,0,,让我们搜索像顶针之类的东西。
Dialogue: 0,0:37:12.24,0:37:14.32,中文,,0,0,0,,我们看到它确实找到了。
Dialogue: 0,0:37:14.32,0:37:19.27,中文,,0,0,0,,否则，让我们搜索一些我知道不存在的东西，比如赛车，那是我小时候的东西。
Dialogue: 0,0:37:19.27,0:37:23.35,中文,,0,0,0,,但是，出现了 segmentation fault（段错误），Core dumped（核心已转储）。
Dialogue: 0,0:37:23.35,0:37:25.85,中文,,0,0,0,,实际上，你们中的一些人以前也遇到过这个错误。
Dialogue: 0,0:37:25.85,0:37:27.21,中文,,0,0,0,,有人想承认看到过这个错误吗？
Dialogue: 0,0:37:27.21,0:37:29.62,中文,,0,0,0,,这不是我们讨论过的话题。
Dialogue: 0,0:37:29.62,0:37:32.22,中文,,0,0,0,,老实说，这也不是我现在打算讲的内容。
Dialogue: 0,0:37:32.22,0:37:34.64,中文,,0,0,0,,但是，我们下周会看到。
Dialogue: 0,0:37:34.64,0:37:40.11,中文,,0,0,0,,谁能直观地解释一下为什么我的程序崩溃了吗？
Dialogue: 0,0:37:40.11,0:37:41.85,中文,,0,0,0,,我没有改变逻辑。
Dialogue: 0,0:37:41.85,0:37:43.54,中文,,0,0,0,,它仍然是线性搜索。
Dialogue: 0,0:37:43.54,0:37:46.36,中文,,0,0,0,,让我隐藏终端，以便您可以一次看到所有代码。
Dialogue: 0,0:37:46.36,0:37:49.85,中文,,0,0,0,,我做的唯一改变是从整数切换到字符串。
Dialogue: 0,0:37:49.85,0:37:52.49,中文,,0,0,0,,我在这里切换到 str compare。
Dialogue: 0,0:37:52.49,0:37:54.51,中文,,0,0,0,,但是发生了 segmentation fault。
Dialogue: 0,0:37:54.51,0:38:01.56,中文,,0,0,0,,预告一下，这在某种程度上与计算机内存有关。
Dialogue: 0,0:38:01.56,0:38:03.54,中文,,0,0,0,,是的，这很微妙，但说到点子上了。
Dialogue: 0,0:38:03.54,0:38:12.91,中文,,0,0,0,,这个数组中总共有 1、2、3、4、5、6 个元素，而我们之前的大富翁面额有 7 个数字。
Dialogue: 0,0:38:12.91,0:38:15.91,中文,,0,0,0,,这就是问题所在，这反过来让我自食其果。
Dialogue: 0,0:38:15.91,0:38:26.78,中文,,0,0,0,,我将这个值硬编码在代码中，而不是将其作为一个常量分离出来\N或在更高层声明它，这一事实让我在这里自食其果，因为现在我正在迭代一个大小为 6 的数组，
Dialogue: 0,0:38:26.78,0:38:32.44,中文,,0,0,0,,显然，我多走了一步，因为我要迭代七次，而不是六次。
Dialogue: 0,0:38:32.44,0:38:35.61,中文,,0,0,0,,就好像我在查看这里的内存。
Dialogue: 0,0:38:35.61,0:38:37.53,中文,,0,0,0,,实际上，我们下周会重点学习内存。
Dialogue: 0,0:38:37.53,0:38:38.77,中文,,0,0,0,,那是件坏事。
Dialogue: 0,0:38:38.77,0:38:44.23,中文,,0,0,0,,即使不看上周的代码，如果你们中有人遇到过段错误，
Dialogue: 0,0:38:44.23,0:38:47.28,中文,,0,0,0,,很可能是你访问了不应该访问的内存。
Dialogue: 0,0:38:47.28,0:38:49.42,中文,,0,0,0,,你可能循环次数太多了。
Dialogue: 0,0:38:49.42,0:38:52.80,中文,,0,0,0,,你可能用了一个负数来访问数组。
Dialogue: 0,0:38:52.80,0:38:55.40,中文,,0,0,0,,总的来说，你访问了不应该访问的内存。
Dialogue: 0,0:38:55.40,0:38:57.82,中文,,0,0,0,,你访问了不应该访问的内存段。
Dialogue: 0,0:38:57.82,0:39:00.12,中文,,0,0,0,,不过，至少在我的例子中，解决方法很简单。
Dialogue: 0,0:39:00.12,0:39:01.38,中文,,0,0,0,,别那样做就行了。
Dialogue: 0,0:39:01.38,0:39:03.33,中文,,0,0,0,,让我来重新编译一下。
Dialogue: 0,0:39:03.33,0:39:05.86,中文,,0,0,0,,make search
Dialogue: 0,0:39:05.86,0:39:09.70,中文,,0,0,0,,./search，我再搜索一次 race car。
Dialogue: 0,0:39:09.70,0:39:10.54,中文,,0,0,0,,回车。
Dialogue: 0,0:39:10.54,0:39:13.55,中文,,0,0,0,,现在它没有崩溃，但它告诉我没有找到。
Dialogue: 0,0:39:13.55,0:39:17.11,中文,,0,0,0,,很细微，但你可能已经自己遇到过了。
Dialogue: 0,0:39:17.11,0:39:23.13,中文,,0,0,0,,那么，我对刚才做的事情有什么疑问吗？有意或无意的？
Dialogue: 0,0:39:23.13,0:39:33.24,中文,,0,0,0,,前面那位同学。观众 1：有一点是，即使不写 return 0、return 1，程序仍然可以运行。
Dialogue: 0,0:39:33.24,0:39:34.14,中文,,0,0,0,,问得好。
Dialogue: 0,0:39:34.14,0:39:38.94,中文,,0,0,0,,所以即使我不写 return 0 或 return 1，程序仍然可以运行。
Dialogue: 0,0:39:38.94,0:39:44.08,中文,,0,0,0,,我打开这个文件，把终端窗口先隐藏起来。
Dialogue: 0,0:39:44.08,0:39:48.23,中文,,0,0,0,,我们把这个 return 语句去掉。
Dialogue: 0,0:39:48.23,0:39:50.81,中文,,0,0,0,,但是，看看会发生什么。
Dialogue: 0,0:39:50.81,0:39:53.75,中文,,0,0,0,,我先重新编译一下，make search。
Dialogue: 0,0:39:53.75,0:39:55.69,中文,,0,0,0,,让我向上滚动代码。
Dialogue: 0,0:39:55.69,0:39:57.50,中文,,0,0,0,,执行程序，./search。
Dialogue: 0,0:39:57.50,0:40:00.32,中文,,0,0,0,,我要搜索列表中的第一个词。
Dialogue: 0,0:40:00.32,0:40:02.92,中文,,0,0,0,,battleship，我知道应该能找到。
Dialogue: 0,0:40:02.92,0:40:04.67,中文,,0,0,0,,按下回车键。
Dialogue: 0,0:40:04.67,0:40:06.15,中文,,0,0,0,,有意思。
Dialogue: 0,0:40:06.15,0:40:07.13,中文,,0,0,0,,它显示找到了，没找到。
Dialogue: 0,0:40:07.13,0:40:13.06,中文,,0,0,0,,但是从逻辑上来说，你知道这是为什么吗？
Dialogue: 0,0:40:13.06,0:40:14.08,中文,,0,0,0,,没错。
Dialogue: 0,0:40:14.08,0:40:15.22,中文,,0,0,0,,循环还在运行。
Dialogue: 0,0:40:15.22,0:40:16.98,中文,,0,0,0,,有几种解决方案。
Dialogue: 0,0:40:16.98,0:40:21.08,中文,,0,0,0,,我可以在这里用某种方式跳出循环。
Dialogue: 0,0:40:21.08,0:40:24.35,中文,,0,0,0,,但这仍然会导致第 18 行被执行。
Dialogue: 0,0:40:24.35,0:40:26.73,中文,,0,0,0,,我可以在找到后直接 return。
Dialogue: 0,0:40:26.73,0:40:29.39,中文,,0,0,0,,我不需要在最后返回 1。
Dialogue: 0,0:40:29.39,0:40:37.58,中文,,0,0,0,,但是我上周说过，就像真正的程序员那样，至少表明你的程序是否按预期工作，这在你的程序变得越来越复杂时很有帮助。
Dialogue: 0,0:40:37.58,0:40:39.22,中文,,0,0,0,,错误代码，当程序出错时。
Dialogue: 0,0:40:39.22,0:40:44.18,中文,,0,0,0,,在 `main` 函数中返回 0 是表示代码执行完毕的最简单的方式。
Dialogue: 0,0:40:44.18,0:40:45.68,中文,,0,0,0,,表示程序成功退出。
Dialogue: 0,0:40:45.68,0:40:46.50,中文,,0,0,0,,就是这样。
Dialogue: 0,0:40:46.50,0:40:50.17,中文,,0,0,0,,在这里，我仍然可以返回 0，因为这不是什么大问题。
Dialogue: 0,0:40:50.17,0:40:55.25,中文,,0,0,0,,它算不上一个需要用弹出窗口来提醒用户出错的错误。
Dialogue: 0,0:40:55.25,0:41:00.25,中文,,0,0,0,,但返回 1 是一种更底层的信号，表示没有找到要查找的内容。
Dialogue: 0,0:41:00.25,0:41:03.46,中文,,0,0,0,,回想一下上周的内容，你可以这样理解。
Dialogue: 0,0:41:03.46,0:41:05.52,中文,,0,0,0,,如果我重新编译。
Dialogue: 0,0:41:05.52,0:41:08.30,中文,,0,0,0,,现在我已经还原了这些更改，所以 `make search`。
Dialogue: 0,0:41:08.30,0:41:23.01,中文,,0,0,0,,如果我执行 `./search` 并搜索 `battleship`，它确实找到了，\N回想一下我可以执行这个神奇的命令 `echo $?`，你不会经常执行它，但它会显示 `main` 函数返回了什么。
Dialogue: 0,0:41:23.01,0:41:32.35,中文,,0,0,0,,如果我再次运行 `search` 并搜索 `race car`，它没有找到，我看到了“not found”，但我也可以再次运行这个命令，看到它返回了 1。
Dialogue: 0,0:41:32.35,0:41:40.10,中文,,0,0,0,,几个月或几年后，当你真的在公司或为更大的项目编写代码时，你可能想要自动化软件。
Dialogue: 0,0:41:40.10,0:41:43.28,中文,,0,0,0,,你可能不希望用户必须手动运行它。
Dialogue: 0,0:41:43.28,0:41:50.48,中文,,0,0,0,,你可能希望代码能通过一些夜间进程或类似的东西自动执行，使用这些退出代码。
Dialogue: 0,0:41:50.48,0:41:56.04,中文,,0,0,0,,程序可以判断其他代码是否成功执行吗？
Dialogue: 0,0:41:56.04,0:42:02.29,中文,,0,0,0,,关于线性搜索还有其他问题吗？
Dialogue: 0,0:42:02.29,0:42:11.58,中文,,0,0,0,,让我们通过将这两个概念整合到另一个程序中，来将其转换为 C 语言的另一个特性。
Dialogue: 0,0:42:11.58,0:42:16.75,中文,,0,0,0,,我要在 C 语言中创建一个电话簿，输入 `code space phonebook.c`。
Dialogue: 0,0:42:16.75,0:42:23.07,中文,,0,0,0,,让我们结合其中一些概念，实现搜索电话簿中的实际姓名并返回号码的功能。
Dialogue: 0,0:42:23.07,0:42:31.02,中文,,0,0,0,,我要继续快速引入一些相同的东西，`cs50.h` 用于获取输入，`stdio.h` 用于打印输出。
Dialogue: 0,0:42:31.02,0:42:35.46,中文,,0,0,0,,并且我要预先包含 `string.h`，以防我们也需要它。
Dialogue: 0,0:42:35.46,0:42:39.24,中文,,0,0,0,,`int main`  `void`，今天不需要命令行参数。
Dialogue: 0,0:42:39.24,0:42:42.54,中文,,0,0,0,,现在让我给自己一个用于此电话簿的姓名数组。
Dialogue: 0,0:42:42.54,0:42:50.79,中文,,0,0,0,,输入 `string names` 等于，然后在大括号中，Carter 是电话簿中的一个人，而 David，我自己，将是另一个人。
Dialogue: 0,0:42:50.79,0:42:53.19,中文,,0,0,0,,我们将保持简短，这样我们就不必输入太多名字。
Dialogue: 0,0:42:53.19,0:42:55.87,中文,,0,0,0,,到目前为止，这是一本只有两个人的电话簿。
Dialogue: 0,0:42:55.87,0:42:59.68,中文,,0,0,0,,假设现在我们也想存储 Carter 和我的电话号码。
Dialogue: 0,0:42:59.68,0:43:01.42,中文,,0,0,0,,所以它不仅仅是说找到或没找到。
Dialogue: 0,0:43:01.42,0:43:05.50,中文,,0,0,0,,它实际上像一个合适的电话簿一样查找我们的电话号码。
Dialogue: 0,0:43:05.50,0:43:09.36,中文,,0,0,0,,目前，真的没有办法做到这一点。
Dialogue: 0,0:43:09.36,0:43:13.56,中文,,0,0,0,,我可以做一些不规范的操作，比如我可以在 Carter 后面放一个数字，比如 6174951000。
Dialogue: 0,0:43:13.56,0:43:22.49,中文,,0,0,0,,我可以在我后面放一个数字，比如 9494682750。
Dialogue: 0,0:43:22.49,0:43:25.09,中文,,0,0,0,,现在你有点像是在把苹果和橘子混在一起了，对吧？
Dialogue: 0,0:43:25.09,0:43:26.45,中文,,0,0,0,,就像，现在它不再是字符串了。
Dialogue: 0,0:43:26.45,0:43:28.52,中文,,0,0,0,,它是一个字符串、整数、字符串、整数。
Dialogue: 0,0:43:28.52,0:43:31.42,中文,,0,0,0,,也许我可以把所有这些都变成字符串。
Dialogue: 0,0:43:31.42,0:43:34.58,中文,,0,0,0,,现在这只是在概念上混合苹果和橘子。
Dialogue: 0,0:43:34.58,0:43:36.50,中文,,0,0,0,,就像，是的，那是一个包含四个字符串的数组。
Dialogue: 0,0:43:36.50,0:43:43.17,中文,,0,0,0,,现在你要凭记忆知道第一个字符串是名字，第二个字符串是数字，第三个字符串是，比如，你可以做到。
Dialogue: 0,0:43:43.17,0:43:45.13,中文,,0,0,0,,这有点像是在耍花招。
Dialogue: 0,0:43:45.13,0:43:47.47,中文,,0,0,0,,那么有什么比这更简洁的方法呢？
Dialogue: 0,0:43:47.47,0:43:55.56,中文,,0,0,0,,除了将电话号码和姓名合并到同一个数组中以外，我们还可以做些什么呢？也许有更好的方法？
Dialogue: 0,0:43:55.56,0:43:59.02,中文,,0,0,0,,能说得大声一点吗？
Dialogue: 0,0:43:59.02,0:44:01.82,中文,,0,0,0,,二维数组，或许我们可以这样做。
Dialogue: 0,0:44:01.82,0:44:08.15,中文,,0,0,0,,我现在打算把它简化一下，因为我们没有用过这些名字，尽管上周我们看到了 argv 在技术上就是这样。
Dialogue: 0,0:44:08.15,0:44:10.25,中文,,0,0,0,,如果我想存储姓名和号码，我还能做什么？
Dialogue: 0,0:44:10.25,0:44:12.35,中文,,0,0,0,,嗯？
Dialogue: 0,0:44:12.35,0:44:13.47,中文,,0,0,0,,让我采用这个建议。
Dialogue: 0,0:44:13.47,0:44:14.51,中文,,0,0,0,,只是这样简单一点。
Dialogue: 0,0:44:14.51,0:44:19.17,中文,,0,0,0,,让我继续使用 string，而不是在不同的维度上把事情复杂化。
Dialogue: 0,0:44:19.17,0:44:21.91,中文,,0,0,0,,我可以使用 int numbers。
Dialogue: 0,0:44:21.91,0:44:22.75,中文,,0,0,0,,你知道吗？
Dialogue: 0,0:44:22.75,0:44:29.21,中文,,0,0,0,,为了支持像破折号、括号甚至国家代码这样的标点符号，我打算这样做。
Dialogue: 0,0:44:29.21,0:44:37.43,中文,,0,0,0,,我打算使用 string numbers，这样我就可以用引号将 Carter 的号码表示为 +1（美国），617495。
Dialogue: 0,0:44:37.43,0:44:40.56,中文,,0,0,0,,1,000，用连字符隔开，就像美国惯例一样。
Dialogue: 0,0:44:40.56,0:44:47.90,中文,,0,0,0,,然后是我的号码，我将继续输入 +1、9、4、9，比如说 4、6、8、2、7、5、0，分号。
Dialogue: 0,0:44:47.90,0:44:54.09,中文,,0,0,0,,现在，让我们在下面真正让用户能够搜索这个电话簿，就像我们在第零周做的那样。
Dialogue: 0,0:44:54.09,0:44:55.95,中文,,0,0,0,,String name 等于 getString。
Dialogue: 0,0:44:55.95,0:45:00.03,中文,,0,0,0,,让我们询问用户姓名，大概是 David 或 Carter 或其他人。
Dialogue: 0,0:45:00.03,0:45:01.76,中文,,0,0,0,,现在我们重新实现线性搜索。
Dialogue: 0,0:45:01.76,0:45:05.90,中文,,0,0,0,,对于 int i = 0，i < 2。
Dialogue: 0,0:45:05.90,0:45:07.54,中文,,0,0,0,,按我说的做，不要像我这样做。
Dialogue: 0,0:45:07.54,0:45:13.22,中文,,0,0,0,,我认为我们应该注意这种硬编码，但现在为了简单起见，我们还是保持这样。 i ++。
Dialogue: 0,0:45:13.22,0:45:17.04,中文,,0,0,0,,在这个 for 循环中，我认为我们拥有解决这个问题的所有要素。
Dialogue: 0,0:45:17.04,0:45:27.97,中文,,0,0,0,,所以如果 str compare 的返回值，所有名字，括号 i，与用户输入的名字进行比较，如果所有这些都等于等于 0，
Dialogue: 0,0:45:27.97,0:45:36.97,中文,,0,0,0,,也就是说，这两个字符串中的所有字符都相等，那么我认为我们可以继续说找到了，就像上次一样。
Dialogue: 0,0:45:36.97,0:45:40.05,中文,,0,0,0,,你知道吗？我们实际上打印 Carter 的或我的电话号码。
Dialogue: 0,0:45:40.05,0:45:41.51,中文,,0,0,0,,找到了 %s。
Dialogue: 0,0:45:41.51,0:45:48.81,中文,,0,0,0,,我们将插入号码，括号 i。然后为了保持一致性，我在这里和下面都返回 0。
Dialogue: 0,0:45:48.81,0:45:53.72,中文,,0,0,0,,为了清楚起见，我可以说 printf Not found。
Dialogue: 0,0:45:53.72,0:45:56.30,中文,,0,0,0,,然后我也返回 1。
Dialogue: 0,0:45:56.30,0:45:58.14,中文,,0,0,0,,所以回顾一下，这里是所有的代码。
Dialogue: 0,0:45:58.14,0:46:00.18,中文,,0,0,0,,它几乎和以前一样。
Dialogue: 0,0:46:00.18,0:46:01.50,中文,,0,0,0,,除了现在它很有用。
Dialogue: 0,0:46:01.50,0:46:03.44,中文,,0,0,0,,我不只是说找到了或没找到。
Dialogue: 0,0:46:03.44,0:46:07.32,中文,,0,0,0,,我在大富翁游戏中找到了一个数字，或者我在大富翁游戏中找到了一个棋子。
Dialogue: 0,0:46:07.32,0:46:12.87,中文,,0,0,0,,我在一个数组中查找其中一个字符串，然后从另一个数组中打印答案。
Dialogue: 0,0:46:12.87,0:46:19.61,中文,,0,0,0,,让我在这里继续运行编译器，制作 phonebook，输入。
Dialogue: 0,0:46:19.61,0:46:20.55,中文,,0,0,0,,这很有希望。
Dialogue: 0,0:46:20.55,0:46:21.09,中文,,0,0,0,,没有错误。
Dialogue: 0,0:46:21.09,0:46:22.90,中文,,0,0,0,,现在运行 phonebook。
Dialogue: 0,0:46:22.90,0:46:25.42,中文,,0,0,0,,让我们搜索，例如 Carter。
Dialogue: 0,0:46:25.42,0:46:28.04,中文,,0,0,0,,回车。我们找到了 Carter 的号码。
Dialogue: 0,0:46:28.04,0:46:29.00,中文,,0,0,0,,好的，让我们再试一次。
Dialogue: 0,0:46:29.00,0:46:31.32,中文,,0,0,0,,Phonebook，让我们搜索 David。
Dialogue: 0,0:46:31.32,0:46:32.90,中文,,0,0,0,,我们似乎找到了 David 的号码。
Dialogue: 0,0:46:32.90,0:46:34.06,中文,,0,0,0,,我们最后再试一次。
Dialogue: 0,0:46:34.06,0:46:35.54,中文,,0,0,0,,Phonebook，回车。
Dialogue: 0,0:46:35.54,0:46:37.53,中文,,0,0,0,,现在我们要搜索，比如 John Harvard。
Dialogue: 0,0:46:37.53,0:46:38.63,中文,,0,0,0,,回车。
Dialogue: 0,0:46:38.63,0:46:40.15,中文,,0,0,0,,未找到。
Dialogue: 0,0:46:40.15,0:46:45.63,中文,,0,0,0,,我敢说，尽管测试不多，这段代码是正确的。
Dialogue: 0,0:46:45.63,0:46:48.23,中文,,0,0,0,,现在有人想批评一下这个设计吗？
Dialogue: 0,0:46:48.23,0:46:55.23,中文,,0,0,0,,对于这种方法，你是否感到不妥？
Dialogue: 0,0:46:55.23,0:47:01.49,中文,,0,0,0,,像往常一样，思考一下如果程序变得更长、更复杂，这样的决定会如何发展。
Dialogue: 0,0:47:01.49,0:47:04.47,中文,,0,0,0,,是吗？
Dialogue: 0,0:47:04.47,0:47:13.18,中文,,0,0,0,,如果 i 小于 2，从技术上讲，如果我更改了这个电话簿中的人数，我就必须更新 i。我们已经看到我把自己弄得一团糟。
Dialogue: 0,0:47:13.18,0:47:14.08,中文,,0,0,0,,所以这是糟糕的设计。
Dialogue: 0,0:47:14.08,0:47:14.30,中文,,0,0,0,,很好。
Dialogue: 0,0:47:14.30,0:47:21.89,中文,,0,0,0,,假设你要在电话簿中添加一个人的名字，但你没有相应的号码。
Dialogue: 0,0:47:21.89,0:47:24.89,中文,,0,0,0,,那么当你想要存储他们的号码时，
Dialogue: 0,0:47:24.89,0:47:28.18,中文,,0,0,0,,是的，再说一次，我有点相信自己不会搞砸。
Dialogue: 0,0:47:28.18,0:47:36.60,中文,,0,0,0,,如果我在第一个数组中添加 John 或其他任何人，但我忘记将他们的号码添加到第二个数组中，最终会导致数据漂移和不一致。
Dialogue: 0,0:47:36.60,0:47:38.98,中文,,0,0,0,,那时代码就会出错。
Dialogue: 0,0:47:38.98,0:47:43.52,中文,,0,0,0,,所以说，这是一种糟糕的设计，它会让我在未来失败，如果你愿意这样理解的话。
Dialogue: 0,0:47:43.52,0:47:45.00,中文,,0,0,0,,还有其他想法吗？
Dialogue: 0,0:47:45.00,0:47:53.32,中文,,0,0,0,,有吗？ 观众2：有。
Dialogue: 0,0:47:53.32,0:47:54.10,中文,,0,0,0,,很好。
Dialogue: 0,0:47:54.10,0:47:55.56,中文,,0,0,0,,我们假设顺序相同。
Dialogue: 0,0:47:55.56,0:47:57.54,中文,,0,0,0,,名字从左到右排列。
Dialogue: 0,0:47:57.54,0:47:59.56,中文,,0,0,0,,号码也从左到右排列。
Dialogue: 0,0:47:59.56,0:48:01.15,中文,,0,0,0,,但这只是君子协定。
Dialogue: 0,0:48:01.15,0:48:07.07,中文,,0,0,0,,就好像代码中没有任何东西阻止我颠倒顺序，或者出于某种原因对名字进行排序。
Dialogue: 0,0:48:07.07,0:48:10.13,中文,,0,0,0,,比如，它们现在是有序的，也许这是故意的，也许不是。
Dialogue: 0,0:48:10.13,0:48:12.95,中文,,0,0,0,,所以这种君子协定也不好，对吧？
Dialogue: 0,0:48:12.95,0:48:16.11,中文,,0,0,0,,我可以在里面加个注释来提醒自己。
Dialogue: 0,0:48:16.11,0:48:19.50,中文,,0,0,0,,提醒自己，始终以相同的方式更新数组。
Dialogue: 0,0:48:19.50,0:48:26.22,中文,,0,0,0,,最终还是会出问题，特别是当我们有的不是两个，而是三个，三十个，三百个名字和号码的时候。
Dialogue: 0,0:48:26.22,0:48:29.59,中文,,0,0,0,,如果能把所有相关数据放在一起就好了。
Dialogue: 0,0:48:29.59,0:48:38.07,中文,,0,0,0,,实际上，我们今天要介绍的 C 语言的新特性，是可以让我们实现自己的数据结构。
Dialogue: 0,0:48:38.07,0:48:45.82,中文,,0,0,0,,你可以把数组看作是一个非常轻量级的数据结构，因为它允许你将相关数据一个接一个地聚集在一起。
Dialogue: 0,0:48:45.82,0:48:48.16,中文,,0,0,0,,字符串就是这样实现的。
Dialogue: 0,0:48:48.16,0:48:51.77,中文,,0,0,0,,它们是用数组实现的数据结构。
Dialogue: 0,0:48:51.77,0:48:59.69,中文,,0,0,0,,但使用 C 语言和其他语言，你可以发明自己的数据类型，无论是 一维、二维，甚至更高维度。
Dialogue: 0,0:48:59.69,0:49:07.10,中文,,0,0,0,,使用 C 语言，你可以创建自己的类型，并为其命名。
Dialogue: 0,0:49:07.10,0:49:16.45,中文,,0,0,0,,例如，如果 C 语言不仅提供 char、int、float、long 等数据类型，那不是很好吗？
Dialogue: 0,0:49:16.45,0:49:20.09,中文,,0,0,0,,如果 C 语言提供一种名为 person 的数据类型，那不是很好吗？
Dialogue: 0,0:49:20.09,0:49:22.87,中文,,0,0,0,,理想情况下，一个人应该有一个名字和一个号码。
Dialogue: 0,0:49:22.87,0:49:24.83,中文,,0,0,0,,现在，这有点天真和不现实。
Dialogue: 0,0:49:24.83,0:49:28.46,中文,,0,0,0,,为什么他们会把人定义为只有这两个字段？
Dialogue: 0,0:49:28.46,0:49:32.12,中文,,0,0,0,,当然，人们对于人的定义可能会有分歧，所以他们把这个问题留给我们。
Dialogue: 0,0:49:32.12,0:49:36.92,中文,,0,0,0,,C 语言的作者给了我们所有这些基本类型，int、float、string 等等。
Dialogue: 0,0:49:36.92,0:49:43.45,中文,,0,0,0,,现在取决于我们如何以更有趣的方式使用它们，以便我们可以创建一个由 person 组成的数组。
Dialogue: 0,0:49:43.45,0:49:48.07,中文,,0,0,0,,你可以把数组中的变量看作是一个叫做 people 的数组，这里只是为了用复数形式表示。
Dialogue: 0,0:49:48.07,0:49:49.63,中文,,0,0,0,,那么我们要怎么做呢？
Dialogue: 0,0:49:49.63,0:49:58.00,中文,,0,0,0,,现在，我们先规定一个人将拥有一个名字和一个号码，我们可以一直争论一个人还应该拥有什么。
Dialogue: 0,0:49:58.00,0:49:58.50,中文,,0,0,0,,这没问题。
Dialogue: 0,0:49:58.50,0:50:01.93,中文,,0,0,0,,你最终可以创造你自己的“人”。
Dialogue: 0,0:50:01.93,0:50:06.49,中文,,0,0,0,,目前，我只使用两个变量来定义一个人的姓名和号码。
Dialogue: 0,0:50:06.49,0:50:14.84,中文,,0,0,0,,如果能把这两种数据类型封装，也就是组合成一种新的、改进后的数据类型叫做 person，岂不是更好？
Dialogue: 0,0:50:14.84,0:50:17.52,中文,,0,0,0,,语法是这样的。
Dialogue: 0,0:50:17.52,0:50:18.96,中文,,0,0,0,,这有点拗口。
Dialogue: 0,0:50:18.96,0:50:21.88,中文,,0,0,0,,你也许可以推断出其中一些部分的作用。
Dialogue: 0,0:50:21.88,0:50:24.63,中文,,0,0,0,,事实证明，C 语言中有一个叫做 typedef 的关键字。
Dialogue: 0,0:50:24.63,0:50:28.61,中文,,0,0,0,,顾名思义，它允许你定义自己的类型。
Dialogue: 0,0:50:28.61,0:50:31.59,中文,,0,0,0,,struct 表示它是一个结构体。
Dialogue: 0,0:50:31.59,0:50:36.89,中文,,0,0,0,,它就像一个结构，里面有多个值，你想定义这些值。
Dialogue: 0,0:50:36.89,0:50:42.38,中文,,0,0,0,,最下面，花括号外面，是你想创建的类型的名称。
Dialogue: 0,0:50:42.38,0:50:46.80,中文,,0,0,0,,所以在这种情况下，你不能随意使用 typedef 或 struct。
Dialogue: 0,0:50:46.80,0:50:48.66,中文,,0,0,0,,但是你可以随意命名。
Dialogue: 0,0:50:48.66,0:50:52.70,中文,,0,0,0,,你也可以在结构体中放入任何你想要的东西。
Dialogue: 0,0:50:52.70,0:50:56.77,中文,,0,0,0,,一旦代码底部的分号被执行，
Dialogue: 0,0:50:56.77,0:51:05.85,中文,,0,0,0,,之后的每一行都可以访问 person 数据类型，无论是作为单个变量还是作为整个数组。
Dialogue: 0,0:51:05.85,0:51:10.17,中文,,0,0,0,,如果我想在此基础上继续构建，让我继续这样做。
Dialogue: 0,0:51:10.17,0:51:12.47,中文,,0,0,0,,让我回到 C 代码。
Dialogue: 0,0:51:12.47,0:51:17.53,中文,,0,0,0,,我要继续修改几处。
Dialogue: 0,0:51:17.53,0:51:19.06,中文,,0,0,0,,我们来做这件事。
Dialogue: 0,0:51:19.06,0:51:23.48,中文,,0,0,0,,我要先把这两个硬编码的数组去掉。
Dialogue: 0,0:51:23.48,0:51:27.34,中文,,0,0,0,,让我在我的文件顶部，
Dialogue: 0,0:51:27.34,0:51:30.42,中文,,0,0,0,,创建这种类型，使用 typedef struct。
Dialogue: 0,0:51:30.42,0:51:34.70,中文,,0,0,0,,里面将有一个字符串 name 和一个字符串 number。
Dialogue: 0,0:51:34.70,0:51:36.81,中文,,0,0,0,,然后将此结构命名为 person。
Dialogue: 0,0:51:36.81,0:51:44.61,中文,,0,0,0,,最佳做法是在文件的开头定义它，以便我的任何函数实际上都可以使用它，即使在这种情况下我只使用了 main 函数。
Dialogue: 0,0:51:44.61,0:51:50.48,中文,,0,0,0,,现在，如果我想的话，我可以这样做，比如 person p1 和 person p2。
Dialogue: 0,0:51:50.48,0:51:53.04,中文,,0,0,0,,我们从上周就知道，这已经是糟糕的设计了。
Dialogue: 0,0:51:53.04,0:52:01.69,中文,,0,0,0,,如果你想拥有同一类型的多个变量实例，我们应该使用什么？
Dialogue: 0,0:52:01.69,0:52:03.48,中文,,0,0,0,,是的，数组。
Dialogue: 0,0:52:03.48,0:52:05.24,中文,,0,0,0,,所以我不会那样做。
Dialogue: 0,0:52:05.24,0:52:06.84,中文,,0,0,0,,我将这样做。
Dialogue: 0,0:52:06.84,0:52:09.84,中文,,0,0,0,,Person 将是数组的类型。
Dialogue: 0,0:52:09.84,0:52:12.00,中文,,0,0,0,,我将把它叫做，我可以称之为 persons。
Dialogue: 0,0:52:12.00,0:52:13.74,中文,,0,0,0,,通常我们说 people。
Dialogue: 0,0:52:13.74,0:52:15.33,中文,,0,0,0,,所以我将数组命名为 people。
Dialogue: 0,0:52:15.33,0:52:21.12,中文,,0,0,0,,我希望在这个数组中存在两个人，当然我可以将这个数字更改为任何我想要的数字。
Dialogue: 0,0:52:21.12,0:52:27.16,中文,,0,0,0,,如何将姓名放入 person 中，然后将号码放入同一个 person 中？
Dialogue: 0,0:52:27.16,0:52:29.10,中文,,0,0,0,,今天会有一些新的语法。
Dialogue: 0,0:52:29.10,0:52:30.64,中文,,0,0,0,,我要继续说。
Dialogue: 0,0:52:30.64,0:52:34.45,中文,,0,0,0,,people[0] 只是给了我数组中的第一个人。
Dialogue: 0,0:52:34.45,0:52:35.69,中文,,0,0,0,,这并不新鲜。
Dialogue: 0,0:52:35.69,0:52:43.39,中文,,0,0,0,,如果你想访问内存中那个人的内部，就使用一个点，然后指定属性的名称。
Dialogue: 0,0:52:43.39,0:52:44.79,中文,,0,0,0,,他们所在的属性。
Dialogue: 0,0:52:44.79,0:52:49.50,中文,,0,0,0,,所以如果我想把第一个人的名字设置为 Carter，我就会使用这种所谓的点符号。
Dialogue: 0,0:52:49.50,0:52:56.20,中文,,0,0,0,,然后如果我想用点符号设置 Carter 的号码，我会这样做，加 1，617, 495, 1,000。
Dialogue: 0,0:52:56.20,0:53:01.53,中文,,0,0,0,,然后如果我想对自己做同样的事情，我现在就做 people 中括号 1。
Dialogue: 0,0:53:01.53,0:53:03.93,中文,,0,0,0,,点 name 等于，引号，David。
Dialogue: 0,0:53:03.93,0:53:13.25,中文,,0,0,0,,然后 people 中括号 1，仍然是，点 number 等于，引号，加 1—949—468—2750。
Dialogue: 0,0:53:13.25,0:53:18.78,中文,,0,0,0,,现在，在我的文件底部，我认为我的逻辑几乎可以保持不变。
Dialogue: 0,0:53:18.78,0:53:24.58,中文,,0,0,0,,我仍然可以在这一行，提示用户输入他们想要查找的人的姓名。
Dialogue: 0,0:53:24.58,0:53:28.10,中文,,0,0,0,,目前，虽然我承认这不是最佳设计，但我只是为了演示。
Dialogue: 0,0:53:28.10,0:53:31.52,中文,,0,0,0,,我将保留这两个，因为我知道我有两个人。
Dialogue: 0,0:53:31.52,0:53:34.18,中文,,0,0,0,,但在这里，这将不得不改变。
Dialogue: 0,0:53:34.18,0:53:37.01,中文,,0,0,0,,我不想再比较 names 中括号 i 了。
Dialogue: 0,0:53:37.01,0:53:42.23,中文,,0,0,0,,我想在这里输入什么作为 str compare 的第一个参数？
Dialogue: 0,0:53:42.23,0:53:44.07,中文,,0,0,0,,我想在这里做什么？
Dialogue: 0,0:53:44.07,0:53:46.98,中文,,0,0,0,,是的。
Dialogue: 0,0:53:46.98,0:53:49.16,中文,,0,0,0,,所以 people i 点 name，是的。
Dialogue: 0,0:53:49.16,0:53:54.44,中文,,0,0,0,,所以我想进入 people 数组的第 i 个位置，因为这就是我的循环正在做的事情。
Dialogue: 0,0:53:54.44,0:53:56.04,中文,,0,0,0,,它在一次又一次地更新 i。
Dialogue: 0,0:53:56.04,0:53:57.56,中文,,0,0,0,,然后查看 name。
Dialogue: 0,0:53:57.56,0:53:58.16,中文,,0,0,0,,很好。
Dialogue: 0,0:53:58.16,0:53:59.66,中文,,0,0,0,,我想现在我也需要改一下这个。
Dialogue: 0,0:53:59.66,0:54:01.91,中文,,0,0,0,,如果找到了这个人，我想打印什么？
Dialogue: 0,0:54:01.91,0:54:05.09,中文,,0,0,0,,其他人？
Dialogue: 0,0:54:05.09,0:54:08.93,中文,,0,0,0,,如果我找到了这个人的名字，我想在这里打印什么？
Dialogue: 0,0:54:08.93,0:54:11.29,中文,,0,0,0,,是的。
Dialogue: 0,0:54:11.29,0:54:14.31,中文,,0,0,0,,大声点说。
Dialogue: 0,0:54:14.31,0:54:20.35,中文,,0,0,0,,很好，`people[i].number`，如果我的确想打印这个人的对应号码。
Dialogue: 0,0:54:20.35,0:54:22.96,中文,,0,0,0,,然后我想我的代码的其余部分可以保持不变。
Dialogue: 0,0:54:22.96,0:54:27.36,中文,,0,0,0,,让我继续，重新运行 `make phonebook` 来重新编译这个版本。
Dialogue: 0,0:54:27.36,0:54:28.18,中文,,0,0,0,,目前为止，一切顺利。
Dialogue: 0,0:54:28.18,0:54:29.51,中文,,0,0,0,,`./phonebook`
Dialogue: 0,0:54:29.51,0:54:31.47,中文,,0,0,0,,让我们继续输入 Carter 的名字。
Dialogue: 0,0:54:31.47,0:54:32.15,中文,,0,0,0,,找到。
Dialogue: 0,0:54:32.15,0:54:33.45,中文,,0,0,0,,让我们继续再运行一次。
Dialogue: 0,0:54:33.45,0:54:34.69,中文,,0,0,0,,David 的名字。
Dialogue: 0,0:54:34.69,0:54:36.83,中文,,0,0,0,,找到，让我们继续再运行一次。
Dialogue: 0,0:54:36.83,0:54:38.88,中文,,0,0,0,,输入 John Harvard，例如。
Dialogue: 0,0:54:38.88,0:54:40.46,中文,,0,0,0,,在这种情况下没找到。
Dialogue: 0,0:54:40.46,0:54:43.70,中文,,0,0,0,,从根本上说，代码并没有什么不同。
Dialogue: 0,0:54:43.70,0:54:46.19,中文,,0,0,0,,线性查找的行为方式仍然相同。
Dialogue: 0,0:54:46.19,0:54:48.47,中文,,0,0,0,,我承认，这看起来有点丑陋。
Dialogue: 0,0:54:48.47,0:54:52.58,中文,,0,0,0,,好像我们用五行代码做了一个两行的解决方案。
Dialogue: 0,0:54:52.58,0:55:06.77,中文,,0,0,0,,如果我们快进一两周，当我们开始将信息保存到文件时，我们会向大家介绍 CSV 文件，\N即逗号分隔值文件，或者电子表格文件，你肯定在过去某个时候在 Mac 或 PC 上打开过这些文件。
Dialogue: 0,0:55:06.77,0:55:12.01,中文,,0,0,0,,可以这么说，我们很快就会学习将姓名和数字等信息存储在文件中的技术。
Dialogue: 0,0:55:12.01,0:55:19.18,中文,,0,0,0,,到那时，我们就不会再做这种手工编码数字 2 的事情，也不会再手动地将我的名字、Carter 的名字和号码输入到程序中了。
Dialogue: 0,0:55:19.18,0:55:21.72,中文,,0,0,0,,我们将从文件中动态读取信息。
Dialogue: 0,0:55:21.72,0:55:25.24,中文,,0,0,0,,几周后，我们将从数据库中动态读取信息。
Dialogue: 0,0:55:25.24,0:55:32.39,中文,,0,0,0,,现在，这只是语法上如何创建一个大小为 2 的数组，其中每个人都包含在一个元素中。
Dialogue: 0,0:55:32.39,0:55:37.91,中文,,0,0,0,,我们可以更新第一个人的姓名和号码，更新第二个人的姓名和号码，
Dialogue: 0,0:55:37.91,0:55:41.62,中文,,0,0,0,,然后，搜索这些姓名并打印出相应的号码。
Dialogue: 0,0:55:41.62,0:55:44.22,中文,,0,0,0,,在这个意义上，这是一个更好的设计。
Dialogue: 0,0:55:44.22,0:55:44.86,中文,,0,0,0,,为什么？
Dialogue: 0,0:55:44.86,0:55:53.56,中文,,0,0,0,,因为我的 person 数据类型现在封装了成为一个人的所有意义，至少在这个狭窄的世界里是这样。
Dialogue: 0,0:55:53.56,0:56:03.81,中文,,0,0,0,,如果我想给一个人的概念添加一些东西，例如，我可以到我的 typedef 中，明天给每个人添加一个地址，并开始读取它。
Dialogue: 0,0:56:03.81,0:56:05.83,中文,,0,0,0,,现在就不是君子协定了。
Dialogue: 0,0:56:05.83,0:56:17.88,中文,,0,0,0,,姓名数组、号码数组、地址数组以及你可能想到的与人相关的所有其他内容，都被封装（这是一个专业术语）在同一类型中。
Dialogue: 0,0:56:17.88,0:56:23.28,中文,,0,0,0,,如果你们中有些人以前编过程序，就会想起面向对象编程，但我们现在还没讲到那里。
Dialogue: 0,0:56:23.28,0:56:24.82,中文,,0,0,0,,C 语言不是那样的。
Dialogue: 0,0:56:24.82,0:56:35.07,中文,,0,0,0,,关于 struct 的使用或这种新语法的使用，点运算符是这里真正有趣的部分，大家有什么问题吗？
Dialogue: 0,0:56:35.07,0:56:35.59,中文,,0,0,0,,有什么问题吗？
Dialogue: 0,0:56:35.59,0:56:42.96,中文,,0,0,0,,有。
Dialogue: 0,0:56:42.96,0:56:46.59,中文,,0,0,0,,哪一行？
Dialogue: 0,0:56:46.59,0:56:51.29,中文,,0,0,0,,第 16 行？对，从语法上来说，我们上周介绍了方括号。
Dialogue: 0,0:56:51.29,0:56:55.29,中文,,0,0,0,,所以 `people[0]` 的意思是访问数组中的第一个人。
Dialogue: 0,0:56:55.29,0:56:58.47,中文,,0,0,0,,就像 Stephanie 打开这扇门一样。
Dialogue: 0,0:56:58.47,0:57:00.11,中文,,0,0,0,,那是 `doors[0]`。
Dialogue: 0,0:57:00.11,0:57:02.48,中文,,0,0,0,,这当然是 `people[0]`。
Dialogue: 0,0:57:02.48,0:57:04.60,中文,,0,0,0,,今天，点号是一种新的语法。
Dialogue: 0,0:57:04.60,0:57:08.72,中文,,0,0,0,,它的意思是进入内存中的那个人。
Dialogue: 0,0:57:08.72,0:57:13.36,中文,,0,0,0,,查看其中的名字，并将其设置为 Carter，对 number 也做同样的事情。
Dialogue: 0,0:57:13.36,0:57:13.88,中文,,0,0,0,,就是这样。
Dialogue: 0,0:57:13.88,0:57:18.61,中文,,0,0,0,,就像打开储物柜门，进去，然后查看或设置名字和号码。
Dialogue: 0,0:57:18.61,0:57:19.77,中文,,0,0,0,,还有问题吗？
Dialogue: 0,0:57:29.34,0:57:30.86,中文,,0,0,0,,属性没问题。
Dialogue: 0,0:57:30.86,0:57:31.70,中文,,0,0,0,,问得好。
Dialogue: 0,0:57:31.70,0:57:34.16,中文,,0,0,0,,在结构体中，可以设置默认值吗？
Dialogue: 0,0:57:34.16,0:57:35.12,中文,,0,0,0,,简而言之，不能。
Dialogue: 0,0:57:35.12,0:57:42.49,中文,,0,0,0,,这就是 C 语言不如 Python、Java 等更现代的语言功能丰富的地方，在这些语言中，实际上可以做到这一点。
Dialogue: 0,0:57:42.49,0:57:47.05,中文,,0,0,0,,所以几周后，当我们过渡到 Python 时，我们会看到如何开始解决这类问题。
Dialogue: 0,0:57:47.05,0:57:51.56,中文,,0,0,0,,现在，由你来初始化姓名和数字。
Dialogue: 0,0:58:04.69,0:58:08.55,中文,,0,0,0,,问得好，我们该如何调整或评价我正在做的设计呢？
Dialogue: 0,0:58:08.55,0:58:14.00,中文,,0,0,0,,这是少数情况下我会说“照我说的做，不要照我做的”的情况之一。
Dialogue: 0,0:58:14.00,0:58:17.88,中文,,0,0,0,,我使用这种相当丑陋的行只是为了介绍语法。
Dialogue: 0,0:58:17.88,0:58:26.22,中文,,0,0,0,,我今天在教学上的说法是，最终当我们开始将姓名、数字或其他东西存储在文件或数据库中时，就不会有这种冗余了。
Dialogue: 0,0:58:26.22,0:58:31.83,中文,,0,0,0,,你将只有一两行代码从文件或数据库中读取信息。
Dialogue: 0,0:58:31.83,0:58:34.61,中文,,0,0,0,,然后用这些数据填充整个数组。
Dialogue: 0,0:58:34.61,0:58:38.28,中文,,0,0,0,,现在，我只是手动完成，以便我们将注意力集中在新语法上。
Dialogue: 0,0:58:38.28,0:58:39.58,中文,,0,0,0,,就是这样。
Dialogue: 0,0:58:39.58,0:58:42.81,中文,,0,0,0,,所以请原谅今天设计上的缺陷。
Dialogue: 0,0:58:42.81,0:58:45.83,中文,,0,0,0,,对此还有其他问题吗？
Dialogue: 0,0:58:45.83,0:58:47.89,中文,,0,0,0,,好了，已经讲了很多了。
Dialogue: 0,0:58:47.89,0:58:50.45,中文,,0,0,0,,我们先休息十分钟，吃点零食怎么样？
Dialogue: 0,0:58:50.45,0:58:53.45,中文,,0,0,0,,大厅里有一些美味的布朗尼蛋糕。
Dialogue: 0,0:58:53.45,0:58:55.98,中文,,0,0,0,,好了，我们回来了。
Dialogue: 0,0:58:55.98,0:59:02.34,中文,,0,0,0,,到目前为止，如果你的数据是排序的，这显然是件好事，因为可以使用二分查找。
Dialogue: 0,0:59:02.34,0:59:05.54,中文,,0,0,0,,你对数据了解多一点。
Dialogue: 0,0:59:05.54,0:59:10.79,中文,,0,0,0,,事实证明，排序本身也是一个需要解决的问题。
Dialogue: 0,0:59:10.79,0:59:19.87,中文,,0,0,0,,你可能会想，如果排序速度很快，我们绝对应该在开始搜索之前进行排序，因为这只会加快我们所有的搜索速度。
Dialogue: 0,0:59:19.87,0:59:28.08,中文,,0,0,0,,但如果排序很慢，这就会引出一个问题：如果我们只搜索数据一次或两次，我们是否还要对数据进行排序？
Dialogue: 0,0:59:28.08,0:59:30.58,中文,,0,0,0,,所以这里可能需要权衡一下。
Dialogue: 0,0:59:30.58,0:59:33.33,中文,,0,0,0,,我们来思考一下，对数据进行排序到底意味着什么。
Dialogue: 0,0:59:33.33,0:59:36.11,中文,,0,0,0,,在我们的例子中，我们会尽量简化，使用数字。
Dialogue: 0,0:59:36.11,0:59:40.93,中文,,0,0,0,,但在 Google 这样的公司，它可能是网页、人员或类似的东西。
Dialogue: 0,0:59:40.93,0:59:46.31,中文,,0,0,0,,这是我们解决任何问题的排序输入的典型图示。
Dialogue: 0,0:59:46.31,0:59:48.27,中文,,0,0,0,,左侧输入，右侧输出。
Dialogue: 0,0:59:48.27,0:59:54.56,中文,,0,0,0,,我们排序问题的输入是一组未排序的值。
Dialogue: 0,0:59:54.56,0:59:57.94,中文,,0,0,0,,理想情况下，输出将是相同的值集，但已排序。
Dialogue: 0,0:59:57.94,1:00:05.89,中文,,0,0,0,,具体来说，假设我们要对以下数字列表进行排序：7、2、5、4、1、6、0、3。
Dialogue: 0,1:00:05.89,1:00:10.11,中文,,0,0,0,,所以这是从 0 到 7 的所有数字，但它们以某种方式随机排列。
Dialogue: 0,1:00:10.11,1:00:11.57,中文,,0,0,0,,这将是问题的输入。
Dialogue: 0,1:00:11.57,1:00:18.03,中文,,0,0,0,,现在的目标是将它们排序，以便得到 0、1、2、3、4、5、6、7。
Dialogue: 0,1:00:18.03,1:00:23.92,中文,,0,0,0,,事实证明，我们可以用很多不同的方法对这些数字进行排序。
Dialogue: 0,1:00:23.92,1:00:32.40,中文,,0,0,0,,事实上，为了补充我们之前的搜索示例，我们能否请八位志愿者上来，如果你不介意出现在互联网上的话？
Dialogue: 0,1:00:32.40,1:00:39.17,中文,,0,0,0,,如果你想参加，好的，两个，三个，四个，五个，六个，七个，八个，怎么样？
Dialogue: 0,1:00:39.17,1:00:44.99,中文,,0,0,0,,好的，下来吧。
Dialogue: 0,1:00:44.99,1:00:48.06,中文,,0,0,0,,好的。
Dialogue: 0,1:00:48.06,1:00:50.68,中文,,0,0,0,,到这边来，我给你们每个人一个号码。
Dialogue: 0,1:00:50.68,1:01:04.69,中文,,0,0,0,,然后请你们按照在板上看到的数字顺序排列，抬头看投影，按照从左到右的顺序排列。
Dialogue: 0,1:01:04.69,1:01:06.21,中文,,0,0,0,,第一个就完美。
Dialogue: 0,1:01:06.21,1:01:07.91,中文,,0,0,0,,请到这边来。
Dialogue: 0,1:01:07.91,1:01:10.41,中文,,0,0,0,,就和这个对齐。
Dialogue: 0,1:01:10.41,1:01:13.97,中文,,0,0,0,,好的，再来几个人。
Dialogue: 0,1:01:13.97,1:01:19.91,中文,,0,0,0,,好的，数字 2、6，完美。
Dialogue: 0,1:01:19.91,1:01:20.83,中文,,0,0,0,,人数正好。
Dialogue: 0,1:01:20.83,1:01:21.81,中文,,0,0,0,,好的。
Dialogue: 0,1:01:21.81,1:01:22.97,中文,,0,0,0,,啊哦。
Dialogue: 0,1:01:22.97,1:01:23.63,中文,,0,0,0,,好的，就这样。
Dialogue: 0,1:01:23.63,1:01:24.52,中文,,0,0,0,,数字 3。
Dialogue: 0,1:01:24.52,1:01:26.26,中文,,0,0,0,,我们来快速检查一下。
Dialogue: 0,1:01:26.26,1:01:30.54,中文,,0,0,0,,我们有 7、2、5、4、1、6、0、3。
Dialogue: 0,1:01:30.54,1:01:31.40,中文,,0,0,0,,目前为止非常好。
Dialogue: 0,1:01:31.40,1:01:34.60,中文,,0,0,0,,你能往这边挪一点吗？这样空间大一些。
Dialogue: 0,1:01:34.60,1:01:37.96,中文,,0,0,0,,现在让我们看看谁在台上。
Dialogue: 0,1:01:37.96,1:01:40.58,中文,,0,0,0,,你们能分别向观众打个招呼吗？
Dialogue: 0,1:01:40.58,1:01:42.10,中文,,0,0,0,,嗨，我叫 Ryan。
Dialogue: 0,1:01:42.10,1:01:45.85,中文,,0,0,0,,我来自 Pennypacker，一年级。
Dialogue: 0,1:01:45.85,1:01:46.91,中文,,0,0,0,,嗨，我叫 Itzel。
Dialogue: 0,1:01:46.91,1:01:49.23,中文,,0,0,0,,我是 Strauss 的一年级学生。
Dialogue: 0,1:01:49.23,1:01:50.23,中文,,0,0,0,,嗨，我叫 Lucy。
Dialogue: 0,1:01:50.23,1:01:52.67,中文,,0,0,0,,我是 Greeno 的一年级学生。
Dialogue: 0,1:01:52.67,1:01:53.63,中文,,0,0,0,,嗨，我叫 Shiloh。
Dialogue: 0,1:01:53.63,1:01:54.95,中文,,0,0,0,,我是 Wigglesworth 的一年级学生。
Dialogue: 0,1:01:54.95,1:02:00.26,中文,,0,0,0,,嗨，我叫 Jack，我是 Strauss 的一年级学生。
Dialogue: 0,1:02:00.26,1:02:01.20,中文,,0,0,0,,嗨，我叫 Catherine。
Dialogue: 0,1:02:01.20,1:02:03.16,中文,,0,0,0,,我是 Strauss 的一年级学生。
Dialogue: 0,1:02:03.16,1:02:06.46,中文,,0,0,0,,嗨，我叫 Michael，我是 Pennypacker 的一年级学生。
Dialogue: 0,1:02:06.46,1:02:07.46,中文,,0,0,0,,嗨，我叫 Muhammad。
Dialogue: 0,1:02:07.46,1:02:09.17,中文,,0,0,0,,我是 Masseuse 的一年级学生。
Dialogue: 0,1:02:09.17,1:02:10.67,中文,,0,0,0,,好，欢迎大家。
Dialogue: 0,1:02:10.67,1:02:24.14,中文,,0,0,0,,好了，让我们考虑一下如何对我们这些志愿者进行排序，目标是将他们按从最小到最大的顺序排列，这样我们就可以使用比线性搜索更智能的方法。
Dialogue: 0,1:02:24.14,1:02:25.86,中文,,0,0,0,,我们可以使用二分查找。
Dialogue: 0,1:02:25.86,1:02:28.03,中文,,0,0,0,,假设他们已经排好序了。
Dialogue: 0,1:02:28.03,1:02:32.67,中文,,0,0,0,,让我们先考虑一个叫做选择排序的算法。
Dialogue: 0,1:02:32.67,1:02:43.56,中文,,0,0,0,,选择排序实际上是由我，或者说是由作为程序员的你，一次又一次地选择最小的元素，然后将它们放到适当的位置。
Dialogue: 0,1:02:43.56,1:02:47.24,中文,,0,0,0,,让我们从数字 7 开始。
Dialogue: 0,1:02:47.24,1:02:49.23,中文,,0,0,0,,目前，7 是我找到的最小数字。
Dialogue: 0,1:02:49.23,1:02:50.59,中文,,0,0,0,,我要记住这一点。
Dialogue: 0,1:02:50.59,1:02:52.59,中文,,0,0,0,,把它放在一个心理变量中。
Dialogue: 0,1:02:52.59,1:02:53.57,中文,,0,0,0,,我要继续了。
Dialogue: 0,1:02:53.57,1:02:55.03,中文,,0,0,0,,显然数字 2 更小。
Dialogue: 0,1:02:55.03,1:02:58.41,中文,,0,0,0,,所以我将在脑海中记住 2 是目前最小的数字。
Dialogue: 0,1:02:58.41,1:03:01.58,中文,,0,0,0,,暂时忘记数字 7。
Dialogue: 0,1:03:01.58,1:03:02.76,中文,,0,0,0,,5，不比它小。
Dialogue: 0,1:03:02.76,1:03:03.70,中文,,0,0,0,,4，不比它小。
Dialogue: 0,1:03:03.70,1:03:04.42,中文,,0,0,0,,1，比它小。
Dialogue: 0,1:03:04.42,1:03:06.36,中文,,0,0,0,,我要记住这一点。
Dialogue: 0,1:03:06.36,1:03:07.00,中文,,0,0,0,,6，不比它小。
Dialogue: 0,1:03:07.00,1:03:08.16,中文,,0,0,0,,0，更小。
Dialogue: 0,1:03:08.16,1:03:11.32,中文,,0,0,0,,记住这一点，现在其他数字都忘了。
Dialogue: 0,1:03:11.32,1:03:13.16,中文,,0,0,0,,现在数字 3 不比它小。
Dialogue: 0,1:03:13.16,1:03:14.74,中文,,0,0,0,,你叫什么名字？
Dialogue: 0,1:03:14.74,1:03:16.41,中文,,0,0,0,,Michael 的号码是 0。
Dialogue: 0,1:03:16.41,1:03:18.35,中文,,0,0,0,,他应该排在最前面。
Dialogue: 0,1:03:18.35,1:03:20.92,中文,,0,0,0,,你是？
Dialogue: 0,1:03:20.92,1:03:21.74,中文,,0,0,0,,Ryan？
Dialogue: 0,1:03:21.74,1:03:24.57,中文,,0,0,0,,Ryan 挡住了路，我们该怎么办？
Dialogue: 0,1:03:24.57,1:03:27.73,中文,,0,0,0,,我们应该如何排序这个列表？
Dialogue: 0,1:03:27.73,1:03:30.66,中文,,0,0,0,,数字 0 应该放在哪里？
Dialogue: 0,1:03:30.66,1:03:35.25,中文,,0,0,0,,你想说大声点吗？
Dialogue: 0,1:03:35.25,1:03:36.63,中文,,0,0,0,,我们直接交换吧。
Dialogue: 0,1:03:36.63,1:03:39.31,中文,,0,0,0,,你去数字 7 的位置。
Dialogue: 0,1:03:39.31,1:03:41.27,中文,,0,0,0,,我们需要给数字 7 腾出空间。
Dialogue: 0,1:03:41.27,1:03:45.70,中文,,0,0,0,,如果每个人都礼貌地往旁边挪一点，那就有点作弊了。
Dialogue: 0,1:03:45.70,1:03:46.04,中文,,0,0,0,,为什么？
Dialogue: 0,1:03:46.04,1:03:54.26,中文,,0,0,0,,因为如果我们将所有志愿者想象成一个数组，为了腾出一个位置而移动数组中的每个元素，工作量太大了。
Dialogue: 0,1:03:54.26,1:03:57.14,中文,,0,0,0,,所以我们保持简单，直接把原来位置上的那个人“赶走”。
Dialogue: 0,1:03:57.14,1:04:01.01,中文,,0,0,0,,也许我们很幸运，数字 7 实际上离它的目的地更近了。
Dialogue: 0,1:04:01.01,1:04:05.25,中文,,0,0,0,,也许我们不幸，它移动得更远了，但我们至少解决了一个问题。
Dialogue: 0,1:04:05.25,1:04:10.35,中文,,0,0,0,,如果我们最初有 n 个问题，现在我们有 n-1 个，因为数字 0 确实在正确的位置。
Dialogue: 0,1:04:10.35,1:04:15.46,中文,,0,0,0,,如果我继续这样做，比如我说 2，现在最小的。
Dialogue: 0,1:04:15.46,1:04:16.20,中文,,0,0,0,,5，不是。
Dialogue: 0,1:04:16.20,1:04:16.76,中文,,0,0,0,,4，也不是。
Dialogue: 0,1:04:16.76,1:04:18.00,中文,,0,0,0,,1，目前最小的。
Dialogue: 0,1:04:18.00,1:04:20.50,中文,,0,0,0,,我会记住的。
Dialogue: 0,1:04:20.50,1:04:21.74,中文,,0,0,0,,6，7，3。
Dialogue: 0,1:04:21.74,1:04:23.02,中文,,0,0,0,,现在我停一下。
Dialogue: 0,1:04:23.02,1:04:26.07,中文,,0,0,0,,1 显然是现在最小的元素。
Dialogue: 0,1:04:26.07,1:04:27.79,中文,,0,0,0,,我还需要继续吗？
Dialogue: 0,1:04:27.79,1:04:31.89,中文,,0,0,0,,事实证明，至少在我定义选择排序的方式中，我需要继续下去。
Dialogue: 0,1:04:31.89,1:04:36.67,中文,,0,0,0,,因为我只声称我在脑海中使用了一个变量来记住当时最小的元素。
Dialogue: 0,1:04:36.67,1:04:41.43,中文,,0,0,0,,我不像我们人类那样聪明，能够记住，等等，1 绝对是最小的。
Dialogue: 0,1:04:41.43,1:04:43.11,中文,,0,0,0,,现在，我没有全部的记忆。
Dialogue: 0,1:04:43.11,1:04:45.47,中文,,0,0,0,,所以我只是在跟踪现在最小的那个。
Dialogue: 0,1:04:45.47,1:04:47.11,中文,,0,0,0,,1 号，你叫什么名字？
Dialogue: 0,1:04:47.11,1:04:47.77,中文,,0,0,0,,Jack。
Dialogue: 0,1:04:47.77,1:04:49.44,中文,,0,0,0,,Jack 你应该去哪里？
Dialogue: 0,1:04:49.44,1:04:51.48,中文,,0,0,0,,应该在那里，你叫什么名字？
Dialogue: 0,1:04:51.48,1:04:51.95,中文,,0,0,0,,Itzel？
Dialogue: 0,1:04:51.95,1:04:57.41,中文,,0,0,0,,好的，Jack 和 Itzel，如果你们想交换位置，我们现在已经解决了 n 个总问题中的两个。
Dialogue: 0,1:04:57.41,1:05:02.49,中文,,0,0,0,,如果你们每个人都想在我找到合适的人选时开始交换，我们会做得更快一些。
Dialogue: 0,1:05:02.49,1:05:04.29,中文,,0,0,0,,5，最小。
Dialogue: 0,1:05:04.29,1:05:05.43,中文,,0,0,0,,4 更小。
Dialogue: 0,1:05:05.43,1:05:06.41,中文,,0,0,0,,2 更小。
Dialogue: 0,1:05:06.41,1:05:07.85,中文,,0,0,0,,得继续检查。
Dialogue: 0,1:05:07.85,1:05:09.84,中文,,0,0,0,,好的，2 更小。
Dialogue: 0,1:05:09.84,1:05:11.72,中文,,0,0,0,,现在我要回到开头。
Dialogue: 0,1:05:11.72,1:05:13.44,中文,,0,0,0,,好的，4 很小。
Dialogue: 0,1:05:13.44,1:05:14.28,中文,,0,0,0,,5 不是。
Dialogue: 0,1:05:14.28,1:05:14.74,中文,,0,0,0,,6 不是。
Dialogue: 0,1:05:14.74,1:05:15.04,中文,,0,0,0,,7 也不是。
Dialogue: 0,1:05:15.04,1:05:16.16,中文,,0,0,0,,哦，3 很小。
Dialogue: 0,1:05:16.16,1:05:17.88,中文,,0,0,0,,你想去哪里？
Dialogue: 0,1:05:17.88,1:05:18.76,中文,,0,0,0,,好的。
Dialogue: 0,1:05:18.76,1:05:19.92,中文,,0,0,0,,我要回到这里。
Dialogue: 0,1:05:19.92,1:05:21.18,中文,,0,0,0,,我可以聪明一点。
Dialogue: 0,1:05:21.18,1:05:24.87,中文,,0,0,0,,我不必一直走到最后，因为我知道这些人已经排好序了。
Dialogue: 0,1:05:24.87,1:05:26.67,中文,,0,0,0,,所以我可以至少稍微优化一下。
Dialogue: 0,1:05:26.67,1:05:29.17,中文,,0,0,0,,所以现在 5 很小，6 很小，7 是 4。
Dialogue: 0,1:05:29.17,1:05:33.19,中文,,0,0,0,,如果你想把它放在那里，4 更小。
Dialogue: 0,1:05:33.19,1:05:34.85,中文,,0,0,0,,现在事情变得有趣了。
Dialogue: 0,1:05:34.85,1:05:39.51,中文,,0,0,0,,我可以通过不再看这些人来优化，因为他们显然已经解决了问题。
Dialogue: 0,1:05:39.51,1:05:42.96,中文,,0,0,0,,但是现在 5 很小，6 不是，7 也不是。
Dialogue: 0,1:05:42.96,1:05:45.14,中文,,0,0,0,,好的，5，你可以待在原地。
Dialogue: 0,1:05:45.14,1:05:49.58,中文,,0,0,0,,现在，房间里的人显然会质疑我为什么要浪费更多时间。
Dialogue: 0,1:05:49.58,1:05:52.20,中文,,0,0,0,,但是根据我目前对选择排序的定义，
Dialogue: 0,1:05:52.20,1:05:55.99,中文,,0,0,0,,我仍然需要检查 6 是否最小，而不是 7。
Dialogue: 0,1:05:55.99,1:05:58.55,中文,,0,0,0,,现在我的最后一步，它们都到位了。
Dialogue: 0,1:05:58.55,1:06:05.11,中文,,0,0,0,,所以这里也有这种二分法，我们所有人都有这种对整个问题的鸟瞰图，很明显每个人都需要去哪里。
Dialogue: 0,1:06:05.11,1:06:09.19,中文,,0,0,0,,但使用数组实现这一点的计算机必须更加有条理。
Dialogue: 0,1:06:09.19,1:06:10.69,中文,,0,0,0,,我们实际上在这里节省了一个步骤。
Dialogue: 0,1:06:10.69,1:06:13.84,中文,,0,0,0,,如果我们真的这样做，这些数字都将不可见。
Dialogue: 0,1:06:13.84,1:06:16.84,中文,,0,0,0,,我们所有的八名志愿者都将被锁在一扇门内。
Dialogue: 0,1:06:16.84,1:06:19.28,中文,,0,0,0,,只有这样，我们才能一次看到一个。
Dialogue: 0,1:06:19.28,1:06:21.84,中文,,0,0,0,,我们现在只关注排序方面。
Dialogue: 0,1:06:21.84,1:06:29.70,中文,,0,0,0,,在我进行另一个演示之前，让我先提出，我刚才用伪代码所做的事情就像这样。
Dialogue: 0,1:06:29.70,1:06:38.31,中文,,0,0,0,,对于从 0 到 n-1 的 i，请记住 0 始终是数组的左侧，n-1 始终是数组的右端。
Dialogue: 0,1:06:38.31,1:06:45.73,中文,,0,0,0,,对于从 0 到 n-1 的 i，我找到了 numbers[i] 和 numbers[n-1] 之间的最小数字。
Dialogue: 0,1:06:45.73,1:06:48.61,中文,,0,0,0,,这是表达这种优化的非常书呆子的方式。
Dialogue: 0,1:06:48.61,1:06:51.61,中文,,0,0,0,,无论我在哪里，我总是从 numbers[i] 开始。
Dialogue: 0,1:06:51.61,1:06:53.35,中文,,0,0,0,,然后是右边的一切。
Dialogue: 0,1:06:53.35,1:06:57.11,中文,,0,0,0,,这就是允许我忽略已经排序的志愿者的原因。
Dialogue: 0,1:06:57.11,1:07:05.58,中文,,0,0,0,,但是，如果我的最后一行写着“将最小的数字与 numbers[i] 交换”，我认为这实现了我们的人通过走到另一个位置来实现的目标。
Dialogue: 0,1:07:05.58,1:07:09.38,中文,,0,0,0,,好了，这就是我们所说的选择排序。
Dialogue: 0,1:07:09.38,1:07:13.36,中文,,0,0,0,,让我们继续，使用我将称之为冒泡排序的算法进行第二种方法。
Dialogue: 0,1:07:13.36,1:07:16.08,中文,,0,0,0,,要做到这一点，我们需要你们所有人都回到原来的位置。
Dialogue: 0,1:07:16.08,1:07:20.00,中文,,0,0,0,,如果你想回到这个位置，我们在黑板上有一个小抄。
Dialogue: 0,1:07:20.00,1:07:26.67,中文,,0,0,0,,让我采取一种根本不同的方法，因为我真的不太喜欢选择排序，因为它需要来回走动很多次。
Dialogue: 0,1:07:26.67,1:07:30.71,中文,,0,0,0,,走动很多意味着要一遍又一遍地走很多步。
Dialogue: 0,1:07:30.71,1:07:31.99,中文,,0,0,0,,那我可以怎么做呢？
Dialogue: 0,1:07:31.99,1:07:38.15,中文,,0,0,0,,冒泡排序让我更直观地关注较小的问题。让我们看看这样是否能帮我找到方向。
Dialogue: 0,1:07:38.15,1:07:43.61,中文,,0,0,0,,如果只看 7 和 2，不看其他数字，这显然是个问题。
Dialogue: 0,1:07:43.61,1:07:44.29,中文,,0,0,0,,为什么？
Dialogue: 0,1:07:44.29,1:07:45.41,中文,,0,0,0,,因为它们的顺序不对。
Dialogue: 0,1:07:45.41,1:07:49.75,中文,,0,0,0,,我们先解决一个小问题。7 和 2，为什么不交换一下呢？
Dialogue: 0,1:07:49.75,1:07:54.26,中文,,0,0,0,,我知道 2 现在的位置更合适，因为它肯定比 7 小。
Dialogue: 0,1:07:54.26,1:07:55.78,中文,,0,0,0,,所以我觉得现在可以继续了。
Dialogue: 0,1:07:55.78,1:07:57.26,中文,,0,0,0,,7 和 5，有问题。
Dialogue: 0,1:07:57.26,1:07:58.82,中文,,0,0,0,,我们来解决它。
Dialogue: 0,1:07:58.82,1:07:59.84,中文,,0,0,0,,7 和 4，有问题。
Dialogue: 0,1:07:59.84,1:08:00.98,中文,,0,0,0,,我们来解决它。
Dialogue: 0,1:08:00.98,1:08:02.82,中文,,0,0,0,,7 和 1，我们来解决它。
Dialogue: 0,1:08:02.82,1:08:03.92,中文,,0,0,0,,7 和 6，我们来解决它。
Dialogue: 0,1:08:03.92,1:08:05.30,中文,,0,0,0,,7 和 0，解决它。
Dialogue: 0,1:08:05.30,1:08:06.60,中文,,0,0,0,,7 和 3，解决它。
Dialogue: 0,1:08:06.60,1:08:07.42,中文,,0,0,0,,好了，完成了。
Dialogue: 0,1:08:07.42,1:08:09.21,中文,,0,0,0,,排序好了，对吧？
Dialogue: 0,1:08:09.21,1:08:11.81,中文,,0,0,0,,显然没有，只要你看一眼这些数字就知道了。
Dialogue: 0,1:08:11.81,1:08:15.08,中文,,0,0,0,,我们已经从根本上解决了一部分问题。
Dialogue: 0,1:08:15.08,1:08:17.02,中文,,0,0,0,,7 的确在正确的位置。
Dialogue: 0,1:08:17.02,1:08:21.38,中文,,0,0,0,,所以我们最多还有 n-1 个问题要解决。
Dialogue: 0,1:08:21.38,1:08:23.64,中文,,0,0,0,,那我该怎么做呢？
Dialogue: 0,1:08:23.64,1:08:37.05,中文,,0,0,0,,我想我可以重复同样的逻辑。让我来看看。2 和 5，可以。5 和 4，不行。5 和 1，不行。5 和 6，可以。6 和 0，不行。6 和 3，不行。
Dialogue: 0,1:08:37.05,1:08:39.37,中文,,0,0,0,,现在我们已经解决了两个问题。
Dialogue: 0,1:08:39.37,1:08:42.60,中文,,0,0,0,,冒泡排序的优点是，至少乍一看，它简洁明了。
Dialogue: 0,1:08:42.60,1:08:46.70,中文,,0,0,0,,它简洁且局部化。你只需不断地逐步解决越来越多的问题。
Dialogue: 0,1:08:46.70,1:08:47.98,中文,,0,0,0,,让我们继续，再来一次。
Dialogue: 0,1:08:47.98,1:08:50.38,中文,,0,0,0,,我们可以做得更快。
Dialogue: 0,1:08:50.38,1:08:51.72,中文,,0,0,0,,我们知道 2 和 4 是没问题的。
Dialogue: 0,1:08:51.72,1:08:56.15,中文,,0,0,0,,4 和 1。4 和 5。5 和 0。5 和 3。5 和 6。6 和 7。很好。我们回去。2 和 1。
Dialogue: 0,1:08:56.15,1:08:58.49,中文,,0,0,0,,又解决了一个问题。
Dialogue: 0,1:08:58.49,1:09:09.93,中文,,0,0,0,,2 和 4。4 和 0，4 和 3，4 和 5，5 和 6，6 和 7。
Dialogue: 0,1:09:09.93,1:09:15.28,中文,,0,0,0,,正如它的名字一样，最大的元素已经“冒泡”到了顶部。
Dialogue: 0,1:09:15.28,1:09:18.34,中文,,0,0,0,,这就是我们在解决剩余问题时所看到的情况。
Dialogue: 0,1:09:18.34,1:09:26.19,中文,,0,0,0,,快完成了。1 和 2，2 和 0。2 和 3，3 和 4，4 和 5，5 和 6，6 和 7。
Dialogue: 0,1:09:26.19,1:09:27.71,中文,,0,0,0,,快完成了。
Dialogue: 0,1:09:27.71,1:09:29.99,中文,,0,0,0,,显然，在我们人类看来，它已经完成了。
Dialogue: 0,1:09:29.99,1:09:32.73,中文,,0,0,0,,作为计算机，我怎么才能确定呢？
Dialogue: 0,1:09:32.73,1:09:34.77,中文,,0,0,0,,对我来说，现在最万无一失的方法是什么？
Dialogue: 0,1:09:34.77,1:09:35.59,中文,,0,0,0,,还没完。
Dialogue: 0,1:09:35.59,1:09:36.51,中文,,0,0,0,,抱歉。
Dialogue: 0,1:09:36.51,1:09:38.00,中文,,0,0,0,,这是个 bug。
Dialogue: 0,1:09:38.00,1:09:40.38,中文,,0,0,0,,好，1 和 0。
Dialogue: 0,1:09:40.38,1:09:43.36,中文,,0,0,0,,好，1 和 2，2 和 3，3 和 4，4 和 5，5 和 6，6 和 7。
Dialogue: 0,1:09:43.36,1:09:48.07,中文,,0,0,0,,好，现在对我们台上其他人来说，这显然是排好序了。
Dialogue: 0,1:09:48.07,1:09:50.29,中文,,0,0,0,,我怎样才能在代码中确认这一点呢？
Dialogue: 0,1:09:50.29,1:09:52.69,中文,,0,0,0,,你在用你的大脑，仅仅是扫一眼就知道了。
Dialogue: 0,1:09:52.69,1:09:56.17,中文,,0,0,0,,计算机，代码，如何才能确定这个列表现在是有序的？
Dialogue: 0,1:09:56.17,1:09:58.45,中文,,0,0,0,,嗯？
Dialogue: 0,1:09:58.45,1:10:05.63,中文,,0,0,0,,我们再做一次，然后得出什么结论？
Dialogue: 0,1:10:05.63,1:10:08.91,中文,,0,0,0,,我们再做一次，虽然这有点浪费。
Dialogue: 0,1:10:08.91,1:10:18.46,中文,,0,0,0,,逻辑上，如果我一遍又一遍地遍历整个列表比较对，而且那次我没有做任何工作，那么现在从逻辑上讲，显然可以安全地停下来。
Dialogue: 0,1:10:18.46,1:10:23.30,中文,,0,0,0,,因为否则，如果没有人真的在移动，我就是在浪费时间一遍又一遍地做同样的事情。
Dialogue: 0,1:10:23.30,1:10:26.66,中文,,0,0,0,,恐怕我们没有 Monopoly 游戏给你们所有人，但我们有 8 个压力球。
Dialogue: 0,1:10:26.66,1:10:30.10,中文,,0,0,0,,如果可以的话，请为我们的志愿者们鼓掌。
Dialogue: 0,1:10:30.10,1:10:33.97,中文,,0,0,0,,如果你们想把你们的数字放在架子上。
Dialogue: 0,1:10:33.97,1:10:36.70,中文,,0,0,0,,如果我们考虑一下，谢谢。
Dialogue: 0,1:10:36.70,1:10:39.26,中文,,0,0,0,,非常感谢。
Dialogue: 0,1:10:39.26,1:10:42.14,中文,,0,0,0,,好的。
Dialogue: 0,1:10:42.14,1:10:44.44,中文,,0,0,0,,谢谢。谢谢。
Dialogue: 0,1:10:44.44,1:10:48.93,中文,,0,0,0,,那么如果我们现在考虑这两种算法，哪个更好？
Dialogue: 0,1:10:48.93,1:10:56.07,中文,,0,0,0,,对于选择排序（第一个）比冒泡排序（第二个）更好还是更差，有什么直觉吗？
Dialogue: 0,1:10:56.07,1:10:58.17,中文,,0,0,0,,有什么想法吗？
Dialogue: 0,1:10:58.17,1:11:03.02,中文,,0,0,0,,有吗？
Dialogue: 0,1:11:03.02,1:11:09.00,中文,,0,0,0,,冒泡排序看起来工作量更少，尤其是我专注于那些局部问题的时候。
Dialogue: 0,1:11:09.00,1:11:11.57,中文,,0,0,0,,其他直觉呢？
Dialogue: 0,1:11:11.57,1:11:14.72,中文,,0,0,0,,选择排序与冒泡排序相比。
Dialogue: 0,1:11:14.72,1:11:19.30,中文,,0,0,0,,让我提出，我们尝试量化它，以便我们可以用某种方式实际分析它。
Dialogue: 0,1:11:19.30,1:11:22.58,中文,,0,0,0,,对于许多算法，我们不会经常进行这种练习。
Dialogue: 0,1:11:22.58,1:11:24.84,中文,,0,0,0,,这些算法很有代表性。
Dialogue: 0,1:11:24.84,1:11:28.86,中文,,0,0,0,,所以我们确实可以理解这些东西的性能或设计。
Dialogue: 0,1:11:28.86,1:11:34.40,中文,,0,0,0,,这是我的 SelectionSort 伪代码，顾名思义，
Dialogue: 0,1:11:34.40,1:11:38.63,中文,,0,0,0,,我只是迭代地一次又一次地选择下一个最小的元素。
Dialogue: 0,1:11:38.63,1:11:41.79,中文,,0,0,0,,那么我们如何分析这样的东西呢？
Dialogue: 0,1:11:41.79,1:11:48.15,中文,,0,0,0,,我们可以用纸笔计算一下代码逻辑上隐含的步骤数。
Dialogue: 0,1:11:48.15,1:11:53.04,中文,,0,0,0,,我们可以从左到右，数一下我一次又一次采取的步骤数。
Dialogue: 0,1:11:53.04,1:11:55.98,中文,,0,0,0,,我们也可以只计算比较的次数。
Dialogue: 0,1:11:55.98,1:11:58.58,中文,,0,0,0,,我把每个参与的人都比较了一遍。
Dialogue: 0,1:11:58.58,1:12:00.66,中文,,0,0,0,,我在选择排序中做得很快。
Dialogue: 0,1:12:00.66,1:12:11.87,中文,,0,0,0,,每次我要决定是否要记住一个数是最小的数时，我都在比较两个值，用的是等于等于、小于或大于号，至少如果我们用代码来实现的话是这样。
Dialogue: 0,1:12:11.87,1:12:16.65,中文,,0,0,0,,所以在分析这类算法时，计算比较次数往往是一种常见做法。
Dialogue: 0,1:12:16.65,1:12:23.70,中文,,0,0,0,,因为它是一种我们可以用来比较不同算法的全局度量单位。
Dialogue: 0,1:12:23.70,1:12:37.79,中文,,0,0,0,,想象一下，通常情况下，当我们有超过 8 个志愿者，超过 7 扇门时，我们可以将数组概括为：第一个元素在方括号0处，最后一个元素始终是 n - 1。
Dialogue: 0,1:12:37.79,1:12:47.32,中文,,0,0,0,,所以数组，或者说这里的门，或者说志愿者，总是从 0 开始到 n - 1 进行数字索引，如果总共有 n 个元素的话。
Dialogue: 0,1:12:47.32,1:12:51.14,中文,,0,0,0,,那么我们如何分析选择排序的代码呢？
Dialogue: 0,1:12:51.14,1:12:56.43,中文,,0,0,0,,我花了多少步找到第一个最小的元素？
Dialogue: 0,1:12:56.43,1:13:06.19,中文,,0,0,0,,或者更准确地说，当我从左向右走，找到第一个最小的人，也就是 0 时，我需要进行多少次比较？
Dialogue: 0,1:13:06.19,1:13:09.35,中文,,0,0,0,,从左向右走，我进行了多少次比较？
Dialogue: 0,1:13:09.35,1:13:15.93,中文,,0,0,0,,如果台上站着八个人，我总共进行了多少次比较？
Dialogue: 0,1:13:15.93,1:13:22.40,中文,,0,0,0,,比如，如果有八个人，我比较了这两个人，然后是这个人，这个人，是的。
Dialogue: 0,1:13:22.40,1:13:23.72,中文,,0,0,0,,是的，所以总共是七次，对吧？
Dialogue: 0,1:13:23.72,1:13:29.89,中文,,0,0,0,,因为如果台上站着八个人，你总共只能进行七次比较，否则你就会把一个数字和它自己进行比较。
Dialogue: 0,1:13:29.89,1:13:38.55,中文,,0,0,0,,因此，在一般情况下，如果你要对 n 个数字进行排序，首先找到最小的元素需要进行 n - 1 次比较。
Dialogue: 0,1:13:38.55,1:13:46.18,中文,,0,0,0,,也许从左到右总共需要 n 步，我认为比较次数是一个很有用的度量单位，它是 n - 1。
Dialogue: 0,1:13:46.18,1:13:48.70,中文,,0,0,0,,找到下一个最小的数呢？
Dialogue: 0,1:13:48.70,1:13:53.10,中文,,0,0,0,,我花了多少步找到下一个最小的数，也就是数字 1？
Dialogue: 0,1:13:53.10,1:13:58.40,中文,,0,0,0,,是吗？
Dialogue: 0,1:13:58.40,1:13:59.58,中文,,0,0,0,,是的，所以只需要 n - 2。
Dialogue: 0,1:13:59.58,1:14:01.63,中文,,0,0,0,,为什么？因为我已经解决了一个问题。
Dialogue: 0,1:14:01.63,1:14:03.07,中文,,0,0,0,,已经有人就位了。
Dialogue: 0,1:14:03.07,1:14:05.53,中文,,0,0,0,,再一遍遍地数就太蠢了。
Dialogue: 0,1:14:05.53,1:14:09.33,中文,,0,0,0,,所以我可以把下一轮比较的次数减少到 n - 2 次。
Dialogue: 0,1:14:09.33,1:14:12.33,中文,,0,0,0,,第三轮找到第三小的数字需要 n - 3 次比较。
Dialogue: 0,1:14:12.33,1:14:13.65,中文,,0,0,0,,以此类推。
Dialogue: 0,1:14:13.65,1:14:17.63,中文,,0,0,0,,假设这个故事，这个公式，在你只剩下一组
Dialogue: 0,1:14:17.63,1:14:19.73,中文,,0,0,0,,最后两个人要比较的时候结束。
Dialogue: 0,1:14:19.73,1:14:33.64,中文,,0,0,0,,如果这让你想起了高中数学或物理中某种递归，那么我可以告诉你，如果你真的把这个数学题做出来并进行概括，它就等于 n( n - 1)/ 2。
Dialogue: 0,1:14:33.64,1:14:35.00,中文,,0,0,0,,如果你对这个公式不熟悉，没关系。
Dialogue: 0,1:14:35.00,1:14:37.82,中文,,0,0,0,,只要记住，任何时候你把
Dialogue: 0,1:14:37.82,1:14:46.64,中文,,0,0,0,,这种级数加起来，一个数加上一个略小的数，再加上一个更小的数，每个数都相差 1，你就会得到这个公式，n( n - 1)/ 2。
Dialogue: 0,1:14:46.64,1:14:51.68,中文,,0,0,0,,当然，如果我们把它乘出来，那就是 (n² - n)/ 2。
Dialogue: 0,1:14:51.68,1:14:56.69,中文,,0,0,0,,如果我们继续把它乘出来，那就是 n² /2 － n/2。
Dialogue: 0,1:14:56.69,1:15:00.43,中文,,0,0,0,,现在我们有了一些词汇可以用来
Dialogue: 0,1:15:00.43,1:15:03.27,中文,,0,0,0,,讨论这个算法的效率和设计。
Dialogue: 0,1:15:03.27,1:15:09.55,中文,,0,0,0,,说实话，我不太关心这种精确度，比如 n² /2 － n/2。
Dialogue: 0,1:15:09.55,1:15:20.54,中文,,0,0,0,,当 n 变得非常大时，这些符号，哪些项会真正占主导地位，成为步骤总数的最大影响因素？
Dialogue: 0,1:15:20.54,1:15:21.70,中文,,0,0,0,,对，是平方，对吧？
Dialogue: 0,1:15:21.70,1:15:23.38,中文,,0,0,0,,很明显，它不是 n/2。
Dialogue: 0,1:15:23.38,1:15:24.58,中文,,0,0,0,,这节省了一些时间。
Dialogue: 0,1:15:24.58,1:15:27.80,中文,,0,0,0,,但随着 n 变大，n² 会变得非常大。
Dialogue: 0,1:15:27.80,1:15:29.98,中文,,0,0,0,,如果 n 是 100，那么 n² 会更大。
Dialogue: 0,1:15:29.98,1:15:32.66,中文,,0,0,0,,如果 n 是一百万，n² 就更大了。
Dialogue: 0,1:15:32.66,1:15:45.91,中文,,0,0,0,,最后，当我们只是粗略地分析时，可以将选择排序的上限看作是 n² 步。
Dialogue: 0,1:15:45.91,1:15:47.85,中文,,0,0,0,,它不完全是 n² 步。
Dialogue: 0,1:15:47.85,1:15:48.71,中文,,0,0,0,,但是你知道吗？
Dialogue: 0,1:15:48.71,1:15:55.48,中文,,0,0,0,,n²/2，这里的直觉可能是它就是 n² 的一半。
Dialogue: 0,1:15:55.48,1:15:58.76,中文,,0,0,0,,当 n 变得非常非常大的时候，真正重要的是 n²。
Dialogue: 0,1:15:58.76,1:16:02.23,中文,,0,0,0,,当你开始思考并尝试解决 Google 级别的问题时，就会遇到这种情况。
Dialogue: 0,1:16:02.23,1:16:07.71,中文,,0,0,0,,当 n 变大时，你必须比仅仅使用任何算法的天真实现更聪明。
Dialogue: 0,1:16:07.71,1:16:12.38,中文,,0,0,0,,那么，这个算法属于哪种分类呢？
Dialogue: 0,1:16:12.38,1:16:19.84,中文,,0,0,0,,事实证明，在最坏情况下，无论是否排序，n² 都属于 n² 步的量级。
Dialogue: 0,1:16:19.84,1:16:24.29,中文,,0,0,0,,不过，事实证明，如果我们考虑相同的代码，下限是，
Dialogue: 0,1:16:24.29,1:16:42.84,中文,,0,0,0,,假设是最佳情况，比如我们的八名志愿者走上舞台，\N并且因为他们已经按照 0 到 7 排好了队，假设他们碰巧处于这种状态，选择排序需要多少步才能对已经排好序的志愿者列表进行排序？
Dialogue: 0,1:16:42.84,1:16:47.96,中文,,0,0,0,,有什么想法吗？
Dialogue: 0,1:16:47.96,1:16:51.34,中文,,0,0,0,,还会是 n 吗？
Dialogue: 0,1:16:51.34,1:17:04.00,中文,,0,0,0,,对于第一次遍历，仍然是 7，因为即使我声称 0 在这里，但我不知道 0 是否是最小的，直到我一路走到那里，做了所有七次比较。
Dialogue: 0,1:17:04.00,1:17:04.90,中文,,0,0,0,,好的。
Dialogue: 0,1:17:04.90,1:17:08.36,中文,,0,0,0,,第一次遍历需要 7 步，或者更一般地说，n-1 步。
Dialogue: 0,1:17:08.36,1:17:14.54,中文,,0,0,0,,如果我寻找下一个最小的元素，并且在这个例子中，人们已经按照 0 到 7 排好了序呢？
Dialogue: 0,1:17:14.54,1:17:17.73,中文,,0,0,0,,没错，数字 1 在这里，我第一个看到它们。
Dialogue: 0,1:17:17.73,1:17:23.93,中文,,0,0,0,,我不知道它们是最小的，直到我与其他所有数字进行比较，到达列表的末尾，然后意识到，好吧，那太蠢了。
Dialogue: 0,1:17:23.93,1:17:26.69,中文,,0,0,0,,那时我已经找到了最小的数字。
Dialogue: 0,1:17:26.69,1:17:31.62,中文,,0,0,0,,所以这段伪代码，这个选择排序的实现，就是这样固定的。
Dialogue: 0,1:17:31.62,1:17:35.66,中文,,0,0,0,,没有特殊情况说，如果已经排序，就提前退出。
Dialogue: 0,1:17:35.66,1:17:37.86,中文,,0,0,0,,它总是需要 n² 步。
Dialogue: 0,1:17:37.86,1:17:44.03,中文,,0,0,0,,所以在这种情况下，如果我们借用前面使用 Ω 符号的术语，
Dialogue: 0,1:17:44.03,1:17:50.78,中文,,0,0,0,,需要明确的是，在这个版本中，选择排序也将是 Ω(n²)。
Dialogue: 0,1:17:50.78,1:18:01.85,中文,,0,0,0,,因为即使在最好的情况下，列表已经排序，你也要浪费大量的时间来验证，或者说是发现，即使我们人类一眼就能看出来。
Dialogue: 0,1:18:01.85,1:18:08.76,中文,,0,0,0,,因此，选择排序在最坏情况下似乎需要 n² 步，在最好情况下也需要 n² 步。
Dialogue: 0,1:18:08.76,1:18:11.42,中文,,0,0,0,,你知道吗？我们可以用 Θ 符号来表示。
Dialogue: 0,1:18:11.42,1:18:19.67,中文,,0,0,0,,这里有一个算法，就像之前的计数一样，它总是需要 n² 步，无论数组从一开始是否排序。
Dialogue: 0,1:18:19.67,1:18:21.35,中文,,0,0,0,,希望我们能做得更好。
Dialogue: 0,1:18:21.35,1:18:25.65,中文,,0,0,0,,之前有人提出冒泡排序感觉像是在使用更少的步骤。
Dialogue: 0,1:18:25.65,1:18:28.39,中文,,0,0,0,,好吧，接下来让我们考虑一下使用冒泡排序，
Dialogue: 0,1:18:28.39,1:18:33.86,中文,,0,0,0,,我们有这段伪代码，我声称，首先让我们关注代码的内部。
Dialogue: 0,1:18:33.86,1:18:36.24,中文,,0,0,0,,在这里，我在做什么？
Dialogue: 0,1:18:36.24,1:18:40.18,中文,,0,0,0,,对于从 0 到 n-2 的 i。
Dialogue: 0,1:18:40.18,1:18:40.72,中文,,0,0,0,,这很奇怪。
Dialogue: 0,1:18:40.72,1:18:42.38,中文,,0,0,0,,我们之前没见过 n-2。
Dialogue: 0,1:18:42.38,1:18:44.06,中文,,0,0,0,,我问了这个问题。
Dialogue: 0,1:18:44.06,1:18:50.41,中文,,0,0,0,,如果数字 [i] 和数字 [i + 1] 的顺序不对，就交换它们。
Dialogue: 0,1:18:50.41,1:18:53.67,中文,,0,0,0,,所以那是我指着我们这里的前两名志愿者的时候。
Dialogue: 0,1:18:53.67,1:18:57.30,中文,,0,0,0,,我看到他们的顺序不对，所以我交换了他们。
Dialogue: 0,1:18:57.30,1:19:09.83,中文,,0,0,0,,为什么我要一次又一次地这样做，直到 n-2，而不是 n-1，而到目前为止我们一直使用 n-1 作为我们最右边的边界？
Dialogue: 0,1:19:09.83,1:19:14.20,中文,,0,0,0,,对于我为什么从 0 到 n-2 这样做，有什么直觉吗？
Dialogue: 0,1:19:14.20,1:19:15.38,中文,,0,0,0,,是吗?
Dialogue: 0,1:19:21.28,1:19:31.45,中文,,0,0,0,,没错，因为我根据这里的伪代码，我查看的是第 i 个人和第 i+1 个人，我最好确保我没有超出数组的边界。
Dialogue: 0,1:19:31.45,1:19:41.50,中文,,0,0,0,,如果你想想我的左手，当我背对着这里，指着第一个位置的当前的人，我的右手，对于这个 if 条件，本质上是指着他们旁边的人。
Dialogue: 0,1:19:41.50,1:19:44.75,中文,,0,0,0,,你想用你的左手遍历所有这些人。
Dialogue: 0,1:19:44.75,1:19:47.73,中文,,0,0,0,,你不希望你的左手指向最后一个人。
Dialogue: 0,1:19:47.73,1:19:50.03,中文,,0,0,0,,你希望它指向倒数第二个人。
Dialogue: 0,1:19:50.03,1:19:54.47,中文,,0,0,0,,我们知道最后一个人总是在 n-1 处。
Dialogue: 0,1:19:54.47,1:19:57.81,中文,,0,0,0,,从数学上讲，倒数第二个人在 n-2 处。
Dialogue: 0,1:19:57.81,1:19:58.89,中文,,0,0,0,,所以这是一个微妙之处。
Dialogue: 0,1:19:58.89,1:20:00.87,中文,,0,0,0,,这就像一个等待发生的段错误。
Dialogue: 0,1:20:00.87,1:20:04.40,中文,,0,0,0,,如果你使用 n-1 实现冒泡排序，就会这样。
Dialogue: 0,1:20:04.40,1:20:07.26,中文,,0,0,0,,我的右手会超出数组的边界。
Dialogue: 0,1:20:07.26,1:20:08.26,中文,,0,0,0,,所以很糟糕。
Dialogue: 0,1:20:08.26,1:20:10.38,中文,,0,0,0,,为什么要说 n 次？
Dialogue: 0,1:20:10.38,1:20:13.00,中文,,0,0,0,,我们之前是用人来演示的。
Dialogue: 0,1:20:13.00,1:20:23.10,中文,,0,0,0,,每次有人，也就是每次遍历数组，都会有一个数字冒泡到最后，先是数字 7，然后是数字 6，然后是数字 5。
Dialogue: 0,1:20:23.10,1:20:34.55,中文,,0,0,0,,如果每次遍历志愿者数组都能解决至少一个问题，那么冒泡排序似乎总共只需要运行 n 次就可以解决所有 n 个问题。
Dialogue: 0,1:20:34.55,1:20:36.95,中文,,0,0,0,,因为第一次遍历至少会将一个数字放到正确的位置。
Dialogue: 0,1:20:36.95,1:20:38.43,中文,,0,0,0,,第二次遍历，第二个数字归位。
Dialogue: 0,1:20:38.43,1:20:40.14,中文,,0,0,0,,你可能很幸运，它会做得更多。
Dialogue: 0,1:20:40.14,1:20:41.76,中文,,0,0,0,,在最坏的情况下，这似乎也足够了。
Dialogue: 0,1:20:41.76,1:20:46.38,中文,,0,0,0,,只要盲目地做 n 次，它们就会排列整齐。
Dialogue: 0,1:20:46.38,1:20:49.86,中文,,0,0,0,,严格来说，我们现在要深入细节了。
Dialogue: 0,1:20:49.86,1:20:52.10,中文,,0,0,0,,严格来说，你只需要重复 n - 1 次。
Dialogue: 0,1:20:52.10,1:20:58.89,中文,,0,0,0,,因为如果你解决了所有 n - 1 个其他的问题，只剩下 1 个，从逻辑上讲，那个人已经在他们需要的位置上了。
Dialogue: 0,1:20:58.89,1:21:02.47,中文,,0,0,0,,如果你已经对其他所有内容进行了排序，只剩下 1 个，它就已经冒泡了。
Dialogue: 0,1:21:02.47,1:21:03.87,中文,,0,0,0,,那么如何分析呢？
Dialogue: 0,1:21:03.87,1:21:06.84,中文,,0,0,0,,在冒泡排序中，我们可能会这样做。
Dialogue: 0,1:21:06.84,1:21:11.56,中文,,0,0,0,,我实际上是在做 n - 1 次 (n - 1) 件事。
Dialogue: 0,1:21:11.56,1:21:15.16,中文,,0,0,0,,现在，让我回到伪代码，因为这一点不太明显。
Dialogue: 0,1:21:15.16,1:21:21.03,中文,,0,0,0,,在这里，你可以从循环中数学地推断出你正在进行多少步。
Dialogue: 0,1:21:21.03,1:21:25.01,中文,,0,0,0,,所以第一行字面意思是，将以下内容重复 n - 1 次。
Dialogue: 0,1:21:25.01,1:21:30.42,中文,,0,0,0,,所以这将非常直接地转化为我们的数学公式。 做 n-1 次。
Dialogue: 0,1:21:30.42,1:21:35.90,中文,,0,0,0,,这个循环，因为我用了 for 循环的术语，所以它的框架略有不同。
Dialogue: 0,1:21:35.90,1:21:40.08,中文,,0,0,0,,如果你从 0 迭代到 n-2，
Dialogue: 0,1:21:40.08,1:21:43.69,中文,,0,0,0,,你总共迭代了 n-1 次。
Dialogue: 0,1:21:43.69,1:21:48.57,中文,,0,0,0,,再说一次，算术有点烦人，这仅仅意味着将以下操作执行 n-1 次。
Dialogue: 0,1:21:48.57,1:21:54.51,中文,,0,0,0,,所以做 n-1 件事，做 n-1 次，现在我们可以得出如下公式。
Dialogue: 0,1:21:54.51,1:21:57.95,中文,,0,0,0,,我们有公式 (n-1) × (n-1)。
Dialogue: 0,1:21:57.95,1:22:03.26,中文,,0,0,0,,我们在这里使用 FOIL 方法，n²-1×n-1×n+1。
Dialogue: 0,1:22:03.26,1:22:06.66,中文,,0,0,0,,我们可以合并同类项，n²-2n+1。
Dialogue: 0,1:22:06.66,1:22:10.89,中文,,0,0,0,,在这一点上，当 n 变得非常大时，我们真正关心的是哪一项？
Dialogue: 0,1:22:10.89,1:22:13.46,中文,,0,0,0,,它的数量级是。
Dialogue: 0,1:22:13.46,1:22:14.92,中文,,0,0,0,,是的，n²。
Dialogue: 0,1:22:14.92,1:22:25.39,中文,,0,0,0,,所以至少渐近地，渐近地意味着当 n 趋近于无穷大时，变得非常大，结果是选择排序和冒泡排序的上界本质上是相同的。
Dialogue: 0,1:22:25.39,1:22:29.81,中文,,0,0,0,,现在，如果我们真的吹毛求疵，比较总的比较次数，它们可能略有不同。
Dialogue: 0,1:22:29.81,1:22:36.48,中文,,0,0,0,,当 n 变得很大时，老实说，你几乎不会注意到这两种算法之间的区别。
Dialogue: 0,1:22:36.48,1:22:38.50,中文,,0,0,0,,但是呢？
Dialogue: 0,1:22:38.50,1:22:39.66,中文,,0,0,0,,下界。
Dialogue: 0,1:22:39.66,1:22:45.38,中文,,0,0,0,,如果冒泡排序的上界也是 O(n²)，那么这里的下界呢？
Dialogue: 0,1:22:45.38,1:22:50.25,中文,,0,0,0,,那么，对于这段伪代码，冒泡排序的下界是什么？
Dialogue: 0,1:22:50.25,1:22:54.05,中文,,0,0,0,,即使在最好的情况下，当所有的志愿者都排好序时。
Dialogue: 0,1:22:54.05,1:22:56.89,中文,,0,0,0,,有什么直观的想法吗？
Dialogue: 0,1:22:56.89,1:22:59.09,中文,,0,0,0,,在这个伪代码中？ 对，在中间部分。
Dialogue: 0,1:23:06.36,1:23:12.93,中文,,0,0,0,,问得好，冒泡排序的设计初衷不就是不需要比较已经冒泡到位的数字吗？
Dialogue: 0,1:23:12.93,1:23:17.11,中文,,0,0,0,,这就是中间部分隐含的内容。
Dialogue: 0,1:23:17.11,1:23:19.39,中文,,0,0,0,,我总是从左到右进行比较。
Dialogue: 0,1:23:19.39,1:23:26.24,中文,,0,0,0,,请记住，即使我在最后搞砸了，最后两个人顺序错误，我也总是需要从头开始重新排序。
Dialogue: 0,1:23:26.24,1:23:33.37,中文,,0,0,0,,因为大的数字会往那边移动，小的数字会往这边移动。
Dialogue: 0,1:23:33.37,1:23:34.07,中文,,0,0,0,,是的，没错。
Dialogue: 0,1:23:34.07,1:23:37.54,中文,,0,0,0,,这里有一些轻微的优化，我稍微略过了一下。
Dialogue: 0,1:23:37.54,1:23:40.70,中文,,0,0,0,,我断言它最终的时间复杂度仍然是 n 的平方级。
Dialogue: 0,1:23:40.70,1:23:44.12,中文,,0,0,0,,这肯定会减少一些实际的运行时间。
Dialogue: 0,1:23:44.12,1:23:46.44,中文,,0,0,0,,如果列表已经排序了呢？
Dialogue: 0,1:23:46.44,1:23:51.18,中文,,0,0,0,,我们目前的伪代码没有考虑到如果列表已经排序就提前退出的情况。
Dialogue: 0,1:23:51.18,1:23:58.91,中文,,0,0,0,,所以除非我们修改伪代码，就像我之前口头说的那样，否则我们将盲目地执行 n-1 次 n-1 次操作。
Dialogue: 0,1:23:58.91,1:24:00.17,中文,,0,0,0,,我建议这样做。
Dialogue: 0,1:24:00.17,1:24:10.51,中文,,0,0,0,,在外部循环中，如果你遍历了所有志愿者，并且你的计数器没有进行任何交换（你需要使用某种变量来跟踪），那么你就可以停止了。
Dialogue: 0,1:24:10.51,1:24:17.91,中文,,0,0,0,,因为如果你进行了一次完整的遍历并且没有进行任何交换，为什么还要浪费时间再次执行，期待不同的结果呢？
Dialogue: 0,1:24:17.91,1:24:20.62,中文,,0,0,0,,为了帮助大家理解。
Dialogue: 0,1:24:20.62,1:24:26.64,中文,,0,0,0,,因此，如果数据已经排序或大部分排序，冒泡排序就会更有利。
Dialogue: 0,1:24:26.64,1:24:27.24,中文,,0,0,0,,为什么？
Dialogue: 0,1:24:27.24,1:24:31.54,中文,,0,0,0,,因为至少在我们这样实现它的时候，它确实有这个短路细节。
Dialogue: 0,1:24:31.54,1:24:36.41,中文,,0,0,0,,我们如何才能更清楚地将这些东西可视化呢？
Dialogue: 0,1:24:36.41,1:24:37.57,中文,,0,0,0,,让我来演示一下。
Dialogue: 0,1:24:37.57,1:24:47.03,中文,,0,0,0,,让我在这里展示一下这些算法的可视化，这要感谢一个第三方工具，它将帮助我们如下所示地将这些排序算法可视化。
Dialogue: 0,1:24:47.03,1:24:48.83,中文,,0,0,0,,小条表示小数字。
Dialogue: 0,1:24:48.83,1:24:50.49,中文,,0,0,0,,大条表示大数字。
Dialogue: 0,1:24:50.49,1:24:56.83,中文,,0,0,0,,现在的想法是，当我点击一个按钮，让所有的小条都朝这边移动，所有的大条都朝那边移动。
Dialogue: 0,1:24:56.83,1:25:02.47,中文,,0,0,0,,就像我们的志愿者一样，但不是拿着发光的数字，而是用条形图来表示它们的大小。
Dialogue: 0,1:25:02.47,1:25:07.32,中文,,0,0,0,,让我们从选择排序开始。
Dialogue: 0,1:25:07.32,1:25:14.79,中文,,0,0,0,,你会看到粉红色突出显示的是当前正在选择的数字，然后一直拉到最左边。
Dialogue: 0,1:25:14.79,1:25:16.47,中文,,0,0,0,,这就是选择排序。
Dialogue: 0,1:25:16.47,1:25:18.01,中文,,0,0,0,,再来一次。
Dialogue: 0,1:25:18.01,1:25:20.57,中文,,0,0,0,,它正在选择下一个最小的元素。
Dialogue: 0,1:25:20.57,1:25:32.36,中文,,0,0,0,,你可以在这里更清楚地看到，就像我的人脚走了很多步一样，这个算法也在一次又一次地触碰这些元素。
Dialogue: 0,1:25:32.36,1:25:35.06,中文,,0,0,0,,这就是为什么 n² 是真实存在的。
Dialogue: 0,1:25:35.06,1:25:37.38,中文,,0,0,0,,这里一定有一些内在的冗余。
Dialogue: 0,1:25:37.38,1:25:40.40,中文,,0,0,0,,为什么我们要一遍又一遍地看同一个元素？
Dialogue: 0,1:25:40.40,1:25:43.26,中文,,0,0,0,,就我们的伪代码而言，我们确实需要这样做。
Dialogue: 0,1:25:43.26,1:25:48.79,中文,,0,0,0,,正是这种冗余的比较， kind of 解释了为什么是 n²。
Dialogue: 0,1:25:48.79,1:25:49.53,中文,,0,0,0,,好了。
Dialogue: 0,1:25:49.53,1:25:51.11,中文,,0,0,0,,这边是短条，那边是长条。
Dialogue: 0,1:25:51.11,1:25:54.75,中文,,0,0,0,,我必须一直说话来拖延时间，因为它比较慢。
Dialogue: 0,1:25:54.75,1:25:58.77,中文,,0,0,0,,让我重新随机排列数组，这样我们就从不同的顺序开始了。
Dialogue: 0,1:25:58.77,1:26:00.52,中文,,0,0,0,,现在让我点击冒泡排序。
Dialogue: 0,1:26:00.52,1:26:03.16,中文,,0,0,0,,你会看到类似的想法，但算法不同。
Dialogue: 0,1:26:03.16,1:26:10.06,中文,,0,0,0,,现在，粉红色的两个条是被比较和可能修复的两个条，如果它们顺序错误的话。
Dialogue: 0,1:26:10.06,1:26:14.60,中文,,0,0,0,,你可以看到最大的条形图正在冒泡到顶部。
Dialogue: 0,1:26:14.60,1:26:17.66,中文,,0,0,0,,现在你也可以看到这种冗余。
Dialogue: 0,1:26:17.66,1:26:22.85,中文,,0,0,0,,我们一遍又一遍地扫描列表，就像我一直在来回走动一样。
Dialogue: 0,1:26:22.85,1:26:23.75,中文,,0,0,0,,这是 n²。
Dialogue: 0,1:26:23.75,1:26:24.91,中文,,0,0,0,,这没有那么多条。
Dialogue: 0,1:26:24.91,1:26:27.96,中文,,0,0,0,,什么，10，20？我猜这大概是 40 根柱子。
Dialogue: 0,1:26:27.96,1:26:31.98,中文,,0,0,0,,仅仅排序 40 个数字就已经很慢了。
Dialogue: 0,1:26:31.98,1:26:37.59,中文,,0,0,0,,我想如果我继续说下去会很乏味。所以我们假设这也是相对较慢的。
Dialogue: 0,1:26:37.59,1:26:43.37,中文,,0,0,0,,如果我很幸运，并且列表已经排好序了，那么冒泡排序会非常快。
Dialogue: 0,1:26:43.37,1:26:46.05,中文,,0,0,0,,这是一个真正随机的数组，所以我们没有那么幸运。
Dialogue: 0,1:26:46.05,1:26:50.07,中文,,0,0,0,,最坏的情况可能就是这里发生的情况。
Dialogue: 0,1:26:50.07,1:26:55.91,中文,,0,0,0,,所以我觉得如果不让你看到结局，就会像忍住打喷嚏一样扫兴。
Dialogue: 0,1:26:55.91,1:26:58.05,中文,,0,0,0,,开始了。
Dialogue: 0,1:26:58.05,1:27:00.22,中文,,0,0,0,,没什么特别的。
Dialogue: 0,1:27:00.22,1:27:02.37,中文,,0,0,0,,快完成了。
Dialogue: 0,1:27:02.37,1:27:03.19,中文,,0,0,0,,好了，完成了。
Dialogue: 0,1:27:03.19,1:27:06.79,中文,,0,0,0,,好的，谢谢。
Dialogue: 0,1:27:06.79,1:27:09.29,中文,,0,0,0,,谢谢。
Dialogue: 0,1:27:09.29,1:27:15.83,中文,,0,0,0,,还是有点慢，那我们还能不能从根本上改进一下呢？
Dialogue: 0,1:27:15.83,1:27:19.05,中文,,0,0,0,,我们可以通过引入另一种技术来实现。
Dialogue: 0,1:27:19.05,1:27:22.09,中文,,0,0,0,,这与其说是一个代码函数，不如说是一个概念。
Dialogue: 0,1:27:22.09,1:27:27.53,中文,,0,0,0,,你可能在现实世界中见过这种概念，但可能不是那么明显。
Dialogue: 0,1:27:27.53,1:27:35.02,中文,,0,0,0,,事实证明，在编程中， 递归是指函数调用自身的能力。
Dialogue: 0,1:27:35.02,1:27:43.82,中文,,0,0,0,,在数学领域，如果一个函数 f 在一个公式的左右两边都出现，那么在数学领域，它也是一个递归函数。
Dialogue: 0,1:27:43.82,1:27:53.77,中文,,0,0,0,,每当 f 根据自身定义时，或者在我们的例子中，在编程中，任何时候一个函数调用自身，这个函数就被称为递归函数。
Dialogue: 0,1:27:53.77,1:27:57.01,中文,,0,0,0,,这实际上是我们在课堂上已经见过，即使我们没有这样称呼它。
Dialogue: 0,1:27:57.01,1:28:06.58,中文,,0,0,0,,例如，考虑一下之前这个伪代码，它是用二分查找进行搜索的伪代码。
Dialogue: 0,1:28:06.58,1:28:07.90,中文,,0,0,0,,一堆门。
Dialogue: 0,1:28:07.90,1:28:09.88,中文,,0,0,0,,如果没有门了，返回 false。
Dialogue: 0,1:28:09.88,1:28:12.66,中文,,0,0,0,,这是我们添加的附加条件。
Dialogue: 0,1:28:12.66,1:28:15.05,中文,,0,0,0,,如果数字在中间门后面，返回 true。
Dialogue: 0,1:28:15.05,1:28:16.59,中文,,0,0,0,,有趣的部分来了。
Dialogue: 0,1:28:16.59,1:28:20.89,中文,,0,0,0,,如果数字小于中间那扇门，就在左半部分查找。
Dialogue: 0,1:28:20.89,1:28:24.11,中文,,0,0,0,,否则，如果数字大于中间那扇门，就在右半部分查找。
Dialogue: 0,1:28:24.11,1:28:27.80,中文,,0,0,0,,前面的这段伪代码本身就是递归的。
Dialogue: 0,1:28:27.80,1:28:28.46,中文,,0,0,0,,为什么？
Dialogue: 0,1:28:28.46,1:28:30.72,中文,,0,0,0,,因为这里有个搜索的算法。
Dialogue: 0,1:28:30.72,1:28:32.44,中文,,0,0,0,,这个算法告诉我们什么呢？
Dialogue: 0,1:28:32.44,1:28:37.44,中文,,0,0,0,,在这行和这行，它告诉我们要搜索其他的东西。
Dialogue: 0,1:28:37.44,1:28:47.83,中文,,0,0,0,,所以即使它没有在代码中被明确定义为具有名称，但如果这是一个搜索算法，并且该搜索算法正在使用一个搜索算法，那么这段伪代码就是递归的。
Dialogue: 0,1:28:47.83,1:28:53.60,中文,,0,0,0,,如果一个函数只是不断地调用自身，这很快就会给你带来麻烦。
Dialogue: 0,1:28:53.60,1:29:01.97,中文,,0,0,0,,凭直觉，为什么这段代码，这段伪代码，调用自身是没有问题的呢？
Dialogue: 0,1:29:01.97,1:29:03.49,中文,,0,0,0,,为什么算法还会停止？
Dialogue: 0,1:29:03.49,1:29:07.97,中文,,0,0,0,,是的。
Dialogue: 0,1:29:07.97,1:29:10.87,中文,,0,0,0,,没错，它有一些退出条件，比如如果没有门比它小。
Dialogue: 0,1:29:10.87,1:29:17.34,中文,,0,0,0,,更重要的是，每次你搜索左半部分，你都是在搜索一个更小的问题。
Dialogue: 0,1:29:17.34,1:29:22.42,中文,,0,0,0,,每次你搜索右半部分，你都是在搜索一个更小的问题，字面上是原来大小的一半。
Dialogue: 0,1:29:22.42,1:29:29.61,中文,,0,0,0,,这就是为什么在电话簿里，我显然不能无限次地把电话簿撕成两半，因为它每次都在变小。
Dialogue: 0,1:29:29.61,1:29:33.53,中文,,0,0,0,,所以递归就是这种调用自身的能力。
Dialogue: 0,1:29:33.53,1:29:42.11,中文,,0,0,0,,重要的是，你是在一个越来越小的问题上这样做，这样最终你就没有问题要解决了，或者没有数据了，没有门了。
Dialogue: 0,1:29:42.11,1:29:46.20,中文,,0,0,0,,所以这两行就是递归的元素。
Dialogue: 0,1:29:46.20,1:29:49.60,中文,,0,0,0,,如果我们回到第 0 周，我们本可以用另一种方式使用递归。
Dialogue: 0,1:29:49.60,1:29:52.00,中文,,0,0,0,,这就是我们之前设计的电话簿伪代码。
Dialogue: 0,1:29:52.00,1:29:59.12,中文,,0,0,0,,回想第 0 周的内容，我们把这些黄线描述为循环，一种周而复始的循环。
Dialogue: 0,1:29:59.12,1:30:01.08,中文,,0,0,0,,这里我们错过了一个机会。
Dialogue: 0,1:30:01.08,1:30:05.92,中文,,0,0,0,,如果我重新实现这段代码，像这样操作会怎么样？
Dialogue: 0,1:30:05.92,1:30:13.01,中文,,0,0,0,,与其说“打开电话簿左半部分的中间，然后回到第 3 行”，或者说“打开电话簿右半部分的中间，
Dialogue: 0,1:30:13.01,1:30:21.01,中文,,0,0,0,,然后回到第 3 行”，这实际上是引入了一个循环，为什么我不直接把我现在做的事情看作是一个算法呢？
Dialogue: 0,1:30:21.01,1:30:23.95,中文,,0,0,0,,用来搜索电话簿的算法。
Dialogue: 0,1:30:23.95,1:30:30.75,中文,,0,0,0,,如果你想搜索一个更小的电话簿，比如从 A 到 M 或者从 N 到 Z，我们只需要使用相同的算法。
Dialogue: 0,1:30:30.75,1:30:35.09,中文,,0,0,0,,简单来说，我可以把这些黄线替换成这样。
Dialogue: 0,1:30:35.09,1:30:36.45,中文,,0,0,0,,搜索电话簿的左半部分。
Dialogue: 0,1:30:36.45,1:30:37.45,中文,,0,0,0,,搜索电话簿的右半部分。
Dialogue: 0,1:30:37.45,1:30:43.85,中文,,0,0,0,,这将是一种隐式的递归实现，现在我可以把第 0 周的电话簿伪代码缩短。
Dialogue: 0,1:30:43.85,1:30:48.92,中文,,0,0,0,,它是递归的，因为如果这是一个搜索算法，而你说去搜索其他东西，这是可以的。
Dialogue: 0,1:30:48.92,1:30:50.06,中文,,0,0,0,,这就是递归。
Dialogue: 0,1:30:50.06,1:30:55.90,中文,,0,0,0,,因为你每次都在搜索电话簿的一半，所以它确实会变得越来越小。
Dialogue: 0,1:30:55.90,1:31:03.68,中文,,0,0,0,,即使在现实世界或虚拟世界中，你也可以在现实中看到递归数据结构，或者至少像这样的超级玛丽兄弟游戏。
Dialogue: 0,1:31:03.68,1:31:10.98,中文,,0,0,0,,让我们去掉所有干扰因素，把注意力集中在这个金字塔上，它有一块砖，然后是两块，然后是三块，然后是四块。
Dialogue: 0,1:31:10.98,1:31:16.73,中文,,0,0,0,,从技术上讲，这本身就是递归定义的，那么，什么是高度为 4 的金字塔呢？
Dialogue: 0,1:31:16.73,1:31:19.23,中文,,0,0,0,,它实际上是 什么？
Dialogue: 0,1:31:19.23,1:31:30.73,中文,,0,0,0,,你会怎么描述一个高度为 4 的金字塔？它实际上和一个高度为 3 的金字塔加上一层额外的层是一样的。
Dialogue: 0,1:31:30.73,1:31:31.89,中文,,0,0,0,,那么，高度为 3 的金字塔是什么样的？
Dialogue: 0,1:31:31.89,1:31:36.15,中文,,0,0,0,,它实际上是一个高度为 2 的金字塔再加上一层。
Dialogue: 0,1:31:36.15,1:31:40.63,中文,,0,0,0,,如果可以用自身来定义物理结构，那么它们也可以是递归的。
Dialogue: 0,1:31:40.63,1:31:45.97,中文,,0,0,0,,在某个时刻，你必须说，如果金字塔的高度是 1，那就只有一块积木。
Dialogue: 0,1:31:45.97,1:31:49.03,中文,,0,0,0,,你不能永远说它是根据负 1 的高度来定义的。
Dialogue: 0,1:31:49.03,1:31:50.47,中文,,0,0,0,,负 2，你就永远不会停止了。
Dialogue: 0,1:31:50.47,1:31:52.95,中文,,0,0,0,,所以你必须得有一个特殊情况。
Dialogue: 0,1:31:52.95,1:31:55.71,中文,,0,0,0,,让我们继续，把类似的东西转换成代码。
Dialogue: 0,1:31:55.71,1:31:58.03,中文,,0,0,0,,让我回到 VS Code。
Dialogue: 0,1:31:58.03,1:32:03.24,中文,,0,0,0,,让我来实现一个名为 iteration 的程序，它指的是循环迭代。
Dialogue: 0,1:32:03.24,1:32:08.44,中文,,0,0,0,,让我实现一个像那样的非常简单的金字塔。让我继续，包含 CS50 库。
Dialogue: 0,1:32:08.44,1:32:11.62,中文,,0,0,0,,我会包含我们的 stdio.h。
Dialogue: 0,1:32:11.62,1:32:13.36,中文,,0,0,0,,int main (void)。
Dialogue: 0,1:32:13.36,1:32:16.12,中文,,0,0,0,,今天没有命令行参数。让我们继续，做这个。
Dialogue: 0,1:32:16.12,1:32:21.43,中文,,0,0,0,,让我们声明一个名为 height 的变量。询问用户金字塔的高度。
Dialogue: 0,1:32:21.43,1:32:25.29,中文,,0,0,0,,然后让我们继续，画一个那个高度的金字塔。
Dialogue: 0,1:32:25.29,1:32:27.63,中文,,0,0,0,,当然，draw 函数还不存在。
Dialogue: 0,1:32:27.63,1:32:30.20,中文,,0,0,0,,所以我需要发明 draw 函数。
Dialogue: 0,1:32:30.20,1:32:33.20,中文,,0,0,0,,让我继续，定义一个没有返回值的函数。
Dialogue: 0,1:32:33.20,1:32:34.36,中文,,0,0,0,,它只会产生副作用。
Dialogue: 0,1:32:34.36,1:32:36.34,中文,,0,0,0,,它只会在屏幕上打印砖块。
Dialogue: 0,1:32:36.34,1:32:40.39,中文,,0,0,0,,调用 draw 函数，它接受一个整数 n 作为输入。
Dialogue: 0,1:32:40.39,1:32:41.85,中文,,0,0,0,,我要怎么实现它呢？
Dialogue: 0,1:32:41.85,1:32:46.57,中文,,0,0,0,,我想要打印一行砖块，第一行 1 个，第二行 2 个，以此类推。
Dialogue: 0,1:32:46.57,1:32:49.65,中文,,0,0,0,,这很简单，至少在你熟悉循环之后。
Dialogue: 0,1:32:49.65,1:32:51.47,中文,,0,0,0,,让我回到代码这里。
Dialogue: 0,1:32:51.47,1:32:58.48,中文,,0,0,0,,让我继续写，`for (int i = 0; i < n; i++)`。
Dialogue: 0,1:32:58.48,1:33:01.36,中文,,0,0,0,,这将一行一行地迭代。
Dialogue: 0,1:33:01.36,1:33:06.06,中文,,0,0,0,,在每一行，我要打印 1 个砖块，然后是 2 个，3 个，4 个。
Dialogue: 0,1:33:06.06,1:33:08.88,中文,,0,0,0,,我现在是从 0 迭代到 1，再到 2，再到 3。
Dialogue: 0,1:33:08.88,1:33:09.70,中文,,0,0,0,,我觉得没问题。
Dialogue: 0,1:33:09.70,1:33:19.65,中文,,0,0,0,,我可以写 `for (int j = 0; j < i; j++)`，聪明一点。
Dialogue: 0,1:33:19.65,1:33:27.15,中文,,0,0,0,,现在，让我继续，在这个循环里面，我想我可以只打印一个井号 `#`。
Dialogue: 0,1:33:27.15,1:33:33.03,中文,,0,0,0,,在循环外面，和上周类似，我要单独打印一个换行符。
Dialogue: 0,1:33:33.03,1:33:38.94,中文,,0,0,0,,所以一开始有点不明显，但这个外部循环一行一行地迭代，或者说，逐行迭代。
Dialogue: 0,1:33:38.94,1:33:45.68,中文,,0,0,0,,然后内部循环只是确保当 `i` 等于 0 时，让我想想。
Dialogue: 0,1:33:45.68,1:33:49.16,中文,,0,0,0,,不对，这里有个 bug。
Dialogue: 0,1:33:49.16,1:33:52.28,中文,,0,0,0,,我需要确保 `j < i + 1`。
Dialogue: 0,1:33:52.28,1:33:57.76,中文,,0,0,0,,所以当 `i` 是 0 的时候，在我的第一行输出中，我要打印一个砖块。
Dialogue: 0,1:33:57.76,1:34:02.27,中文,,0,0,0,,当 i 是 1 时，我要打印两块砖，以此类推。
Dialogue: 0,1:34:02.27,1:34:05.51,中文,,0,0,0,,我来运行一下 make iteration。
Dialogue: 0,1:34:05.51,1:34:06.09,中文,,0,0,0,,好的。
Dialogue: 0,1:34:06.09,1:34:08.95,中文,,0,0,0,,现在看起来可以编译了。
Dialogue: 0,1:34:08.95,1:34:10.41,中文,,0,0,0,,哎呀。
Dialogue: 0,1:34:10.41,1:34:10.85,中文,,0,0,0,,嗯。
Dialogue: 0,1:34:10.85,1:34:12.83,中文,,0,0,0,,函数 draw 隐式声明。
Dialogue: 0,1:34:12.83,1:34:14.47,中文,,0,0,0,,我又犯了第一周的错误。
Dialogue: 0,1:34:14.47,1:34:18.53,中文,,0,0,0,,再说一遍？
Dialogue: 0,1:34:18.53,1:34:20.21,中文,,0,0,0,,是的，缺少原型。
Dialogue: 0,1:34:20.21,1:34:25.64,中文,,0,0,0,,我没有在顶部声明它。这很容易修复。而且只有在这种情况下，复制粘贴才是可以接受的，也是必要的。
Dialogue: 0,1:34:25.64,1:34:29.07,中文,,0,0,0,,让我复制函数声明到这里，用分号结束它。
Dialogue: 0,1:34:29.07,1:34:32.51,中文,,0,0,0,,这样 Clang 就知道 draw 函数的存在了。
Dialogue: 0,1:34:32.51,1:34:33.91,中文,,0,0,0,,运行 make iteration。现在可以工作了。
Dialogue: 0,1:34:33.91,1:34:34.71,中文,,0,0,0,,谢谢。
Dialogue: 0,1:34:34.71,1:34:36.19,中文,,0,0,0,,运行 ./iteration。
Dialogue: 0,1:34:36.19,1:34:37.99,中文,,0,0,0,,输入类似 4 的数字。
Dialogue: 0,1:34:37.99,1:34:43.87,中文,,0,0,0,,这样我们就得到了一个高度为 1、2、3、4 的金字塔，看起来和这个很像，尽管使用的是井号。
Dialogue: 0,1:34:43.87,1:34:49.30,中文,,0,0,0,,这就是我们两周前在第一周，也许是上周，使用数组实现它的方式。
Dialogue: 0,1:34:49.30,1:34:51.20,中文,,0,0,0,,我建议。
Dialogue: 0,1:34:51.20,1:34:53.68,中文,,0,0,0,,我们可以递归地做这件事。
Dialogue: 0,1:34:53.68,1:34:55.58,中文,,0,0,0,,让我关闭这个版本的代码。
Dialogue: 0,1:34:55.58,1:35:01.78,中文,,0,0,0,,让我回到 VS Code 并打开 recursion.c 来演示递归。
Dialogue: 0,1:35:01.78,1:35:04.34,中文,,0,0,0,,我第一次会故意写错。
Dialogue: 0,1:35:04.34,1:35:06.65,中文,,0,0,0,,让我引入 cs50.h。
Dialogue: 0,1:35:06.65,1:35:09.05,中文,,0,0,0,,引入 standardio.h。
Dialogue: 0,1:35:09.05,1:35:12.21,中文,,0,0,0,,定义 `int main (void)`。
Dialogue: 0,1:35:12.21,1:35:18.09,中文,,0,0,0,,让我先画一个高度为 1 的金字塔。
Dialogue: 0,1:35:18.09,1:35:22.01,中文,,0,0,0,,现在，在我的 `draw` 函数中，让我用不同的方式重新实现它。
Dialogue: 0,1:35:22.01,1:35:26.78,中文,,0,0,0,,这次我的 `draw` 函数仍然接受一个数字 n，这代表它要打印多少个井号。
Dialogue: 0,1:35:26.78,1:35:34.28,中文,,0,0,0,,定义 `int i` 并初始化为 0，当 `i` 小于 n 时，`i` 自增。
Dialogue: 0,1:35:34.28,1:35:38.60,中文,,0,0,0,,然后打印一个井号。
Dialogue: 0,1:35:38.60,1:35:44.38,中文,,0,0,0,,之后， 像之前一样，打印换行符。
Dialogue: 0,1:35:44.38,1:35:49.80,中文,,0,0,0,,这只会画一行。
Dialogue: 0,1:35:49.80,1:35:54.89,中文,,0,0,0,,它会打印出一个井号、两个井号或三个井号，但只有一行。
Dialogue: 0,1:35:54.89,1:36:05.07,中文,,0,0,0,,现在，我故意写错，但好奇地想，如果这可以画一个高度为 1 的金字塔，那我们就用它来画一个高度为 n+1 的金字塔。
Dialogue: 0,1:36:05.07,1:36:08.57,中文,,0,0,0,,所以当我第一次调用 `draw` 时，它会打印一个井号。
Dialogue: 0,1:36:08.57,1:36:13.86,中文,,0,0,0,,然后第二次调用 `draw` 时，它会打印两个井号，然后是三个，然后是四个。
Dialogue: 0,1:36:13.86,1:36:18.15,中文,,0,0,0,,所以我们是从上到下铺设这些砖块的。
Dialogue: 0,1:36:18.15,1:36:20.66,中文,,0,0,0,,生成递归。
Dialogue: 0,1:36:20.66,1:36:22.50,中文,,0,0,0,,哎呀，我又搞砸了。
Dialogue: 0,1:36:22.50,1:36:24.70,中文,,0,0,0,,把原型复制过来。
Dialogue: 0,1:36:24.70,1:36:27.20,中文,,0,0,0,,把它放到这里，加个分号。
Dialogue: 0,1:36:27.20,1:36:28.70,中文,,0,0,0,,再来一次。
Dialogue: 0,1:36:28.70,1:36:30.07,中文,,0,0,0,,生成递归。
Dialogue: 0,1:36:30.07,1:36:32.59,中文,,0,0,0,,好了，没问题了，./recursion。
Dialogue: 0,1:36:32.59,1:36:39.56,中文,,0,0,0,,让我放大终端窗口，这样你就能看到更多输出内容。在这里我们有。
Dialogue: 0,1:36:39.56,1:36:41.39,中文,,0,0,0,,不太好，但谢谢。
Dialogue: 0,1:36:41.39,1:36:43.85,中文,,0,0,0,,我们构建了一个无限高的金字塔。
Dialogue: 0,1:36:43.85,1:36:47.17,中文,,0,0,0,,它在屏幕上飞速滚动，所以看起来有点乱。
Dialogue: 0,1:36:47.17,1:36:51.67,中文,,0,0,0,,我打印了一个高度为 1 的金字塔，然后是 2，然后是 3，然后是 4。
Dialogue: 0,1:36:51.67,1:36:53.67,中文,,0,0,0,,不幸的是，我缺少了什么？
Dialogue: 0,1:36:53.67,1:37:00.52,中文,,0,0,0,,任何快速条件，任何可以表示“等一下，当它太高时，完全停止”的条件。所以这是一个无限循环。
Dialogue: 0,1:37:00.52,1:37:03.34,中文,,0,0,0,,它不是循环，而是递归调用。
Dialogue: 0,1:37:03.34,1:37:05.64,中文,,0,0,0,,实际上，这样做通常很糟糕。
Dialogue: 0,1:37:05.64,1:37:14.18,中文,,0,0,0,,我们将在下周看到，如果调用函数次数过多，实际上可能会触发另一个 segmentation fault，因为本质上是在使用过多的内存。
Dialogue: 0,1:37:14.18,1:37:16.30,中文,,0,0,0,,但目前，我还没有触发它。
Dialogue: 0,1:37:16.30,1:37:18.44,中文,,0,0,0,,Control-C 是取消操作的好帮手。
Dialogue: 0,1:37:18.44,1:37:22.76,中文,,0,0,0,,顺便说一下，如果你是在家里跟着操作或者稍后使用这段代码，我实际上在这里耍了点花招。
Dialogue: 0,1:37:22.76,1:37:25.49,中文,,0,0,0,,我们有一个特殊的 Clang 配置功能。
Dialogue: 0,1:37:25.49,1:37:29.37,中文,,0,0,0,,它可以防止你调用这样的函数并产生问题。
Dialogue: 0,1:37:29.37,1:37:31.71,中文,,0,0,0,,我为了演示的目的重写了它。
Dialogue: 0,1:37:31.71,1:37:34.67,中文,,0,0,0,,但很有可能，在家的时候，你自己无法编译这段代码。
Dialogue: 0,1:37:34.67,1:37:39.06,中文,,0,0,0,,但是，让我用递归的方式来正确地编写这段代码，如下所示。
Dialogue: 0,1:37:39.06,1:37:46.54,中文,,0,0,0,,让我回到代码这里。让我继续，而不是仅仅盲目地开始画一层，两层，然后三层砖块。
Dialogue: 0,1:37:46.54,1:37:53.51,中文,,0,0,0,,让我像之前一样，使用 getInt 函数提示用户输入他们想要的“金字塔”的高度。
Dialogue: 0,1:37:53.51,1:37:55.59,中文,,0,0,0,,现在让我再次调用 draw(height)。
Dialogue: 0,1:37:55.59,1:37:58.53,中文,,0,0,0,,所以现在我要回到循环版本。
Dialogue: 0,1:37:58.53,1:38:04.25,中文,,0,0,0,,但是现在，不使用循环，递归就显得非常优雅了。
Dialogue: 0,1:38:04.25,1:38:07.72,中文,,0,0,0,,让我继续执行代码。
Dialogue: 0,1:38:07.72,1:38:10.81,中文,,0,0,0,,draw 函数如下所示。
Dialogue: 0,1:38:10.81,1:38:18.52,中文,,0,0,0,,根据你的定义，如果高度为 4 的金字塔实际上只是一个高度为 3 的金字塔加上另一行，那么让我们按字面意思来理解它。
Dialogue: 0,1:38:18.52,1:38:20.20,中文,,0,0,0,,让我回到代码。
Dialogue: 0,1:38:20.20,1:38:26.91,中文,,0,0,0,,如果你想画一个高度为 4 的金字塔，那就直接画一个高度为 x 的金字塔。
Dialogue: 0,1:38:26.91,1:38:29.53,中文,,0,0,0,,首先是 3，或者更一般地说，是 n - 1。
Dialogue: 0,1:38:29.53,1:38:30.63,中文,,0,0,0,,第二步是什么？
Dialogue: 0,1:38:30.63,1:38:34.63,中文,,0,0,0,,一旦你画了一个高度为 3 的金字塔，再画一行。
Dialogue: 0,1:38:34.63,1:38:37.09,中文,,0,0,0,,至少我得自己解决这个问题的一部分。
Dialogue: 0,1:38:37.09,1:38:50.58,中文,,0,0,0,,所以让我输入 `for (int i = 0; i < n; i++)`，\N然后让我，这个函数的程序员，打印出我的井号，然后在最底部，打印出一个换行符，这样光标就会移动到下一行。
Dialogue: 0,1:38:50.58,1:39:02.13,中文,,0,0,0,,不过我敢说，这还挺优雅的，因为 draw 是递归的。我实际上是将这个想法从英文翻译成 C 代码：高度为 4 的金字塔实际上就是高度为 3 的金字塔。
Dialogue: 0,1:39:02.13,1:39:03.79,中文,,0,0,0,,所以我先这样做。
Dialogue: 0,1:39:03.79,1:39:06.63,中文,,0,0,0,,我有点相信这样行得通。
Dialogue: 0,1:39:06.63,1:39:09.69,中文,,0,0,0,,然后我只需要再铺一层砖，四块。
Dialogue: 0,1:39:09.69,1:39:15.73,中文,,0,0,0,,所以如果 n 是 4，这只是一个简单的 for 循环，就像第一周那样，它会再打印一层。
Dialogue: 0,1:39:15.73,1:39:18.59,中文,,0,0,0,,这最终会成为一个问题。
Dialogue: 0,1:39:18.59,1:39:20.14,中文,,0,0,0,,为什么？
Dialogue: 0,1:39:20.14,1:39:22.81,中文,,0,0,0,,这个程序还没完成。
Dialogue: 0,1:39:22.81,1:39:28.82,中文,,0,0,0,,在这个模型中，draw 会调用自己多少次？
Dialogue: 0,1:39:28.82,1:39:29.72,中文,,0,0,0,,无限多次。
Dialogue: 0,1:39:29.72,1:39:34.34,中文,,0,0,0,,为什么？
Dialogue: 0,1:39:34.34,1:39:36.48,中文,,0,0,0,,是的，没有退出语句。
Dialogue: 0,1:39:36.48,1:39:39.62,中文,,0,0,0,,比如，如果已经打印得足够多了，就退出。
Dialogue: 0,1:39:39.62,1:39:40.96,中文,,0,0,0,,那我们如何捕捉到这一点呢？
Dialogue: 0,1:39:40.96,1:39:43.31,中文,,0,0,0,,我认为我们不希望它变成负数，对吧？
Dialogue: 0,1:39:43.31,1:39:46.69,中文,,0,0,0,,画一个负高度的金字塔是没有意义的。
Dialogue: 0,1:39:46.69,1:39:53.85,中文,,0,0,0,,所以我认为我们可以像程序员一样，挑出一个简单的例子，一个简单的答案，一个所谓的基线条件。
Dialogue: 0,1:39:53.85,1:39:54.91,中文,,0,0,0,,我就要这么做。
Dialogue: 0,1:39:54.91,1:40:01.93,中文,,0,0,0,,在我的 draw 函数的顶部，让我加上 if n
Dialogue: 0,1:40:01.93,1:40:02.86,中文,,0,0,0,,就是这样。
Dialogue: 0,1:40:02.86,1:40:04.52,中文,,0,0,0,,继续，直接返回。
Dialogue: 0,1:40:04.52,1:40:06.20,中文,,0,0,0,,没有其他事可做了。
Dialogue: 0,1:40:06.20,1:40:13.31,中文,,0,0,0,,这个简单的条件，技术上称为基本情况，将确保代码不会永远运行下去。
Dialogue: 0,1:40:13.31,1:40:13.91,中文,,0,0,0,,为什么？
Dialogue: 0,1:40:13.91,1:40:18.17,中文,,0,0,0,,假设调用 draw 函数时传入的参数是 4。
Dialogue: 0,1:40:18.17,1:40:20.71,中文,,0,0,0,,当然，4 不小于 0，所以我们不返回。
Dialogue: 0,1:40:20.71,1:40:22.59,中文,,0,0,0,,我们确实绘制了一个高度为 3 的金字塔。
Dialogue: 0,1:40:22.59,1:40:25.03,中文,,0,0,0,,这就是事情变得有点棘手的地方。
Dialogue: 0,1:40:25.03,1:40:28.35,中文,,0,0,0,,在调用 draw 函数之前，不会移动到第 20 行。
Dialogue: 0,1:40:28.35,1:40:34.57,中文,,0,0,0,,所以当使用参数 3 调用 draw 函数时，就好像你再次从这个函数的顶部开始执行一样。
Dialogue: 0,1:40:34.57,1:40:36.40,中文,,0,0,0,,3 不小于 0，所以你要做什么？
Dialogue: 0,1:40:36.40,1:40:38.22,中文,,0,0,0,,绘制高度为 2 的金字塔。
Dialogue: 0,1:40:38.22,1:40:39.54,中文,,0,0,0,,如何绘制高度为 2 的金字塔？
Dialogue: 0,1:40:39.54,1:40:41.86,中文,,0,0,0,,2 不小于 0，所以你不返回。
Dialogue: 0,1:40:41.86,1:40:42.94,中文,,0,0,0,,所以你绘制高度为 1 的金字塔。
Dialogue: 0,1:40:42.94,1:40:44.36,中文,,0,0,0,,这里要小心。
Dialogue: 0,1:40:44.36,1:40:45.38,中文,,0,0,0,,绘制高度为 1 的金字塔。
Dialogue: 0,1:40:45.38,1:40:47.22,中文,,0,0,0,,现在我们回到开头。
Dialogue: 0,1:40:47.22,1:40:48.06,中文,,0,0,0,,如何绘制高度为 1 的金字塔？
Dialogue: 0,1:40:48.06,1:40:50.52,中文,,0,0,0,,1 不小于 0，所以你不返回。
Dialogue: 0,1:40:50.52,1:40:53.35,中文,,0,0,0,,你画高度为 0。
Dialogue: 0,1:40:53.35,1:40:54.51,中文,,0,0,0,,你怎么画高度为 0 的？
Dialogue: 0,1:40:54.51,1:40:55.61,中文,,0,0,0,,等等。
Dialogue: 0,1:40:55.61,1:40:59.25,中文,,0,0,0,,0 小于等于 0，然后返回。
Dialogue: 0,1:40:59.25,1:41:02.08,中文,,0,0,0,,它就像一个心理堆栈，一个待办事项列表。
Dialogue: 0,1:41:02.08,1:41:09.40,中文,,0,0,0,,你一直推迟执行后面的代码行，因为你一直在重新启动 draw 函数，直到...
Dialogue: 0,1:41:09.40,1:41:12.83,中文,,0,0,0,,最后，其中一个函数调用说，没事可做了。
Dialogue: 0,1:41:12.83,1:41:13.71,中文,,0,0,0,,返回。
Dialogue: 0,1:41:13.71,1:41:16.51,中文,,0,0,0,,然后整个过程就开始瓦解了，如果你愿意这么说的话。
Dialogue: 0,1:41:16.51,1:41:18.45,中文,,0,0,0,,你从中断的地方重新开始。
Dialogue: 0,1:41:18.45,1:41:21.29,中文,,0,0,0,,这可能是最好的情况，我们不会在课堂上做这个。
Dialogue: 0,1:41:21.29,1:41:31.54,中文,,0,0,0,,如果你想自己解决这个问题，可以使用 debug50 逐步进入每一行代码，你就会明白实际发生了什么。
Dialogue: 0,1:41:31.54,1:41:37.85,中文,,0,0,0,,让我进入终端，输入 make recursion，这是现在正确的代码版本，然后是 ./recursion。
Dialogue: 0,1:41:37.85,1:41:39.43,中文,,0,0,0,,输入高度 4。
Dialogue: 0,1:41:39.43,1:41:48.04,中文,,0,0,0,,瞧，现在我们有了相同的金字塔，虽然我们承认，我们使用迭代来打印额外的层，但我们没有使用迭代本身。
Dialogue: 0,1:41:48.04,1:41:58.45,中文,,0,0,0,,我们现在递归地使用 draw 来打印它前面需要的所有较小的金字塔。
Dialogue: 0,1:41:58.45,1:42:01.10,中文,,0,0,0,,问题是，只能对 void 函数使用递归吗？
Dialogue: 0,1:42:01.10,1:42:01.84,中文,,0,0,0,,不，当然不是。
Dialogue: 0,1:42:01.84,1:42:11.55,中文,,0,0,0,,事实上，有一个返回值是很常见的，比如一个整数或其他东西，这样你就可以用这个实际值做一些有建设性的事情。
Dialogue: 0,1:42:11.55,1:42:15.41,中文,,0,0,0,,对此还有其他问题吗？
Dialogue: 0,1:42:15.41,1:42:18.92,中文,,0,0,0,,大声点。
Dialogue: 0,1:42:18.92,1:42:20.98,中文,,0,0,0,,第 21 行什么时候执行？
Dialogue: 0,1:42:20.98,1:42:26.85,中文,,0,0,0,,如果继续展开，让我向下滚动一点，以便您可以看到代码的顶部。
Dialogue: 0,1:42:26.85,1:42:35.41,中文,,0,0,0,,所以第 19 行执行完毕后，就会执行第 21 行。
Dialogue: 0,1:42:35.41,1:42:40.91,中文,,0,0,0,,在我讲的故事中，我们不断地调用 draw，一次又一次。
Dialogue: 0,1:42:40.91,1:42:48.58,中文,,0,0,0,,但是一旦其中一个函数调用（n 等于 0）立即返回，我们就不会再继续绘制了。
Dialogue: 0,1:42:48.58,1:42:59.96,中文,,0,0,0,,所以现在，如果把这个过程看作是反过来的，那么你会继续执行第 21 行，然后再执行第 21 行，再执行第 21 行，以此类推，逻辑就解开了。
Dialogue: 0,1:42:59.96,1:43:03.72,中文,,0,0,0,,下周，我们将实际描绘出计算机内存中实际发生的情况。
Dialogue: 0,1:43:03.72,1:43:07.91,中文,,0,0,0,,现在，它与电话簿的伪代码非常相似。
Dialogue: 0,1:43:07.91,1:43:09.72,中文,,0,0,0,,你只是在一次又一次地搜索。
Dialogue: 0,1:43:09.72,1:43:14.45,中文,,0,0,0,,但是你要等到最后才能得到最终结果。
Dialogue: 0,1:43:14.45,1:43:18.99,中文,,0,0,0,,谷歌，我今天碰巧多次提到了它，当然，它有很多程序员。
Dialogue: 0,1:43:18.99,1:43:20.61,中文,,0,0,0,,这是一个有趣的练习。
Dialogue: 0,1:43:20.61,1:43:23.67,中文,,0,0,0,,让我回到浏览器。
Dialogue: 0,1:43:23.67,1:43:28.08,中文,,0,0,0,,我要搜索 recursion，因为我想学习一些关于递归的知识。
Dialogue: 0,1:43:28.08,1:43:30.22,中文,,0,0,0,,这有点像网络模因或笑话。
Dialogue: 0,1:43:30.22,1:43:35.38,中文,,0,0,0,,如果我放大这里，谷歌的工程师们还挺有趣的。
Dialogue: 0,1:43:35.38,1:43:39.52,中文,,0,0,0,,明白为什么吗？
Dialogue: 0,1:43:39.52,1:43:40.70,中文,,0,0,0,,好了。
Dialogue: 0,1:43:40.70,1:43:41.87,中文,,0,0,0,,看到了吗？
Dialogue: 0,1:43:41.87,1:43:43.05,中文,,0,0,0,,是的，这就是递归。
Dialogue: 0,1:43:43.05,1:43:52.66,中文,,0,0,0,,你会看到很多关于递归的梗，就像你曾经把相机对准显示相机的电视，你会一遍又一遍地看到你自己或图像，那就是递归。
Dialogue: 0,1:43:52.66,1:43:56.38,中文,,0,0,0,,在这种情况下，只有当你遇到单个像素的基本情况时，它才会停止。
Dialogue: 0,1:43:56.38,1:44:01.80,中文,,0,0,0,,当涉及到递归和 Google 时，这对某些圈子来说是一个非常有趣的笑话。
Dialogue: 0,1:44:01.80,1:44:08.21,中文,,0,0,0,,那么，我们如何才能真正地使用 Google，或者说，我们如何才能真正地建设性地使用递归呢？
Dialogue: 0,1:44:08.21,1:44:10.33,中文,,0,0,0,,让我提议一下。
Dialogue: 0,1:44:10.33,1:44:16.85,中文,,0,0,0,,我们实际上引入了第三个也是最后一个排序算法，希望它比目前为止的两种排序算法更好。
Dialogue: 0,1:44:16.85,1:44:19.69,中文,,0,0,0,,我们已经完成了选择排序和冒泡排序。
Dialogue: 0,1:44:19.69,1:44:24.19,中文,,0,0,0,,我们更喜欢冒泡排序，至少在列表已经排序的最佳情况下是这样。
Dialogue: 0,1:44:24.19,1:44:30.65,中文,,0,0,0,,冒泡排序至少更聪明，它实际上会提前终止，在我们的 Ω 符号方面给了我们一个更好的下界。
Dialogue: 0,1:44:30.65,1:44:40.09,中文,,0,0,0,,事实证明，递归，这不一定是递归的特性，而是我们现在可以利用的东西，事实证明，使用递归，
Dialogue: 0,1:44:40.09,1:44:49.09,中文,,0,0,0,,我们可以采用一种根本不同的方法来对一大堆数字进行排序，这样我们就可以进行少得多的比较，并且理想情况下可以加快最终结果。
Dialogue: 0,1:44:49.09,1:44:54.17,中文,,0,0,0,,这就是我们即将看到的所谓归并排序的伪代码。
Dialogue: 0,1:44:54.17,1:44:56.53,中文,,0,0,0,,它真的很简洁。
Dialogue: 0,1:44:56.53,1:44:58.63,中文,,0,0,0,,对数字的左半部分排序。
Dialogue: 0,1:44:58.63,1:45:00.71,中文,,0,0,0,,对数字的右半部分排序。
Dialogue: 0,1:45:00.71,1:45:02.94,中文,,0,0,0,,合并已排序的两半。
Dialogue: 0,1:45:02.94,1:45:14.28,中文,,0,0,0,,这几乎是荒谬的，因为如果你要求一个排序算法，你的回答是，对左半部分排序，对右半部分排序，这就有点困难了，因为我要求的是一个排序算法。
Dialogue: 0,1:45:14.28,1:45:16.82,中文,,0,0,0,,你只是在告诉我对左半部分和右半部分进行排序。
Dialogue: 0,1:45:16.82,1:45:21.78,中文,,0,0,0,,在最后一行中隐含的合并是这种排序的一个非常强大的功能。
Dialogue: 0,1:45:21.78,1:45:24.68,中文,,0,0,0,,现在，我们需要在顶部添加另一个基本情况。让我添加这个。
Dialogue: 0,1:45:24.68,1:45:29.84,中文,,0,0,0,,如果我们发现自己有一个大小为 1 的列表或数组，那么这个数组显然是已排序的。
Dialogue: 0,1:45:29.84,1:45:32.44,中文,,0,0,0,,如果它里面只有一个元素，那就不需要做任何工作。
Dialogue: 0,1:45:32.44,1:45:40.89,中文,,0,0,0,,这就是我们的基本情况，但现在只用这四、六行伪代码就可以对一些元素进行排序。
Dialogue: 0,1:45:40.89,1:45:43.67,中文,,0,0,0,,我们先关注其中的一部分。
Dialogue: 0,1:45:43.67,1:45:46.37,中文,,0,0,0,,我们先来思考一下合并已排序的两部分意味着什么。
Dialogue: 0,1:45:46.37,1:45:50.41,中文,,0,0,0,,Carter 很好心地自愿来帮助我们重置这些数字。
Dialogue: 0,1:45:50.41,1:45:56.05,中文,,0,0,0,,假设在我们即将讲述的故事的中间，我们有两个已排序的部分。
Dialogue: 0,1:45:56.05,1:45:58.29,中文,,0,0,0,,我已经对这些数字的左半部分进行了排序。
Dialogue: 0,1:45:58.29,1:46:01.77,中文,,0,0,0,,事实上，2、4、5、7 是按从小到大的顺序排列的。
Dialogue: 0,1:46:01.77,1:46:06.29,中文,,0,0,0,,右半部分似乎已经排好序了，0、1、3、6，已经排好序了。
Dialogue: 0,1:46:06.29,1:46:10.63,中文,,0,0,0,,所以在我的伪代码中，我们已经完成了对左半部分和右半部分的排序。
Dialogue: 0,1:46:10.63,1:46:12.35,中文,,0,0,0,,我们稍后会看到是如何做到的。
Dialogue: 0,1:46:12.35,1:46:14.99,中文,,0,0,0,,那么，我该如何合并这两部分呢？
Dialogue: 0,1:46:14.99,1:46:20.10,中文,,0,0,0,,因为它们已经排好序了，并且你想按顺序合并它们，我想我们可以翻转一下。
Dialogue: 0,1:46:20.10,1:46:25.22,中文,,0,0,0,,我们可以隐藏这两个子列表中除了第一个数字以外的所有数字。
Dialogue: 0,1:46:25.22,1:46:27.54,中文,,0,0,0,,所以这里我们有一半。
Dialogue: 0,1:46:27.54,1:46:28.52,中文,,0,0,0,,它从 2 开始。
Dialogue: 0,1:46:28.52,1:46:31.98,中文,,0,0,0,,我不太关心其他数字是什么，因为它们显然比 2 大。
Dialogue: 0,1:46:31.98,1:46:33.51,中文,,0,0,0,,我可以只关注 2。
Dialogue: 0,1:46:33.51,1:46:35.27,中文,,0,0,0,,还有 0。
Dialogue: 0,1:46:35.27,1:46:36.81,中文,,0,0,0,,我们知道 0 是最小的。
Dialogue: 0,1:46:36.81,1:46:39.39,中文,,0,0,0,,让我们忽略 Carter 翻下来的数字。
Dialogue: 0,1:46:39.39,1:46:44.25,中文,,0,0,0,,如何将这两个列表合并成一个更大的有序列表？
Dialogue: 0,1:46:44.25,1:46:48.24,中文,,0,0,0,,我将左边的 2 与右边的 0 进行比较。
Dialogue: 0,1:46:48.24,1:46:49.74,中文,,0,0,0,,显然，哪个在前？
Dialogue: 0,1:46:49.74,1:46:50.62,中文,,0,0,0,,是 0。
Dialogue: 0,1:46:50.62,1:46:52.14,中文,,0,0,0,,我把它放在这里。
Dialogue: 0,1:46:52.14,1:46:54.34,中文,,0,0,0,,Carter，请给我们下一个元素。
Dialogue: 0,1:46:54.34,1:46:57.70,中文,,0,0,0,,现在我有两个有序的部分，我已经取走了 1。
Dialogue: 0,1:46:57.70,1:47:00.30,中文,,0,0,0,,现在我将 2 与 1 进行比较。
Dialogue: 0,1:47:00.30,1:47:01.60,中文,,0,0,0,,显然 1 在前。
Dialogue: 0,1:47:01.60,1:47:05.11,中文,,0,0,0,,我将取出 1 并把它放在这里。
Dialogue: 0,1:47:05.11,1:47:06.95,中文,,0,0,0,,现在我将再次比较这两部分。
Dialogue: 0,1:47:06.95,1:47:08.97,中文,,0,0,0,,2 和 3，我先合并哪个？
Dialogue: 0,1:47:08.97,1:47:10.87,中文,,0,0,0,,显然，2 在前。
Dialogue: 0,1:47:10.87,1:47:15.21,中文,,0,0,0,,注意，每次我这样做时，我的手理论上都在向前推进。
Dialogue: 0,1:47:15.21,1:47:20.46,中文,,0,0,0,,我没有像选择排序或冒泡排序那样来回移动。
Dialogue: 0,1:47:20.46,1:47:27.50,中文,,0,0,0,,我的手指一直在向前移动，这是一个关键细节。我比较 4 和 3，显然是 3。
Dialogue: 0,1:47:27.50,1:47:32.76,中文,,0,0,0,,我比较 4 和 6，显然是 4。
Dialogue: 0,1:47:32.76,1:47:36.79,中文,,0,0,0,,我比较 5 和 6，显然是 5。
Dialogue: 0,1:47:36.79,1:47:41.09,中文,,0,0,0,,然后我比较 7 和 6，当然是 6 更小。
Dialogue: 0,1:47:41.09,1:47:42.99,中文,,0,0,0,,最后，我们只剩一个元素了。
Dialogue: 0,1:47:42.99,1:47:48.15,中文,,0,0,0,,尽管我作为一个人移动得有点笨拙，但从技术上讲，我的手只向右移动。
Dialogue: 0,1:47:48.15,1:47:51.13,中文,,0,0,0,,我从来没有循环回去，一遍又一遍地做某件事。
Dialogue: 0,1:47:51.13,1:47:54.69,中文,,0,0,0,,这可能就是直觉，而且刚好有足够的空间容纳数字 7。
Dialogue: 0,1:47:54.69,1:47:58.22,中文,,0,0,0,,这就是合并两个有序部分的方法。
Dialogue: 0,1:47:58.22,1:48:00.86,中文,,0,0,0,,我们从排序好的左半部分和排序好的右半部分开始。
Dialogue: 0,1:48:00.86,1:48:02.90,中文,,0,0,0,,合并就像你作为一个人会做的那样。
Dialogue: 0,1:48:02.90,1:48:08.86,中文,,0,0,0,,Carter 将数字向下翻转，所以我们只关注每组中最小的元素。
Dialogue: 0,1:48:08.86,1:48:17.13,中文,,0,0,0,,在我们继续深入探讨以这种方式合并意味着什么之前，大家有任何问题吗？
Dialogue: 0,1:48:17.13,1:48:19.13,中文,,0,0,0,,现在，这是一个原始列表。
Dialogue: 0,1:48:19.13,1:48:22.65,中文,,0,0,0,,我们故意把它放在顶部，因为归并排序有一个关键细节。
Dialogue: 0,1:48:22.65,1:48:25.40,中文,,0,0,0,,归并排序技术上会使用更多的空间。
Dialogue: 0,1:48:25.40,1:48:32.27,中文,,0,0,0,,因此，虽然之前我们只是让人们四处走动、交换位置，并确保他们最终回到原来的位置，
Dialogue: 0,1:48:32.27,1:48:36.81,中文,,0,0,0,,但在归并排序中，假设这是我们原始的内存数组。
Dialogue: 0,1:48:36.81,1:48:38.95,中文,,0,0,0,,我至少需要另一个内存数组。
Dialogue: 0,1:48:38.95,1:48:41.26,中文,,0,0,0,,我要作弊，我要用更多内存。
Dialogue: 0,1:48:41.26,1:48:45.54,中文,,0,0,0,,从技术上讲，我实际上可以在一个数组和一个辅助数组之间来回切换。
Dialogue: 0,1:48:45.54,1:48:48.51,中文,,0,0,0,,这确实需要我占用更多空间。
Dialogue: 0,1:48:48.51,1:48:51.03,中文,,0,0,0,,那么，我该如何实现归并排序呢？
Dialogue: 0,1:48:51.03,1:48:54.99,中文,,0,0,0,,对这段代码进行归并排序，我们来考虑一下。
Dialogue: 0,1:48:54.99,1:48:57.21,中文,,0,0,0,,这里有一个大小为 8 的数组。
Dialogue: 0,1:48:57.21,1:48:59.49,中文,,0,0,0,,如果只有一个数字，显然不适用。
Dialogue: 0,1:48:59.49,1:49:01.41,中文,,0,0,0,,所以我们关注重点部分。
Dialogue: 0,1:49:01.41,1:49:03.02,中文,,0,0,0,,将左半部分数字排序。
Dialogue: 0,1:49:03.02,1:49:05.12,中文,,0,0,0,,如何对左半部分数字排序？
Dialogue: 0,1:49:05.12,1:49:09.28,中文,,0,0,0,,为了清楚起见，我把它们往旁边挪一下，这就是左半部分。
Dialogue: 0,1:49:09.28,1:49:11.98,中文,,0,0,0,,现在这是一个大小为 4 的子列表。
Dialogue: 0,1:49:11.98,1:49:15.00,中文,,0,0,0,,如何对左半部分排序？
Dialogue: 0,1:49:15.00,1:49:18.45,中文,,0,0,0,,我有一个排序算法吗？有，我该怎么做？
Dialogue: 0,1:49:18.45,1:49:22.20,中文,,0,0,0,,这是一个大小为 4 的列表。如何排序？第一步是什么？
Dialogue: 0,1:49:22.20,1:49:23.38,中文,,0,0,0,,对左半部分排序。
Dialogue: 0,1:49:23.38,1:49:32.19,中文,,0,0,0,,所以我现在在脑海中，将这个大小为 4 的子列表，通过首先对左半部分排序，也就是关注 7 和 2 来进行排序。
Dialogue: 0,1:49:32.19,1:49:34.45,中文,,0,0,0,,这是一个大小为 2 的列表。
Dialogue: 0,1:49:34.45,1:49:38.85,中文,,0,0,0,,如何对大小为 2 的列表排序？
Dialogue: 0,1:49:38.85,1:49:42.38,中文,,0,0,0,,什么？我认为我们只需继续按照指示进行。
Dialogue: 0,1:49:42.38,1:49:43.72,中文,,0,0,0,,对左半部分排序。
Dialogue: 0,1:49:43.72,1:49:45.79,中文,,0,0,0,,这是一个大小为 1 的列表。
Dialogue: 0,1:49:45.79,1:49:49.95,中文,,0,0,0,,如何对大小为 1 的列表排序？
Dialogue: 0,1:49:49.95,1:49:50.47,中文,,0,0,0,,我完成了。
Dialogue: 0,1:49:50.47,1:49:51.29,中文,,0,0,0,,就像，它完成了。
Dialogue: 0,1:49:51.29,1:49:52.85,中文,,0,0,0,,所以我就不管它了。
Dialogue: 0,1:49:52.85,1:49:54.75,中文,,0,0,0,,下一步是什么？
Dialogue: 0,1:49:54.75,1:49:58.33,中文,,0,0,0,,我排序了左半边的左半边的左半边。
Dialogue: 0,1:49:58.33,1:49:59.69,中文,,0,0,0,,接下来呢？
Dialogue: 0,1:49:59.69,1:50:03.50,中文,,0,0,0,,我排序左半边的左半边的右半边。
Dialogue: 0,1:50:03.50,1:50:06.54,中文,,0,0,0,,完成了，因为它只有一个元素。
Dialogue: 0,1:50:06.54,1:50:09.35,中文,,0,0,0,,接下来是什么？
Dialogue: 0,1:50:09.35,1:50:10.27,中文,,0,0,0,,合并。
Dialogue: 0,1:50:10.27,1:50:16.27,中文,,0,0,0,,这部分有点烧脑，因为你必须记住我们在哪里暂停，一次又一次地递归执行操作。
Dialogue: 0,1:50:16.27,1:50:20.94,中文,,0,0,0,,如果我已经排序了左半边和右半边，现在我把它们合并在一起。
Dialogue: 0,1:50:20.94,1:50:25.06,中文,,0,0,0,,这是一个非常短的列表，所以我们不需要像之前那样寻求 Carter 的帮助。
Dialogue: 0,1:50:25.06,1:50:27.84,中文,,0,0,0,,我认为我在这里取的第一个数字是 2。
Dialogue: 0,1:50:27.84,1:50:31.85,中文,,0,0,0,,然后我取的第二个数字是 7，因为它是唯一的选择。
Dialogue: 0,1:50:31.85,1:50:37.11,中文,,0,0,0,,现在好的一点是，请注意，左半边的左半边确实是排序的。
Dialogue: 0,1:50:37.11,1:50:42.82,中文,,0,0,0,,因为我简单地排序了它的左半边和右半边，但合并才是真正神奇的地方。
Dialogue: 0,1:50:42.82,1:50:51.64,中文,,0,0,0,,再次，如果你在脑海中回放，如果我已经排序了左半边的左半边，接下来会发生什么？
Dialogue: 0,1:50:51.64,1:50:55.08,中文,,0,0,0,,排序左半边的右半边。
Dialogue: 0,1:50:55.08,1:50:56.88,中文,,0,0,0,,你要在时间上回溯。
Dialogue: 0,1:50:56.88,1:50:58.27,中文,,0,0,0,,我该怎么做？
Dialogue: 0,1:50:58.27,1:50:59.55,中文,,0,0,0,,我有一个大小为 2 的列表。
Dialogue: 0,1:50:59.55,1:51:00.61,中文,,0,0,0,,我先将左半部分排序。
Dialogue: 0,1:51:00.61,1:51:01.51,中文,,0,0,0,,调整 5。
Dialogue: 0,1:51:01.51,1:51:02.09,中文,,0,0,0,,完成。
Dialogue: 0,1:51:02.09,1:51:03.41,中文,,0,0,0,,将右半部分排序。
Dialogue: 0,1:51:03.41,1:51:03.69,中文,,0,0,0,,4。
Dialogue: 0,1:51:03.69,1:51:04.37,中文,,0,0,0,,完成。
Dialogue: 0,1:51:04.37,1:51:05.45,中文,,0,0,0,,现在是重点。
Dialogue: 0,1:51:05.45,1:51:11.49,中文,,0,0,0,,我要合并左半部分和右半部分的右半部分的左半部分。
Dialogue: 0,1:51:11.49,1:51:12.79,中文,,0,0,0,,那我该怎么做？
Dialogue: 0,1:51:12.79,1:51:14.79,中文,,0,0,0,,4 放到这下面。
Dialogue: 0,1:51:14.79,1:51:16.51,中文,,0,0,0,,5 放到这下面。
Dialogue: 0,1:51:16.51,1:51:18.45,中文,,0,0,0,,然后呢？
Dialogue: 0,1:51:18.45,1:51:20.07,中文,,0,0,0,,注意看我现在拥有什么。
Dialogue: 0,1:51:20.07,1:51:21.81,中文,,0,0,0,,左半部分已排序。
Dialogue: 0,1:51:21.81,1:51:23.19,中文,,0,0,0,,右半部分已排序。
Dialogue: 0,1:51:23.19,1:51:26.03,中文,,0,0,0,,如果我们倒带回去，我的下一步是什么？
Dialogue: 0,1:51:26.03,1:51:26.79,中文,,0,0,0,,3？
Dialogue: 0,1:51:26.79,1:51:27.83,中文,,0,0,0,,合并这两个部分。
Dialogue: 0,1:51:27.83,1:51:29.71,中文,,0,0,0,,这就是 Carter 之前帮我做的事情。
Dialogue: 0,1:51:29.71,1:51:32.69,中文,,0,0,0,,我们先只关注最小的元素，这样干扰会少一些。
Dialogue: 0,1:51:32.69,1:51:34.32,中文,,0,0,0,,比较 2 和 4。
Dialogue: 0,1:51:34.32,1:51:36.66,中文,,0,0,0,,2 在前面，所以很明显把它放在这里。
Dialogue: 0,1:51:36.66,1:51:41.56,中文,,0,0,0,,现在比较这个列表的新开头和旧开头。
Dialogue: 0,1:51:41.56,1:51:43.32,中文,,0,0,0,,显然 4 在后面。
Dialogue: 0,1:51:43.32,1:51:46.28,中文,,0,0,0,,现在比较 7 和 5。
Dialogue: 0,1:51:46.28,1:51:47.48,中文,,0,0,0,,显然 5 在后面。
Dialogue: 0,1:51:47.48,1:51:49.31,中文,,0,0,0,,现在只剩下一个数字了。
Dialogue: 0,1:51:49.31,1:51:51.15,中文,,0,0,0,,所以现在只剩下 7 了。
Dialogue: 0,1:51:51.15,1:51:58.43,中文,,0,0,0,,即使你没有完全理解其中的细节，只要退一步看，我们还有原始的右半部分没有动。
Dialogue: 0,1:51:58.43,1:52:09.02,中文,,0,0,0,,但是原始输入的左半部分现在确实排序了，都是通过对左半部分、右半部分、左半部分、右半部分进行排序，但中间进行了合并。
Dialogue: 0,1:52:09.02,1:52:12.20,中文,,0,0,0,,好了，如果我们刚刚对左半部分进行了排序，
Dialogue: 0,1:52:12.20,1:52:13.56,中文,,0,0,0,,我们回退到最开始。
Dialogue: 0,1:52:13.56,1:52:15.70,中文,,0,0,0,,我现在要做什么？
Dialogue: 0,1:52:15.70,1:52:17.12,中文,,0,0,0,,对，排序右半部分。
Dialogue: 0,1:52:17.12,1:52:18.39,中文,,0,0,0,,排序右半部分。
Dialogue: 0,1:52:18.39,1:52:20.29,中文,,0,0,0,,如何对大小为 4 的列表进行排序？
Dialogue: 0,1:52:20.29,1:52:22.65,中文,,0,0,0,,首先排序左半部分，1 和 6。
Dialogue: 0,1:52:22.65,1:52:24.65,中文,,0,0,0,,如何对大小为 2 的列表进行排序？
Dialogue: 0,1:52:24.65,1:52:26.93,中文,,0,0,0,,排序左半部分，只有数字 1。
Dialogue: 0,1:52:26.93,1:52:28.47,中文,,0,0,0,,显然，这里没有工作要做。
Dialogue: 0,1:52:28.47,1:52:30.85,中文,,0,0,0,,完成，左半边排序完毕。
Dialogue: 0,1:52:30.85,1:52:33.24,中文,,0,0,0,,6，完成，右半边排序完毕。
Dialogue: 0,1:52:33.24,1:52:34.36,中文,,0,0,0,,现在我要做什么？
Dialogue: 0,1:52:34.36,1:52:40.76,中文,,0,0,0,,我把左半边和右半边合并。
Dialogue: 0,1:52:40.76,1:52:42.30,中文,,0,0,0,,这个很简单。
Dialogue: 0,1:52:42.30,1:52:44.08,中文,,0,0,0,,现在我要做什么？ 我刚刚合并了。
Dialogue: 0,1:52:44.08,1:52:47.10,中文,,0,0,0,,现在我已经对右半边的左半边进行了排序。
Dialogue: 0,1:52:47.10,1:52:49.75,中文,,0,0,0,,现在我将对右半边的右半边进行排序。
Dialogue: 0,1:52:49.75,1:52:51.65,中文,,0,0,0,,我考虑 0，完成。
Dialogue: 0,1:52:51.65,1:52:53.41,中文,,0,0,0,,我考虑 3，完成。
Dialogue: 0,1:52:53.41,1:52:55.47,中文,,0,0,0,,现在我把这两个合并在一起。
Dialogue: 0,1:52:55.47,1:52:56.71,中文,,0,0,0,,当然，0 在最前面。
Dialogue: 0,1:52:56.71,1:52:58.25,中文,,0,0,0,,然后是 3。
Dialogue: 0,1:52:58.25,1:53:05.05,中文,,0,0,0,,现在我已经对右半边的左半边和右半边的右半边进行了排序。
Dialogue: 0,1:53:05.05,1:53:09.47,中文,,0,0,0,,那么第三步是什么？合并，我会像和 Carter 一起做的那样再做一次。
Dialogue: 0,1:53:09.47,1:53:10.69,中文,,0,0,0,,好的，1 和 0。
Dialogue: 0,1:53:10.69,1:53:12.51,中文,,0,0,0,,显然，0 在最前面。
Dialogue: 0,1:53:12.51,1:53:14.48,中文,,0,0,0,,现在比较 1 和 3。
Dialogue: 0,1:53:14.48,1:53:16.22,中文,,0,0,0,,显然，1 在最前面。
Dialogue: 0,1:53:16.22,1:53:17.56,中文,,0,0,0,,比较 6 和 3。
Dialogue: 0,1:53:17.56,1:53:18.74,中文,,0,0,0,,显然是 3。
Dialogue: 0,1:53:18.74,1:53:20.52,中文,,0,0,0,,最后是 6。
Dialogue: 0,1:53:20.52,1:53:22.04,中文,,0,0,0,,现在到哪了？
Dialogue: 0,1:53:22.04,1:53:27.00,中文,,0,0,0,,我们已经排序了整个数组的左半部分。
Dialogue: 0,1:53:27.00,1:53:30.18,中文,,0,0,0,,然后我们排序了整个数组的右半部分。
Dialogue: 0,1:53:30.18,1:53:35.28,中文,,0,0,0,,现在，我们最后一次来到步骤 3。我们要做什么？
Dialogue: 0,1:53:35.28,1:53:39.35,中文,,0,0,0,,合并，为了保持一致，我把这些往下推。
Dialogue: 0,1:53:39.35,1:53:45.45,中文,,0,0,0,,让我们比较左边和右边，注意它们只进行向前的比较，没有来回的比较。
Dialogue: 0,1:53:45.45,1:53:47.43,中文,,0,0,0,,2 和 0，当然是 0。
Dialogue: 0,1:53:47.43,1:53:49.31,中文,,0,0,0,,所以我们把它放在这里。
Dialogue: 0,1:53:49.31,1:53:51.15,中文,,0,0,0,,2 和 1，当然是 1。
Dialogue: 0,1:53:51.15,1:53:53.33,中文,,0,0,0,,所以我们把它放在这里。
Dialogue: 0,1:53:53.33,1:53:57.41,中文,,0,0,0,,2 和 3，我们合并，当然是 2。
Dialogue: 0,1:53:57.41,1:54:01.25,中文,,0,0,0,,4 和 3，我们现在合并，得到 3。
Dialogue: 0,1:54:01.25,1:54:05.94,中文,,0,0,0,,4 和 6，我们现在合并，当然是 4。
Dialogue: 0,1:54:05.94,1:54:12.72,中文,,0,0,0,,现在我们比较 5 和 6。我们保留 5。
Dialogue: 0,1:54:12.72,1:54:15.41,中文,,0,0,0,,错误。
Dialogue: 0,1:54:15.41,1:54:20.11,中文,,0,0,0,,好吧，假设 5 亮着。
Dialogue: 0,1:54:20.11,1:54:21.57,中文,,0,0,0,,这就是原因。
Dialogue: 0,1:54:21.57,1:54:23.39,中文,,0,0,0,,好，现在我们比较 7 和 6。
Dialogue: 0,1:54:23.39,1:54:26.73,中文,,0,0,0,,6 没了。
Dialogue: 0,1:54:26.73,1:54:29.59,中文,,0,0,0,,最后，7 是最后一个。
Dialogue: 0,1:54:29.59,1:54:41.00,中文,,0,0,0,,我承认，在所有算法中，这可能是最难掌握的一个，尤其是我现在是用画外音的方式来讲解。你要知道，我们刚才所做的只是递归地执行了那三个步骤。
Dialogue: 0,1:54:41.00,1:54:42.61,中文,,0,0,0,,我们开始时有一个大小为 8 的列表。
Dialogue: 0,1:54:42.61,1:54:43.77,中文,,0,0,0,,我们对左半部分进行了排序。
Dialogue: 0,1:54:43.77,1:54:44.93,中文,,0,0,0,,我们对右半部分进行了排序。
Dialogue: 0,1:54:44.93,1:54:46.37,中文,,0,0,0,,然后我们将这两部分合并在一起。
Dialogue: 0,1:54:46.37,1:54:54.03,中文,,0,0,0,,如果你深入到每一个“兔子洞”中，也就是说，对左半部分进行排序涉及到对左半部分的左半部分和左半部分的右半部分进行排序。
Dialogue: 0,1:54:54.03,1:55:02.52,中文,,0,0,0,,以此类推。 这种“分而治之”的思想的核心，并不是说你要把问题分成两半，只处理其中的一半。
Dialogue: 0,1:55:02.52,1:55:07.84,中文,,0,0,0,,显然，我们最终是要对一半进行排序，然后再对另一半进行排序，最后将它们合并在一起。
Dialogue: 0,1:55:07.84,1:55:10.91,中文,,0,0,0,,它确实仍然可以让我们得到相同的解决方案。
Dialogue: 0,1:55:10.91,1:55:15.43,中文,,0,0,0,,如果我们现在将剩下的部分可视化，就像这样，
Dialogue: 0,1:55:15.43,1:55:20.41,中文,,0,0,0,,在屏幕上，你可以看到数字最初在顶行从左到右的位置。
Dialogue: 0,1:55:20.41,1:55:29.00,中文,,0,0,0,,本质上，即使顺序不同，但我最终还是将这个大小为 8 的列表分成了 8 个大小为 1 的列表。
Dialogue: 0,1:55:29.00,1:55:32.84,中文,,0,0,0,,这就是基本情况发挥作用的地方，它只是说，好了，我们已经完成了排序。
Dialogue: 0,1:55:32.84,1:55:41.40,中文,,0,0,0,,在那之后，从逻辑上讲，我将两个大小为 1 的列表合并成许多大小为 2 的列表，然后将这些大小为 2 的列表合并成大小为 4 的列表，
Dialogue: 0,1:55:41.40,1:55:47.40,中文,,0,0,0,,最后将大小为 4 的列表合并成一个大小为 8 的已排序的大列表。
Dialogue: 0,1:55:47.40,1:55:55.82,中文,,0,0,0,,我在这里用小线条指示器来展示这张图片，是因为我将它分成一半、一半、一半地分了多少次？
Dialogue: 0,1:55:55.82,1:55:57.34,中文,,0,0,0,,或者实际上是翻倍、翻倍、翻倍了多少次。
Dialogue: 0,1:55:57.34,1:55:59.07,中文,,0,0,0,,所以指数运算和这个相反。
Dialogue: 0,1:55:59.07,1:56:00.77,中文,,0,0,0,,哦，剧透了。
Dialogue: 0,1:56:00.77,1:56:02.61,中文,,0,0,0,,我除了几次？
Dialogue: 0,1:56:02.61,1:56:04.51,中文,,0,0,0,,三次。
Dialogue: 0,1:56:04.51,1:56:12.31,中文,,0,0,0,,如果总共有 8 个元素，或者更一般地说，有 n 个元素，那么实际上就是 log n 次“分而治之”。
Dialogue: 0,1:56:12.31,1:56:15.35,中文,,0,0,0,,你可以这样开始，你可以除以 1、2、3 次，也就是 log n 次。
Dialogue: 0,1:56:15.35,1:56:25.68,中文,,0,0,0,,或者反过来，你可以从这里开始，指数级地翻倍、翻倍、翻倍三次，也就是 log n 次。实际上，在每一行、每一个“架子”上，我都小题大做了，
Dialogue: 0,1:56:25.68,1:56:34.54,中文,,0,0,0,,我的手只是从左到右地指着，不断地向前移动，这样每次我进行合并的时候，我都会且只会碰到每个元素一次。
Dialogue: 0,1:56:34.54,1:56:37.71,中文,,0,0,0,,在台上没有来回走动的情况。
Dialogue: 0,1:56:37.71,1:56:49.77,中文,,0,0,0,,如果我做某事 log n 次，或者更确切地说，我做 n 件事 log n 次，那我们的大 O 表示法会是什么呢？
Dialogue: 0,1:56:49.77,1:56:52.31,中文,,0,0,0,,做 n 件事 log n 次？
Dialogue: 0,1:56:52.31,1:56:58.60,中文,,0,0,0,,是的，n log n，n log n 的阶就是我们描述归并排序运行时间的方式。
Dialogue: 0,1:56:58.60,1:57:10.82,中文,,0,0,0,,到目前为止，在我们见过的所有排序算法中，归并排序实际上是 n log n，这明显优于 n²，也就是选择排序和冒泡排序的时间复杂度。
Dialogue: 0,1:57:10.82,1:57:14.12,中文,,0,0,0,,它也比线性搜索慢。
Dialogue: 0,1:57:14.12,1:57:15.39,中文,,0,0,0,,这也在你的预期之内。
Dialogue: 0,1:57:15.39,1:57:21.59,中文,,0,0,0,,如果你必须在前期做大量工作来对一些元素进行排序，而不是仅仅搜索它们，那么你就必须付出更多的努力。
Dialogue: 0,1:57:21.59,1:57:30.29,中文,,0,0,0,,是否应该使用线性搜索盲目地搜索某个东西而不进行排序，这个问题的答案归结为：你是否能够承受花费这么多时间？
Dialogue: 0,1:57:30.29,1:57:35.17,中文,,0,0,0,,如果你是像 Google 这样的公司，你肯定不想每次都线性搜索你的数据库。
Dialogue: 0,1:57:35.17,1:57:35.81,中文,,0,0,0,,为什么？
Dialogue: 0,1:57:35.81,1:57:46.65,中文,,0,0,0,,因为你可以对它排序一次，然后让随后数十亿人受益，他们可以使用二分搜索，或者实际上比二分搜索更高级、更快的算法。
Dialogue: 0,1:57:46.65,1:57:48.49,中文,,0,0,0,,这其中总是有一个权衡。
Dialogue: 0,1:57:48.49,1:57:52.30,中文,,0,0,0,,只有元素有序排列时，才能实现二分查找。
Dialogue: 0,1:57:52.30,1:57:53.96,中文,,0,0,0,,对它们进行排序需要多少成本？
Dialogue: 0,1:57:53.96,1:57:57.10,中文,,0,0,0,,如果使用前面提到的一些算法，可能是 n²。
Dialogue: 0,1:57:57.10,1:58:01.00,中文,,0,0,0,,事实证明，n log n 也相当快。
Dialogue: 0,1:58:01.00,1:58:06.25,中文,,0,0,0,,因此，最终，这些运行时间涉及到权衡。
Dialogue: 0,1:58:06.25,1:58:17.24,中文,,0,0,0,,实际上，关于归并排序 2，我还应该指出，归并排序的下限也将是 Ω(n log n)。\N因此，我们可以用 Θ 符号来描述它，说归并排序实际上是在 Θ(n log n)。
Dialogue: 0,1:58:17.24,1:58:28.22,中文,,0,0,0,,所以一般来说，可能最好使用归并排序或其他一些在 O(n log n) 中的算法。在实践中，大多数程序员不会自己实现这些排序算法。
Dialogue: 0,1:58:28.22,1:58:34.33,中文,,0,0,0,,他们很可能会使用现成的库，这些库本身已经决定了使用哪种算法。
Dialogue: 0,1:58:34.33,1:58:42.83,中文,,0,0,0,,总的来说，我们现在第一次看到，如果想要提高时间效率，比如使用更少的时间，编写更快的代码，就必须付出代价。
Dialogue: 0,1:58:42.83,1:58:49.44,中文,,0,0,0,,这可能是需要你花费更多的人力时间。编写更复杂、更难实现的代码需要你花费更多的时间。
Dialogue: 0,1:58:49.44,1:58:52.04,中文,,0,0,0,,或者你需要花费一些空间。
Dialogue: 0,1:58:52.04,1:58:55.82,中文,,0,0,0,,正如这些架子所示，这也是归并排序的关键细节之一。
Dialogue: 0,1:58:55.82,1:58:58.61,中文,,0,0,0,,你不能只是让元素原地交换。
Dialogue: 0,1:58:58.61,1:59:04.11,中文,,0,0,0,,你至少需要一个辅助数组，这样在进行合并时，你就有地方放置它们。
Dialogue: 0,1:59:04.11,1:59:06.15,中文,,0,0,0,,这么大的内存空间太过分了。
Dialogue: 0,1:59:06.15,1:59:08.99,中文,,0,0,0,,我本来可以在顶层和底层之间来回移动。
Dialogue: 0,1:59:08.99,1:59:11.19,中文,,0,0,0,,自上而下会更有趣一些。
Dialogue: 0,1:59:11.19,1:59:12.98,中文,,0,0,0,,但你的确需要更多的空间。
Dialogue: 0,1:59:12.98,1:59:15.78,中文,,0,0,0,,几十年前，空间真的很昂贵。
Dialogue: 0,1:59:15.78,1:59:16.48,中文,,0,0,0,,你知道吗？
Dialogue: 0,1:59:16.48,1:59:23.44,中文,,0,0,0,,也许不用归并排序，而使用冒泡排序、选择排序，或者其他算法会更好。
Dialogue: 0,1:59:23.44,1:59:25.31,中文,,0,0,0,,现在，空间相对便宜。
Dialogue: 0,1:59:25.31,1:59:27.19,中文,,0,0,0,,所以这些都是更容易接受的权衡。
Dialogue: 0,1:59:27.19,1:59:29.85,中文,,0,0,0,,这完全取决于应用程序。
Dialogue: 0,1:59:29.85,1:59:34.45,中文,,0,0,0,,我们最后想做的是向你展示一些排序算法的实际比较。
Dialogue: 0,1:59:34.45,1:59:47.03,中文,,0,0,0,,这个视频大约 60 秒长，它将并行比较选择排序、冒泡排序和归并排序，同时配有一些有趣的排序音乐，
Dialogue: 0,1:59:47.03,1:59:59.03,中文,,0,0,0,,最终向你展示 O(n²) 或 O(n log n) 的真正含义。顶部是选择排序，底部是冒泡排序，中间是归并排序。
Dialogue: 0,2:00:53.67,2:00:55.70,中文,,0,0,0,,好了，CS50 就到这里。
Dialogue: 0,2:00:55.70,2:00:56.64,中文,,0,0,0,,下次再见。
Dialogue: 0,0:00:00.00,0:00:05.00,英文,,0,0,0,,
