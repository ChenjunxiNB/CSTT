[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 3
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1152
PlayResY: 720

[Aegisub Project Garbage]
Export Encoding: Unicode (UTF-8)
Audio File: D:/python_code/video_tool/video_tool/result/[61B SP24] Lecture 17 - B-Trees (2-3, 2-3-4 Trees).mp4
Video File: D:/python_code/video_tool/video_tool/result/[61B SP24] Lecture 17 - B-Trees (2-3, 2-3-4 Trees).mp4
Video AR Mode: 4
Video AR Value: 1.600000
Video Zoom Percent: 0.750000
Scroll Position: 876
Active Line: 885
Video Position: 11471

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,13,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,90,100,0,0,1,1.33333,1.33333,2,6,6,7,1
Style: 英文,Arial,24,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1.33333,1.33333,2,1,1,5,1
Style: 中文,微软雅黑,38,&H0029EEF1,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1.33333,1.33333,2,2,2,30,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,
Dialogue: 0,0:00:02.15,0:00:05.39,英文,,0,0,0,,Oh, OK.
Dialogue: 0,0:00:05.39,0:00:06.88,英文,,0,0,0,,OK.
Dialogue: 0,0:00:06.88,0:00:09.34,英文,,0,0,0,,Hello again.
Dialogue: 0,0:00:06.88,0:00:09.34,中文,,0,0,0,,再次你好
Dialogue: 0,0:00:09.34,0:00:13.62,英文,,0,0,0,,Let's finish talking about Dijkstra's, and then I'll show you some minimum spanning trees.
Dialogue: 0,0:00:09.34,0:00:13.62,中文,,0,0,0,,让我们先谈谈迪杰斯特拉 然后我会给你展示一些最小生成树
Dialogue: 0,0:00:13.62,0:00:14.42,英文,,0,0,0,,Fun.
Dialogue: 0,0:00:13.62,0:00:14.42,中文,,0,0,0,,有趣
Dialogue: 0,0:00:14.42,0:00:17.00,英文,,0,0,0,,OK, so here's the proof sketch from last time.
Dialogue: 0,0:00:14.42,0:00:17.00,中文,,0,0,0,,好的 这是上次的证明概要
Dialogue: 0,0:00:17.00,0:00:20.99,英文,,0,0,0,,I won't go through it in too much detail, because you saw it at the end of last lecture.
Dialogue: 0,0:00:17.00,0:00:20.99,中文,,0,0,0,,我不会详细讲解 因为你在上一堂课的结尾已经看过了
Dialogue: 0,0:00:20.99,0:00:28.82,英文,,0,0,0,,But the one thing I want to highlight, the thing that makes Dijkstra's work, is the fact that if you try to relax,
Dialogue: 0,0:00:20.99,0:00:28.82,中文,,0,0,0,,但我想要强调的一件事是 让迪杰斯特拉的工作变得特别的那个东西 就是如果你试图放弃
Dialogue: 0,0:00:28.82,0:00:35.70,英文,,0,0,0,,an edge that points at a vertex you've already visited, that relaxation will fail.
Dialogue: 0,0:00:28.82,0:00:35.70,中文,,0,0,0,,指向已经访问过的顶点的边 那么放弃就会失败
Dialogue: 0,0:00:35.70,0:00:40.71,英文,,0,0,0,,Hopefully you're sick of hearing me say that at this point, but that is the property that makes Dijkstra's work.
Dialogue: 0,0:00:35.70,0:00:40.71,中文,,0,0,0,,希望到了这个时候你已经厌烦我说这个了 但这就是让迪杰斯特拉的工作变得特别的那个性质
Dialogue: 0,0:00:40.71,0:00:44.95,英文,,0,0,0,,Here's the picture that I tried to draw to make it clear why this is the case.
Dialogue: 0,0:00:40.71,0:00:44.95,中文,,0,0,0,,这是我试图画出来以便清楚地说明为什么会这样的图片
Dialogue: 0,0:00:44.95,0:00:47.65,英文,,0,0,0,,So here I have a visited edge, V1.
Dialogue: 0,0:00:44.95,0:00:47.65,中文,,0,0,0,,这里我有一个已经访问过的边 V1
Dialogue: 0,0:00:47.65,0:00:48.35,英文,,0,0,0,,It's white.
Dialogue: 0,0:00:47.65,0:00:48.35,中文,,0,0,0,,它是白色的
Dialogue: 0,0:00:48.35,0:00:50.79,英文,,0,0,0,,I've already been there.
Dialogue: 0,0:00:48.35,0:00:50.79,中文,,0,0,0,,我已经去过那里了
Dialogue: 0,0:00:50.79,0:00:58.48,英文,,0,0,0,,And so if I have an edge, like w, and I'm considering, do I want to use w and add it to the family, or do I not want to use w?
Dialogue: 0,0:00:50.79,0:00:58.48,中文,,0,0,0,,如果我有一个边缘 像w这样 我在考虑 我要使用w并将其添加到家庭中 还是不想使用w呢
Dialogue: 0,0:00:58.48,0:01:03.49,英文,,0,0,0,,Well, then I have to consider, what is the cost if I use w to go to v1?
Dialogue: 0,0:00:58.48,0:01:03.49,中文,,0,0,0,,那么 我必须考虑 如果我使用w去v1的成本是多少
Dialogue: 0,0:01:03.49,0:01:05.21,英文,,0,0,0,,Well, it's the sum of two numbers.
Dialogue: 0,0:01:03.49,0:01:05.21,中文,,0,0,0,,好吧 那就是两个数字的总和
Dialogue: 0,0:01:05.21,0:01:07.27,英文,,0,0,0,,First, I need to get.
Dialogue: 0,0:01:05.21,0:01:07.27,中文,,0,0,0,,首先 我需要到达
Dialogue: 0,0:01:07.27,0:01:13.01,英文,,0,0,0,,to P, which already costs more than C, because I said V1 is the closest vertex.
Dialogue: 0,0:01:07.27,0:01:13.01,中文,,0,0,0,,到P 这已经比C更贵 因为我说V1是最近的顶点
Dialogue: 0,0:01:13.01,0:01:21.10,英文,,0,0,0,,So to get to P, it already costs me more than C. And then I add even more weight, even more W on top of that greater than C weight.
Dialogue: 0,0:01:13.01,0:01:21.10,中文,,0,0,0,,要到P 我已经花了比C更多的钱 然后我还要增加更多的权重 甚至比C的权重更大
Dialogue: 0,0:01:21.10,0:01:30.08,英文,,0,0,0,,Well, then the sum of this number in red plus this number in blue, that's definitely going to be greater than C. So this edge will not be used.
Dialogue: 0,0:01:21.10,0:01:30.08,中文,,0,0,0,,那么这个红色数字加上这个蓝色数字的总和肯定会大于C 所以这条边将不会被使用
Dialogue: 0,0:01:30.08,0:01:36.02,英文,,0,0,0,,Because if I try to relax it, the sum of these two numbers, a number that's greater than C, and I add more,
Dialogue: 0,0:01:30.08,0:01:36.02,中文,,0,0,0,,因为如果我试着放弃它 这两个数字的总和 一个比 C 大的数字 我再加上更多
Dialogue: 0,0:01:36.02,0:01:40.18,英文,,0,0,0,,definitely going to be greater than c, so no point using this edge.
Dialogue: 0,0:01:36.02,0:01:40.18,中文,,0,0,0,,肯定会大于 c 所以没有使用这个边的意义
Dialogue: 0,0:01:40.18,0:01:46.93,英文,,0,0,0,,And the same holds for any other deeper edge in the graph, because I assumed that v1 is the closest vertex.
Dialogue: 0,0:01:40.18,0:01:46.93,中文,,0,0,0,,对于图中的任何其他更深的边都是一样的 因为我假设 v1 是最近的顶点
Dialogue: 0,0:01:46.93,0:01:50.39,英文,,0,0,0,,That's why I marked it first, because I'm visiting in best first order.
Dialogue: 0,0:01:46.93,0:01:50.39,中文,,0,0,0,,这就是为什么我首先标记它的原因 因为我按照最佳优先顺序访问
Dialogue: 0,0:01:50.39,0:01:52.27,英文,,0,0,0,,I'm doing all the closer ones first.
Dialogue: 0,0:01:50.39,0:01:52.27,中文,,0,0,0,,我首先处理所有更接近的顶点
Dialogue: 0,0:01:52.27,0:02:02.30,英文,,0,0,0,,So if this was the closest vertex and I already visited it, then any of these further vertices having an edge pointing at v1, their relaxations will fail.
Dialogue: 0,0:01:52.27,0:02:02.30,中文,,0,0,0,,如果这是最近的顶点 而且我已经访问过它 那么任何指向 v1 的更远的顶点的边 它们的放弃都会失败
Dialogue: 0,0:02:02.30,0:02:03.62,英文,,0,0,0,,And I don't even have to do the math.
Dialogue: 0,0:02:02.30,0:02:03.62,中文,,0,0,0,,而且我甚至不需要做数学计算
Dialogue: 0,0:02:03.62,0:02:07.14,英文,,0,0,0,,I can just look and say, well, this edge is pointing at a marked vertex.
Dialogue: 0,0:02:03.62,0:02:07.14,中文,,0,0,0,,我只需看一眼就能说 这个边是指向一个标记过的顶点的
Dialogue: 0,0:02:07.14,0:02:10.26,英文,,0,0,0,,That relaxation, not going to work.
Dialogue: 0,0:02:07.14,0:02:10.26,中文,,0,0,0,,那种放弃 不会奏效
Dialogue: 0,0:02:10.26,0:02:11.79,英文,,0,0,0,,So this is a proof sketch.
Dialogue: 0,0:02:10.26,0:02:11.79,中文,,0,0,0,,这只是一个证明草图
Dialogue: 0,0:02:11.79,0:02:16.07,英文,,0,0,0,,You sort of have to induct it upwards and think about V2, V3, V4 after this.
Dialogue: 0,0:02:11.79,0:02:16.07,中文,,0,0,0,,你得沿着向上归纳并考虑 V2、V3、V4
Dialogue: 0,0:02:16.07,0:02:18.01,英文,,0,0,0,,But the process is pretty similar.
Dialogue: 0,0:02:16.07,0:02:18.01,中文,,0,0,0,,但是过程相当类似
Dialogue: 0,0:02:18.01,0:02:26.83,英文,,0,0,0,,And again, all of it builds on the fact that if I relax an edge and the edge points at a visited vertex, that relaxation will fail.
Dialogue: 0,0:02:18.01,0:02:26.83,中文,,0,0,0,,而且 所有这些都建立在这样一个事实之上：如果我放弃一条边并且该边指向一个已访问的顶点 那么该放弃将失败
Dialogue: 0,0:02:26.83,0:02:31.70,英文,,0,0,0,,That edge will never join the family.
Dialogue: 0,0:02:26.83,0:02:31.70,中文,,0,0,0,,那条边永远不会加入到这个家族中
Dialogue: 0,0:02:31.70,0:02:37.62,英文,,0,0,0,,So something that maybe you've thought of is, well, what if some of the edges have negative weight?
Dialogue: 0,0:02:31.70,0:02:37.62,中文,,0,0,0,,也许你曾经想过的一个问题是 如果一些边的权重是负数呢
Dialogue: 0,0:02:37.62,0:02:44.23,英文,,0,0,0,,So, so far, all the graphs I've shown you, the weights on the edges, that is the number associated with every edge,
Dialogue: 0,0:02:37.62,0:02:44.23,中文,,0,0,0,,到目前为止 我给你展示的所有图中 边上的权重 也就是与每条边相关联的数字
Dialogue: 0,0:02:44.23,0:02:51.63,英文,,0,0,0,,and that could represent something in real life like distance of the road or something else, depending on what your graph is representing.
Dialogue: 0,0:02:44.23,0:02:51.63,中文,,0,0,0,,可能代表现实生活中的某些东西 比如道路的距离或其他东西 这取决于你的图表示的是什么
Dialogue: 0,0:02:51.63,0:02:56.26,英文,,0,0,0,,Well, so far, I've been shoving positive numbers on
Dialogue: 0,0:02:51.63,0:02:56.26,中文,,0,0,0,,到目前为止 我一直在边上放置正数
Dialogue: 0,0:02:56.26,0:03:00.86,英文,,0,0,0,,Those edges, but you could imagine trying to put negative numbers on those edges.
Dialogue: 0,0:02:56.26,0:03:00.86,中文,,0,0,0,,但你可以想象尝试在这些边上放置负数
Dialogue: 0,0:03:00.86,0:03:05.15,英文,,0,0,0,,But if you do, you have to be careful because Dijkstra's will actually fail.
Dialogue: 0,0:03:00.86,0:03:05.15,中文,,0,0,0,,但如果你这样做 你必须小心 因为 Dijkstra 的算法实际上会失败
Dialogue: 0,0:03:05.15,0:03:12.83,英文,,0,0,0,,So all of our proofs and our intuition so far relies on the fact that all of your edge weights are positive or non-negative at least.
Dialogue: 0,0:03:05.15,0:03:12.83,中文,,0,0,0,,到目前为止 我们所有的证明和直觉都依赖于一个事实 那就是你所有的边权重都是正数或至少是非负数的
Dialogue: 0,0:03:12.83,0:03:14.20,英文,,0,0,0,,So here's an example.
Dialogue: 0,0:03:12.83,0:03:14.20,中文,,0,0,0,,这里有一个例子
Dialogue: 0,0:03:14.20,0:03:18.50,英文,,0,0,0,,You remember this little dummy nodes trick that I briefly showed you last time?
Dialogue: 0,0:03:14.20,0:03:18.50,中文,,0,0,0,,记得上次我简要展示给你看的这个小虚节点技巧吗
Dialogue: 0,0:03:18.50,0:03:27.79,英文,,0,0,0,,Well, if you try doing the negative weights on this little dummy nodes trick, how would you add negative 1 dummy nodes between two vertices?
Dialogue: 0,0:03:18.50,0:03:27.79,中文,,0,0,0,,如果你尝试在这个小虚节点技巧上做负权重 你会怎么在两个顶点之间添加负1个虚节点呢
Dialogue: 0,0:03:27.79,0:03:30.39,英文,,0,0,0,,Or how would you add negative 5 nodes?
Dialogue: 0,0:03:27.79,0:03:30.39,中文,,0,0,0,,或者你会怎么添加负5个节点
Dialogue: 0,0:03:30.39,0:03:31.85,英文,,0,0,0,,Doesn't really make sense.
Dialogue: 0,0:03:30.39,0:03:31.85,中文,,0,0,0,,这真的没有什么意义
Dialogue: 0,0:03:31.85,0:03:42.58,英文,,0,0,0,,And also, if you remember our best first order, I said you should visit all the nodes that are distance 1 away, and then check out all the nodes that are distance 2, and then all the nodes that are distance 3.
Dialogue: 0,0:03:31.85,0:03:42.58,中文,,0,0,0,,而且 如果你还记得我们的最佳优先顺序 我说过你应该先访问所有距离为1的节点 然后查看所有距离为2的节点 然后是所有距离为3的节点
Dialogue: 0,0:03:42.58,0:03:45.69,英文,,0,0,0,,So you're looking at all the closer nodes before the further nodes.
Dialogue: 0,0:03:42.58,0:03:45.69,中文,,0,0,0,,你会在查看更远的节点之前先查看所有更近的节点
Dialogue: 0,0:03:45.69,0:03:47.67,英文,,0,0,0,,How would you put negative 1 in this order?
Dialogue: 0,0:03:45.69,0:03:47.67,中文,,0,0,0,,你会怎么按这个顺序放负1呢
Dialogue: 0,0:03:47.67,0:03:50.83,英文,,0,0,0,,What about negative 2, negative 5, negative 100?
Dialogue: 0,0:03:47.67,0:03:50.83,中文,,0,0,0,,负2、负5、负100怎么办
Dialogue: 0,0:03:50.83,0:03:54.19,英文,,0,0,0,,How would you come up with an order if there were negative edges?
Dialogue: 0,0:03:50.83,0:03:54.19,中文,,0,0,0,,如果有负边 你会怎么确定顺序呢
Dialogue: 0,0:03:54.19,0:04:05.56,英文,,0,0,0,,So all of this is to say, if I have negative edges or negative weight edges, then the reasoning that we've been using to convince ourselves that Dijkstra's works kind of starts to fall apart.
Dialogue: 0,0:03:54.19,0:04:05.56,中文,,0,0,0,,这一切都是为了说明 如果我有负边或负权重边 那么我们一直在用来说服自己迪杰斯特拉算法有效的推理开始失效了
Dialogue: 0,0:04:05.56,0:04:12.39,英文,,0,0,0,,Here's another example of the reasoning we've been using kind of falling apart if I add negative weight edges.
Dialogue: 0,0:04:05.56,0:04:12.39,中文,,0,0,0,,这里是另一个例子 我们一直在使用的推理如果加入负权重边就会出现问题
Dialogue: 0,0:04:12.39,0:04:22.59,英文,,0,0,0,,So for example, Remember the property I've just told you like five different times, which is that if I relax an edge and it points at an already visited vertex, that relaxation needs to fail.
Dialogue: 0,0:04:12.39,0:04:22.59,中文,,0,0,0,,比如说  还记得我刚刚告诉过你好几次的那个性质吗 就是如果我放弃一条边 而它指向的是一个已经访问过的顶点 那么这个放弃操作必须失败
Dialogue: 0,0:04:22.59,0:04:25.49,英文,,0,0,0,,That's what makes Dijkstra's work.
Dialogue: 0,0:04:22.59,0:04:25.49,中文,,0,0,0,,这就是迪杰斯特拉算法的工作原理
Dialogue: 0,0:04:25.49,0:04:30.05,英文,,0,0,0,,But here's an example where the relaxation succeeds, thanks to the negative edge.
Dialogue: 0,0:04:25.49,0:04:30.05,中文,,0,0,0,,但是这里有一个例子 松弛成功了 多亏了负边缘
Dialogue: 0,0:04:30.05,0:04:34.18,英文,,0,0,0,,So right now, the best known way to get to x is 82.
Dialogue: 0,0:04:30.05,0:04:34.18,中文,,0,0,0,,现在 到达x的最佳方法是82
Dialogue: 0,0:04:34.18,0:04:38.94,英文,,0,0,0,,So I don't know how to get there, but the best way to get there is distance 82.
Dialogue: 0,0:04:34.18,0:04:38.94,中文,,0,0,0,,我不知道怎么去那里 但到达那里的最佳方法是距离82
Dialogue: 0,0:04:38.94,0:04:41.74,英文,,0,0,0,,The rest of the graph is off the slide.
Dialogue: 0,0:04:38.94,0:04:41.74,中文,,0,0,0,,图的其余部分在幻灯片之外
Dialogue: 0,0:04:41.74,0:04:45.28,英文,,0,0,0,,Now I'm looking at y, which I haven't visited before, and it's further away.
Dialogue: 0,0:04:41.74,0:04:45.28,中文,,0,0,0,,现在我正在看y 这是我以前没有访问过的 而且它更远了
Dialogue: 0,0:04:45.28,0:04:47.04,英文,,0,0,0,,Look, it's distance 101.
Dialogue: 0,0:04:45.28,0:04:47.04,中文,,0,0,0,,看 是距离101
Dialogue: 0,0:04:47.04,0:04:54.51,英文,,0,0,0,,And so I ask, y to x using this magical negative edge, is this a better way to get to x?
Dialogue: 0,0:04:47.04,0:04:54.51,中文,,0,0,0,,我问 使用这个神奇的负边缘从y到x 这是到达x的更好方法吗
Dialogue: 0,0:04:54.51,0:04:59.09,英文,,0,0,0,,Well, 101 minus 67 is 34.
Dialogue: 0,0:04:54.51,0:04:59.09,中文,,0,0,0,,好的 101-67等于34
Dialogue: 0,0:04:59.09,0:05:03.99,英文,,0,0,0,,So the sum of these two numbers using this edge to get to x has weight 34.
Dialogue: 0,0:04:59.09,0:05:03.99,中文,,0,0,0,,利用这条边到x的两个数字的和是34
Dialogue: 0,0:05:03.99,0:05:05.55,英文,,0,0,0,,It's better than 82.
Dialogue: 0,0:05:03.99,0:05:05.55,中文,,0,0,0,,这比82好
Dialogue: 0,0:05:05.55,0:05:11.30,英文,,0,0,0,,So I actually end up kicking an old edge out of the family and adding this negative edge.
Dialogue: 0,0:05:05.55,0:05:11.30,中文,,0,0,0,,我实际上踢出了家庭中的一条旧边 添加了这条负边
Dialogue: 0,0:05:11.30,0:05:17.80,英文,,0,0,0,,So somehow, the relaxation of an already visited vertex has succeeded, and so Dijkstra's no longer works.
Dialogue: 0,0:05:11.30,0:05:17.80,中文,,0,0,0,,不知何故 已经访问过的顶点的放弃成功了 所以迪杰斯特拉不再适用
Dialogue: 0,0:05:17.80,0:05:21.08,英文,,0,0,0,,The proof that we just described falls apart.
Dialogue: 0,0:05:17.80,0:05:21.08,中文,,0,0,0,,我们刚才描述的证明破裂了
Dialogue: 0,0:05:21.08,0:05:22.62,英文,,0,0,0,,OK.
Dialogue: 0,0:05:22.62,0:05:23.00,英文,,0,0,0,,Great.
Dialogue: 0,0:05:23.00,0:05:28.52,英文,,0,0,0,,So be careful with negative edges, because they do not work with the analysis we've done so far.
Dialogue: 0,0:05:23.00,0:05:28.52,中文,,0,0,0,,要小心负边 因为它们与我们目前所做的分析不相容
Dialogue: 0,0:05:28.52,0:05:32.45,英文,,0,0,0,,If you have negative edges, you need to switch to a different algorithm.
Dialogue: 0,0:05:28.52,0:05:32.45,中文,,0,0,0,,如果有负边 你需要切换到另一个算法
Dialogue: 0,0:05:32.45,0:05:33.97,英文,,0,0,0,,OK.
Dialogue: 0,0:05:33.97,0:05:35.13,英文,,0,0,0,,Time for some runtime.
Dialogue: 0,0:05:33.97,0:05:35.13,中文,,0,0,0,,是时候进行一些运行时间了
Dialogue: 0,0:05:35.13,0:05:41.97,英文,,0,0,0,,So this is the one slide, two-minute speed run of Dijkstra's algorithm runtime.
Dialogue: 0,0:05:35.13,0:05:41.97,中文,,0,0,0,,这是 Dijkstra 算法运行时间的一张幻灯片 两分钟速成
Dialogue: 0,0:05:41.97,0:05:48.61,英文,,0,0,0,,It's actually not too bad if you consider the fact that if I look at what the algorithm is doing, you can go back and play with the demo.
Dialogue: 0,0:05:41.97,0:05:48.61,中文,,0,0,0,,实际上如果你考虑算法在做什么 其实也不算太糟糕 你可以回去玩玩演示
Dialogue: 0,0:05:48.61,0:05:49.57,英文,,0,0,0,,I think it's fun.
Dialogue: 0,0:05:48.61,0:05:49.57,中文,,0,0,0,,我觉得这很有趣
Dialogue: 0,0:05:49.57,0:05:52.49,英文,,0,0,0,,But if you think about what the algorithm is doing,
Dialogue: 0,0:05:49.57,0:05:52.49,中文,,0,0,0,,但如果你仔细想想算法在做什么
Dialogue: 0,0:05:52.49,0:05:57.75,英文,,0,0,0,,All that it's doing is doing priority queue operations over and over and over again.
Dialogue: 0,0:05:52.49,0:05:57.75,中文,,0,0,0,,它其实就是一遍又一遍地进行优先队列操作
Dialogue: 0,0:05:57.75,0:06:07.72,英文,,0,0,0,,Almost everything else Dijkstra's algorithm does is constant time, like adding two numbers, constant time, or comparing two numbers to see who's greater, constant time.
Dialogue: 0,0:05:57.75,0:06:07.72,中文,,0,0,0,,几乎Dijkstra算法的其他所有操作都是常数时间的 比如加两个数 常数时间 或者比较两个数谁更大 也是常数时间
Dialogue: 0,0:06:07.72,0:06:14.72,英文,,0,0,0,,So the only real operations that take time, that scale with the size of the graph, are priority queue operations.
Dialogue: 0,0:06:07.72,0:06:14.72,中文,,0,0,0,,唯一真正需要时间、随图的大小而扩展的操作就是优先队列操作
Dialogue: 0,0:06:14.72,0:06:17.20,英文,,0,0,0,,In particular, if you go back to the demo,
Dialogue: 0,0:06:14.72,0:06:17.20,中文,,0,0,0,,特别是如果你回看那个演示
Dialogue: 0,0:06:17.20,0:06:18.62,英文,,0,0,0,,Should I go back to the demo?
Dialogue: 0,0:06:17.20,0:06:18.62,中文,,0,0,0,,我应该回去看那个演示吗
Dialogue: 0,0:06:18.62,0:06:20.12,英文,,0,0,0,,Sure, I'll do it, just to show it to you.
Dialogue: 0,0:06:18.62,0:06:20.12,中文,,0,0,0,,我来做 只是为了给你看看
Dialogue: 0,0:06:20.12,0:06:21.30,英文,,0,0,0,,OK, I'll find it.
Dialogue: 0,0:06:20.12,0:06:21.30,中文,,0,0,0,,好的 我会找到它
Dialogue: 0,0:06:21.30,0:06:23.34,英文,,0,0,0,,So in the demo, what has to happen?
Dialogue: 0,0:06:21.30,0:06:23.34,中文,,0,0,0,,在演示中 需要发生什么
Dialogue: 0,0:06:23.34,0:06:28.67,英文,,0,0,0,,The first thing that has to happen is I have to take all of these nodes and put them on the fringe.
Dialogue: 0,0:06:23.34,0:06:28.67,中文,,0,0,0,,首先 我必须将所有这些节点放在边缘上
Dialogue: 0,0:06:28.67,0:06:30.67,英文,,0,0,0,,Look at my fringe. It's got all the nodes.
Dialogue: 0,0:06:28.67,0:06:30.67,中文,,0,0,0,,看看我的边缘  它包含了所有的节点
Dialogue: 0,0:06:30.67,0:06:35.35,英文,,0,0,0,,So I need to add all of these nodes to my priority queue.
Dialogue: 0,0:06:30.67,0:06:35.35,中文,,0,0,0,,我需要将所有这些节点添加到我的优先队列中
Dialogue: 0,0:06:35.35,0:06:41.34,英文,,0,0,0,,And then if you watch this demo, I have to slowly take all of the nodes out of the priority queue one by one.
Dialogue: 0,0:06:35.35,0:06:41.34,中文,,0,0,0,,然后 如果你看这个演示 我得一点点地把所有节点从优先队列中取出来
Dialogue: 0,0:06:41.34,0:06:48.58,英文,,0,0,0,,So if you just stare at the fringe down here, it had all the things, and I'm slowly removing nodes one by one as I visit them.
Dialogue: 0,0:06:41.34,0:06:48.58,中文,,0,0,0,,如果你只是盯着这里的边缘看 它包含了所有的东西 我正在一点点地移除节点 就像我访问它们一样
Dialogue: 0,0:06:48.58,0:06:52.15,英文,,0,0,0,,So every time I visit a node, I remove it from the fringe.
Dialogue: 0,0:06:48.58,0:06:52.15,中文,,0,0,0,,每次我访问一个节点 我就把它从边缘中移除
Dialogue: 0,0:06:52.15,0:06:55.73,英文,,0,0,0,,So I need to add all the things to the fringe, all the nodes, that is.
Dialogue: 0,0:06:52.15,0:06:55.73,中文,,0,0,0,,我需要把所有的东西都加入到边缘中 也就是所有的节点
Dialogue: 0,0:06:55.73,0:06:58.17,英文,,0,0,0,,I have to remove all the nodes from the fringe.
Dialogue: 0,0:06:55.73,0:06:58.17,中文,,0,0,0,,我得把所有的节点从边缘中移除
Dialogue: 0,0:06:58.17,0:07:01.27,英文,,0,0,0,,And every time I relax an edge,
Dialogue: 0,0:06:58.17,0:07:01.27,中文,,0,0,0,,每次我放弃一条边
Dialogue: 0,0:07:01.27,0:07:04.48,英文,,0,0,0,,I am potentially changing the priority in the fringe.
Dialogue: 0,0:07:01.27,0:07:04.48,中文,,0,0,0,,我都有可能改变边缘中的优先级
Dialogue: 0,0:07:04.48,0:07:09.84,英文,,0,0,0,,So for example, here, the best known distance to E is infinity.
Dialogue: 0,0:07:04.48,0:07:09.84,中文,,0,0,0,,比如说 这里 到达E的最短距离是无穷大
Dialogue: 0,0:07:09.84,0:07:11.24,英文,,0,0,0,,But then I look at this edge.
Dialogue: 0,0:07:09.84,0:07:11.24,中文,,0,0,0,,但是我看了看这条边
Dialogue: 0,0:07:11.24,0:07:18.43,英文,,0,0,0,,This edge, if I use this edge to get to E, I am using weight, or I have cost 2 plus 3 equals 5.
Dialogue: 0,0:07:11.24,0:07:18.43,中文,,0,0,0,,这条边 如果我用这条边去到达E 我需要付出权重 或者说我花费了2+3等于5
Dialogue: 0,0:07:18.43,0:07:19.75,英文,,0,0,0,,5 is better than infinity.
Dialogue: 0,0:07:18.43,0:07:19.75,中文,,0,0,0,,5比无穷大要好
Dialogue: 0,0:07:19.75,0:07:23.70,英文,,0,0,0,,So I actually have to go into the priority queue and change the infinity
Dialogue: 0,0:07:19.75,0:07:23.70,中文,,0,0,0,,我实际上必须进入优先队列并将无穷大改为5
Dialogue: 0,0:07:23.70,0:07:25.12,英文,,0,0,0,,priority to be a 5.
Dialogue: 0,0:07:23.70,0:07:25.12,中文,,0,0,0,,看 优先级变了
Dialogue: 0,0:07:25.12,0:07:27.60,英文,,0,0,0,,See, the priority, it changed.
Dialogue: 0,0:07:25.12,0:07:27.60,中文,,0,0,0,,看见了吧 优先级变了
Dialogue: 0,0:07:27.60,0:07:33.00,英文,,0,0,0,,So every time I relax an edge, I potentially have to change the priority in the fringe.
Dialogue: 0,0:07:27.60,0:07:33.00,中文,,0,0,0,,每次我放弃一个边 我潜在地需要改变优先级在边缘
Dialogue: 0,0:07:33.00,0:07:41.49,英文,,0,0,0,,So all of this is to say, all the things I'm doing in Dijkstra's that actually scale with the size of the graph are priority queue operations.
Dialogue: 0,0:07:33.00,0:07:41.49,中文,,0,0,0,,所有这一切都是为了说 所有我在 Dijkstra 做的事情实际上与图的大小成比例是优先队列操作
Dialogue: 0,0:07:41.49,0:07:47.71,英文,,0,0,0,,At the beginning, I need to add everything to the priority queue, as in all of the vertices.
Dialogue: 0,0:07:41.49,0:07:47.71,中文,,0,0,0,,在开始时 我需要将所有东西添加到优先队列中 就像所有的顶点一样
Dialogue: 0,0:07:47.71,0:07:49.55,英文,,0,0,0,,There are V vertices.
Dialogue: 0,0:07:47.71,0:07:49.55,中文,,0,0,0,,有 V 个顶点
Dialogue: 0,0:07:49.55,0:07:57.06,英文,,0,0,0,,Every time I add a vertex to the priority queue, it costs log V time, because priority queues have logarithmic runtime.
Dialogue: 0,0:07:49.55,0:07:57.06,中文,,0,0,0,,每次我将一个顶点添加到优先队列中 它都会花费 log V 的时间 因为优先队列具有对数运行时间
Dialogue: 0,0:07:57.06,0:07:58.94,英文,,0,0,0,,That's from the heaps lecture.
Dialogue: 0,0:07:57.06,0:07:58.94,中文,,0,0,0,,那是来自堆的讲座
Dialogue: 0,0:07:58.94,0:08:03.88,英文,,0,0,0,,So the add operations take total cost V log V. There are V adds.
Dialogue: 0,0:07:58.94,0:08:03.88,中文,,0,0,0,,添加操作总共花费 V log V 的时间 有 V 次添加
Dialogue: 0,0:08:03.88,0:08:06.44,英文,,0,0,0,,Each of them takes log V time.
Dialogue: 0,0:08:03.88,0:08:06.44,中文,,0,0,0,,它们每一个都需要花费log V的时间
Dialogue: 0,0:08:06.44,0:08:09.52,英文,,0,0,0,,Then I have to remove everything from the priority queue one by one.
Dialogue: 0,0:08:06.44,0:08:09.52,中文,,0,0,0,,然后我必须一个接一个地从优先队列中移除所有东西
Dialogue: 0,0:08:09.52,0:08:13.71,英文,,0,0,0,,In particular, there are v things in the priority queue, one per vertex.
Dialogue: 0,0:08:09.52,0:08:13.71,中文,,0,0,0,,特别是 优先队列中有V个东西 每个顶点一个
Dialogue: 0,0:08:13.71,0:08:17.09,英文,,0,0,0,,I need to remove all of them in the course of the algorithm.
Dialogue: 0,0:08:13.71,0:08:17.09,中文,,0,0,0,,在算法的过程中 我需要将它们全部移除
Dialogue: 0,0:08:17.09,0:08:19.37,英文,,0,0,0,,So that will take log v time.
Dialogue: 0,0:08:17.09,0:08:19.37,中文,,0,0,0,,这将花费log V的时间
Dialogue: 0,0:08:19.37,0:08:23.38,英文,,0,0,0,,And so I have another factor of v, log v.
Dialogue: 0,0:08:19.37,0:08:23.38,中文,,0,0,0,,我又多了一个因素V log V
Dialogue: 0,0:08:23.38,0:08:31.27,英文,,0,0,0,,Finally, there was that change priority operation where if I relax an edge, I potentially have to go to the priority queue and update one of the numbers.
Dialogue: 0,0:08:23.38,0:08:31.27,中文,,0,0,0,,最后 还有那个改变优先级的操作 如果我放弃一条边 我可能需要去优先队列并更新其中的一个数字
Dialogue: 0,0:08:31.27,0:08:37.07,英文,,0,0,0,,And then that node has to float or sink, which could take a sink or swim, I guess, which takes logarithmic time.
Dialogue: 0,0:08:31.27,0:08:37.07,中文,,0,0,0,,然后该节点必须浮动或下沉 可能需要下沉或浮动 我猜 这需要对数时间
Dialogue: 0,0:08:37.07,0:08:40.21,英文,,0,0,0,,So there are e edges in the total graph.
Dialogue: 0,0:08:37.07,0:08:40.21,中文,,0,0,0,,总图中有 E 条边
Dialogue: 0,0:08:40.21,0:08:43.47,英文,,0,0,0,,And potentially, every single relaxation could succeed.
Dialogue: 0,0:08:40.21,0:08:43.47,中文,,0,0,0,,潜在地 每次松弛都可能成功
Dialogue: 0,0:08:43.47,0:08:47.42,英文,,0,0,0,,If that happens, then I have to change priority e times.
Dialogue: 0,0:08:43.47,0:08:47.42,中文,,0,0,0,,如果发生这种情况 那么我必须改变优先级 E 次
Dialogue: 0,0:08:47.42,0:08:50.08,英文,,0,0,0,,Every change priority takes log v time.
Dialogue: 0,0:08:47.42,0:08:50.08,中文,,0,0,0,,每次改变优先级都需要 log V 时间
Dialogue: 0,0:08:50.08,0:08:53.58,英文,,0,0,0,,So I have another factor of e log v.
Dialogue: 0,0:08:50.08,0:08:53.58,中文,,0,0,0,,我还有一个因素是 E log V
Dialogue: 0,0:08:53.58,0:08:56.34,英文,,0,0,0,,And in the end, these three things, I want to sum them up.
Dialogue: 0,0:08:53.58,0:08:56.34,中文,,0,0,0,,最后 这三件事 我想把它们总结起来
Dialogue: 0,0:08:56.34,0:08:56.86,英文,,0,0,0,,Why is that?
Dialogue: 0,0:08:56.34,0:08:56.86,中文,,0,0,0,,为什么这样
Dialogue: 0,0:08:56.86,0:09:03.35,英文,,0,0,0,,Because I have to do the adds, and then I have to do the removeSmallest, and then I have to do the changePriorities.
Dialogue: 0,0:08:56.86,0:09:03.35,中文,,0,0,0,,因为我必须执行添加操作 然后执行removeSmallest操作 然后执行changePriority操作
Dialogue: 0,0:09:03.35,0:09:09.33,英文,,0,0,0,,It's not that every time I add, I have to remove everything from the graph, then there might be some multiplication.
Dialogue: 0,0:09:03.35,0:09:09.33,中文,,0,0,0,,并不是每次我添加时都必须从图中删除所有内容 然后可能会有一些乘法
Dialogue: 0,0:09:09.33,0:09:13.84,英文,,0,0,0,,But in this case, these three things are all separate operations that have to happen.
Dialogue: 0,0:09:09.33,0:09:13.84,中文,,0,0,0,,但在这种情况下 这三件事都是单独的操作 必须执行
Dialogue: 0,0:09:13.84,0:09:16.15,英文,,0,0,0,,That's where the addition comes in.
Dialogue: 0,0:09:13.84,0:09:16.15,中文,,0,0,0,,这就是添加的地方
Dialogue: 0,0:09:16.15,0:09:17.39,英文,,0,0,0,,I have to add everything.
Dialogue: 0,0:09:16.15,0:09:17.39,中文,,0,0,0,,我必须添加所有内容
Dialogue: 0,0:09:17.39,0:09:20.65,英文,,0,0,0,,And also, separately from that, I have to remove everything.
Dialogue: 0,0:09:17.39,0:09:20.65,中文,,0,0,0,,而且 与此分开 我还必须删除所有内容
Dialogue: 0,0:09:20.65,0:09:27.44,英文,,0,0,0,,And also, separately from that, I potentially have to change the priority once for every edge that I encounter.
Dialogue: 0,0:09:20.65,0:09:27.44,中文,,0,0,0,,我可能需要为我遇到的每一条边改变一次优先级
Dialogue: 0,0:09:27.44,0:09:31.14,英文,,0,0,0,,So every edge could possibly trigger one change priority operation.
Dialogue: 0,0:09:27.44,0:09:31.14,中文,,0,0,0,,每一条边可能会触发一次改变优先级的操作
Dialogue: 0,0:09:31.14,0:09:36.72,英文,,0,0,0,,There are e edges. Every change priority takes log v time, in the worst case.
Dialogue: 0,0:09:31.14,0:09:36.72,中文,,0,0,0,,有E条边  每次改变优先级最坏情况下需要log V时间
Dialogue: 0,0:09:36.72,0:09:37.58,英文,,0,0,0,,OK.
Dialogue: 0,0:09:37.58,0:09:39.14,英文,,0,0,0,,Great, so then I sum all this up.
Dialogue: 0,0:09:37.58,0:09:39.14,中文,,0,0,0,,太棒了 然后我把这一切加起来
Dialogue: 0,0:09:39.14,0:09:45.13,英文,,0,0,0,,I get V log V plus V log V plus E log V. It's a big old sum.
Dialogue: 0,0:09:39.14,0:09:45.13,中文,,0,0,0,,我得到V log V加上V log V加上E log V 这是一个很大的总和
Dialogue: 0,0:09:45.13,0:09:52.21,英文,,0,0,0,,But if you assume that E is greater than V, and that kind of depends on your graph, sometimes people simplify this to E log V,
Dialogue: 0,0:09:45.13,0:09:52.21,中文,,0,0,0,,但如果你假设 E 大于 V 而且那在你的图中有点依赖的话 有时人们会简化为 E 对数 V
Dialogue: 0,0:09:52.21,0:09:58.21,英文,,0,0,0,,which would be the largest term if E was greater than V. But if you don't like that, you can write it the whole sum.
Dialogue: 0,0:09:52.21,0:09:58.21,中文,,0,0,0,,如果 E 大于 V 这会是最大的项 但如果你不喜欢 你可以写出整个求和
Dialogue: 0,0:09:58.21,0:09:59.73,英文,,0,0,0,,That's OK, too.
Dialogue: 0,0:09:58.21,0:09:59.73,中文,,0,0,0,,那也可以
Dialogue: 0,0:09:59.73,0:10:00.93,英文,,0,0,0,,OK, there's the runtime.
Dialogue: 0,0:09:59.73,0:10:00.93,中文,,0,0,0,,好了 这就是运行时间
Dialogue: 0,0:10:00.93,0:10:06.94,英文,,0,0,0,,It's a lot of terms, but I actually don't find it that bad compared to some of the other runtimes.
Dialogue: 0,0:10:00.93,0:10:06.94,中文,,0,0,0,,这是很多项 但与其他运行时间相比 我实际上觉得还好
Dialogue: 0,0:10:06.94,0:10:08.96,英文,,0,0,0,,I don't know, maybe it's confusing the first time.
Dialogue: 0,0:10:06.94,0:10:08.96,中文,,0,0,0,,我不知道 也许第一次会有点混淆
Dialogue: 0,0:10:08.96,0:10:10.04,英文,,0,0,0,,OK, well, there it is.
Dialogue: 0,0:10:08.96,0:10:10.04,中文,,0,0,0,,那就是它了
Dialogue: 0,0:10:10.04,0:10:10.86,英文,,0,0,0,,You can stare at it.
Dialogue: 0,0:10:10.04,0:10:10.86,中文,,0,0,0,,你可以盯着它看
Dialogue: 0,0:10:10.86,0:10:11.80,英文,,0,0,0,,Check it out.
Dialogue: 0,0:10:10.86,0:10:11.80,中文,,0,0,0,,看一下吧
Dialogue: 0,0:10:11.80,0:10:25.53,英文,,0,0,0,,OK, I have one more Dijkstra's shortest path thing to show you, which is, remember our goal from way back in last lecture, which was I wanted to maybe build some sort of directions application, Google Maps.
Dialogue: 0,0:10:11.80,0:10:25.53,中文,,0,0,0,,我还有一个 Dijkstra 的最短路径的东西要给你看 记得我们上次课讲的目标吗 就是我想也许建一个类似导航应用的东西 比如 Google 地图
Dialogue: 0,0:10:25.53,0:10:31.36,英文,,0,0,0,,I want to figure out how to get from point A to point B in the shortest path possible.
Dialogue: 0,0:10:25.53,0:10:31.36,中文,,0,0,0,,我想弄清楚如何从A点到B点找到最短路径
Dialogue: 0,0:10:31.36,0:10:42.24,英文,,0,0,0,,So the question for you is, if I use Dijkstra's to try and find the shortest path from Denver, Colorado to New York City, will Dijkstra's algorithm give me the correct shortest path?
Dialogue: 0,0:10:31.36,0:10:42.24,中文,,0,0,0,,问题就是 如果我用 Dijkstra 的算法试图找到从科罗拉多州丹佛到纽约市的最短路径 Dijkstra 的算法会给我正确的最短路径吗
Dialogue: 0,0:10:42.24,0:10:46.35,英文,,0,0,0,,So assume I have a big old graph representing all the roads in the country.
Dialogue: 0,0:10:42.24,0:10:46.35,中文,,0,0,0,,假设我有一个表示全国所有道路的大图
Dialogue: 0,0:10:46.35,0:10:51.17,英文,,0,0,0,,Will Dijkstra's algorithm give me the shortest path from Denver to New York?
Dialogue: 0,0:10:46.35,0:10:51.17,中文,,0,0,0,,Dijkstra 的算法会给我从丹佛到纽约的最短路径吗
Dialogue: 0,0:10:51.17,0:10:55.15,英文,,0,0,0,,And the second question is, will Dijkstra's do it efficiently?
Dialogue: 0,0:10:51.17,0:10:55.15,中文,,0,0,0,,第二个问题是 Dijkstra 的算法会高效地完成吗
Dialogue: 0,0:10:55.15,0:10:57.81,英文,,0,0,0,,And it's kind of up to you to determine what that means by efficient.
Dialogue: 0,0:10:55.15,0:10:57.81,中文,,0,0,0,,这其实取决于你如何定义高效
Dialogue: 0,0:10:57.81,0:11:01.05,英文,,0,0,0,,Am I doing any wasted work that I shouldn't be doing?
Dialogue: 0,0:10:57.81,0:11:01.05,中文,,0,0,0,,我是否在做一些不必要的工作
Dialogue: 0,0:11:01.05,0:11:06.74,英文,,0,0,0,,So think about what Dijkstra's would do, and maybe it helps to think, what kind of solution does Dijkstra's build?
Dialogue: 0,0:11:01.05,0:11:06.74,中文,,0,0,0,,想想 Dijkstra 会怎么做 也许想想 Dijkstra 构建的是什么样的解决方案会有所帮助
Dialogue: 0,0:11:06.74,0:11:10.87,英文,,0,0,0,,Because remember, Dijkstra's builds a shortest paths tree.
Dialogue: 0,0:11:06.74,0:11:10.87,中文,,0,0,0,,因为记住 Dijkstra 构建的是一棵最短路径树
Dialogue: 0,0:11:10.87,0:11:17.57,英文,,0,0,0,,And also remember, Dijkstra's explores everything distance 1, and then everything distance 2, and then everything distance 3.
Dialogue: 0,0:11:10.87,0:11:17.57,中文,,0,0,0,,还要记住 Dijkstra 会探索所有距离为 1 的节点 然后是距离为 2 的节点 然后是距离为 3 的节点
Dialogue: 0,0:11:17.57,0:11:20.32,英文,,0,0,0,,So in this case, the first answer, will it be correct?
Dialogue: 0,0:11:17.57,0:11:20.32,中文,,0,0,0,,在这种情况下 第一个答案 会是正确的吗
Dialogue: 0,0:11:20.32,0:11:29.11,英文,,0,0,0,,The answer is yes, because we know Dijkstra's is giving us the shortest path to all the other nodes in the graph.
Dialogue: 0,0:11:20.32,0:11:29.11,中文,,0,0,0,,答案是肯定的 因为我们知道 Dijkstra 正在给我们图中所有其他节点的最短路径
Dialogue: 0,0:11:29.11,0:11:36.66,英文,,0,0,0,,However, There's a problem, because if I try to explore using Dijkstra's, I will explore everything within one mile of Colorado,
Dialogue: 0,0:11:29.11,0:11:36.66,中文,,0,0,0,,有一个问题 因为如果我尝试使用迪杰斯特拉算法 我会探索科罗拉多一英里范围内的所有地方
Dialogue: 0,0:11:36.66,0:11:41.66,英文,,0,0,0,,and then everything within two miles of Denver, and then everything within three miles of Denver,
Dialogue: 0,0:11:36.66,0:11:41.66,中文,,0,0,0,,然后是丹佛两英里范围内的所有地方 然后是丹佛三英里范围内的所有地方
Dialogue: 0,0:11:41.66,0:11:44.66,英文,,0,0,0,,everything within four miles of Denver, everything within five.
Dialogue: 0,0:11:41.66,0:11:44.66,中文,,0,0,0,,以此类推 直到丹佛1,700英里范围内的所有地方
Dialogue: 0,0:11:44.66,0:11:53.70,英文,,0,0,0,,So eventually, I will actually get the shortest path not just to New York, but to every other destination 1,700 miles from Denver.
Dialogue: 0,0:11:44.66,0:11:53.70,中文,,0,0,0,,因此 最终我将得到不仅到达纽约的最短路径 而且到达丹佛以外1,700英里范围内每个目的地的最短路径
Dialogue: 0,0:11:53.70,0:12:00.39,英文,,0,0,0,,So I'll get great shortest paths from Denver to Los Angeles and San Francisco and Seattle and everything else.
Dialogue: 0,0:11:53.70,0:12:00.39,中文,,0,0,0,,我会得到从丹佛到洛杉矶、旧金山、西雅图和其他所有地方的最佳最短路径
Dialogue: 0,0:12:00.39,0:12:02.41,英文,,0,0,0,,But it's like, wait, why do I care about all these?
Dialogue: 0,0:12:00.39,0:12:02.41,中文,,0,0,0,,但问题是 等等 我为什么要在乎所有这些
Dialogue: 0,0:12:02.41,0:12:04.37,英文,,0,0,0,,I just want to get to New York.
Dialogue: 0,0:12:02.41,0:12:04.37,中文,,0,0,0,,我只想去纽约
Dialogue: 0,0:12:04.37,0:12:13.25,英文,,0,0,0,,So while this works, it wastes a lot of time exploring the shortest paths to everywhere, when all I cared about was a single target, New York.
Dialogue: 0,0:12:04.37,0:12:13.25,中文,,0,0,0,,因此 虽然这个方法有效 但它会浪费大量时间探索到达各处的最短路径 而我只关心一个目标 那就是纽约
Dialogue: 0,0:12:13.25,0:12:15.57,英文,,0,0,0,,So that's the problem with Dijkstra's.
Dialogue: 0,0:12:13.25,0:12:15.57,中文,,0,0,0,,这就是迪杰斯特拉的问题
Dialogue: 0,0:12:15.57,0:12:21.76,英文,,0,0,0,,While it works, it wastes a lot of effort giving you your shortest paths to all sorts of places you might never go.
Dialogue: 0,0:12:15.57,0:12:21.76,中文,,0,0,0,,虽然它能工作 但它浪费了很多精力给你计算到各种可能永远也不会去的地方的最短路径
Dialogue: 0,0:12:21.76,0:12:25.36,英文,,0,0,0,,Like, I'll get the shortest path to North Dakota, but why would I ever go there?
Dialogue: 0,0:12:21.76,0:12:25.36,中文,,0,0,0,,比如 我会得到通往北达科他州的最短路径 但我为什么要去那里呢
Dialogue: 0,0:12:25.36,0:12:27.45,英文,,0,0,0,,Sorry, North Dakotans.
Dialogue: 0,0:12:25.36,0:12:27.45,中文,,0,0,0,,抱歉 北达科他州的人
Dialogue: 0,0:12:27.45,0:12:30.29,英文,,0,0,0,,I get it, but it's an extra solution that I don't care about.
Dialogue: 0,0:12:27.45,0:12:30.29,中文,,0,0,0,,我明白了 但这是一个我不关心的额外解决方案
Dialogue: 0,0:12:30.29,0:12:34.39,英文,,0,0,0,,I just needed the path to New York.
Dialogue: 0,0:12:30.29,0:12:34.39,中文,,0,0,0,,我只需要通往纽约的路径而已
Dialogue: 0,0:12:34.39,0:12:48.74,英文,,0,0,0,,So the question is, how should I modify my algorithm if instead of getting the shortest path to every single other vertex, I just want the shortest path to a single target vertex, and I do not care how to get to North Dakota or anywhere else?
Dialogue: 0,0:12:34.39,0:12:48.74,中文,,0,0,0,,问题是 如果我只想要到达单个目标顶点的最短路径 而不关心如何到达北达科他州或其他任何地方 我应该如何修改我的算法
Dialogue: 0,0:12:48.74,0:12:50.54,英文,,0,0,0,,So we're going to change our algorithm.
Dialogue: 0,0:12:48.74,0:12:50.54,中文,,0,0,0,,我们要改变我们的算法
Dialogue: 0,0:12:50.54,0:12:55.28,英文,,0,0,0,,And the rough idea here is that Well, I kind of want the algorithm to go that way.
Dialogue: 0,0:12:50.54,0:12:55.28,中文,,0,0,0,,这里的大致想法是 我有点希望算法朝这个方向发展
Dialogue: 0,0:12:55.28,0:13:00.96,英文,,0,0,0,,So I'm like, oh, algorithm, Dijkstra's algorithm, please go this way, because New York is that way.
Dialogue: 0,0:12:55.28,0:13:00.96,中文,,0,0,0,,我就像算法 迪杰斯特拉的算法 请朝这个方向走 因为纽约就在那边
Dialogue: 0,0:13:00.96,0:13:06.38,英文,,0,0,0,,And all the vertices on this side and the West Coast, don't go there, because that's far away from New York.
Dialogue: 0,0:13:00.96,0:13:06.38,中文,,0,0,0,,而且这一边和西海岸上的所有顶点 不要去那里 因为那离纽约很远
Dialogue: 0,0:13:06.38,0:13:11.86,英文,,0,0,0,,So somehow, I need to tell the algorithm to go explore that way and don't explore that way.
Dialogue: 0,0:13:06.38,0:13:11.86,中文,,0,0,0,,我需要想办法告诉算法去探索那边 不要探索那边
Dialogue: 0,0:13:11.86,0:13:13.57,英文,,0,0,0,,So how do I do that?
Dialogue: 0,0:13:11.86,0:13:13.57,中文,,0,0,0,,那我该怎么做呢
Dialogue: 0,0:13:13.57,0:13:14.63,英文,,0,0,0,,OK, look, the arrows.
Dialogue: 0,0:13:13.57,0:13:14.63,中文,,0,0,0,,看 箭头
Dialogue: 0,0:13:14.63,0:13:16.19,英文,,0,0,0,,I'm like, please go this way.
Dialogue: 0,0:13:14.63,0:13:16.19,中文,,0,0,0,,我就是说 请往这边走
Dialogue: 0,0:13:16.19,0:13:18.73,英文,,0,0,0,,How do I tell the algorithm to go in a certain way?
Dialogue: 0,0:13:16.19,0:13:18.73,中文,,0,0,0,,我怎么告诉算法按某种方式走
Dialogue: 0,0:13:18.73,0:13:23.10,英文,,0,0,0,,So this introduces the next algorithm we'll see called A star.
Dialogue: 0,0:13:18.73,0:13:23.10,中文,,0,0,0,,这就介绍了我们接下来要看的一个算法 叫做A*
Dialogue: 0,0:13:23.10,0:13:26.06,英文,,0,0,0,,And so this algorithm, it is just Dijkstra's.
Dialogue: 0,0:13:23.10,0:13:26.06,中文,,0,0,0,,这个算法 其实就是迪杰斯特拉算法
Dialogue: 0,0:13:26.06,0:13:29.13,英文,,0,0,0,,I just have to make a single pretty small tweak.
Dialogue: 0,0:13:26.06,0:13:29.13,中文,,0,0,0,,我只需要做一个相当小的调整
Dialogue: 0,0:13:29.13,0:13:43.23,英文,,0,0,0,,So all I have to do is, when I'm thinking about the priority of every single vertex, I'm thinking about which vertex to explore next and relax all of its outgoing edges, I'm going to start applying penalties.
Dialogue: 0,0:13:29.13,0:13:43.23,中文,,0,0,0,,我所要做的就是 当我考虑每个顶点的优先级时 我会考虑下一个要探索的顶点并放弃其所有外发边 我要开始施加惩罚
Dialogue: 0,0:13:43.23,0:13:53.12,英文,,0,0,0,,So instead of the priority just being the distance so far, which causes us to explore all of the close things and then all of the further things, I'm going to apply a penalty.
Dialogue: 0,0:13:43.23,0:13:53.12,中文,,0,0,0,,与其只根据到目前为止的距离来确定优先级 导致我们先探索所有近处的事物 再探索更远的事物 我打算施加一个惩罚
Dialogue: 0,0:13:53.12,0:13:55.00,英文,,0,0,0,,And here's the penalty right here.
Dialogue: 0,0:13:53.12,0:13:55.00,中文,,0,0,0,,这就是我要施加的惩罚
Dialogue: 0,0:13:55.00,0:14:07.00,英文,,0,0,0,,And it basically says, nodes that are probably further away from the goal, like all of these nodes on the West Coast, I'm going to hit them with really big penalties to say, don't look at this node.
Dialogue: 0,0:13:55.00,0:14:07.00,中文,,0,0,0,,它基本上是说 可能离目标更远的节点 比如西海岸的所有这些节点 我会给它们施加很大的惩罚 意思是不要看这个节点
Dialogue: 0,0:14:07.00,0:14:08.08,英文,,0,0,0,,I'm going to add a penalty.
Dialogue: 0,0:14:07.00,0:14:08.08,中文,,0,0,0,,我要加上一个惩罚
Dialogue: 0,0:14:08.08,0:14:11.55,英文,,0,0,0,,Now it has super high priority, or low priority, I guess.
Dialogue: 0,0:14:08.08,0:14:11.55,中文,,0,0,0,,现在它的优先级非常高 或者说是很低
Dialogue: 0,0:14:11.55,0:14:15.01,英文,,0,0,0,,But don't look at it, because it's got a really big penalty attached.
Dialogue: 0,0:14:11.55,0:14:15.01,中文,,0,0,0,,但不要看它 因为它有很大的惩罚
Dialogue: 0,0:14:15.01,0:14:19.93,英文,,0,0,0,,But all of these nodes that are closer to New York, I'm going to apply a lesser penalty and say, those are good.
Dialogue: 0,0:14:15.01,0:14:19.93,中文,,0,0,0,,但是所有那些离纽约更近的节点 我会施加较小的惩罚 并说 那些是好的
Dialogue: 0,0:14:19.93,0:14:20.97,英文,,0,0,0,,Go that way.
Dialogue: 0,0:14:19.93,0:14:20.97,中文,,0,0,0,,往那边走
Dialogue: 0,0:14:20.97,0:14:23.43,英文,,0,0,0,,So that's how I'm going to bias Dijkstra's.
Dialogue: 0,0:14:20.97,0:14:23.43,中文,,0,0,0,,我打算这样对待Dijkstra's算法
Dialogue: 0,0:14:23.43,0:14:33.64,英文,,0,0,0,,I'm going to apply big penalties to nodes that are far away, and that I think are far away at least, and smaller penalties to nodes that I think are closer to my one single target.
Dialogue: 0,0:14:23.43,0:14:33.64,中文,,0,0,0,,对于我认为至少是远离目标的节点 我会施加重罚 而对于我认为更靠近我的唯一目标的节点 则施加较轻的惩罚
Dialogue: 0,0:14:33.64,0:14:35.48,英文,,0,0,0,,That's the key difference in A star.
Dialogue: 0,0:14:33.64,0:14:35.48,中文,,0,0,0,,这就是A* 的关键不同之处
Dialogue: 0,0:14:35.48,0:14:37.37,英文,,0,0,0,,A star has one single target.
Dialogue: 0,0:14:35.48,0:14:37.37,中文,,0,0,0,,A* 有一个唯一的目标
Dialogue: 0,0:14:37.37,0:14:40.51,英文,,0,0,0,,I do not care about North Dakota or other states.
Dialogue: 0,0:14:37.37,0:14:40.51,中文,,0,0,0,,我不关心北达科他州或其他州
Dialogue: 0,0:14:40.51,0:14:41.25,英文,,0,0,0,,OK.
Dialogue: 0,0:14:41.25,0:14:46.16,英文,,0,0,0,,So for example, here I am in Denver, and maybe there are four nodes that I need to put on the fringe.
Dialogue: 0,0:14:41.25,0:14:46.16,中文,,0,0,0,,比如说 我在丹佛 可能有四个节点需要放在边缘
Dialogue: 0,0:14:46.16,0:14:51.46,英文,,0,0,0,,Maybe there's this Broomfield node, Henderson node, Inglewood node, and Aurora node.
Dialogue: 0,0:14:46.16,0:14:51.46,中文,,0,0,0,,或许有这么一个布鲁姆菲尔德节点、亨德森节点、英格尔伍德节点和奥罗拉节点
Dialogue: 0,0:14:51.46,0:14:54.32,英文,,0,0,0,,So those are, I guess, four cities that are near Denver.
Dialogue: 0,0:14:51.46,0:14:54.32,中文,,0,0,0,,这些 我猜 是丹佛附近的四个城市
Dialogue: 0,0:14:54.32,0:14:59.11,英文,,0,0,0,,Well, in this case, I want to apply big penalties to Broomfield and Inglewood.
Dialogue: 0,0:14:54.32,0:14:59.11,中文,,0,0,0,,好吧 在这种情况下 我想对布鲁姆菲尔德和英格尔伍德施加严厉的惩罚
Dialogue: 0,0:14:59.11,0:15:03.54,英文,,0,0,0,,I have nothing against these cities, but they're further away from New York because they're going in the wrong direction.
Dialogue: 0,0:14:59.11,0:15:03.54,中文,,0,0,0,,我对这些城市没什么意见 但它们离纽约更远 因为它们走错了方向
Dialogue: 0,0:15:03.54,0:15:04.58,英文,,0,0,0,,Don't go that way.
Dialogue: 0,0:15:03.54,0:15:04.58,中文,,0,0,0,,不要朝那个方向走
Dialogue: 0,0:15:04.58,0:15:06.86,英文,,0,0,0,,So these should have bigger penalties applied.
Dialogue: 0,0:15:04.58,0:15:06.86,中文,,0,0,0,,这些应该受到更严厉的惩罚
Dialogue: 0,0:15:06.86,0:15:09.12,英文,,0,0,0,,And then Henderson and Aurora, those are the right directions.
Dialogue: 0,0:15:06.86,0:15:09.12,中文,,0,0,0,,然后是亨德森和奥罗拉 这是正确的方向
Dialogue: 0,0:15:09.12,0:15:12.29,英文,,0,0,0,,So we give them smaller penalties, and we say, A star.
Dialogue: 0,0:15:09.12,0:15:12.29,中文,,0,0,0,,我们给他们较小的惩罚 然后我们说 A*
Dialogue: 0,0:15:12.29,0:15:13.25,英文,,0,0,0,,Go that way.
Dialogue: 0,0:15:12.29,0:15:13.25,中文,,0,0,0,,朝那个方向走
Dialogue: 0,0:15:13.25,0:15:14.50,英文,,0,0,0,,OK.
Dialogue: 0,0:15:14.50,0:15:16.62,英文,,0,0,0,,So here is A star.
Dialogue: 0,0:15:14.50,0:15:16.62,中文,,0,0,0,,这就是A*
Dialogue: 0,0:15:16.62,0:15:19.64,英文,,0,0,0,,The only difference is that these priorities will change.
Dialogue: 0,0:15:16.62,0:15:19.64,中文,,0,0,0,,唯一的区别是这些优先级会改变
Dialogue: 0,0:15:19.64,0:15:21.08,英文,,0,0,0,,Everything else is the same.
Dialogue: 0,0:15:19.64,0:15:21.08,中文,,0,0,0,,其他的都一样
Dialogue: 0,0:15:21.08,0:15:25.96,英文,,0,0,0,,The distance to array will mostly be copied, maybe with a small difference I'll show you later.
Dialogue: 0,0:15:21.08,0:15:25.96,中文,,0,0,0,,距离数组的距离大部分会被复制 也许会有一点点不同 我等会儿会给你看
Dialogue: 0,0:15:25.96,0:15:28.11,英文,,0,0,0,,The edge to array serves the exact same purpose.
Dialogue: 0,0:15:25.96,0:15:28.11,中文,,0,0,0,,边缘数组的作用完全一样
Dialogue: 0,0:15:28.11,0:15:30.61,英文,,0,0,0,,I'm still relaxing nodes like I always do.
Dialogue: 0,0:15:28.11,0:15:30.61,中文,,0,0,0,,我还是像往常一样放弃节点
Dialogue: 0,0:15:30.61,0:15:35.63,英文,,0,0,0,,The only difference is that the priorities are going to change with penalties.
Dialogue: 0,0:15:30.61,0:15:35.63,中文,,0,0,0,,唯一的区别是优先级会随着惩罚而改变
Dialogue: 0,0:15:35.63,0:15:39.41,英文,,0,0,0,,And here are the penalties that someone has provided to me ahead of time.
Dialogue: 0,0:15:35.63,0:15:39.41,中文,,0,0,0,,这里是有人事先提供给我的惩罚
Dialogue: 0,0:15:39.41,0:15:40.71,英文,,0,0,0,,So they've told me.
Dialogue: 0,0:15:39.41,0:15:40.71,中文,,0,0,0,,他们告诉了我
Dialogue: 0,0:15:40.71,0:15:43.30,英文,,0,0,0,,And how you get these numbers, someone else has to give them to you.
Dialogue: 0,0:15:40.71,0:15:43.30,中文,,0,0,0,,你要获取这些数字的方法 还得有人给你
Dialogue: 0,0:15:43.30,0:15:45.46,英文,,0,0,0,,It's not baked into the algorithm.
Dialogue: 0,0:15:43.30,0:15:45.46,中文,,0,0,0,,算法里没有内置它
Dialogue: 0,0:15:45.46,0:15:48.58,英文,,0,0,0,,But someone else has told me A has a penalty of 1.
Dialogue: 0,0:15:45.46,0:15:48.58,中文,,0,0,0,,但是其他人告诉我A有一个惩罚为1
Dialogue: 0,0:15:48.58,0:15:49.18,英文,,0,0,0,,It's a good node.
Dialogue: 0,0:15:48.58,0:15:49.18,中文,,0,0,0,,这是一个好节点
Dialogue: 0,0:15:49.18,0:15:50.05,英文,,0,0,0,,I like it.
Dialogue: 0,0:15:49.18,0:15:50.05,中文,,0,0,0,,我喜欢它
Dialogue: 0,0:15:50.05,0:15:51.35,英文,,0,0,0,,And C has a penalty of 15.
Dialogue: 0,0:15:50.05,0:15:51.35,中文,,0,0,0,,而C的惩罚是15
Dialogue: 0,0:15:51.35,0:15:52.47,英文,,0,0,0,,It's a bad node.
Dialogue: 0,0:15:51.35,0:15:52.47,中文,,0,0,0,,这是一个坏节点
Dialogue: 0,0:15:52.47,0:15:53.47,英文,,0,0,0,,We don't like it.
Dialogue: 0,0:15:52.47,0:15:53.47,中文,,0,0,0,,我们不喜欢它
Dialogue: 0,0:15:53.47,0:15:56.15,英文,,0,0,0,,So someone has given me a list of penalties.
Dialogue: 0,0:15:53.47,0:15:56.15,中文,,0,0,0,,有人给了我一个处罚清单
Dialogue: 0,0:15:56.15,0:15:58.08,英文,,0,0,0,,I will use those.
Dialogue: 0,0:15:56.15,0:15:58.08,中文,,0,0,0,,我会使用它们
Dialogue: 0,0:15:58.08,0:16:00.24,英文,,0,0,0,,when I'm thinking about the priorities in the fringe.
Dialogue: 0,0:15:58.08,0:16:00.24,中文,,0,0,0,,当我考虑边缘的优先级时
Dialogue: 0,0:16:00.24,0:16:01.78,英文,,0,0,0,,So here I go.
Dialogue: 0,0:16:00.24,0:16:01.78,中文,,0,0,0,,我开始了
Dialogue: 0,0:16:01.78,0:16:05.74,英文,,0,0,0,,All the non-visited vertices are in the fringe, BCDEFG.
Dialogue: 0,0:16:01.78,0:16:05.74,中文,,0,0,0,,所有未访问的顶点都在边缘上 BCDEFG
Dialogue: 0,0:16:05.74,0:16:07.72,英文,,0,0,0,,Also, I identified a target.
Dialogue: 0,0:16:05.74,0:16:07.72,中文,,0,0,0,,此外 我确定了一个目标
Dialogue: 0,0:16:07.72,0:16:11.02,英文,,0,0,0,,So you didn't see this in Dijkstra's, but now there's a single target.
Dialogue: 0,0:16:07.72,0:16:11.02,中文,,0,0,0,,在 Dijkstra 算法中你没有看到这个 但现在有一个单一的目标
Dialogue: 0,0:16:11.02,0:16:17.31,英文,,0,0,0,,I am intensely curious about how to get to G. I do not care about how to get to any other vertex.
Dialogue: 0,0:16:11.02,0:16:17.31,中文,,0,0,0,,我非常好奇如何到达 G 点 我不关心如何到达其他任何顶点
Dialogue: 0,0:16:17.31,0:16:18.91,英文,,0,0,0,,So here I go.
Dialogue: 0,0:16:17.31,0:16:18.91,中文,,0,0,0,,我就开始了
Dialogue: 0,0:16:18.91,0:16:20.19,英文,,0,0,0,,I'm going to get relaxing.
Dialogue: 0,0:16:18.91,0:16:20.19,中文,,0,0,0,,我要放弃一下
Dialogue: 0,0:16:20.19,0:16:23.29,英文,,0,0,0,,If you're comfortable with relaxing, this might be boring.
Dialogue: 0,0:16:20.19,0:16:23.29,中文,,0,0,0,,如果你对放弃感到舒适 这可能会有点无聊
Dialogue: 0,0:16:23.29,0:16:23.95,英文,,0,0,0,,I'm sorry.
Dialogue: 0,0:16:23.29,0:16:23.95,中文,,0,0,0,,对不起
Dialogue: 0,0:16:23.95,0:16:24.03,英文,,0,0,0,,OK.
Dialogue: 0,0:16:24.03,0:16:25.87,英文,,0,0,0,,So I'm going to look at this edge.
Dialogue: 0,0:16:24.03,0:16:25.87,中文,,0,0,0,,我要看看这条边
Dialogue: 0,0:16:25.87,0:16:29.35,英文,,0,0,0,,Is 0 plus 2 better than the best known way to get to b?
Dialogue: 0,0:16:25.87,0:16:29.35,中文,,0,0,0,,0+2比到达B的最佳已知方法好吗
Dialogue: 0,0:16:29.35,0:16:29.97,英文,,0,0,0,,Yes.
Dialogue: 0,0:16:29.35,0:16:29.97,中文,,0,0,0,,是的
Dialogue: 0,0:16:29.97,0:16:34.07,英文,,0,0,0,,So I use this edge, 0 to 1, or 0 plus 1, better than infinity.
Dialogue: 0,0:16:29.97,0:16:34.07,中文,,0,0,0,,我使用这条边 从0到1 或者0+1 比无穷大好
Dialogue: 0,0:16:34.07,0:16:35.97,英文,,0,0,0,,So both of these edges get used.
Dialogue: 0,0:16:34.07,0:16:35.97,中文,,0,0,0,,这两条边都被使用了
Dialogue: 0,0:16:35.97,0:16:39.33,英文,,0,0,0,,And the best known distance to c is 1, same as Dijkstra's.
Dialogue: 0,0:16:35.97,0:16:39.33,中文,,0,0,0,,而到达c的最佳已知距离是1 和Dijkstra的一样
Dialogue: 0,0:16:39.33,0:16:42.45,英文,,0,0,0,,Best known distance to B is 2, same as Dijkstra's.
Dialogue: 0,0:16:39.33,0:16:42.45,中文,,0,0,0,,到达B的最佳已知距离是2 和Dijkstra的一样
Dialogue: 0,0:16:42.45,0:16:43.79,英文,,0,0,0,,Here is the difference.
Dialogue: 0,0:16:42.45,0:16:43.79,中文,,0,0,0,,这就是区别
Dialogue: 0,0:16:43.79,0:16:49.65,英文,,0,0,0,,When I update C and B's priority in the fringe, in Dijkstra's, what would C's priority be?
Dialogue: 0,0:16:43.79,0:16:49.65,中文,,0,0,0,,在 Dijkstra 算法中 当我更新 fringe 中 C 和 B 的优先级时 C 的优先级会是多少
Dialogue: 0,0:16:49.65,0:16:51.43,英文,,0,0,0,,It'd be 1, because it's close.
Dialogue: 0,0:16:49.65,0:16:51.43,中文,,0,0,0,,它会是 1 因为它很近
Dialogue: 0,0:16:51.43,0:16:52.77,英文,,0,0,0,,And what would B's priority be?
Dialogue: 0,0:16:51.43,0:16:52.77,中文,,0,0,0,,B 的优先级会是多少
Dialogue: 0,0:16:52.77,0:16:55.25,英文,,0,0,0,,It'd be 2, because it's a little further away.
Dialogue: 0,0:16:52.77,0:16:55.25,中文,,0,0,0,,它会是 2 因为它稍微远一点
Dialogue: 0,0:16:55.25,0:16:57.81,英文,,0,0,0,,But this time, I'm adding penalties.
Dialogue: 0,0:16:55.25,0:16:57.81,中文,,0,0,0,,但这次 我要添加惩罚
Dialogue: 0,0:16:57.81,0:16:59.79,英文,,0,0,0,,So look, what's the priority of B?
Dialogue: 0,0:16:57.81,0:16:59.79,中文,,0,0,0,,看 B 的优先级是多少
Dialogue: 0,0:16:59.79,0:17:02.80,英文,,0,0,0,,It's supposed to be 2 if I was using Dijkstra's.
Dialogue: 0,0:16:59.79,0:17:02.80,中文,,0,0,0,,如果我在使用 Dijkstra 算法 它应该是 2
Dialogue: 0,0:17:02.80,0:17:07.30,英文,,0,0,0,,But my little heuristics table says, please apply a penalty of 3.
Dialogue: 0,0:17:02.80,0:17:07.30,中文,,0,0,0,,但是我的小启发表说 请给予惩罚 3 分
Dialogue: 0,0:17:07.30,0:17:09.34,英文,,0,0,0,,Because B is kind of close, but not really close.
Dialogue: 0,0:17:07.30,0:17:09.34,中文,,0,0,0,,因为 B 稍微接近 但并不是非常接近
Dialogue: 0,0:17:09.34,0:17:12.10,英文,,0,0,0,,So 2 plus 3 is 5.
Dialogue: 0,0:17:09.34,0:17:12.10,中文,,0,0,0,, 2 + 3 是 5
Dialogue: 0,0:17:12.10,0:17:14.98,英文,,0,0,0,,So it's supposed to be 2, but I hit it with the penalty.
Dialogue: 0,0:17:12.10,0:17:14.98,中文,,0,0,0,,它应该是 2 但我对它进行了惩罚
Dialogue: 0,0:17:14.98,0:17:18.32,英文,,0,0,0,,And look at C. This was supposed to have priority 1.
Dialogue: 0,0:17:14.98,0:17:18.32,中文,,0,0,0,,看看 C 这本应该是优先级 1 的
Dialogue: 0,0:17:18.32,0:17:26.67,英文,,0,0,0,,But my list of penalties tells me, please apply a big penalty of 15 to C. We don't like C. So look, C now has a really big penalty.
Dialogue: 0,0:17:18.32,0:17:26.67,中文,,0,0,0,,但是我的惩罚清单告诉我 请对 C 应用一个大惩罚 15 分 我们不喜欢 C 看 C 现在有一个非常大的惩罚
Dialogue: 0,0:17:26.67,0:17:28.27,英文,,0,0,0,,And that means I'm going to explore it later.
Dialogue: 0,0:17:26.67,0:17:28.27,中文,,0,0,0,,这意味着我会稍后探索它
Dialogue: 0,0:17:28.27,0:17:29.97,英文,,0,0,0,,It's one of those nodes that's to the west.
Dialogue: 0,0:17:28.27,0:17:29.97,中文,,0,0,0,,这是西边的一个节点
Dialogue: 0,0:17:29.97,0:17:31.19,英文,,0,0,0,,I don't care about it.
Dialogue: 0,0:17:29.97,0:17:31.19,中文,,0,0,0,,我不在乎它
Dialogue: 0,0:17:31.19,0:17:32.05,英文,,0,0,0,,OK.
Dialogue: 0,0:17:32.05,0:17:33.69,英文,,0,0,0,,So then this goes onwards.
Dialogue: 0,0:17:32.05,0:17:33.69,中文,,0,0,0,,然后这个继续前进
Dialogue: 0,0:17:33.69,0:17:38.91,英文,,0,0,0,,The next node I'm going to explore, in Dijkstra's, it would have been C, because Dijkstra's would have said C is closer.
Dialogue: 0,0:17:33.69,0:17:38.91,中文,,0,0,0,,下一个节点我要探索的 在迪杰斯特拉算法中 应该是C 因为迪杰斯特拉算法会说C更近
Dialogue: 0,0:17:38.91,0:17:40.92,英文,,0,0,0,,It's got distance 1, and B is further.
Dialogue: 0,0:17:38.91,0:17:40.92,中文,,0,0,0,,它的距离是1 B更远
Dialogue: 0,0:17:40.92,0:17:42.34,英文,,0,0,0,,It's got distance 2.
Dialogue: 0,0:17:40.92,0:17:42.34,中文,,0,0,0,,它的距离是2
Dialogue: 0,0:17:42.34,0:17:46.80,英文,,0,0,0,,So Dijkstra's would have checked out C next, but A star is different.
Dialogue: 0,0:17:42.34,0:17:46.80,中文,,0,0,0,,Dijkstra 算法接下来会检查 C 但 A* 算法不同
Dialogue: 0,0:17:46.80,0:17:49.28,英文,,0,0,0,,A star chooses to check out B next.
Dialogue: 0,0:17:46.80,0:17:49.28,中文,,0,0,0,,A* 算法选择下一个检查的是 B
Dialogue: 0,0:17:49.28,0:17:54.25,英文,,0,0,0,,And that's because if I look in the priority queue, B has the best priority, the lowest priority.
Dialogue: 0,0:17:49.28,0:17:54.25,中文,,0,0,0,,这是因为如果我看一下优先队列 B 有最好的优先级 即最低的优先级
Dialogue: 0,0:17:54.25,0:17:58.79,英文,,0,0,0,,And that's because with the penalty included, B seems to be a better bet.
Dialogue: 0,0:17:54.25,0:17:58.79,中文,,0,0,0,,这是因为包含惩罚的情况下 B 似乎是一个更好的选择
Dialogue: 0,0:17:58.79,0:18:01.97,英文,,0,0,0,,So in Dijkstra's, I explore all the closer things first.
Dialogue: 0,0:17:58.79,0:18:01.97,中文,,0,0,0,,在 Dijkstra 算法中 我首先探索所有更近的东西
Dialogue: 0,0:18:01.97,0:18:08.05,英文,,0,0,0,,In A star, I still kind of explore the closest things first, but I apply penalties to try and
Dialogue: 0,0:18:01.97,0:18:08.05,中文,,0,0,0,,在 A* 算法中 我仍然有点像先探索最近的东西 但我会施加惩罚
Dialogue: 0,0:18:08.05,0:18:16.05,英文,,0,0,0,,get the algorithm to look at vertices that are more promising, that are better ways to get the g we hope, based on these numbers that someone gave us.
Dialogue: 0,0:18:08.05,0:18:16.05,中文,,0,0,0,,以试图让算法看看更有前途的顶点 更好的路径 根据某些人给我们的这些数字 我们希望获得 G
Dialogue: 0,0:18:16.05,0:18:18.39,英文,,0,0,0,,So here I am at B. I'm going to start relaxing.
Dialogue: 0,0:18:16.05,0:18:18.39,中文,,0,0,0,,我现在在 B 我要开始放弃了
Dialogue: 0,0:18:18.39,0:18:22.94,英文,,0,0,0,,So these two should succeed because they're better than infinity.
Dialogue: 0,0:18:18.39,0:18:22.94,中文,,0,0,0,,这两个应该成功 因为它们比无穷大好
Dialogue: 0,0:18:22.94,0:18:26.28,英文,,0,0,0,,This one, 2 plus 5 is 7, is not better than 1.
Dialogue: 0,0:18:22.94,0:18:26.28,中文,,0,0,0,,这个 2+5等于7 不比1好
Dialogue: 0,0:18:26.28,0:18:28.21,英文,,0,0,0,,So this relaxation fails.
Dialogue: 0,0:18:26.28,0:18:28.21,中文,,0,0,0,,这个放弃失败了
Dialogue: 0,0:18:28.21,0:18:30.03,英文,,0,0,0,,Those are all things we've seen before.
Dialogue: 0,0:18:28.21,0:18:30.03,中文,,0,0,0,,这些都是我们之前见过的东西
Dialogue: 0,0:18:30.03,0:18:31.17,英文,,0,0,0,,OK.
Dialogue: 0,0:18:31.17,0:18:34.18,英文,,0,0,0,,And again, here is where we're updating the priorities.
Dialogue: 0,0:18:31.17,0:18:34.18,中文,,0,0,0,,再次 这里是我们更新优先级的地方
Dialogue: 0,0:18:34.18,0:18:37.64,英文,,0,0,0,,If you know how to update the priorities, you have A star totally down.
Dialogue: 0,0:18:34.18,0:18:37.64,中文,,0,0,0,,如果你知道如何更新优先级 那你就完全掌握了A*
Dialogue: 0,0:18:37.64,0:18:40.46,英文,,0,0,0,,So look, the distance to D is 13.
Dialogue: 0,0:18:37.64,0:18:40.46,中文,,0,0,0,,看 到 D 的距离是 13
Dialogue: 0,0:18:40.46,0:18:41.62,英文,,0,0,0,,That's still always true.
Dialogue: 0,0:18:40.46,0:18:41.62,中文,,0,0,0,,这仍然始终如一
Dialogue: 0,0:18:41.62,0:18:45.20,英文,,0,0,0,,No penalties being used here.
Dialogue: 0,0:18:41.62,0:18:45.20,中文,,0,0,0,,这里没有使用任何惩罚
Dialogue: 0,0:18:45.20,0:18:48.68,英文,,0,0,0,,The best way to get to D is 2 plus 11 is 13.
Dialogue: 0,0:18:45.20,0:18:48.68,中文,,0,0,0,,到达 D 的最佳方式是 2 + 11 得到 13
Dialogue: 0,0:18:48.68,0:18:50.78,英文,,0,0,0,,Best known distance to D.
Dialogue: 0,0:18:48.68,0:18:50.78,中文,,0,0,0,,到达 D 的最佳已知距离
Dialogue: 0,0:18:50.78,0:18:59.29,英文,,0,0,0,,But in the fringe, I need to apply the extra penalty that someone told me of 2, because they think d is pretty good, maybe really good.
Dialogue: 0,0:18:50.78,0:18:59.29,中文,,0,0,0,,但在边缘情况下 我需要施加额外的惩罚 有人告诉我是 2 因为他们认为 D 相当好 也许真的很好
Dialogue: 0,0:18:59.29,0:19:01.33,英文,,0,0,0,,That's why the penalty is only 2.
Dialogue: 0,0:18:59.29,0:19:01.33,中文,,0,0,0,,这就是为什么惩罚只有 2
Dialogue: 0,0:19:01.33,0:19:02.49,英文,,0,0,0,,But I need to apply it.
Dialogue: 0,0:19:01.33,0:19:02.49,中文,,0,0,0,,但是我需要应用它
Dialogue: 0,0:19:02.49,0:19:05.55,英文,,0,0,0,,That's why d has priority 15.
Dialogue: 0,0:19:02.49,0:19:05.55,中文,,0,0,0,,这就是为什么 D 优先级为 15
Dialogue: 0,0:19:05.55,0:19:10.13,英文,,0,0,0,,And likewise, e, the best known distance is 5, just like Dijkstra's.
Dialogue: 0,0:19:05.55,0:19:10.13,中文,,0,0,0,,同样地 E 最佳已知距离是 5 就像 Dijkstra 的一样
Dialogue: 0,0:19:10.13,0:19:13.19,英文,,0,0,0,,But when I go to the fringe, I can't just put the number 5 here.
Dialogue: 0,0:19:10.13,0:19:13.19,中文,,0,0,0,,但是当我到达边缘时 我不能只把数字 5 放在这里
Dialogue: 0,0:19:13.19,0:19:17.34,英文,,0,0,0,,I need to add the extra penalty of 1 to get 6.
Dialogue: 0,0:19:13.19,0:19:17.34,中文,,0,0,0,,我需要额外增加 1 的惩罚来得到 6
Dialogue: 0,0:19:17.34,0:19:19.00,英文,,0,0,0,,OK, and so I go onwards.
Dialogue: 0,0:19:17.34,0:19:19.00,中文,,0,0,0,,我继续前进
Dialogue: 0,0:19:19.00,0:19:22.68,英文,,0,0,0,,So the next thing I'm going to take off the fringe, I look at these priorities.
Dialogue: 0,0:19:19.00,0:19:22.68,中文,,0,0,0,,接下来我要从边缘中取下的东西 我看看这些优先级
Dialogue: 0,0:19:22.68,0:19:29.77,英文,,0,0,0,,The best one is E, because that's the one with the lowest cost or distance so far, plus penalty.
Dialogue: 0,0:19:22.68,0:19:29.77,中文,,0,0,0,,最好的是 E 因为这是到目前为止成本或距离最低的 再加上惩罚
Dialogue: 0,0:19:29.77,0:19:31.39,英文,,0,0,0,,I need to account for both.
Dialogue: 0,0:19:29.77,0:19:31.39,中文,,0,0,0,,我需要考虑两者
Dialogue: 0,0:19:31.39,0:19:32.73,英文,,0,0,0,,So I take E off the fringe.
Dialogue: 0,0:19:31.39,0:19:32.73,中文,,0,0,0,,我从 fringe 中移除 E
Dialogue: 0,0:19:32.73,0:19:33.97,英文,,0,0,0,,I'm now going to mark it.
Dialogue: 0,0:19:32.73,0:19:33.97,中文,,0,0,0,,现在我要标记它
Dialogue: 0,0:19:33.97,0:19:37.24,英文,,0,0,0,,And it's time to relax both of these outgoing edges.
Dialogue: 0,0:19:33.97,0:19:37.24,中文,,0,0,0,,现在是放弃这两条出边的时候了
Dialogue: 0,0:19:37.24,0:19:38.40,英文,,0,0,0,,So I relax.
Dialogue: 0,0:19:37.24,0:19:38.40,中文,,0,0,0,,我放弃
Dialogue: 0,0:19:38.40,0:19:39.60,英文,,0,0,0,,OK, there they go.
Dialogue: 0,0:19:38.40,0:19:39.60,中文,,0,0,0,,它们走了
Dialogue: 0,0:19:39.60,0:19:42.54,英文,,0,0,0,,And again, I update G, I update F. And here's the key thing.
Dialogue: 0,0:19:39.60,0:19:42.54,中文,,0,0,0,,再一次 我更新 G 我更新 F 这是关键
Dialogue: 0,0:19:42.54,0:19:44.14,英文,,0,0,0,,Do you know how to get the number 10?
Dialogue: 0,0:19:42.54,0:19:44.14,中文,,0,0,0,,你知道怎么得到数字 10 吗
Dialogue: 0,0:19:44.14,0:19:45.34,英文,,0,0,0,,Do you know how to get the number 15?
Dialogue: 0,0:19:44.14,0:19:45.34,中文,,0,0,0,,怎么得到数字 15 吗
Dialogue: 0,0:19:45.34,0:19:48.34,英文,,0,0,0,,If you do, you know how A star works.
Dialogue: 0,0:19:45.34,0:19:48.34,中文,,0,0,0,,如果你知道 你就知道 A* 是怎么工作的
Dialogue: 0,0:19:48.34,0:19:49.51,英文,,0,0,0,,So how do I get 10?
Dialogue: 0,0:19:48.34,0:19:49.51,中文,,0,0,0,,那么我怎么得到 10 呢
Dialogue: 0,0:19:49.51,0:19:52.35,英文,,0,0,0,,It's 10 plus the penalty of 0 is 10.
Dialogue: 0,0:19:49.51,0:19:52.35,中文,,0,0,0,,就是 10 加上罚分 0 等于 10
Dialogue: 0,0:19:52.35,0:19:53.75,英文,,0,0,0,,How do I get 15?
Dialogue: 0,0:19:52.35,0:19:53.75,中文,,0,0,0,,我怎么得到 15
Dialogue: 0,0:19:53.75,0:19:59.27,英文,,0,0,0,,F has distance to F is 9, plus F has penalty infinity.
Dialogue: 0,0:19:53.75,0:19:59.27,中文,,0,0,0,,F 到 F 的距离是 9 再加上 F 的惩罚是无穷大
Dialogue: 0,0:19:59.27,0:20:02.39,英文,,0,0,0,,So F has priority infinity.
Dialogue: 0,0:19:59.27,0:20:02.39,中文,,0,0,0,, F 的优先级是无穷大
Dialogue: 0,0:20:02.39,0:20:04.95,英文,,0,0,0,,And then eventually, I take G off the fringe.
Dialogue: 0,0:20:02.39,0:20:04.95,中文,,0,0,0,,然后最终 我将 G 从边缘中移除
Dialogue: 0,0:20:04.95,0:20:08.53,英文,,0,0,0,,And as soon as I take G off the fringe, I can declare success.
Dialogue: 0,0:20:04.95,0:20:08.53,中文,,0,0,0,,一旦我将 G 从边缘中移除 我就可以宣布成功了
Dialogue: 0,0:20:08.53,0:20:16.52,英文,,0,0,0,,Because I take G off the fringe, that means I found a way to G. Look, A, B, E, G. I found the way to G. That's great.
Dialogue: 0,0:20:08.53,0:20:16.52,中文,,0,0,0,,因为我将 G 从边缘中移除 这意味着我找到了通往 G 的路径 看 A、B、E、G 我找到了通往 G 的路径 太棒了
Dialogue: 0,0:20:16.52,0:20:20.10,英文,,0,0,0,,And I can declare victory because I found my way to New York, and I'm done.
Dialogue: 0,0:20:16.52,0:20:20.10,中文,,0,0,0,,我可以宣布胜利 因为我找到了通往纽约的路 我完成了
Dialogue: 0,0:20:20.10,0:20:21.62,英文,,0,0,0,,That's all I cared about.
Dialogue: 0,0:20:20.10,0:20:21.62,中文,,0,0,0,,这就是我关心的全部
Dialogue: 0,0:20:21.62,0:20:23.70,英文,,0,0,0,,So some observations really quickly.
Dialogue: 0,0:20:21.62,0:20:23.70,中文,,0,0,0,,所以一些观察很快
Dialogue: 0,0:20:23.70,0:20:27.22,英文,,0,0,0,,One thing to observe is we actually never looked at C.
Dialogue: 0,0:20:23.70,0:20:27.22,中文,,0,0,0,,有一件事要观察 我们实际上从未看过C
Dialogue: 0,0:20:27.22,0:20:33.36,英文,,0,0,0,,or F or D. These were the states like California and North Dakota that we never cared about.
Dialogue: 0,0:20:27.22,0:20:33.36,中文,,0,0,0,,或者F或D 这些是像加利福尼亚和北达科他这样的州 我们从未关心过的
Dialogue: 0,0:20:33.36,0:20:39.81,英文,,0,0,0,,Because we don't care about how to get to these vertices, we actually ignored visiting them, and we finished the algorithm a little bit faster.
Dialogue: 0,0:20:33.36,0:20:39.81,中文,,0,0,0,,因为我们不关心如何到达这些顶点 我们实际上忽略了访问它们 这样我们就可以更快地完成算法
Dialogue: 0,0:20:39.81,0:20:41.81,英文,,0,0,0,,We didn't have to look at all the vertices.
Dialogue: 0,0:20:39.81,0:20:41.81,中文,,0,0,0,,我们不必看所有的顶点
Dialogue: 0,0:20:41.81,0:20:43.21,英文,,0,0,0,,That's pretty good.
Dialogue: 0,0:20:41.81,0:20:43.21,中文,,0,0,0,,那挺好的
Dialogue: 0,0:20:43.21,0:20:47.33,英文,,0,0,0,,Another thing you'll notice is that some of the paths are actually just wrong.
Dialogue: 0,0:20:43.21,0:20:47.33,中文,,0,0,0,,另一件你会注意到的事情是 有些路径实际上是错误的
Dialogue: 0,0:20:47.33,0:20:52.70,英文,,0,0,0,,Like, look at the path to D. It's suggesting to go A, B, D.
Dialogue: 0,0:20:47.33,0:20:52.70,中文,,0,0,0,,就好比 看看到达 D 的路径 它建议走 A、B、D
Dialogue: 0,0:20:52.70,0:20:54.10,英文,,0,0,0,,which has cost 13.
Dialogue: 0,0:20:52.70,0:20:54.10,中文,,0,0,0,,这已经花费了 13
Dialogue: 0,0:20:54.10,0:20:57.26,英文,,0,0,0,,But the real best path to D, I think, is different.
Dialogue: 0,0:20:54.10,0:20:57.26,中文,,0,0,0,,但我觉得 真正最佳的到达 D 的路径是不同的
Dialogue: 0,0:20:57.26,0:20:59.72,英文,,0,0,0,,I actually don't remember what the exact path is.
Dialogue: 0,0:20:57.26,0:20:59.72,中文,,0,0,0,,我其实不记得确切的路径是什么
Dialogue: 0,0:20:59.72,0:21:02.02,英文,,0,0,0,,Is it A, B?
Dialogue: 0,0:20:59.72,0:21:02.02,中文,,0,0,0,,是 A、B 吗
Dialogue: 0,0:21:02.02,0:21:02.93,英文,,0,0,0,,EGD.
Dialogue: 0,0:21:02.02,0:21:02.93,中文,,0,0,0,,EGD
Dialogue: 0,0:21:02.93,0:21:08.13,英文,,0,0,0,,Okay, so the better path D is A, B, E, G, D. It's okay if you didn't see that.
Dialogue: 0,0:21:02.93,0:21:08.13,中文,,0,0,0,,更好的路径 D 是 A、B、E、G、D 如果你没看到也没关系
Dialogue: 0,0:21:08.13,0:21:09.11,英文,,0,0,0,,I didn't see it either.
Dialogue: 0,0:21:08.13,0:21:09.11,中文,,0,0,0,,我也没看到
Dialogue: 0,0:21:09.11,0:21:11.85,英文,,0,0,0,,But the key idea is this path is actually wrong.
Dialogue: 0,0:21:09.11,0:21:11.85,中文,,0,0,0,,但关键是这条路实际上是错误的
Dialogue: 0,0:21:11.85,0:21:17.21,英文,,0,0,0,,So I get the wrong directions to get to North Dakota or whatever state this is, but that's okay.
Dialogue: 0,0:21:11.85,0:21:17.21,中文,,0,0,0,,我得到了错误的方向去北达科他州或者其他什么州 但没关系
Dialogue: 0,0:21:17.21,0:21:21.86,英文,,0,0,0,,We don't care about how to get to D. We only care about how to get to G.
Dialogue: 0,0:21:17.21,0:21:21.86,中文,,0,0,0,,我们不关心如何到达D 我们只关心如何到达G
Dialogue: 0,0:21:21.86,0:21:29.86,英文,,0,0,0,,So A star gives you the right answer for your one target at the expense of giving you the wrong answer or just no answer at all for all the other targets.
Dialogue: 0,0:21:21.86,0:21:29.86,中文,,0,0,0,,所以A* 算法能够在为你的一个目标提供正确答案的同时 为所有其他目标提供错误答案或者根本没有答案
Dialogue: 0,0:21:29.86,0:21:34.23,英文,,0,0,0,,And that's OK, because we just care about a single target.
Dialogue: 0,0:21:29.86,0:21:34.23,中文,,0,0,0,,这没关系 因为我们只关心一个单一的目标
Dialogue: 0,0:21:34.23,0:21:38.15,英文,,0,0,0,,OK, so the last thing I need to tell you, unless you have questions.
Dialogue: 0,0:21:34.23,0:21:38.15,中文,,0,0,0,,除非你有问题 否则我需要告诉你的最后一件事
Dialogue: 0,0:21:38.15,0:21:42.89,英文,,0,0,0,,OK, the last thing I need to tell you about A star is who came up with these penalties.
Dialogue: 0,0:21:38.15,0:21:42.89,中文,,0,0,0,,关于A* 算法 我需要告诉你的最后一件事是谁提出了这些惩罚
Dialogue: 0,0:21:42.89,0:21:46.80,英文,,0,0,0,,So it turns out these numbers are not baked into the A star algorithm.
Dialogue: 0,0:21:42.89,0:21:46.80,中文,,0,0,0,,原来这些数字并没有嵌入到A* 算法中
Dialogue: 0,0:21:46.80,0:21:52.38,英文,,0,0,0,,Someone needs to make up these numbers and give them to you for every single graph that you can think of.
Dialogue: 0,0:21:46.80,0:21:52.38,中文,,0,0,0,,需要有人为你想到的每一个图形编制这些数字并把它们提供给你
Dialogue: 0,0:21:52.38,0:21:59.56,英文,,0,0,0,,So if someone hands you a graph and says run A star, they also need to hand you a list of numbers, one per node.
Dialogue: 0,0:21:52.38,0:21:59.56,中文,,0,0,0,,如果有人交给你一个图 并告诉你运行A* 算法 他们还需要递交给你一个数字列表 每个节点一个
Dialogue: 0,0:21:59.56,0:22:00.90,英文,,0,0,0,,So I take every node.
Dialogue: 0,0:21:59.56,0:22:00.90,中文,,0,0,0,,我遍历每一个节点
Dialogue: 0,0:22:00.90,0:22:02.44,英文,,0,0,0,,And I match it to a number.
Dialogue: 0,0:22:00.90,0:22:02.44,中文,,0,0,0,,然后我将其与一个数字进行匹配
Dialogue: 0,0:22:02.44,0:22:05.21,英文,,0,0,0,,And that number has to be some sort of penalty.
Dialogue: 0,0:22:02.44,0:22:05.21,中文,,0,0,0,,这个数字必须是某种惩罚
Dialogue: 0,0:22:05.21,0:22:07.69,英文,,0,0,0,,And I want further nodes to have higher penalties.
Dialogue: 0,0:22:05.21,0:22:07.69,中文,,0,0,0,,我希望进一步的节点有更高的惩罚
Dialogue: 0,0:22:07.69,0:22:10.65,英文,,0,0,0,,I want closer nodes to have fewer penalty.
Dialogue: 0,0:22:07.69,0:22:10.65,中文,,0,0,0,,我希望更接近的节点受到更少的惩罚
Dialogue: 0,0:22:10.65,0:22:13.63,英文,,0,0,0,,So you can almost think of it as closer nodes.
Dialogue: 0,0:22:10.65,0:22:13.63,中文,,0,0,0,,你几乎可以把它看作是更接近的节点
Dialogue: 0,0:22:13.63,0:22:20.01,英文,,0,0,0,,You can almost think of the heuristic, which is what sometimes people call these numbers, as an estimate of how close you are.
Dialogue: 0,0:22:13.63,0:22:20.01,中文,,0,0,0,,你几乎可以把这种启发式想象成一个估计 有时人们称这些数字为估计你有多接近的数字
Dialogue: 0,0:22:20.01,0:22:23.94,英文,,0,0,0,,So I like to think of them as penalties sometimes when I'm running the algorithm.
Dialogue: 0,0:22:20.01,0:22:23.94,中文,,0,0,0,,有时当我运行算法时 我喜欢把它们想象成惩罚
Dialogue: 0,0:22:23.94,0:22:30.16,英文,,0,0,0,,You could also think of them, and it's exactly the same idea, as the estimated cost to the goal.
Dialogue: 0,0:22:23.94,0:22:30.16,中文,,0,0,0,,你也可以把它们想象成一样的概念 即到目标的估计成本
Dialogue: 0,0:22:30.16,0:22:32.06,英文,,0,0,0,,So why are these estimated costs to the goal?
Dialogue: 0,0:22:30.16,0:22:32.06,中文,,0,0,0,,那么为什么这些到目标的估计成本呢
Dialogue: 0,0:22:32.06,0:22:39.25,英文,,0,0,0,,Because if someone is far from the goal, I should assign it a big penalty, and that reflects the fact that it's far away from the goal.
Dialogue: 0,0:22:32.06,0:22:39.25,中文,,0,0,0,,因为如果有人离目标很远 我应该给它分配一个很大的惩罚 这反映了它离目标很远的事实
Dialogue: 0,0:22:39.25,0:22:42.47,英文,,0,0,0,,If someone is close to the goal, I should assign it a small penalty.
Dialogue: 0,0:22:39.25,0:22:42.47,中文,,0,0,0,,如果有人接近目标 我应该给它分配一个小的惩罚
Dialogue: 0,0:22:42.47,0:22:44.89,英文,,0,0,0,,And that reflects the fact that it's close to the goal.
Dialogue: 0,0:22:42.47,0:22:44.89,中文,,0,0,0,,这反映了它接近目标的事实
Dialogue: 0,0:22:44.89,0:22:49.40,英文,,0,0,0,,So sometimes you can think of the heuristic, which is just a mapping of nodes to numbers.
Dialogue: 0,0:22:44.89,0:22:49.40,中文,,0,0,0,,有时候你可以考虑启发式 它只是将节点映射到数字
Dialogue: 0,0:22:49.40,0:22:55.16,英文,,0,0,0,,Every node gets a number for your graph as the estimated cost to the goal.
Dialogue: 0,0:22:49.40,0:22:55.16,中文,,0,0,0,,每个节点都为你的图得到一个数字 作为到目标的估计成本
Dialogue: 0,0:22:55.16,0:22:57.06,英文,,0,0,0,,And it's an estimate. It doesn't have to be perfect.
Dialogue: 0,0:22:55.16,0:22:57.06,中文,,0,0,0,,这只是一个估计  它不必完美
Dialogue: 0,0:22:57.06,0:23:01.18,英文,,0,0,0,,It just has to be good enough to help us bias the direction in the right way.
Dialogue: 0,0:22:57.06,0:23:01.18,中文,,0,0,0,,它只需要足够好 以帮助我们偏向正确的方向
Dialogue: 0,0:23:01.18,0:23:09.76,英文,,0,0,0,,So for example, if I had a graph like this Google Maps graph, how would you estimate, for example, the distance from Henderson to New York?
Dialogue: 0,0:23:01.18,0:23:09.76,中文,,0,0,0,,比如说 如果我有一个像谷歌地图那样的图 你怎么估计 比如说 从亨德森到纽约的距离
Dialogue: 0,0:23:09.76,0:23:11.50,英文,,0,0,0,,You don't know the exact distance.
Dialogue: 0,0:23:09.76,0:23:11.50,中文,,0,0,0,,你不知道确切的距离
Dialogue: 0,0:23:11.50,0:23:15.41,英文,,0,0,0,,To know the exact distance, you have to run Dijkstra's or run a star.
Dialogue: 0,0:23:11.50,0:23:15.41,中文,,0,0,0,,要知道确切的距离 你得运行迪杰斯特拉算法或者运行 A* 算法
Dialogue: 0,0:23:15.41,0:23:20.27,英文,,0,0,0,,So if I had to take a guess, what's your best guess for the distance from Henderson to New York?
Dialogue: 0,0:23:15.41,0:23:20.27,中文,,0,0,0,,如果我不得不猜的话 你对从亨德森到纽约的距离有什么最好的猜测
Dialogue: 0,0:23:20.27,0:23:21.64,英文,,0,0,0,,What do you like?
Dialogue: 0,0:23:20.27,0:23:21.64,中文,,0,0,0,,你喜欢什么
Dialogue: 0,0:23:21.64,0:23:25.30,英文,,0,0,0,,You could draw a straight line or something and maybe measure that distance.
Dialogue: 0,0:23:21.64,0:23:25.30,中文,,0,0,0,,你可以画一条直线或者什么的 然后可能测量那个距离
Dialogue: 0,0:23:25.30,0:23:28.35,英文,,0,0,0,,It's not going to be correct, but it might be close.
Dialogue: 0,0:23:25.30,0:23:28.35,中文,,0,0,0,,这不会是正确的 但可能会接近
Dialogue: 0,0:23:28.35,0:23:32.11,英文,,0,0,0,,So you can use an estimate like straight line distance from Henderson to New York.
Dialogue: 0,0:23:28.35,0:23:32.11,中文,,0,0,0,,你可以使用从亨德森到纽约的直线距离来估计
Dialogue: 0,0:23:32.11,0:23:37.13,英文,,0,0,0,,And that would give you at least a guess as to how close you are and what kind of penalty you should apply.
Dialogue: 0,0:23:32.11,0:23:37.13,中文,,0,0,0,,这样至少可以让你猜到你离目的地有多近 以及你应该应用什么样的惩罚
Dialogue: 0,0:23:37.13,0:23:43.33,英文,,0,0,0,,Because if I drew a straight line from San Francisco to New York, I'd get a really big number that would say, don't go to San Francisco.
Dialogue: 0,0:23:37.13,0:23:43.33,中文,,0,0,0,,因为如果我从旧金山画一条直线到纽约 我会得到一个非常大的数字 这会告诉我 不要去旧金山
Dialogue: 0,0:23:43.33,0:23:45.66,英文,,0,0,0,,But maybe Henderson to New York is a smaller number.
Dialogue: 0,0:23:43.33,0:23:45.66,中文,,0,0,0,,但是从亨德森到纽约可能是一个较小的数字
Dialogue: 0,0:23:45.66,0:23:47.66,英文,,0,0,0,,So A star will check that out.
Dialogue: 0,0:23:45.66,0:23:47.66,中文,,0,0,0,,所以A* 算法会检查这个情况
Dialogue: 0,0:23:47.66,0:23:50.06,英文,,0,0,0,,OK, so that's one possible idea.
Dialogue: 0,0:23:47.66,0:23:50.06,中文,,0,0,0,,这是一个可能的想法
Dialogue: 0,0:23:50.06,0:23:54.42,英文,,0,0,0,,But remember, this needs to be provided to you for every single separate graph.
Dialogue: 0,0:23:50.06,0:23:54.42,中文,,0,0,0,,但请记住 这需要为每个单独的图提供给你
Dialogue: 0,0:23:54.42,0:23:57.00,英文,,0,0,0,,So it's not that A star gives you heuristics.
Dialogue: 0,0:23:54.42,0:23:57.00,中文,,0,0,0,,问题不是A* 给你启发
Dialogue: 0,0:23:57.00,0:24:03.78,英文,,0,0,0,,It is that someone else needs to give you the heuristic before you run A star, or they have to feed it to you when you run A star.
Dialogue: 0,0:23:57.00,0:24:03.78,中文,,0,0,0,,而是在你运行A* 之前 其他人需要给你启发 或者在你运行A* 时他们必须给你提供启发
Dialogue: 0,0:24:03.78,0:24:06.58,英文,,0,0,0,,OK, this animation is pretty cool, so check it out.
Dialogue: 0,0:24:03.78,0:24:06.58,中文,,0,0,0,,这个动画挺酷的 所以去看看吧
Dialogue: 0,0:24:06.58,0:24:11.26,英文,,0,0,0,,But the final thing I'll say, just really quickly, is that you need to choose good heuristics.
Dialogue: 0,0:24:06.58,0:24:11.26,中文,,0,0,0,,但我要说的最后一件事 非常简单 就是你需要选择好的启发
Dialogue: 0,0:24:11.26,0:24:19.51,英文,,0,0,0,,So for example, If someone hands you the list of heuristics, or you design it, and you simply write the number 0 for every single vertex.
Dialogue: 0,0:24:11.26,0:24:19.51,中文,,0,0,0,,例如  如果有人给你启发列表 或者你设计了它 然后你只是对每个顶点简单地写下数字0
Dialogue: 0,0:24:19.51,0:24:22.99,英文,,0,0,0,,Remember, the heuristic is a mapping of every vertex gets a number.
Dialogue: 0,0:24:19.51,0:24:22.99,中文,,0,0,0,,记住 启发是每个顶点得到一个数字的映射
Dialogue: 0,0:24:22.99,0:24:29.75,英文,,0,0,0,,If you start writing 0, 0, 0, 0, 0, well, then you're just going to get Dijkstra's algorithm all over again.
Dialogue: 0,0:24:22.99,0:24:29.75,中文,,0,0,0,,如果你从 0, 0, 0, 0, 0 开始写 那么你就会再次得到迪杰斯特拉算法
Dialogue: 0,0:24:29.75,0:24:34.56,英文,,0,0,0,,Because nobody has any penalty, you end up dequeuing the vertices in order of distance.
Dialogue: 0,0:24:29.75,0:24:34.56,中文,,0,0,0,,因为没有任何惩罚 你最终按距离的顺序出列顶点
Dialogue: 0,0:24:34.56,0:24:37.06,英文,,0,0,0,,So you end up visiting all the closer vertices,
Dialogue: 0,0:24:34.56,0:24:37.06,中文,,0,0,0,,你最终访问所有更近的顶点
Dialogue: 0,0:24:37.06,0:24:39.10,英文,,0,0,0,,followed by all the further vertices.
Dialogue: 0,0:24:37.06,0:24:39.10,中文,,0,0,0,,然后是所有更远的顶点
Dialogue: 0,0:24:39.10,0:24:48.22,英文,,0,0,0,,So if you just pick a really silly heuristic, like there's no information about who's closer, and you just write the number 0 over and over again, you just get Dijkstra's algorithm again.
Dialogue: 0,0:24:39.10,0:24:48.22,中文,,0,0,0,,如果你只是选择一个非常愚蠢的启发式 就像没有关于谁更接近的信息 你只是一遍又一遍地写数字 0 你就会再次得到迪杰斯特拉算法
Dialogue: 0,0:24:48.22,0:24:51.00,英文,,0,0,0,,No speed improvement whatsoever.
Dialogue: 0,0:24:48.22,0:24:51.00,中文,,0,0,0,,没有任何速度改进
Dialogue: 0,0:24:51.00,0:24:52.60,英文,,0,0,0,,However, you need to be really careful.
Dialogue: 0,0:24:51.00,0:24:52.60,中文,,0,0,0,,但是 你需要非常小心
Dialogue: 0,0:24:52.60,0:25:01.08,英文,,0,0,0,,So for example, let's say, sorry for insulting all these states today, but let's say we really do not like Illinois for some reason.
Dialogue: 0,0:24:52.60,0:25:01.08,中文,,0,0,0,,举个例子 比方说 抱歉今天冒犯了这么多州 但假设我们真的非常不喜欢伊利诺伊州
Dialogue: 0,0:25:01.08,0:25:02.91,英文,,0,0,0,,See, this one's on the slide, so it's not me.
Dialogue: 0,0:25:01.08,0:25:02.91,中文,,0,0,0,,看 这个在幻灯片上 所以不是我说的
Dialogue: 0,0:25:02.91,0:25:05.29,英文,,0,0,0,,OK, is anyone from Illinois?
Dialogue: 0,0:25:02.91,0:25:05.29,中文,,0,0,0,,有人是伊利诺伊州的吗
Dialogue: 0,0:25:05.29,0:25:06.31,英文,,0,0,0,,OK, no?
Dialogue: 0,0:25:05.29,0:25:06.31,中文,,0,0,0,,没有
Dialogue: 0,0:25:06.31,0:25:06.57,英文,,0,0,0,,No?
Dialogue: 0,0:25:06.31,0:25:06.57,中文,,0,0,0,,没有
Dialogue: 0,0:25:06.57,0:25:08.09,英文,,0,0,0,,OK, that means I can.
Dialogue: 0,0:25:06.57,0:25:08.09,中文,,0,0,0,,那我可以了
Dialogue: 0,0:25:08.09,0:25:14.23,英文,,0,0,0,,Okay, so let's say we are intensely disliking Illinois.
Dialogue: 0,0:25:08.09,0:25:14.23,中文,,0,0,0,,假设我们非常讨厌伊利诺伊州
Dialogue: 0,0:25:14.23,0:25:20.20,英文,,0,0,0,,So we say every single node in Illinois has a heuristic of 100,000.
Dialogue: 0,0:25:14.23,0:25:20.20,中文,,0,0,0,,我们说伊利诺伊州的每个节点的启发式评估是100,000
Dialogue: 0,0:25:20.20,0:25:22.06,英文,,0,0,0,,That is, we hate Illinois.
Dialogue: 0,0:25:20.20,0:25:22.06,中文,,0,0,0,,也就是说 我们讨厌伊利诺伊州
Dialogue: 0,0:25:22.06,0:25:24.74,英文,,0,0,0,,We apply the worst penalty we can think of to Illinois.
Dialogue: 0,0:25:22.06,0:25:24.74,中文,,0,0,0,,我们对伊利诺伊州施加了我们能想到的最严重的惩罚
Dialogue: 0,0:25:24.74,0:25:28.68,英文,,0,0,0,,Please don't go to Illinois under any circumstances.
Dialogue: 0,0:25:24.74,0:25:28.68,中文,,0,0,0,,请无论如何不要去伊利诺伊州
Dialogue: 0,0:25:28.68,0:25:38.11,英文,,0,0,0,,That's what we're telling the algorithm, because every node in Illinois gets hit with this gigantic penalty, and our estimate distance from Illinois to the goal is like 100,000 miles.
Dialogue: 0,0:25:28.68,0:25:38.11,中文,,0,0,0,,因为伊利诺伊州的每个节点都被这个巨大的惩罚打击 我们估计从伊利诺伊州到目标的距离大概是100,000英里
Dialogue: 0,0:25:38.11,0:25:39.37,英文,,0,0,0,,It's so far.
Dialogue: 0,0:25:38.11,0:25:39.37,中文,,0,0,0,,太远了
Dialogue: 0,0:25:39.37,0:25:42.11,英文,,0,0,0,,Well then, will I get the correct answer?
Dialogue: 0,0:25:39.37,0:25:42.11,中文,,0,0,0,,那么 我能得到正确答案吗
Dialogue: 0,0:25:42.11,0:25:44.09,英文,,0,0,0,,And maybe this picture will help.
Dialogue: 0,0:25:42.11,0:25:44.09,中文,,0,0,0,,也许这张图片会有所帮助
Dialogue: 0,0:25:44.09,0:25:49.32,英文,,0,0,0,,Will I get the correct answer if I bias A star to avoid any path going through Illinois?
Dialogue: 0,0:25:44.09,0:25:49.32,中文,,0,0,0,,如果我偏向 A* 算法 避免任何路径穿过伊利诺伊州 我会得到正确的答案吗
Dialogue: 0,0:25:49.32,0:25:53.46,英文,,0,0,0,,I force it to check everybody else before it can check Illinois.
Dialogue: 0,0:25:49.32,0:25:53.46,中文,,0,0,0,,我强制它在检查伊利诺伊州之前先检查其他人
Dialogue: 0,0:25:53.46,0:25:54.56,英文,,0,0,0,,Well, then I'll get the wrong answer.
Dialogue: 0,0:25:53.46,0:25:54.56,中文,,0,0,0,,那么我会得到错误的答案
Dialogue: 0,0:25:54.56,0:25:57.90,英文,,0,0,0,,Because look, the actual answer does go through Illinois.
Dialogue: 0,0:25:54.56,0:25:57.90,中文,,0,0,0,,因为看 实际答案确实经过伊利诺伊州
Dialogue: 0,0:25:57.90,0:26:05.04,英文,,0,0,0,,So by applying such a gigantic penalty on paths that go through Illinois, I will actually get the wrong answer.
Dialogue: 0,0:25:57.90,0:26:05.04,中文,,0,0,0,,通过对经过伊利诺伊州的路径施加如此巨大的惩罚 我实际上会得到错误的答案
Dialogue: 0,0:26:05.04,0:26:11.11,英文,,0,0,0,,Because I will be too scared, or A star will be too scared, to explore the correct path.
Dialogue: 0,0:26:05.04,0:26:11.11,中文,,0,0,0,,因为我会太害怕 或者说 A* 算法会太害怕去探索正确的路径
Dialogue: 0,0:26:11.11,0:26:17.43,英文,,0,0,0,,Because you are so Illinois-phobic that you don't want A star to go through Illinois, then it will give you the wrong path.
Dialogue: 0,0:26:11.11,0:26:17.43,中文,,0,0,0,,因为你对伊利诺伊州过于恐惧 所以不想让A* 穿过伊利诺伊州 结果会给你错误的路径
Dialogue: 0,0:26:17.43,0:26:22.17,英文,,0,0,0,,Because it tries to dodge Illinois at all costs, because that's what you told A star to do.
Dialogue: 0,0:26:17.43,0:26:22.17,中文,,0,0,0,,因为它竭尽全力避开伊利诺伊州 因为这是你告诉A* 要做的事情
Dialogue: 0,0:26:22.17,0:26:29.36,英文,,0,0,0,,So you need to actually be a little bit careful and design a heuristic for every single graph that you come up with.
Dialogue: 0,0:26:22.17,0:26:29.36,中文,,0,0,0,,你实际上需要小心设计每个你遇到的图形的启发式
Dialogue: 0,0:26:29.36,0:26:31.98,英文,,0,0,0,,That gives pretty good estimates.
Dialogue: 0,0:26:29.36,0:26:31.98,中文,,0,0,0,,这给出了相当不错的估计
Dialogue: 0,0:26:31.98,0:26:35.52,英文,,0,0,0,,You don't want to do something nuts like this, where you just completely ignore Illinois.
Dialogue: 0,0:26:31.98,0:26:35.52,中文,,0,0,0,,你不想做像这样的疯狂事情 完全忽略伊利诺伊州
Dialogue: 0,0:26:35.52,0:26:37.04,英文,,0,0,0,,It gives you the wrong answer.
Dialogue: 0,0:26:35.52,0:26:37.04,中文,,0,0,0,,这会给出错误的答案
Dialogue: 0,0:26:37.04,0:26:39.65,英文,,0,0,0,,In particular, there are two properties that we care about.
Dialogue: 0,0:26:37.04,0:26:39.65,中文,,0,0,0,,特别是 有两个我们关心的属性
Dialogue: 0,0:26:39.65,0:26:41.49,英文,,0,0,0,,I'm not going to talk about them in too much detail.
Dialogue: 0,0:26:39.65,0:26:41.49,中文,,0,0,0,,我不会详细讨论它们
Dialogue: 0,0:26:41.49,0:26:46.95,英文,,0,0,0,,But roughly speaking, what you need to do is be optimistic and underestimate the true cost.
Dialogue: 0,0:26:41.49,0:26:46.95,中文,,0,0,0,,但大致来说 你需要做的是乐观并低估真实成本
Dialogue: 0,0:26:46.95,0:26:50.19,英文,,0,0,0,,So in this case, I overestimated the true cost.
Dialogue: 0,0:26:46.95,0:26:50.19,中文,,0,0,0,,在这种情况下 我高估了真实成本
Dialogue: 0,0:26:50.19,0:26:55.48,英文,,0,0,0,,The real cost from Illinois to New York is not 100,000 miles. It's less than.
Dialogue: 0,0:26:50.19,0:26:55.48,中文,,0,0,0,,从伊利诺伊州到纽约的实际成本不是10万英里  少于10万
Dialogue: 0,0:26:55.48,0:26:57.10,英文,,0,0,0,,I overestimated the true cost.
Dialogue: 0,0:26:55.48,0:26:57.10,中文,,0,0,0,,我高估了真实成本
Dialogue: 0,0:26:57.10,0:27:00.46,英文,,0,0,0,,I was too scared of Illinois, so I got the wrong answer.
Dialogue: 0,0:26:57.10,0:27:00.46,中文,,0,0,0,,我对伊利诺伊州太害怕了 所以我给出了错误的答案
Dialogue: 0,0:27:00.46,0:27:06.59,英文,,0,0,0,,By contrast, if you're generally optimistic and you give answers that are lower than the true cost,
Dialogue: 0,0:27:00.46,0:27:06.59,中文,,0,0,0,,相比之下 如果你通常是乐观的 而且回答的价格比真实成本低
Dialogue: 0,0:27:06.59,0:27:10.31,英文,,0,0,0,,then generally some versions of A star will give you the right answer.
Dialogue: 0,0:27:06.59,0:27:10.31,中文,,0,0,0,,那么一些版本的A* 算法通常会给出正确的答案
Dialogue: 0,0:27:10.31,0:27:16.63,英文,,0,0,0,,To get all versions of A star to give you the right answer, you need something stronger called consistency, which I won't talk about in detail.
Dialogue: 0,0:27:10.31,0:27:16.63,中文,,0,0,0,,要让所有版本的A* 算法都给出正确的答案 你需要更强大的一种叫做一致性的东西 我就不详细谈了
Dialogue: 0,0:27:16.63,0:27:19.77,英文,,0,0,0,,But the important thing is you need to choose the heuristic yourself.
Dialogue: 0,0:27:16.63,0:27:19.77,中文,,0,0,0,,但重要的是你需要自己选择启发式函数
Dialogue: 0,0:27:19.77,0:27:23.09,英文,,0,0,0,,If you choose bad ones, you will get the wrong answer.
Dialogue: 0,0:27:19.77,0:27:23.09,中文,,0,0,0,,如果你选择了糟糕的启发式函数 你就会得到错误的答案
Dialogue: 0,0:27:23.09,0:27:28.14,英文,,0,0,0,,So I guess we loved you, Illinois, after all, because you actually were part of the right answer.
Dialogue: 0,0:27:23.09,0:27:28.14,中文,,0,0,0,,我猜我们终究还是喜欢你 伊利诺伊州 因为你实际上是正确答案的一部分
Dialogue: 0,0:27:28.14,0:27:29.32,英文,,0,0,0,,OK.
Dialogue: 0,0:27:29.32,0:27:31.88,英文,,0,0,0,,See, redeemed.
Dialogue: 0,0:27:29.32,0:27:31.88,中文,,0,0,0,,看 赎回了
Dialogue: 0,0:27:31.88,0:27:32.86,英文,,0,0,0,,The last bullet point's wrong?
Dialogue: 0,0:27:31.88,0:27:32.86,中文,,0,0,0,,最后一个要点错了吗
Dialogue: 0,0:27:32.86,0:27:33.98,英文,,0,0,0,,OK, I'll change it.
Dialogue: 0,0:27:32.86,0:27:33.98,中文,,0,0,0,,我会改的
Dialogue: 0,0:27:33.98,0:27:35.57,英文,,0,0,0,,So what do you want me to do with it?
Dialogue: 0,0:27:33.98,0:27:35.57,中文,,0,0,0,,那你要我怎么处理它
Dialogue: 0,0:27:35.57,0:27:36.41,英文,,0,0,0,,I'm going to delete it.
Dialogue: 0,0:27:35.57,0:27:36.41,中文,,0,0,0,,我要删除它
Dialogue: 0,0:27:36.41,0:27:38.15,英文,,0,0,0,,OK.
Dialogue: 0,0:27:38.15,0:27:39.51,英文,,0,0,0,,The not?
Dialogue: 0,0:27:38.15,0:27:39.51,中文,,0,0,0,,不是吗
Dialogue: 0,0:27:39.51,0:27:41.81,英文,,0,0,0,,OK.
Dialogue: 0,0:27:41.81,0:27:42.37,英文,,0,0,0,,I'll delete it.
Dialogue: 0,0:27:41.81,0:27:42.37,中文,,0,0,0,,我会删除它
Dialogue: 0,0:27:42.37,0:27:42.87,英文,,0,0,0,,Don't worry about it.
Dialogue: 0,0:27:42.37,0:27:42.87,中文,,0,0,0,,别担心
Dialogue: 0,0:27:42.87,0:27:43.07,英文,,0,0,0,,OK.
Dialogue: 0,0:27:43.07,0:27:46.38,英文,,0,0,0,,Where's my strikethrough text?
Dialogue: 0,0:27:43.07,0:27:46.38,中文,,0,0,0,,我的删除线文字呢
Dialogue: 0,0:27:46.38,0:27:47.00,英文,,0,0,0,,OK.
Dialogue: 0,0:27:47.00,0:27:47.58,英文,,0,0,0,,It's gone.
Dialogue: 0,0:27:47.00,0:27:47.58,中文,,0,0,0,,它已经消失了
Dialogue: 0,0:27:47.58,0:27:47.82,英文,,0,0,0,,OK.
Dialogue: 0,0:27:47.82,0:27:49.78,英文,,0,0,0,,So you do need to know a little bit about admissibility.
Dialogue: 0,0:27:47.82,0:27:49.78,中文,,0,0,0,,你确实需要了解一点关于可接受性的知识
Dialogue: 0,0:27:49.78,0:27:51.84,英文,,0,0,0,,Sorry.
Dialogue: 0,0:27:49.78,0:27:51.84,中文,,0,0,0,,抱歉
Dialogue: 0,0:27:51.84,0:27:53.24,英文,,0,0,0,,OK.
Dialogue: 0,0:27:53.24,0:27:55.94,英文,,0,0,0,,Anything else you want to know about ASTAR before I keep going?
Dialogue: 0,0:27:53.24,0:27:55.94,中文,,0,0,0,,在我继续之前 你还想了解关于ASTAR的其他内容吗
Dialogue: 0,0:27:55.94,0:27:58.06,英文,,0,0,0,,I don't think you need to know about this, though.
Dialogue: 0,0:27:55.94,0:27:58.06,中文,,0,0,0,,不过我觉得在这之前你不需要了解这个
Dialogue: 0,0:27:58.06,0:27:59.38,英文,,0,0,0,,OK.
Dialogue: 0,0:27:59.38,0:28:14.84,英文,,0,0,0,,Question?
Dialogue: 0,0:27:59.38,0:28:14.84,中文,,0,0,0,,问题
Dialogue: 0,0:28:14.84,0:28:19.45,英文,,0,0,0,,Yeah, that's a great point, which is the heuristic is trying to guide me to the shortest path.
Dialogue: 0,0:28:14.84,0:28:19.45,中文,,0,0,0,,是啊 这一点很棒 启发式试图指导我走最短路径
Dialogue: 0,0:28:19.45,0:28:21.57,英文,,0,0,0,,But what if the heuristic gets it wrong?
Dialogue: 0,0:28:19.45,0:28:21.57,中文,,0,0,0,,但如果启发式错了怎么办
Dialogue: 0,0:28:21.57,0:28:30.42,英文,,0,0,0,,Remember, A star is considering, when I think about the priorities, I'm considering total cost so far plus the heuristic.
Dialogue: 0,0:28:21.57,0:28:30.42,中文,,0,0,0,,记住 A* 考虑的是 当我考虑优先级时 我考虑的是到目前为止的总成本加上启发式
Dialogue: 0,0:28:30.42,0:28:33.18,英文,,0,0,0,,So you can almost think of A star as trying to balance two things.
Dialogue: 0,0:28:30.42,0:28:33.18,中文,,0,0,0,,你可以把A* 想象成在平衡两件事情
Dialogue: 0,0:28:33.18,0:28:36.44,英文,,0,0,0,,It's still checking out things that are close before things that are far.
Dialogue: 0,0:28:33.18,0:28:36.44,中文,,0,0,0,,它仍然会先检查距离近的事物 然后才是远的
Dialogue: 0,0:28:36.44,0:28:42.16,英文,,0,0,0,,Like, I'm not going to skip and just check out New York, first of all, because I'm still thinking about things that are close to Denver.
Dialogue: 0,0:28:36.44,0:28:42.16,中文,,0,0,0,,比如 我不会直接跳过并首先查看纽约 因为我仍然在考虑离丹佛近的事物
Dialogue: 0,0:28:42.16,0:28:46.27,英文,,0,0,0,,So I'm still going to roughly be looking at closer things before further things.
Dialogue: 0,0:28:42.16,0:28:46.27,中文,,0,0,0,,在进一步之前 我仍然会粗略地看看更接近的东西
Dialogue: 0,0:28:46.27,0:28:50.65,英文,,0,0,0,,I'm just giving the algorithm a little boost by being like, hint, please go that way.
Dialogue: 0,0:28:46.27,0:28:50.65,中文,,0,0,0,,我只是通过类似的方式给算法一点推动 暗示 请朝那个方向走
Dialogue: 0,0:28:50.65,0:28:53.47,英文,,0,0,0,,But A star is still checking out lots of different vertices.
Dialogue: 0,0:28:50.65,0:28:53.47,中文,,0,0,0,,但是A* 仍然在检查许多不同的顶点
Dialogue: 0,0:28:53.47,0:28:55.33,英文,,0,0,0,,So that's where the correct answer comes from.
Dialogue: 0,0:28:53.47,0:28:55.33,中文,,0,0,0,,这就是正确答案的来源
Dialogue: 0,0:28:55.33,0:28:58.32,英文,,0,0,0,,It's not just checking a single path that you define.
Dialogue: 0,0:28:55.33,0:28:58.32,中文,,0,0,0,,它不仅仅是在检查你定义的单个路径
Dialogue: 0,0:28:58.32,0:29:04.30,英文,,0,0,0,,It's still balancing out and using a little bit of Dijkstra's power to try and look for things that are closer before things that are further.
Dialogue: 0,0:28:58.32,0:29:04.30,中文,,0,0,0,,它仍然在平衡并使用一点Dijkstra的能力来尝试寻找比较接近的东西
Dialogue: 0,0:29:04.30,0:29:08.26,英文,,0,0,0,,But as you mentioned, bad heuristics can actually give you the wrong answer.
Dialogue: 0,0:29:04.30,0:29:08.26,中文,,0,0,0,,但正如你提到的 不好的启发式方法实际上可能会给你错误的答案
Dialogue: 0,0:29:08.26,0:29:09.90,英文,,0,0,0,,So you have to be careful.
Dialogue: 0,0:29:08.26,0:29:09.90,中文,,0,0,0,,你得小心点
Dialogue: 0,0:29:09.90,0:29:11.30,英文,,0,0,0,,Okay, that's a great point.
Dialogue: 0,0:29:09.90,0:29:11.30,中文,,0,0,0,,这是一个很好的观点
Dialogue: 0,0:29:11.30,0:29:13.42,英文,,0,0,0,,Anything else on Zoom I need to know about?
Dialogue: 0,0:29:11.30,0:29:13.42,中文,,0,0,0,,Zoom上还有什么其他的事情我需要知道吗
Dialogue: 0,0:29:13.42,0:29:13.90,英文,,0,0,0,,No?
Dialogue: 0,0:29:13.42,0:29:13.90,中文,,0,0,0,,没有
Dialogue: 0,0:29:13.90,0:29:18.79,英文,,0,0,0,,Okay, that's it for A-star Dijkstra's shortest paths.
Dialogue: 0,0:29:13.90,0:29:18.79,中文,,0,0,0,,A* 算法Dijkstra最短路径就到这里了
Dialogue: 0,0:29:18.79,0:29:21.97,英文,,0,0,0,,I'm going to switch lecture slides.
Dialogue: 0,0:29:18.79,0:29:21.97,中文,,0,0,0,,我要切换讲义
Dialogue: 0,0:29:21.97,0:29:23.47,英文,,0,0,0,,Unless there are any objections.
Dialogue: 0,0:29:21.97,0:29:23.47,中文,,0,0,0,,除非有任何异议
Dialogue: 0,0:29:23.47,0:29:24.32,英文,,0,0,0,,OK.
Dialogue: 0,0:29:24.32,0:29:25.28,英文,,0,0,0,,Look at the flaming tree.
Dialogue: 0,0:29:24.32,0:29:25.28,中文,,0,0,0,,看着那棵燃烧的树
Dialogue: 0,0:29:25.28,0:29:25.86,英文,,0,0,0,,It's so cool.
Dialogue: 0,0:29:25.28,0:29:25.86,中文,,0,0,0,,太酷了
Dialogue: 0,0:29:25.86,0:29:27.32,英文,,0,0,0,,OK. Great.
Dialogue: 0,0:29:25.86,0:29:27.32,中文,,0,0,0,,好的  太棒了
Dialogue: 0,0:29:27.32,0:29:31.14,英文,,0,0,0,,So here's a quick intermission, I guess, a little warm-up problem.
Dialogue: 0,0:29:27.32,0:29:31.14,中文,,0,0,0,,这里有一个快速的中场休息 我想 一个小小的热身问题
Dialogue: 0,0:29:31.14,0:29:34.27,英文,,0,0,0,,This was supposed to be the start of the lecture, but now it's halfway through.
Dialogue: 0,0:29:31.14,0:29:34.27,中文,,0,0,0,,这本应该是讲座的开始 但现在已经过了一半了
Dialogue: 0,0:29:34.27,0:29:34.97,英文,,0,0,0,,Oh, well.
Dialogue: 0,0:29:34.97,0:29:39.86,英文,,0,0,0,,Let's do a little warm-up problem, which is I'm going to give you an undirected graph
Dialogue: 0,0:29:34.97,0:29:39.86,中文,,0,0,0,,我们来做一个小小的热身问题 我要给你一个无向图
Dialogue: 0,0:29:39.86,0:29:42.48,英文,,0,0,0,,And I want you to tell me if the graph contains cycles.
Dialogue: 0,0:29:39.86,0:29:42.48,中文,,0,0,0,,然后我想让你告诉我这个图是否包含循环
Dialogue: 0,0:29:42.48,0:29:43.32,英文,,0,0,0,,Do whatever you want.
Dialogue: 0,0:29:42.48,0:29:43.32,中文,,0,0,0,,随便你
Dialogue: 0,0:29:43.32,0:29:45.02,英文,,0,0,0,,Tell me if it contains cycles.
Dialogue: 0,0:29:43.32,0:29:45.02,中文,,0,0,0,,告诉我它是否包含循环
Dialogue: 0,0:29:45.02,0:29:50.23,英文,,0,0,0,,In this case, just staring at it by eye, the answer is yes, there's a cycle because I look.
Dialogue: 0,0:29:45.02,0:29:50.23,中文,,0,0,0,,在这种情况下 仅仅凭眼睛盯着看 答案是肯定的 因为我看到了一个循环
Dialogue: 0,0:29:50.23,0:29:53.99,英文,,0,0,0,,F to E to G to F to E to G cycle.
Dialogue: 0,0:29:50.23,0:29:53.99,中文,,0,0,0,,从 F 到 E 到 G 到 F 到 E 到 G 的循环
Dialogue: 0,0:29:53.99,0:29:55.85,英文,,0,0,0,,So how would you do it?
Dialogue: 0,0:29:53.99,0:29:55.85,中文,,0,0,0,,那你会怎么做呢
Dialogue: 0,0:29:55.85,0:30:02.00,英文,,0,0,0,,Try and think about what algorithms am I even going to say here in 10 seconds.
Dialogue: 0,0:29:55.85,0:30:02.00,中文,,0,0,0,,试着想想 我这里要在十秒钟内说些什么算法
Dialogue: 0,0:30:02.00,0:30:03.06,英文,,0,0,0,,What data structures would you use?
Dialogue: 0,0:30:02.00,0:30:03.06,中文,,0,0,0,,你会用什么数据结构
Dialogue: 0,0:30:03.06,0:30:03.70,英文,,0,0,0,,What algorithms?
Dialogue: 0,0:30:03.06,0:30:03.70,中文,,0,0,0,,什么算法
Dialogue: 0,0:30:03.70,0:30:05.00,英文,,0,0,0,,You can use any of them.
Dialogue: 0,0:30:03.70,0:30:05.00,中文,,0,0,0,,你可以使用任何一个
Dialogue: 0,0:30:05.00,0:30:06.72,英文,,0,0,0,,You don't have to build a full algorithm.
Dialogue: 0,0:30:05.00,0:30:06.72,中文,,0,0,0,,你不必构建完整的算法
Dialogue: 0,0:30:06.72,0:30:08.22,英文,,0,0,0,,Maybe tell me what data structures are good.
Dialogue: 0,0:30:06.72,0:30:08.22,中文,,0,0,0,,也许告诉我哪些数据结构比较好
Dialogue: 0,0:30:08.22,0:30:09.48,英文,,0,0,0,,OK.
Dialogue: 0,0:30:09.48,0:30:11.14,英文,,0,0,0,,Here's a couple I like.
Dialogue: 0,0:30:09.48,0:30:11.14,中文,,0,0,0,,这儿有几个我喜欢的
Dialogue: 0,0:30:11.14,0:30:14.59,英文,,0,0,0,,So one algorithm is inspired by depth-first search.
Dialogue: 0,0:30:11.14,0:30:14.59,中文,,0,0,0,,一个算法是受到深度优先搜索的启发
Dialogue: 0,0:30:14.59,0:30:16.05,英文,,0,0,0,,I will not say it all out loud.
Dialogue: 0,0:30:14.59,0:30:16.05,中文,,0,0,0,,我不会把它全部说出来
Dialogue: 0,0:30:16.05,0:30:22.51,英文,,0,0,0,,But the idea is you run depth-first search, and you might start writing things like A, B, D, G, F, E. Wait a minute.
Dialogue: 0,0:30:16.05,0:30:22.51,中文,,0,0,0,,但是想法是你运行深度优先搜索 你可能会开始写类似 A B D G F E 这样的东西 等一下
Dialogue: 0,0:30:22.51,0:30:24.05,英文,,0,0,0,,I've already seen G before.
Dialogue: 0,0:30:22.51,0:30:24.05,中文,,0,0,0,,我已经看到 G 了
Dialogue: 0,0:30:24.05,0:30:30.14,英文,,0,0,0,,So by running depth-first search and looking for vertices that have already been marked, you can actually find cycles.
Dialogue: 0,0:30:24.05,0:30:30.14,中文,,0,0,0,,通过运行深度优先搜索并寻找已经被标记的顶点 你实际上可以找到循环
Dialogue: 0,0:30:30.14,0:30:40.40,英文,,0,0,0,,So you, for example, explore A, B, D, G, E, D, G, F, E. And then when you look at E's neighbors, you'll be like, well, there's G, but I've already seen you before.
Dialogue: 0,0:30:30.14,0:30:40.40,中文,,0,0,0,,比如说 你探索 A、B、D、G、E、D、G、F、E 然后当你看 E 的邻居时 你会觉得 这里有 G 但我之前已经见过你了
Dialogue: 0,0:30:40.40,0:30:42.53,英文,,0,0,0,,So that's where you find the cycle.
Dialogue: 0,0:30:40.40,0:30:42.53,中文,,0,0,0,,这就是你找到循环的地方
Dialogue: 0,0:30:42.53,0:30:49.21,英文,,0,0,0,,There's a little bit of a fix you have to make just to make it totally work, but a depth-first search-inspired approach will work.
Dialogue: 0,0:30:42.53,0:30:49.21,中文,,0,0,0,,有一个小小的修复 你必须做一下 才能使它完全工作 但是一个深度优先搜索灵感的方法是行得通的
Dialogue: 0,0:30:49.21,0:30:56.62,英文,,0,0,0,,So hopefully it feels convincing that depth-first search-inspired approaches will work, even though you have to be a little bit clever with it to actually implement it.
Dialogue: 0,0:30:49.21,0:30:56.62,中文,,0,0,0,,希望深度优先搜索灵感的方法能够令人信服 即使你必须对其进行一些巧妙的处理才能真正实现它
Dialogue: 0,0:30:56.62,0:30:58.98,英文,,0,0,0,,You can go try it if you're curious.
Dialogue: 0,0:30:56.62,0:30:58.98,中文,,0,0,0,,如果你感兴趣 可以尝试一下
Dialogue: 0,0:30:58.98,0:31:01.28,英文,,0,0,0,,Here's the second approach, which I find is kind of fun.
Dialogue: 0,0:30:58.98,0:31:01.28,中文,,0,0,0,,这是第二种方法 我觉得有点有趣
Dialogue: 0,0:31:01.28,0:31:06.18,英文,,0,0,0,,And so this one actually uses the DisjointSets object from like 25 lectures ago.
Dialogue: 0,0:31:01.28,0:31:06.18,中文,,0,0,0,,这个实际上使用了 25 讲之前的 DisjointSets 对象
Dialogue: 0,0:31:06.18,0:31:07.32,英文,,0,0,0,,Okay, maybe not that many.
Dialogue: 0,0:31:06.18,0:31:07.32,中文,,0,0,0,,好吧 也许没有那么多
Dialogue: 0,0:31:07.32,0:31:10.29,英文,,0,0,0,,But a long time ago, we talked about DisjointSets.
Dialogue: 0,0:31:07.32,0:31:10.29,中文,,0,0,0,,但很久以前 我们谈论过 DisjointSets
Dialogue: 0,0:31:10.29,0:31:18.65,英文,,0,0,0,,And so the idea here is that I'm going to create a DisjointSets with seven Items, A, B, C, D, E, F, G, they're all disconnected.
Dialogue: 0,0:31:10.29,0:31:18.65,中文,,0,0,0,,这里的想法是我将创建一个具有七个项目的 DisjointSets A、B、C、D、E、F、G 它们都是不相连的
Dialogue: 0,0:31:18.65,0:31:22.48,英文,,0,0,0,,And every single time I see an edge between two vertices, I'll connect them.
Dialogue: 0,0:31:18.65,0:31:22.48,中文,,0,0,0,,每当我看到两个顶点之间有一条边 我就把它们连接起来
Dialogue: 0,0:31:22.48,0:31:24.80,英文,,0,0,0,,So initially, they're all disconnected.
Dialogue: 0,0:31:22.48,0:31:24.80,中文,,0,0,0,,初始时 它们都是不相连的
Dialogue: 0,0:31:24.80,0:31:30.12,英文,,0,0,0,,I see A and B. Those get connected together into part of a tree or part of a little family.
Dialogue: 0,0:31:24.80,0:31:30.12,中文,,0,0,0,,我看到 A 和 B 它们被连接成了一个树的一部分或一个小家庭的一部分
Dialogue: 0,0:31:30.12,0:31:33.56,英文,,0,0,0,,Then I see B to D. So now A, B, and D are all connected.
Dialogue: 0,0:31:30.12,0:31:33.56,中文,,0,0,0,,然后我看到B到D 所以现在A、B和D都连接了
Dialogue: 0,0:31:33.56,0:31:36.72,英文,,0,0,0,,Then I see G. So A, B, D, G are all connected.
Dialogue: 0,0:31:33.56,0:31:36.72,中文,,0,0,0,,然后我看到G 所以A、B、D、G都连接了
Dialogue: 0,0:31:36.72,0:31:40.43,英文,,0,0,0,,So every time I see an edge, I will union two vertices.
Dialogue: 0,0:31:36.72,0:31:40.43,中文,,0,0,0,,每次我看到一条边 我就会将两个顶点连接起来
Dialogue: 0,0:31:40.43,0:31:49.21,英文,,0,0,0,,And the idea is that, let's say, I am at the point where G and F and E, because of these two edges, are part of the same family.
Dialogue: 0,0:31:40.43,0:31:49.21,中文,,0,0,0,,而且这个想法是 比如说 我在点G、F和E之间 因为这两条边的缘故 它们都是同一个家庭的一部分
Dialogue: 0,0:31:49.21,0:31:51.75,英文,,0,0,0,,In digital train sets, I put them all part of the same team.
Dialogue: 0,0:31:49.21,0:31:51.75,中文,,0,0,0,,在数字列车集中 我把它们都放在同一个队伍里
Dialogue: 0,0:31:51.75,0:31:54.83,英文,,0,0,0,,So G, F, and E, you're all part of the same team.
Dialogue: 0,0:31:51.75,0:31:54.83,中文,,0,0,0,,所以G、F和E 你们都是同一个团队的一部分
Dialogue: 0,0:31:54.83,0:31:59.75,英文,,0,0,0,,Then I find another edge between two people who are already in the same team.
Dialogue: 0,0:31:54.83,0:31:59.75,中文,,0,0,0,,然后我找到另一条边 连接了已经在同一个团队里的两个人
Dialogue: 0,0:31:59.75,0:32:05.24,英文,,0,0,0,,Well, that means there was already a way to get from G to E, because they were part of the same disjoint set.
Dialogue: 0,0:31:59.75,0:32:05.24,中文,,0,0,0,,这意味着已经有一种方法可以从 G 到达 E 因为它们是同一不相交集合的一部分
Dialogue: 0,0:32:05.24,0:32:12.44,英文,,0,0,0,,Now I found another edge to get between E and G. That tells me there's two ways to get between E and G. So I found the cycle.
Dialogue: 0,0:32:05.24,0:32:12.44,中文,,0,0,0,,现在我找到了另一条边 可以在 E 和 G 之间移动 这告诉我有两种方法可以在 E 和 G 之间移动 所以我找到了循环
Dialogue: 0,0:32:12.44,0:32:14.06,英文,,0,0,0,,So I'm just kind of sketching it out here.
Dialogue: 0,0:32:12.44,0:32:14.06,中文,,0,0,0,,我只是在这里草拟一下
Dialogue: 0,0:32:14.06,0:32:17.58,英文,,0,0,0,,It's OK if you don't totally feel comfortable with it.
Dialogue: 0,0:32:14.06,0:32:17.58,中文,,0,0,0,,如果你对此感觉不太舒服也没关系
Dialogue: 0,0:32:17.58,0:32:24.21,英文,,0,0,0,,But the rough idea is that this is possible by unioning vertices together for every edge.
Dialogue: 0,0:32:17.58,0:32:24.21,中文,,0,0,0,,但大致的想法是通过为每条边将顶点合并在一起 这是可能的
Dialogue: 0,0:32:24.21,0:32:29.51,英文,,0,0,0,,And when you see an edge between two vertices that are already part of the same team, there is your cycle.
Dialogue: 0,0:32:24.21,0:32:29.51,中文,,0,0,0,,当你看到两个已经属于同一团队的顶点之间有一条边时 那就是你的循环
Dialogue: 0,0:32:29.51,0:32:32.43,英文,,0,0,0,,because he found two ways to get between the two vertices.
Dialogue: 0,0:32:29.51,0:32:32.43,中文,,0,0,0,,因为他找到了两种方法可以在这两个顶点之间移动
Dialogue: 0,0:32:32.43,0:32:33.62,英文,,0,0,0,,OK.
Dialogue: 0,0:32:33.62,0:32:34.18,英文,,0,0,0,,Great.
Dialogue: 0,0:32:33.62,0:32:34.18,中文,,0,0,0,,太棒了
Dialogue: 0,0:32:34.18,0:32:36.48,英文,,0,0,0,,If you don't like the runtime, come back a little bit later.
Dialogue: 0,0:32:34.18,0:32:36.48,中文,,0,0,0,,如果你不喜欢运行时 请稍后再回来
Dialogue: 0,0:32:36.48,0:32:38.54,英文,,0,0,0,,I will talk about it in more detail.
Dialogue: 0,0:32:36.48,0:32:38.54,中文,,0,0,0,,我会更详细地谈论它
Dialogue: 0,0:32:38.54,0:32:39.46,英文,,0,0,0,,OK.
Dialogue: 0,0:32:39.46,0:32:41.26,英文,,0,0,0,,That was our warm-up.
Dialogue: 0,0:32:39.46,0:32:41.26,中文,,0,0,0,,那只是我们的热身
Dialogue: 0,0:32:41.26,0:32:43.52,英文,,0,0,0,,It's OK if it didn't totally make sense.
Dialogue: 0,0:32:41.26,0:32:43.52,中文,,0,0,0,,如果你完全不明白也没关系
Dialogue: 0,0:32:43.52,0:32:47.24,英文,,0,0,0,,I just wanted to convince you that there are ways to find a graph of cycles.
Dialogue: 0,0:32:43.52,0:32:47.24,中文,,0,0,0,,我只是想说服你 有办法找到一个环的图
Dialogue: 0,0:32:47.24,0:32:48.62,英文,,0,0,0,,That'll be useful today.
Dialogue: 0,0:32:47.24,0:32:48.62,中文,,0,0,0,,今天会有用的
Dialogue: 0,0:32:48.62,0:32:49.35,英文,,0,0,0,,OK.
Dialogue: 0,0:32:49.35,0:32:49.95,英文,,0,0,0,,So here we go.
Dialogue: 0,0:32:49.35,0:32:49.95,中文,,0,0,0,,那我们开始吧
Dialogue: 0,0:32:49.95,0:32:54.31,英文,,0,0,0,,Let's talk about a new problem that is not short as paths, but it's still pretty fun.
Dialogue: 0,0:32:49.95,0:32:54.31,中文,,0,0,0,,让我们谈谈一个新的问题 不像路径那么简单 但还是挺有趣的
Dialogue: 0,0:32:54.31,0:32:55.41,英文,,0,0,0,,So we're going to do it.
Dialogue: 0,0:32:54.31,0:32:55.41,中文,,0,0,0,,我们要做这个
Dialogue: 0,0:32:55.41,0:32:56.25,英文,,0,0,0,,OK.
Dialogue: 0,0:32:56.25,0:32:59.29,英文,,0,0,0,,So in this problem, I'm going to give you an undirected graph.
Dialogue: 0,0:32:56.25,0:32:59.29,中文,,0,0,0,,在这个问题中 我要给你一个无向图
Dialogue: 0,0:32:59.29,0:33:00.43,英文,,0,0,0,,There's no more arrows.
Dialogue: 0,0:32:59.29,0:33:00.43,中文,,0,0,0,,没有箭头了
Dialogue: 0,0:33:00.43,0:33:04.09,英文,,0,0,0,,The graph is undirected for the rest of today and next time.
Dialogue: 0,0:33:00.43,0:33:04.09,中文,,0,0,0,,这个图在今天和下一次都是无向的
Dialogue: 0,0:33:04.09,0:33:07.64,英文,,0,0,0,,And I would like you to come up with a set of edges.
Dialogue: 0,0:33:04.09,0:33:07.64,中文,,0,0,0,,我希望你能想出一组边
Dialogue: 0,0:33:07.64,0:33:12.22,英文,,0,0,0,,So it's kind of similar to the shortest paths problem in the sense that there are a ton of edges.
Dialogue: 0,0:33:07.64,0:33:12.22,中文,,0,0,0,,这在某种意义上有点像最短路径问题 因为有大量的边
Dialogue: 0,0:33:12.22,0:33:14.86,英文,,0,0,0,,I want you to put some of them in the family and bold them.
Dialogue: 0,0:33:12.22,0:33:14.86,中文,,0,0,0,,我希望你把其中一些放在家庭里并加粗显示
Dialogue: 0,0:33:14.86,0:33:19.87,英文,,0,0,0,,And I want you to exclude some of them by not putting them in the family.
Dialogue: 0,0:33:14.86,0:33:19.87,中文,,0,0,0,,同时我希望你通过不把它们放在家庭里来排除其中一些
Dialogue: 0,0:33:19.87,0:33:21.79,英文,,0,0,0,,So I want you to come up with a set of edges.
Dialogue: 0,0:33:19.87,0:33:21.79,中文,,0,0,0,,我希望你能提出一组边
Dialogue: 0,0:33:21.79,0:33:22.83,英文,,0,0,0,,Tell me which ones you like.
Dialogue: 0,0:33:21.79,0:33:22.83,中文,,0,0,0,,告诉我你喜欢哪些
Dialogue: 0,0:33:22.83,0:33:24.33,英文,,0,0,0,,Tell me which ones you don't.
Dialogue: 0,0:33:22.83,0:33:24.33,中文,,0,0,0,,告诉我你不喜欢哪些
Dialogue: 0,0:33:24.33,0:33:27.71,英文,,0,0,0,,And your set of edges should be connected.
Dialogue: 0,0:33:24.33,0:33:27.71,中文,,0,0,0,,而且你的边集应该是连接的
Dialogue: 0,0:33:27.71,0:33:33.17,英文,,0,0,0,,That is, all the edges are kind of connected in one graph structure.
Dialogue: 0,0:33:27.71,0:33:33.17,中文,,0,0,0,,也就是说 所有的边都应该在一个图结构中连接起来
Dialogue: 0,0:33:33.17,0:33:36.28,英文,,0,0,0,,It should be acyclic, so your edges should not form cycles.
Dialogue: 0,0:33:33.17,0:33:36.28,中文,,0,0,0,,它应该是无环的 所以你的边不能形成循环
Dialogue: 0,0:33:36.28,0:33:40.38,英文,,0,0,0,,In other words, these two properties mean your edges should form a tree.
Dialogue: 0,0:33:36.28,0:33:40.38,中文,,0,0,0,,换句话说 这两个属性意味着你的边应该形成一棵树
Dialogue: 0,0:33:40.38,0:33:45.54,英文,,0,0,0,,And the second property is that your set of edges needs to touch every vertex.
Dialogue: 0,0:33:40.38,0:33:45.54,中文,,0,0,0,,第二个属性是 你的边集需要触及每个顶点
Dialogue: 0,0:33:45.54,0:33:53.01,英文,,0,0,0,,So if you look at this set of edges, every single vertex is touched by at least one of the edges that you chose.
Dialogue: 0,0:33:45.54,0:33:53.01,中文,,0,0,0,,如果你看这组边 每个单独的顶点至少被你选择的其中一条边触及
Dialogue: 0,0:33:53.01,0:33:57.45,英文,,0,0,0,,And if all of these properties are true, you get something called a spanning tree.
Dialogue: 0,0:33:53.01,0:33:57.45,中文,,0,0,0,,如果所有这些属性都成立 你就得到了一个被称为生成树的东西
Dialogue: 0,0:33:57.45,0:34:00.19,英文,,0,0,0,,So these first two properties just mean it's a tree.
Dialogue: 0,0:33:57.45,0:34:00.19,中文,,0,0,0,,这些前两个属性只是意味着它是一棵树
Dialogue: 0,0:34:00.19,0:34:01.55,英文,,0,0,0,,So all of my edges are connected.
Dialogue: 0,0:34:00.19,0:34:01.55,中文,,0,0,0,,我的所有边都是连接的
Dialogue: 0,0:34:01.55,0:34:02.55,英文,,0,0,0,,There's no cycles.
Dialogue: 0,0:34:01.55,0:34:02.55,中文,,0,0,0,,没有环
Dialogue: 0,0:34:02.55,0:34:03.73,英文,,0,0,0,,That makes it a tree.
Dialogue: 0,0:34:02.55,0:34:03.73,中文,,0,0,0,,这使它成为了一棵树
Dialogue: 0,0:34:03.73,0:34:10.45,英文,,0,0,0,,And the second property is I would like every single vertex to be touched at least once by one of the edges.
Dialogue: 0,0:34:03.73,0:34:10.45,中文,,0,0,0,,第二个属性是我希望每个顶点至少被一条边触及一次
Dialogue: 0,0:34:10.45,0:34:12.13,英文,,0,0,0,,And that's what makes it spanning.
Dialogue: 0,0:34:10.45,0:34:12.13,中文,,0,0,0,,这就是它成为跨度的原因
Dialogue: 0,0:34:12.13,0:34:14.79,英文,,0,0,0,,So you might say, well, this seems pretty easy.
Dialogue: 0,0:34:12.13,0:34:14.79,中文,,0,0,0,,你可能会说 这似乎很容易
Dialogue: 0,0:34:14.79,0:34:17.25,英文,,0,0,0,,Why don't I just include every single edge?
Dialogue: 0,0:34:14.79,0:34:17.25,中文,,0,0,0,,为什么我不只是包括每一条边呢
Dialogue: 0,0:34:17.25,0:34:20.65,英文,,0,0,0,,Because if I include every single edge, I should touch every vertex.
Dialogue: 0,0:34:17.25,0:34:20.65,中文,,0,0,0,,因为如果我包括每一条边 我应该触及每个顶点
Dialogue: 0,0:34:20.65,0:34:24.26,英文,,0,0,0,,So here's the trick, the challenge, which is I don't want any spanning tree.
Dialogue: 0,0:34:20.65,0:34:24.26,中文,,0,0,0,,这就是诀窍 挑战在于 我不想要任何生成树
Dialogue: 0,0:34:24.26,0:34:26.52,英文,,0,0,0,,I want the minimum spanning tree.
Dialogue: 0,0:34:24.26,0:34:26.52,中文,,0,0,0,,我想要最小生成树
Dialogue: 0,0:34:26.52,0:34:30.24,英文,,0,0,0,,That is, there are actually lots of answers that will touch every vertex.
Dialogue: 0,0:34:26.52,0:34:30.24,中文,,0,0,0,,也就是说 实际上有很多答案会触及每个顶点
Dialogue: 0,0:34:30.24,0:34:37.98,英文,,0,0,0,,But I want the one where if you add up all the edge weights, 2 plus 2 plus 3 plus 8, if you add up all the weights of the edges,
Dialogue: 0,0:34:30.24,0:34:37.98,中文,,0,0,0,,但我想要的是 如果你把所有边的权重加起来 2+2+3+8 如果你把你选择的所有边的权重加起来
Dialogue: 0,0:34:37.98,0:34:42.00,英文,,0,0,0,,that you chose, I want that sum to be as small as possible.
Dialogue: 0,0:34:37.98,0:34:42.00,中文,,0,0,0,,我希望这个和尽可能小
Dialogue: 0,0:34:42.00,0:34:45.55,英文,,0,0,0,,So I want a spanning tree that has minimum weight.
Dialogue: 0,0:34:42.00,0:34:45.55,中文,,0,0,0,,我想要一个具有最小权重的生成树
Dialogue: 0,0:34:45.55,0:34:51.09,英文,,0,0,0,,And so that means our problem is to look for not just any spanning tree, but the minimum spanning tree.
Dialogue: 0,0:34:45.55,0:34:51.09,中文,,0,0,0,,这意味着我们的问题不仅是要寻找任何生成树 而是要寻找最小生成树
Dialogue: 0,0:34:51.09,0:34:52.43,英文,,0,0,0,,So I want it to be a tree.
Dialogue: 0,0:34:51.09,0:34:52.43,中文,,0,0,0,,我希望它是一棵树
Dialogue: 0,0:34:52.43,0:34:53.53,英文,,0,0,0,,I want it to be spanning.
Dialogue: 0,0:34:52.43,0:34:53.53,中文,,0,0,0,,我希望它是跨越的
Dialogue: 0,0:34:53.53,0:34:55.27,英文,,0,0,0,,I want it to touch all the vertices.
Dialogue: 0,0:34:53.53,0:34:55.27,中文,,0,0,0,,我想让它触及所有的顶点
Dialogue: 0,0:34:55.27,0:34:58.23,英文,,0,0,0,,And I want this resulting tree to have minimum weight.
Dialogue: 0,0:34:55.27,0:34:58.23,中文,,0,0,0,,而且我希望这棵结果树的权重最小
Dialogue: 0,0:34:58.23,0:34:59.65,英文,,0,0,0,,I sum up all these numbers.
Dialogue: 0,0:34:58.23,0:34:59.65,中文,,0,0,0,,我把所有这些数字加起来
Dialogue: 0,0:34:59.65,0:35:01.83,英文,,0,0,0,,I want the smallest sum possible.
Dialogue: 0,0:34:59.65,0:35:01.83,中文,,0,0,0,,我想要可能的最小总和
Dialogue: 0,0:35:01.83,0:35:05.87,英文,,0,0,0,,So are we all good on the problem we're about to attempt?
Dialogue: 0,0:35:01.83,0:35:05.87,中文,,0,0,0,,那么我们对即将尝试的问题都没问题了吗
Dialogue: 0,0:35:05.87,0:35:16.39,英文,,0,0,0,,Yes.
Dialogue: 0,0:35:05.87,0:35:16.39,中文,,0,0,0,,是的
Dialogue: 0,0:35:16.39,0:35:19.49,英文,,0,0,0,,Is it possible for a graph to be spanning but not connected?
Dialogue: 0,0:35:16.39,0:35:19.49,中文,,0,0,0,,图是否可能是跨越的但不连通的
Dialogue: 0,0:35:19.49,0:35:20.30,英文,,0,0,0,,Or the other way around?
Dialogue: 0,0:35:19.49,0:35:20.30,中文,,0,0,0,,还是反过来吗
Dialogue: 0,0:35:20.30,0:35:24.76,英文,,0,0,0,,Maybe I'll show you some examples in two slides, and then we can see.
Dialogue: 0,0:35:20.30,0:35:24.76,中文,,0,0,0,,也许我会在两张幻灯片上给你看一些例子 然后我们可以看一下
Dialogue: 0,0:35:24.76,0:35:27.12,英文,,0,0,0,,OK, here are some examples that might help.
Dialogue: 0,0:35:24.76,0:35:27.12,中文,,0,0,0,,这里有一些可能有所帮助的例子
Dialogue: 0,0:35:27.12,0:35:28.61,英文,,0,0,0,,So here are two spanning trees.
Dialogue: 0,0:35:27.12,0:35:28.61,中文,,0,0,0,,这里有两棵生成树
Dialogue: 0,0:35:28.61,0:35:30.43,英文,,0,0,0,,And if you have something to say, I'll check it out later.
Dialogue: 0,0:35:28.61,0:35:30.43,中文,,0,0,0,,如果你有什么要说的 我稍后会检查一下
Dialogue: 0,0:35:30.43,0:35:41.22,英文,,0,0,0,,OK, so. Here are some spanning trees, and you can convince yourself that they're spanning because every single vertex is touched by a bold edge, and the tree is connected.
Dialogue: 0,0:35:30.43,0:35:41.22,中文,,0,0,0,,这里有一些生成树 你可以自己验证它们是生成的 因为每个顶点都被粗体边触及 并且树是连通的
Dialogue: 0,0:35:41.22,0:35:45.96,英文,,0,0,0,,So if I draw out the graph with only the bold edges, I actually form a tree.
Dialogue: 0,0:35:41.22,0:35:45.96,中文,,0,0,0,,如果我只画出图中的粗体边 我实际上形成了一棵树
Dialogue: 0,0:35:45.96,0:35:48.56,英文,,0,0,0,,In this case, it happens to be a line, but still a tree.
Dialogue: 0,0:35:45.96,0:35:48.56,中文,,0,0,0,,在这种情况下 它碰巧是一条线 但仍然是一棵树
Dialogue: 0,0:35:48.56,0:35:50.18,英文,,0,0,0,,In this case, also a tree.
Dialogue: 0,0:35:48.56,0:35:50.18,中文,,0,0,0,,在这种情况下 也是一棵树
Dialogue: 0,0:35:50.18,0:35:51.44,英文,,0,0,0,,There are no cycles.
Dialogue: 0,0:35:50.18,0:35:51.44,中文,,0,0,0,,没有循环
Dialogue: 0,0:35:51.44,0:35:53.50,英文,,0,0,0,,Everybody's connected.
Dialogue: 0,0:35:51.44,0:35:53.50,中文,,0,0,0,,每个人都连接在一起
Dialogue: 0,0:35:53.50,0:36:00.41,英文,,0,0,0,,So here are some possible spanning trees, and I want you to tell me if they are spanning trees or not.
Dialogue: 0,0:35:53.50,0:36:00.41,中文,,0,0,0,,这里是一些可能的生成树 请告诉我它们是否是生成树
Dialogue: 0,0:36:00.41,0:36:03.27,英文,,0,0,0,,OK, so maybe this is where your question gets answered.
Dialogue: 0,0:36:00.41,0:36:03.27,中文,,0,0,0,,也许这就是你的问题得到解答的地方
Dialogue: 0,0:36:03.27,0:36:06.49,英文,,0,0,0,,So is A a spanning tree?
Dialogue: 0,0:36:03.27,0:36:06.49,中文,,0,0,0,,A 是一棵生成树吗
Dialogue: 0,0:36:06.49,0:36:07.71,英文,,0,0,0,,Who thinks it is?
Dialogue: 0,0:36:06.49,0:36:07.71,中文,,0,0,0,,谁觉得是
Dialogue: 0,0:36:07.71,0:36:08.87,英文,,0,0,0,,I don't think it's not.
Dialogue: 0,0:36:07.71,0:36:08.87,中文,,0,0,0,,我觉得不是
Dialogue: 0,0:36:08.87,0:36:11.15,英文,,0,0,0,,I don't think it is, because it's not connected.
Dialogue: 0,0:36:08.87,0:36:11.15,中文,,0,0,0,,我觉得不是 因为它没有连接起来
Dialogue: 0,0:36:11.15,0:36:16.35,英文,,0,0,0,,So see how, if I look at this graph, it's got two disjoint sections.
Dialogue: 0,0:36:11.15,0:36:16.35,中文,,0,0,0,,看 如果我看这个图 它有两个不相交的部分
Dialogue: 0,0:36:16.35,0:36:18.41,英文,,0,0,0,,It's got these four vertices and then these three.
Dialogue: 0,0:36:16.35,0:36:18.41,中文,,0,0,0,,它有这四个顶点然后这三个
Dialogue: 0,0:36:18.41,0:36:21.01,英文,,0,0,0,,There's no connection between them.
Dialogue: 0,0:36:18.41,0:36:21.01,中文,,0,0,0,,它们之间没有连接
Dialogue: 0,0:36:21.01,0:36:24.41,英文,,0,0,0,,Is it a spanning graph?
Dialogue: 0,0:36:21.01,0:36:24.41,中文,,0,0,0,,这是一个跨度图吗
Dialogue: 0,0:36:24.41,0:36:28.31,英文,,0,0,0,,It is a spanning set of edges, according to Justin.
Dialogue: 0,0:36:24.41,0:36:28.31,中文,,0,0,0,,根据贾斯汀的说法 这是一组跨度边
Dialogue: 0,0:36:28.31,0:36:32.84,英文,,0,0,0,,It's called a spanning forest because there's a lot of trees.
Dialogue: 0,0:36:28.31,0:36:32.84,中文,,0,0,0,,这被称为跨度森林 因为有很多树
Dialogue: 0,0:36:32.84,0:36:33.28,英文,,0,0,0,,Awesome.
Dialogue: 0,0:36:32.84,0:36:33.28,中文,,0,0,0,,太棒了
Dialogue: 0,0:36:33.28,0:36:33.94,英文,,0,0,0,,OK.
Dialogue: 0,0:36:33.94,0:36:34.18,英文,,0,0,0,,OK.
Dialogue: 0,0:36:34.18,0:36:39.56,英文,,0,0,0,,But the thing you have to know, basically, is that this is not a spanning tree because the resulting structure is not a tree.
Dialogue: 0,0:36:34.18,0:36:39.56,中文,,0,0,0,,但你基本上要知道的是 这不是一棵跨度树 因为结果结构不是一棵树
Dialogue: 0,0:36:39.56,0:36:42.26,英文,,0,0,0,,It's got two separate sections.
Dialogue: 0,0:36:39.56,0:36:42.26,中文,,0,0,0,,它有两个独立的部分
Dialogue: 0,0:36:42.26,0:36:42.96,英文,,0,0,0,,OK.
Dialogue: 0,0:36:42.96,0:36:44.02,英文,,0,0,0,,What about B?
Dialogue: 0,0:36:42.96,0:36:44.02,中文,,0,0,0,,B呢
Dialogue: 0,0:36:44.02,0:36:46.21,英文,,0,0,0,,Is it a spanning tree?
Dialogue: 0,0:36:44.02,0:36:46.21,中文,,0,0,0,,这是一个生成树吗
Dialogue: 0,0:36:46.21,0:36:47.25,英文,,0,0,0,,Any takers?
Dialogue: 0,0:36:46.21,0:36:47.25,中文,,0,0,0,,有人愿意吗
Dialogue: 0,0:36:47.25,0:36:50.21,英文,,0,0,0,,Anyone not like it?
Dialogue: 0,0:36:47.25,0:36:50.21,中文,,0,0,0,,有人不喜欢吗
Dialogue: 0,0:36:50.21,0:36:53.87,英文,,0,0,0,,Well, I don't like it because here to here to here to here, cycle.
Dialogue: 0,0:36:50.21,0:36:53.87,中文,,0,0,0,,我不喜欢 因为这里到这里到这里到这里 循环
Dialogue: 0,0:36:53.87,0:36:55.77,英文,,0,0,0,,And remember, trees can't have cycles.
Dialogue: 0,0:36:53.87,0:36:55.77,中文,,0,0,0,,记住 树不能有循环
Dialogue: 0,0:36:55.77,0:36:57.84,英文,,0,0,0,,However, C is good.
Dialogue: 0,0:36:55.77,0:36:57.84,中文,,0,0,0,,不过 C 很好
Dialogue: 0,0:36:57.84,0:36:59.44,英文,,0,0,0,,This is actually a spanning tree.
Dialogue: 0,0:36:57.84,0:36:59.44,中文,,0,0,0,,这实际上是一棵生成树
Dialogue: 0,0:36:59.44,0:37:00.78,英文,,0,0,0,,It touches all the vertices.
Dialogue: 0,0:36:59.44,0:37:00.78,中文,,0,0,0,,它触及所有顶点
Dialogue: 0,0:37:00.78,0:37:01.92,英文,,0,0,0,,There are no cycles.
Dialogue: 0,0:37:00.78,0:37:01.92,中文,,0,0,0,,没有循环
Dialogue: 0,0:37:01.92,0:37:03.82,英文,,0,0,0,,And it's one big connected piece.
Dialogue: 0,0:37:01.92,0:37:03.82,中文,,0,0,0,,而且它是一个大的连通块
Dialogue: 0,0:37:03.82,0:37:06.75,英文,,0,0,0,,So I like C. I don't like A and B.
Dialogue: 0,0:37:03.82,0:37:06.75,中文,,0,0,0,,我喜欢C 我不喜欢A和B
Dialogue: 0,0:37:06.75,0:37:08.43,英文,,0,0,0,,if I'm looking for spanning trees.
Dialogue: 0,0:37:06.75,0:37:08.43,中文,,0,0,0,,如果我在寻找生成树
Dialogue: 0,0:37:08.43,0:37:09.89,英文,,0,0,0,,OK, here are some applications.
Dialogue: 0,0:37:08.43,0:37:09.89,中文,,0,0,0,,这里有一些应用
Dialogue: 0,0:37:09.89,0:37:13.32,英文,,0,0,0,,You can check them out if you're curious, but I won't talk about them.
Dialogue: 0,0:37:09.89,0:37:13.32,中文,,0,0,0,,如果你感兴趣 你可以查看它们 但我不会讨论它们
Dialogue: 0,0:37:13.32,0:37:17.92,英文,,0,0,0,,OK, so how do you actually solve the spanning tree problem?
Dialogue: 0,0:37:13.32,0:37:17.92,中文,,0,0,0,,那么你到底是如何解决生成树问题的
Dialogue: 0,0:37:17.92,0:37:19.28,英文,,0,0,0,,Seems like a weird thing to solve.
Dialogue: 0,0:37:17.92,0:37:19.28,中文,,0,0,0,,解决这个问题似乎有点奇怪
Dialogue: 0,0:37:19.28,0:37:23.42,英文,,0,0,0,,So to solve it, I'm going to introduce a property that I find pretty extraordinary.
Dialogue: 0,0:37:19.28,0:37:23.42,中文,,0,0,0,,为了解决它 我将介绍一个我认为非常特别的属性
Dialogue: 0,0:37:23.42,0:37:25.00,英文,,0,0,0,,So maybe you will, too.
Dialogue: 0,0:37:23.42,0:37:25.00,中文,,0,0,0,,也许你也会觉得特别
Dialogue: 0,0:37:25.00,0:37:29.76,英文,,0,0,0,,So this property is called the cut property, and it basically says,
Dialogue: 0,0:37:25.00,0:37:29.76,中文,,0,0,0,,这个属性被称为割边属性 它基本上是这样说的
Dialogue: 0,0:37:29.76,0:37:35.75,英文,,0,0,0,,Let's say I take all of my vertices and I assign them to two distinct teams.
Dialogue: 0,0:37:29.76,0:37:35.75,中文,,0,0,0,,假设我把所有的顶点分配到两个不同的队伍
Dialogue: 0,0:37:35.75,0:37:39.47,英文,,0,0,0,,So you can either be part of the gray team or the white team.
Dialogue: 0,0:37:35.75,0:37:39.47,中文,,0,0,0,,你可以成为灰队或者白队的一员
Dialogue: 0,0:37:39.47,0:37:47.25,英文,,0,0,0,,So in this case, I said these five vertices are part of the gray team, and these three are part of the white team.
Dialogue: 0,0:37:39.47,0:37:47.25,中文,,0,0,0,,在这种情况下 我说这五个顶点是灰队的一部分 这三个是白队的一部分
Dialogue: 0,0:37:47.25,0:37:49.89,英文,,0,0,0,,And I did this completely arbitrarily.
Dialogue: 0,0:37:47.25,0:37:49.89,中文,,0,0,0,,而我完全是任意地这么做的
Dialogue: 0,0:37:49.89,0:37:52.25,英文,,0,0,0,,There was no reason to choose these being gray, these being white.
Dialogue: 0,0:37:49.89,0:37:52.25,中文,,0,0,0,,选择这些顶点为灰色、这些顶点为白色是没有任何理由的
Dialogue: 0,0:37:52.25,0:37:54.01,英文,,0,0,0,,You could have chosen something else.
Dialogue: 0,0:37:52.25,0:37:54.01,中文,,0,0,0,,你本来可以选择其他的东西
Dialogue: 0,0:37:54.01,0:38:08.60,英文,,0,0,0,,However, If I separate the vertices into two teams and then I consider all of the edges that have one foot connected to a gray vertex and one foot connected to a white vertex, so to speak.
Dialogue: 0,0:37:54.01,0:38:08.60,中文,,0,0,0,,然而  如果我把顶点分成两组 然后考虑所有一端连接到灰色顶点 另一端连接到白色顶点的边 这样说来
Dialogue: 0,0:38:08.60,0:38:11.30,英文,,0,0,0,,So an edge connects a gray vertex to a white vertex.
Dialogue: 0,0:38:08.60,0:38:11.30,中文,,0,0,0,,一条边连接着一个灰色顶点和一个白色顶点
Dialogue: 0,0:38:11.30,0:38:14.22,英文,,0,0,0,,It crosses the two teams.
Dialogue: 0,0:38:11.30,0:38:14.22,中文,,0,0,0,,它穿过了这两组
Dialogue: 0,0:38:14.22,0:38:24.07,英文,,0,0,0,,Of all of these edges, one, two, three, four, five, six of them in this graph, there are six edges that cross the cut, that is, they connect a gray vertex to a white vertex.
Dialogue: 0,0:38:14.22,0:38:24.07,中文,,0,0,0,,在所有这些边中 这个图中有六条边 有六条边穿过了这个割 也就是说 它们连接着一个灰色顶点和一个白色顶点
Dialogue: 0,0:38:24.07,0:38:31.60,英文,,0,0,0,,Of these six edges, the one with the minimum weight edge is guaranteed to be in the minimum spanning tree.
Dialogue: 0,0:38:24.07,0:38:31.60,中文,,0,0,0,,在这六条边中 最小权重的边被保证在最小生成树中
Dialogue: 0,0:38:31.60,0:38:39.27,英文,,0,0,0,,Even though I don't know what the minimum spanning tree is, I can already tell you that this edge is a part of it, which is pretty cool.
Dialogue: 0,0:38:31.60,0:38:39.27,中文,,0,0,0,,即使我不知道最小生成树是什么 我已经可以告诉你这条边是它的一部分了 这相当酷
Dialogue: 0,0:38:39.27,0:38:49.07,英文,,0,0,0,,I chose these gray and white vertices completely at random, and still I was able to successfully find a crossing edge that is in the MSD guaranteed.
Dialogue: 0,0:38:39.27,0:38:49.07,中文,,0,0,0,,我完全随机选择了这些灰色和白色的顶点 但我仍然成功地找到了一个在MST中保证的交叉边
Dialogue: 0,0:38:49.07,0:38:50.54,英文,,0,0,0,,Pretty cool.
Dialogue: 0,0:38:49.07,0:38:50.54,中文,,0,0,0,,挺酷的
Dialogue: 0,0:38:50.54,0:38:52.04,英文,,0,0,0,,So that's the cut property.
Dialogue: 0,0:38:50.54,0:38:52.04,中文,,0,0,0,,这就是切割性质
Dialogue: 0,0:38:52.04,0:38:54.42,英文,,0,0,0,,And here's another example to see if it makes sense.
Dialogue: 0,0:38:52.04,0:38:54.42,中文,,0,0,0,,这里有另一个例子 看看是否有意义
Dialogue: 0,0:38:54.42,0:38:58.58,英文,,0,0,0,,So I want you to tell me, this is another cut that I invented totally at random.
Dialogue: 0,0:38:54.42,0:38:58.58,中文,,0,0,0,,我想让你告诉我 这是我完全随机发明的另一个切割
Dialogue: 0,0:38:58.58,0:39:02.31,英文,,0,0,0,,I said, these four nodes are purple, and these four nodes are white.
Dialogue: 0,0:38:58.58,0:39:02.31,中文,,0,0,0,,我说 这四个节点是紫色的 这四个节点是白色的
Dialogue: 0,0:39:02.31,0:39:03.97,英文,,0,0,0,,You could have chosen whatever cut you want.
Dialogue: 0,0:39:02.31,0:39:03.97,中文,,0,0,0,,你可以选择任何你想要的切割
Dialogue: 0,0:39:03.97,0:39:05.53,英文,,0,0,0,,You could have been like, oh, you're purple.
Dialogue: 0,0:39:03.97,0:39:05.53,中文,,0,0,0,,你本来可以说 噢 你是紫色的
Dialogue: 0,0:39:05.53,0:39:06.61,英文,,0,0,0,,Everyone else is white.
Dialogue: 0,0:39:05.53,0:39:06.61,中文,,0,0,0,,其他人都是白色的
Dialogue: 0,0:39:06.61,0:39:08.47,英文,,0,0,0,,You could have been like, five and seven are purple.
Dialogue: 0,0:39:06.61,0:39:08.47,中文,,0,0,0,,你本来可以说 5和7是紫色的
Dialogue: 0,0:39:08.47,0:39:09.23,英文,,0,0,0,,Everyone else is white.
Dialogue: 0,0:39:08.47,0:39:09.23,中文,,0,0,0,,其他人都是白色的
Dialogue: 0,0:39:09.23,0:39:11.20,英文,,0,0,0,,You could have done whatever you wanted.
Dialogue: 0,0:39:09.23,0:39:11.20,中文,,0,0,0,,你本来可以做任何你想做的事情
Dialogue: 0,0:39:11.20,0:39:16.70,英文,,0,0,0,,I chose to do this, and I want you to tell me, what is the minimum weight edge crossing the cut?
Dialogue: 0,0:39:11.20,0:39:16.70,中文,,0,0,0,,我选择了这样做 我想让你告诉我 穿过切割的最小权重边是多少
Dialogue: 0,0:39:16.70,0:39:25.97,英文,,0,0,0,,I want an edge that has one foot touching a white vertex, one foot touching a purple vertex, and I want the edge out of all of those with the minimum weight.
Dialogue: 0,0:39:16.70,0:39:25.97,中文,,0,0,0,,我想要一条边 其中一端与白色顶点接触 另一端与紫色顶点接触 而且我要从所有这些边中找出权重最小的那一条
Dialogue: 0,0:39:25.97,0:39:34.90,英文,,0,0,0,,Because if I find it, I found an edge that is guaranteed to be in the minimum spanning tree, even though I don't know what the minimum spanning tree is.
Dialogue: 0,0:39:25.97,0:39:34.90,中文,,0,0,0,,因为如果我找到它 那就意味着我找到了一条肯定在最小生成树中的边 尽管我不知道最小生成树是什么
Dialogue: 0,0:39:34.90,0:39:36.36,英文,,0,0,0,,So you can try it out.
Dialogue: 0,0:39:34.90,0:39:36.36,中文,,0,0,0,,你可以试一下
Dialogue: 0,0:39:36.36,0:39:38.06,英文,,0,0,0,,Here are all the edge weights, by the way.
Dialogue: 0,0:39:36.36,0:39:38.06,中文,,0,0,0,,顺便说一句 这里是所有的边权重
Dialogue: 0,0:39:38.06,0:39:39.88,英文,,0,0,0,,So I can go through and start checking.
Dialogue: 0,0:39:38.06,0:39:39.88,中文,,0,0,0,,我可以开始逐个检查了
Dialogue: 0,0:39:39.88,0:39:47.14,英文,,0,0,0,,OK, 0 to 7, could that be the edge I'm looking for that crosses the cut?
Dialogue: 0,0:39:39.88,0:39:47.14,中文,,0,0,0,,从0到7 这可能是我要找的横跨切割的边吗
Dialogue: 0,0:39:47.14,0:39:49.36,英文,,0,0,0,,No, because this doesn't cross the cut at all.
Dialogue: 0,0:39:47.14,0:39:49.36,中文,,0,0,0,,不是 因为这根本没有横跨切割
Dialogue: 0,0:39:49.36,0:39:53.05,英文,,0,0,0,,It's touching two vertices, and they're both white.
Dialogue: 0,0:39:49.36,0:39:53.05,中文,,0,0,0,,它接触到两个顶点 它们都是白色的
Dialogue: 0,0:39:53.05,0:39:54.63,英文,,0,0,0,,So you're not crossing the cut.
Dialogue: 0,0:39:53.05,0:39:54.63,中文,,0,0,0,,你没有跨过那条线
Dialogue: 0,0:39:54.63,0:39:57.03,英文,,0,0,0,,You're connecting two people in the same team.
Dialogue: 0,0:39:54.63,0:39:57.03,中文,,0,0,0,,你是在同一个团队里连接两个人
Dialogue: 0,0:39:57.03,0:39:57.61,英文,,0,0,0,,So you don't count.
Dialogue: 0,0:39:57.03,0:39:57.61,中文,,0,0,0,,你不算数
Dialogue: 0,0:39:57.61,0:39:59.86,英文,,0,0,0,,2 to 3, same problem.
Dialogue: 0,0:39:57.61,0:39:59.86,中文,,0,0,0,,2对3 同样的问题
Dialogue: 0,0:39:59.86,0:40:01.68,英文,,0,0,0,,You're connecting two people in the same group.
Dialogue: 0,0:39:59.86,0:40:01.68,中文,,0,0,0,,你是在同一个组里连接两个人
Dialogue: 0,0:40:01.68,0:40:03.10,英文,,0,0,0,,You don't count.
Dialogue: 0,0:40:01.68,0:40:03.10,中文,,0,0,0,,你不算数
Dialogue: 0,0:40:03.10,0:40:05.60,英文,,0,0,0,,1 to 7, same problem.
Dialogue: 0,0:40:03.10,0:40:05.60,中文,,0,0,0,,1对7 同样的问题
Dialogue: 0,0:40:05.60,0:40:07.54,英文,,0,0,0,,You're not crossing the cut.
Dialogue: 0,0:40:05.60,0:40:07.54,中文,,0,0,0,,你没越过切割线
Dialogue: 0,0:40:07.54,0:40:08.64,英文,,0,0,0,,0 to 2.
Dialogue: 0,0:40:07.54,0:40:08.64,中文,,0,0,0,,0 到 2
Dialogue: 0,0:40:08.64,0:40:10.15,英文,,0,0,0,,This is crossing the cut.
Dialogue: 0,0:40:08.64,0:40:10.15,中文,,0,0,0,,这是越过切割线
Dialogue: 0,0:40:10.15,0:40:13.29,英文,,0,0,0,,And it's got the minimum weight of all the edges crossing the cut.
Dialogue: 0,0:40:10.15,0:40:13.29,中文,,0,0,0,,而且它是所有越过切割线的边中最小权重的
Dialogue: 0,0:40:13.29,0:40:19.51,英文,,0,0,0,,So if I choose 0 to 2, this edge, this is actually guaranteed to be part of the minimum spanning tree.
Dialogue: 0,0:40:13.29,0:40:19.51,中文,,0,0,0,,如果我选择 0 到 2 这条边 它实际上肯定是最小生成树的一部分
Dialogue: 0,0:40:19.51,0:40:23.78,英文,,0,0,0,,Even though I don't know what the minimum spanning tree is, I already found an edge in it.
Dialogue: 0,0:40:19.51,0:40:23.78,中文,,0,0,0,,即使我不知道最小生成树是什么 我已经找到了其中的一条边
Dialogue: 0,0:40:23.78,0:40:25.30,英文,,0,0,0,,I find that pretty cool.
Dialogue: 0,0:40:23.78,0:40:25.30,中文,,0,0,0,,我觉得这很酷
Dialogue: 0,0:40:25.30,0:40:26.94,英文,,0,0,0,,That's the cut property.
Dialogue: 0,0:40:25.30,0:40:26.94,中文,,0,0,0,,这就是切割属性
Dialogue: 0,0:40:26.94,0:40:27.88,英文,,0,0,0,,OK.
Dialogue: 0,0:40:27.88,0:40:29.74,英文,,0,0,0,,Thoughts on it?
Dialogue: 0,0:40:27.88,0:40:29.74,中文,,0,0,0,,你有什么想法吗
Dialogue: 0,0:40:29.74,0:40:34.57,英文,,0,0,0,,It's pretty mind-bending that even though I don't know what the tree is, I can tell you this edge is part of it.
Dialogue: 0,0:40:29.74,0:40:34.57,中文,,0,0,0,,相当让人费解的是 即使我不知道这棵树是什么 我也能告诉你这条边是它的一部分
Dialogue: 0,0:40:34.57,0:40:38.23,英文,,0,0,0,,Okay, here's a really quick proof sketch for why the cut property works.
Dialogue: 0,0:40:34.57,0:40:38.23,中文,,0,0,0,,这里是切割属性有效的一个非常快速的证明草图
Dialogue: 0,0:40:38.23,0:40:42.75,英文,,0,0,0,,This is the kind of thing you'll do in CS70, by the way, so if this seems really interesting, check that out.
Dialogue: 0,0:40:38.23,0:40:42.75,中文,,0,0,0,,顺便说一句 这是你在CS70中会做的事情 所以如果这看起来很有趣 可以去看看
Dialogue: 0,0:40:42.75,0:40:44.40,英文,,0,0,0,,But here's the proof.
Dialogue: 0,0:40:42.75,0:40:44.40,中文,,0,0,0,,但这是证明的关键
Dialogue: 0,0:40:44.40,0:40:52.10,英文,,0,0,0,,It's a proof by contradiction, so basically the idea is I'm going to assume the cut property is false and then argue my way to something that's completely absurd.
Dialogue: 0,0:40:44.40,0:40:52.10,中文,,0,0,0,,这是通过反证法证明 基本上想法是我会假设割边性质是错误的 然后以一种完全荒谬的方式来论证
Dialogue: 0,0:40:52.10,0:40:53.22,英文,,0,0,0,,So here I go.
Dialogue: 0,0:40:52.10,0:40:53.22,中文,,0,0,0,,我开始了
Dialogue: 0,0:40:53.22,0:40:55.37,英文,,0,0,0,,I'm going to assume the cut property is false.
Dialogue: 0,0:40:53.22,0:40:55.37,中文,,0,0,0,,我要假设割边性质是错误的
Dialogue: 0,0:40:55.37,0:41:02.33,英文,,0,0,0,,That is, this edge that I just found, the one that's crossing the cut of minimum weight, is not in the minimum spanning tree.
Dialogue: 0,0:40:55.37,0:41:02.33,中文,,0,0,0,,也就是说 我刚刚找到的这条边 即穿过最小权重割的边 不在最小生成树中
Dialogue: 0,0:41:02.33,0:41:06.25,英文,,0,0,0,,So for the sake of argument, I'm going to say the cut property is false.
Dialogue: 0,0:41:02.33,0:41:06.25,中文,,0,0,0,,为了论证 我会说割边性质是错误的
Dialogue: 0,0:41:06.25,0:41:09.34,英文,,0,0,0,,Then I'm going to reason my way to something that's going to seem really stupid.
Dialogue: 0,0:41:06.25,0:41:09.34,中文,,0,0,0,,然后我会推理出一些看起来非常愚蠢的东西
Dialogue: 0,0:41:09.34,0:41:14.44,英文,,0,0,0,,And that's going to tell me that my assumption at the beginning, that the cut property is false, was completely bogus.
Dialogue: 0,0:41:09.34,0:41:14.44,中文,,0,0,0,,这将告诉我 我在开始时假设割边性质是错误的这个假设完全是错误的
Dialogue: 0,0:41:14.44,0:41:16.66,英文,,0,0,0,,The cut property is indeed true.
Dialogue: 0,0:41:14.44,0:41:16.66,中文,,0,0,0,,切割属性确实成立
Dialogue: 0,0:41:16.66,0:41:18.28,英文,,0,0,0,,So let's say the cut property is false.
Dialogue: 0,0:41:16.66,0:41:18.28,中文,,0,0,0,,那么我们假设切割属性为假
Dialogue: 0,0:41:18.28,0:41:22.40,英文,,0,0,0,,That means E is not in the minimum spanning tree.
Dialogue: 0,0:41:18.28,0:41:22.40,中文,,0,0,0,,这意味着E不在最小生成树中
Dialogue: 0,0:41:22.40,0:41:28.04,英文,,0,0,0,,OK, that means there's another minimum spanning tree out there somewhere, and it's got another edge that crosses the cut.
Dialogue: 0,0:41:22.40,0:41:28.04,中文,,0,0,0,,这意味着还有另一棵最小生成树存在 并且它有另一条跨越切割的边
Dialogue: 0,0:41:28.04,0:41:39.96,英文,,0,0,0,,Because these two cuts have to be connected somehow, so there must be some other edge crossing the cut that has more weight that connects these two halves of the graph.
Dialogue: 0,0:41:28.04,0:41:39.96,中文,,0,0,0,,因为这两个切割必须以某种方式相连 必须有某条其他的边穿过切割 它的权重更大 连接图的这两个半部分
Dialogue: 0,0:41:39.96,0:41:42.58,英文,,0,0,0,,I'll label that f, just so I give it a name.
Dialogue: 0,0:41:39.96,0:41:42.58,中文,,0,0,0,,我会将其标记为f 只是为了给它一个名字
Dialogue: 0,0:41:42.58,0:41:46.60,英文,,0,0,0,,So this is the edge that crosses the cut that's in my minimum spanning tree.
Dialogue: 0,0:41:42.58,0:41:46.60,中文,,0,0,0,,这就是穿过切割的边 它在我的最小生成树中
Dialogue: 0,0:41:46.60,0:41:51.40,英文,,0,0,0,,However, if I delete f and I add e back, don't I get a better tree?
Dialogue: 0,0:41:46.60,0:41:51.40,中文,,0,0,0,,然而 如果我删除 f 并且添加 e 回来 难道我不会得到一棵更好的树吗
Dialogue: 0,0:41:51.40,0:41:55.28,英文,,0,0,0,,Because I said e is the smallest weight crossing the cut.
Dialogue: 0,0:41:51.40,0:41:55.28,中文,,0,0,0,,因为我说 e 是跨越割的最小权重
Dialogue: 0,0:41:55.28,0:41:58.04,英文,,0,0,0,,And I also said f is part of the minimum spanning tree.
Dialogue: 0,0:41:55.28,0:41:58.04,中文,,0,0,0,,而且我也说 f 是最小生成树的一部分
Dialogue: 0,0:41:58.04,0:42:04.11,英文,,0,0,0,,But if I take f out of the minimum spanning tree and I replace it with e, I get a better minimum spanning tree.
Dialogue: 0,0:41:58.04,0:42:04.11,中文,,0,0,0,,但是如果我把 f 从最小生成树中拿出来 然后用 e 替换它 我会得到一棵更好的最小生成树
Dialogue: 0,0:42:04.11,0:42:10.67,英文,,0,0,0,,So how could f possibly be in the minimum spanning tree if I found a better tree by using e instead?
Dialogue: 0,0:42:04.11,0:42:10.67,中文,,0,0,0,,那么如果我用 e 而不是 f 找到了一棵更好的树 f 怎么可能在最小生成树中呢
Dialogue: 0,0:42:10.67,0:42:13.39,英文,,0,0,0,,This sounds really absurd, because it is.
Dialogue: 0,0:42:10.67,0:42:13.39,中文,,0,0,0,,这听起来真的很荒谬 因为它就是
Dialogue: 0,0:42:13.39,0:42:15.01,英文,,0,0,0,,It's a contradiction.
Dialogue: 0,0:42:13.39,0:42:15.01,中文,,0,0,0,,这是个矛盾
Dialogue: 0,0:42:15.01,0:42:18.11,英文,,0,0,0,,And that tells me that my assumption at the beginning was wrong all along.
Dialogue: 0,0:42:15.01,0:42:18.11,中文,,0,0,0,,这说明一开始我的假设就是错的
Dialogue: 0,0:42:18.11,0:42:20.59,英文,,0,0,0,,The cup property is indeed true.
Dialogue: 0,0:42:18.11,0:42:20.59,中文,,0,0,0,,杯子属性确实为真
Dialogue: 0,0:42:20.59,0:42:25.95,英文,,0,0,0,,Because if I assume it's false, I get some total gibberish, like, this is the MST, but here's a better one.
Dialogue: 0,0:42:20.59,0:42:25.95,中文,,0,0,0,,因为如果我假设它是假的 我就会得到一些完全的胡言乱语 就像这是MST 但这里有一个更好的
Dialogue: 0,0:42:25.95,0:42:26.51,英文,,0,0,0,,What?
Dialogue: 0,0:42:25.95,0:42:26.51,中文,,0,0,0,,什么
Dialogue: 0,0:42:26.51,0:42:28.07,英文,,0,0,0,,How could there be a better one?
Dialogue: 0,0:42:26.51,0:42:28.07,中文,,0,0,0,,怎么可能有更好的
Dialogue: 0,0:42:28.07,0:42:30.03,英文,,0,0,0,,So that's the proof sketch.
Dialogue: 0,0:42:28.07,0:42:30.03,中文,,0,0,0,,这就是证明的草图
Dialogue: 0,0:42:30.03,0:42:36.11,英文,,0,0,0,,It's kind of a cute question.
Dialogue: 0,0:42:30.03,0:42:36.11,中文,,0,0,0,,这是一个挺有意思的问题
Dialogue: 0,0:42:36.11,0:42:38.60,英文,,0,0,0,,Two slides ago.
Dialogue: 0,0:42:36.11,0:42:38.60,中文,,0,0,0,,两张幻灯片前
Dialogue: 0,0:42:38.60,0:42:39.48,英文,,0,0,0,,Yeah, that's a great question.
Dialogue: 0,0:42:38.60,0:42:39.48,中文,,0,0,0,,是的 这是一个很好的问题
Dialogue: 0,0:42:39.48,0:42:42.66,英文,,0,0,0,,I was going to call it out in a couple of slides, but I'll call it out now, I guess.
Dialogue: 0,0:42:39.48,0:42:42.66,中文,,0,0,0,,我本来打算在几张幻灯片后再提到这一点 但我想现在就提一下吧
Dialogue: 0,0:42:42.66,0:42:48.46,英文,,0,0,0,,If two edges are tied, you can choose either of them to be part of the minimum spanning tree, and it will work.
Dialogue: 0,0:42:42.66,0:42:48.46,中文,,0,0,0,,如果两条边相等 你可以选择其中任意一条作为最小生成树的一部分 它将起作用
Dialogue: 0,0:42:48.46,0:42:54.56,英文,,0,0,0,,You can't necessarily add both, but you can arbitrarily choose one, and you'll get an edge that's part of the minimum spanning tree.
Dialogue: 0,0:42:48.46,0:42:54.56,中文,,0,0,0,,你不一定可以添加两个 但你可以任意选择一个 然后你将获得一条作为最小生成树一部分的边
Dialogue: 0,0:42:54.56,0:43:02.62,英文,,0,0,0,,In general, if your edges are not unique, there could be multiple answers, like multiple minimum spanning trees, but something we'll probably dive into more a bit later.
Dialogue: 0,0:42:54.56,0:43:02.62,中文,,0,0,0,,一般来说 如果你的边不是唯一的 可能会有多个答案 比如多个最小生成树 但我们可能稍后会更深入地讨论这个问题
Dialogue: 0,0:43:02.62,0:43:06.00,英文,,0,0,0,,That's a great question, though.
Dialogue: 0,0:43:02.62,0:43:06.00,中文,,0,0,0,,不过 这是一个很好的问题
Dialogue: 0,0:43:06.00,0:43:08.87,英文,,0,0,0,,Each minimum edge will be part of at least one minimum planning tree.
Dialogue: 0,0:43:06.00,0:43:08.87,中文,,0,0,0,,每个最小的边都将成为至少一个最小生成树的一部分
Dialogue: 0,0:43:08.87,0:43:09.81,英文,,0,0,0,,Interesting.
Dialogue: 0,0:43:08.87,0:43:09.81,中文,,0,0,0,,有趣
Dialogue: 0,0:43:09.81,0:43:10.41,英文,,0,0,0,,Okay.
Dialogue: 0,0:43:10.41,0:43:11.71,英文,,0,0,0,,That's okay if that didn't totally make sense.
Dialogue: 0,0:43:10.41,0:43:11.71,中文,,0,0,0,,如果那完全不合理也没关系
Dialogue: 0,0:43:11.71,0:43:13.99,英文,,0,0,0,,That's a good question though.
Dialogue: 0,0:43:11.71,0:43:13.99,中文,,0,0,0,,不过那是一个很好的问题
Dialogue: 0,0:43:13.99,0:43:15.62,英文,,0,0,0,,OK, great.
Dialogue: 0,0:43:13.99,0:43:15.62,中文,,0,0,0,,好的 很好
Dialogue: 0,0:43:15.62,0:43:18.68,英文,,0,0,0,,So the cut property inspires an algorithm.
Dialogue: 0,0:43:15.62,0:43:18.68,中文,,0,0,0,,切割属性激发了一个算法
Dialogue: 0,0:43:18.68,0:43:24.12,英文,,0,0,0,,And it's kind of silly, but if you run it for long enough, it will work, which is go find a cut.
Dialogue: 0,0:43:18.68,0:43:24.12,中文,,0,0,0,,这有点傻 但如果你运行它足够长的时间 它会起作用 这就是去找到一个切口
Dialogue: 0,0:43:24.12,0:43:29.96,英文,,0,0,0,,So start assigning vertices to teams at random and be like, oh, you're a gray team, you're a white team.
Dialogue: 0,0:43:24.12,0:43:29.96,中文,,0,0,0,,开始随机分配顶点到团队 并且说 你是灰色团队 你是白色团队
Dialogue: 0,0:43:29.96,0:43:35.24,英文,,0,0,0,,And then find the smallest crossing edge and add it to the minimum spanning tree.
Dialogue: 0,0:43:29.96,0:43:35.24,中文,,0,0,0,,然后找到最小的交叉边 将其添加到最小生成树中
Dialogue: 0,0:43:35.24,0:43:37.98,英文,,0,0,0,,Do this until you have a minimum spanning tree.
Dialogue: 0,0:43:35.24,0:43:37.98,中文,,0,0,0,,一直这样做 直到你有一个最小生成树为止
Dialogue: 0,0:43:37.98,0:43:45.27,英文,,0,0,0,,So just go find a random cut, find the edge that crosses it, go find another random cut, find an edge that crosses it, find another random cut.
Dialogue: 0,0:43:37.98,0:43:45.27,中文,,0,0,0,,只需找到一个随机切口 找到穿越它的边 再找到另一个随机切口 找到穿越它的边 再找到另一个随机切口
Dialogue: 0,0:43:45.27,0:43:49.25,英文,,0,0,0,,And if you do this enough times, you might get a minimum spanning tree.
Dialogue: 0,0:43:45.27,0:43:49.25,中文,,0,0,0,,如果你这样做足够多次 你可能会得到一个最小生成树
Dialogue: 0,0:43:49.25,0:43:54.15,英文,,0,0,0,,And remember, trees with v vertices touched have to have v minus 1 edges.
Dialogue: 0,0:43:49.25,0:43:54.15,中文,,0,0,0,,记住 被触及的具有 V 个顶点的树必须有 V-1 条边
Dialogue: 0,0:43:54.15,0:43:55.98,英文,,0,0,0,,That's from the Dijkstra's lecture.
Dialogue: 0,0:43:54.15,0:43:55.98,中文,,0,0,0,,这是迪杰斯特拉的讲座内容
Dialogue: 0,0:43:55.98,0:44:00.46,英文,,0,0,0,,So I'll stop when I get a full tree that has v minus 1 edges.
Dialogue: 0,0:43:55.98,0:44:00.46,中文,,0,0,0,,当我得到一个边数为V-1的完整树时 我就会停下来
Dialogue: 0,0:44:00.46,0:44:04.88,英文,,0,0,0,,This will work, but hopefully we all agree it's not super efficient.
Dialogue: 0,0:44:00.46,0:44:04.88,中文,,0,0,0,,这样做是可行的 但希望我们都同意这并不是非常高效的
Dialogue: 0,0:44:04.88,0:44:14.12,英文,,0,0,0,,Because you're here coming up with cuts at random, and maybe you come up with a cut, and the smallest crossing edge is already in the minimum spanning tree, and you've just wasted some work.
Dialogue: 0,0:44:04.88,0:44:14.12,中文,,0,0,0,,因为你们在这里随机提出切割 也许你们提出了一个切割 最小的横跨边已经在最小生成树中 你们只是浪费了一些工作
Dialogue: 0,0:44:14.12,0:44:17.60,英文,,0,0,0,,So this is not super smart, although it will work.
Dialogue: 0,0:44:14.12,0:44:17.60,中文,,0,0,0,,这并不是非常聪明 尽管它会起作用
Dialogue: 0,0:44:17.60,0:44:18.88,英文,,0,0,0,,It's just very slow.
Dialogue: 0,0:44:17.60,0:44:18.88,中文,,0,0,0,,它只是非常慢
Dialogue: 0,0:44:18.88,0:44:22.35,英文,,0,0,0,,So let's go do something better than coming up with cuts at random.
Dialogue: 0,0:44:18.88,0:44:22.35,中文,,0,0,0,,让我们做些比随机提出切割更好的事情
Dialogue: 0,0:44:22.35,0:44:25.35,英文,,0,0,0,,I still want to use the cut property, because it's really cool.
Dialogue: 0,0:44:22.35,0:44:25.35,中文,,0,0,0,,我还想使用cut属性 因为它真的很酷
Dialogue: 0,0:44:25.35,0:44:27.91,英文,,0,0,0,,But I want to do it in a smarter way.
Dialogue: 0,0:44:25.35,0:44:27.91,中文,,0,0,0,,但我想以更聪明的方式做
Dialogue: 0,0:44:27.91,0:44:32.03,英文,,0,0,0,,So I'll show you two algorithms, but kind of three, to do this.
Dialogue: 0,0:44:27.91,0:44:32.03,中文,,0,0,0,,我会给你展示两种算法 但实际上有三种 来做这件事
Dialogue: 0,0:44:32.03,0:44:36.36,英文,,0,0,0,,So I'll start with one called Prim's Algorithm Conceptual Version.
Dialogue: 0,0:44:32.03,0:44:36.36,中文,,0,0,0,,我会先从一个叫做Prim's算法概念版本的开始
Dialogue: 0,0:44:36.36,0:44:39.30,英文,,0,0,0,,And then later, I'll show you Prim's Algorithm Optimized Version.
Dialogue: 0,0:44:36.36,0:44:39.30,中文,,0,0,0,,然后稍后 我会展示给你Prim's算法优化版本
Dialogue: 0,0:44:39.30,0:44:41.18,英文,,0,0,0,,They're going to seem like totally different algorithms.
Dialogue: 0,0:44:39.30,0:44:41.18,中文,,0,0,0,,它们会看起来像是完全不同的算法
Dialogue: 0,0:44:41.18,0:44:42.24,英文,,0,0,0,,They did for me.
Dialogue: 0,0:44:41.18,0:44:42.24,中文,,0,0,0,,对我来说是这样
Dialogue: 0,0:44:42.24,0:44:44.92,英文,,0,0,0,,But fundamentally, they're doing the same thing.
Dialogue: 0,0:44:42.24,0:44:44.92,中文,,0,0,0,,但从根本上讲 它们都在做同样的事情
Dialogue: 0,0:44:44.92,0:44:47.68,英文,,0,0,0,,But if you want to think of them as two separate algorithms, you can.
Dialogue: 0,0:44:44.92,0:44:47.68,中文,,0,0,0,,但如果你想把它们看作是两个单独的算法 你可以这么认为
Dialogue: 0,0:44:47.68,0:44:52.35,英文,,0,0,0,,But later down the line, you'll eventually realize one of them is actually the same as the other.
Dialogue: 0,0:44:47.68,0:44:52.35,中文,,0,0,0,,但随着时间的推移 你最终会意识到其中一个实际上与另一个相同
Dialogue: 0,0:44:52.35,0:44:55.67,英文,,0,0,0,,It's just that this one is slower, and the optimized variant is faster.
Dialogue: 0,0:44:52.35,0:44:55.67,中文,,0,0,0,,只是这个速度慢一些 而优化的变体更快
Dialogue: 0,0:44:55.67,0:44:57.91,英文,,0,0,0,,OK, that will make more sense once I show it to you.
Dialogue: 0,0:44:55.67,0:44:57.91,中文,,0,0,0,,等我给你展示后 这就会更有意义了
Dialogue: 0,0:44:57.91,0:45:03.23,英文,,0,0,0,,This algorithm is almost so simple, I just wanted to show it to you in an example, and then I'll talk about it.
Dialogue: 0,0:44:57.91,0:45:03.23,中文,,0,0,0,,这个算法几乎如此简单 我只是想用一个例子给你展示一下 然后再谈谈它
Dialogue: 0,0:45:03.23,0:45:05.37,英文,,0,0,0,,So here I go.
Dialogue: 0,0:45:03.23,0:45:05.37,中文,,0,0,0,,我开始吧
Dialogue: 0,0:45:05.37,0:45:07.51,英文,,0,0,0,,I'm going to start from an arbitrary start node.
Dialogue: 0,0:45:05.37,0:45:07.51,中文,,0,0,0,,我要从任意起始节点开始
Dialogue: 0,0:45:07.51,0:45:13.68,英文,,0,0,0,,By the way, this is where I should mention, the minimum spanning tree is a property of the whole graph.
Dialogue: 0,0:45:07.51,0:45:13.68,中文,,0,0,0,,顺便说一下 我应该提一下 最小生成树是整个图的一个属性
Dialogue: 0,0:45:13.68,0:45:16.92,英文,,0,0,0,,So I can hand you a graph and be like, give me the MST.
Dialogue: 0,0:45:13.68,0:45:16.92,中文,,0,0,0,,我可以给你一个图 然后说 给我最小生成树
Dialogue: 0,0:45:16.92,0:45:17.66,英文,,0,0,0,,I give you this graph.
Dialogue: 0,0:45:16.92,0:45:17.66,中文,,0,0,0,,我给你这个图
Dialogue: 0,0:45:17.66,0:45:19.30,英文,,0,0,0,,I'm like, give me the MST.
Dialogue: 0,0:45:17.66,0:45:19.30,中文,,0,0,0,,我就像说 给我最小生成树
Dialogue: 0,0:45:19.30,0:45:23.60,英文,,0,0,0,,However, I cannot hand you a graph and say, give me the shortest path tree.
Dialogue: 0,0:45:19.30,0:45:23.60,中文,,0,0,0,,然而 我不能给你一个图然后说 给我最短路径树
Dialogue: 0,0:45:23.60,0:45:24.36,英文,,0,0,0,,Why is that?
Dialogue: 0,0:45:23.60,0:45:24.36,中文,,0,0,0,,为什么呢
Dialogue: 0,0:45:24.36,0:45:28.33,英文,,0,0,0,,Why can't I just give you a graph and be like, tell me the shortest path tree?
Dialogue: 0,0:45:24.36,0:45:28.33,中文,,0,0,0,,为什么我不能只给你一个图然后说 告诉我最短路径树呢
Dialogue: 0,0:45:28.33,0:45:33.89,英文,,0,0,0,,Because if I do that, your first question to me should be, shortest path from where?
Dialogue: 0,0:45:28.33,0:45:33.89,中文,,0,0,0,,因为如果我那样做 你第一个问题应该是 最短路径是从哪里开始的
Dialogue: 0,0:45:33.89,0:45:36.43,英文,,0,0,0,,Do you want the shortest path from A to everybody?
Dialogue: 0,0:45:33.89,0:45:36.43,中文,,0,0,0,,你想要从 A 到每个人的最短路径吗
Dialogue: 0,0:45:36.43,0:45:38.99,英文,,0,0,0,,Do you want the shortest path from D to everybody?
Dialogue: 0,0:45:36.43,0:45:38.99,中文,,0,0,0,,你想要从 D 到每个人的最短路径吗
Dialogue: 0,0:45:38.99,0:45:45.22,英文,,0,0,0,,So if I give you a graph and I say, give me the shortest path tree, you would ask me, what is the starting vertex?
Dialogue: 0,0:45:38.99,0:45:45.22,中文,,0,0,0,,如果我给你一个图然后说 给我最短路径树 你会问我 起始顶点是什么
Dialogue: 0,0:45:45.22,0:45:50.52,英文,,0,0,0,,So to get the shortest path straight, I need to give you a graph, and I also need to tell you where to start.
Dialogue: 0,0:45:45.22,0:45:50.52,中文,,0,0,0,,要直接得到最短路径 我需要给你一个图 并且还需要告诉你从哪里开始
Dialogue: 0,0:45:50.52,0:45:59.62,英文,,0,0,0,,By contrast, in a minimum spanning tree, I can just give you the graph and be like, tell me what the set of edges are that touches all the vertices with minimum weight, and that's it.
Dialogue: 0,0:45:50.52,0:45:59.62,中文,,0,0,0,,相比之下 在最小生成树中 我只需要给你图然后说 告诉我哪些边集合触及所有顶点并且权重最小 就这样
Dialogue: 0,0:45:59.62,0:46:03.13,英文,,0,0,0,,There does not need to be a starting node.
Dialogue: 0,0:45:59.62,0:46:03.13,中文,,0,0,0,,不需要有起始节点
Dialogue: 0,0:46:03.13,0:46:06.07,英文,,0,0,0,,And that's the difference between the two, or one of the differences.
Dialogue: 0,0:46:03.13,0:46:06.07,中文,,0,0,0,,这就是两者之间的区别 或者说是其中之一
Dialogue: 0,0:46:06.07,0:46:07.92,英文,,0,0,0,,So just wanted to mention it.
Dialogue: 0,0:46:06.07,0:46:07.92,中文,,0,0,0,,我只是想提一下
Dialogue: 0,0:46:07.92,0:46:14.08,英文,,0,0,0,,That being said, I'm probably about to confuse you even further, because Prim's algorithm, it does choose a start node.
Dialogue: 0,0:46:07.92,0:46:14.08,中文,,0,0,0,,话虽如此 我可能会让你更加困惑 因为 Prim's  算法 它确实选择了一个起始节点
Dialogue: 0,0:46:14.08,0:46:15.82,英文,,0,0,0,,But it chooses it totally at random.
Dialogue: 0,0:46:14.08,0:46:15.82,中文,,0,0,0,,但它是完全随机选择的
Dialogue: 0,0:46:15.82,0:46:17.72,英文,,0,0,0,,This is just because I have to start somewhere.
Dialogue: 0,0:46:15.82,0:46:17.72,中文,,0,0,0,,这只是因为我必须从某个地方开始
Dialogue: 0,0:46:17.72,0:46:20.60,英文,,0,0,0,,It's not because someone specified a start node.
Dialogue: 0,0:46:17.72,0:46:20.60,中文,,0,0,0,,不是因为有人指定了一个起始节点
Dialogue: 0,0:46:20.60,0:46:22.48,英文,,0,0,0,,So don't get it totally confused with Dijkstra's.
Dialogue: 0,0:46:20.60,0:46:22.48,中文,,0,0,0,,不要把它和Dijkstra完全混淆了
Dialogue: 0,0:46:22.48,0:46:26.12,英文,,0,0,0,,In Dijkstra's, the user tells you the starting vertex.
Dialogue: 0,0:46:22.48,0:46:26.12,中文,,0,0,0,,在Dijkstra算法中 用户告诉你起始顶点
Dialogue: 0,0:46:26.12,0:46:29.49,英文,,0,0,0,,In Prim's, I'm just picking one at random because I got to start somewhere.
Dialogue: 0,0:46:26.12,0:46:29.49,中文,,0,0,0,,在Prim's 算法中 我只是随机选择一个因为我必须要从某处开始
Dialogue: 0,0:46:29.49,0:46:31.85,英文,,0,0,0,,But it's not something the user has to specify.
Dialogue: 0,0:46:29.49,0:46:31.85,中文,,0,0,0,,但这不是用户必须指定的东西
Dialogue: 0,0:46:31.85,0:46:32.97,英文,,0,0,0,,OK, here we go.
Dialogue: 0,0:46:31.85,0:46:32.97,中文,,0,0,0,,好的 我们开始吧
Dialogue: 0,0:46:32.97,0:46:34.37,英文,,0,0,0,,I am starting here.
Dialogue: 0,0:46:32.97,0:46:34.37,中文,,0,0,0,,我从这里开始
Dialogue: 0,0:46:34.37,0:46:35.81,英文,,0,0,0,,I am going to mark it.
Dialogue: 0,0:46:34.37,0:46:35.81,中文,,0,0,0,,我要标记它
Dialogue: 0,0:46:35.81,0:46:37.07,英文,,0,0,0,,Look, it's marked.
Dialogue: 0,0:46:35.81,0:46:37.07,中文,,0,0,0,,看 它被标记了
Dialogue: 0,0:46:37.07,0:46:39.95,英文,,0,0,0,,And by marking it, I actually created a cut.
Dialogue: 0,0:46:37.07,0:46:39.95,中文,,0,0,0,,通过标记它 我实际上创建了一个切口
Dialogue: 0,0:46:39.95,0:46:40.97,英文,,0,0,0,,Do you see the cut?
Dialogue: 0,0:46:39.95,0:46:40.97,中文,,0,0,0,,你看到切口了吗
Dialogue: 0,0:46:40.97,0:46:44.35,英文,,0,0,0,,The cut is everybody who's marked is part of one team.
Dialogue: 0,0:46:40.97,0:46:44.35,中文,,0,0,0,,切口就是所有被标记的人都是一个团队的一部分
Dialogue: 0,0:46:44.35,0:46:47.11,英文,,0,0,0,,Everybody who's not marked is part of the other team.
Dialogue: 0,0:46:44.35,0:46:47.11,中文,,0,0,0,,所有没有被标记的人都是另一个团队的一部分
Dialogue: 0,0:46:47.11,0:46:51.70,英文,,0,0,0,,So just by marking a vertex, I actually created a cut, which is kind of nice.
Dialogue: 0,0:46:47.11,0:46:51.70,中文,,0,0,0,,仅仅通过标记一个顶点 我实际上创建了一个切口 这挺不错的
Dialogue: 0,0:46:51.70,0:46:53.60,英文,,0,0,0,,Let's use the cut to find an edge.
Dialogue: 0,0:46:51.70,0:46:53.60,中文,,0,0,0,,让我们利用这个切口找到一条边
Dialogue: 0,0:46:53.60,0:47:00.58,英文,,0,0,0,,So I need to highlight all of the edges with one foot in the marked vertex and one foot in an unmarked vertex.
Dialogue: 0,0:46:53.60,0:47:00.58,中文,,0,0,0,,我需要突出显示所有边 其中一只脚在标记的顶点上 另一只脚在未标记的顶点上
Dialogue: 0,0:47:00.58,0:47:03.04,英文,,0,0,0,,That turns out to be these two edges.
Dialogue: 0,0:47:00.58,0:47:03.04,中文,,0,0,0,,结果是这两条边
Dialogue: 0,0:47:03.04,0:47:09.98,英文,,0,0,0,,And try and convince yourself why all of these other edges are not crossing the cut, because they all touch two unmarked vertices.
Dialogue: 0,0:47:03.04,0:47:09.98,中文,,0,0,0,,试着说服自己为什么所有这些其他边不会跨越割 因为它们都接触到两个未标记的顶点
Dialogue: 0,0:47:09.98,0:47:13.98,英文,,0,0,0,,So of these two, who is about to join the minimum spanning tree?
Dialogue: 0,0:47:09.98,0:47:13.98,中文,,0,0,0,,在这两个中 谁将加入最小生成树
Dialogue: 0,0:47:13.98,0:47:14.88,英文,,0,0,0,,Is it two?
Dialogue: 0,0:47:13.98,0:47:14.88,中文,,0,0,0,,是2吗
Dialogue: 0,0:47:14.88,0:47:15.78,英文,,0,0,0,,Is it one?
Dialogue: 0,0:47:14.88,0:47:15.78,中文,,0,0,0,,是1吗
Dialogue: 0,0:47:15.78,0:47:18.80,英文,,0,0,0,,I think it's one, because it's got the smallest weight.
Dialogue: 0,0:47:15.78,0:47:18.80,中文,,0,0,0,,我觉得是1 因为它的权重最小
Dialogue: 0,0:47:18.80,0:47:22.43,英文,,0,0,0,,So thanks to my cut property, I know one is part of the minimum spanning tree.
Dialogue: 0,0:47:18.80,0:47:22.43,中文,,0,0,0,,因此 由于我的切割属性 我知道一个是最小生成树的一部分
Dialogue: 0,0:47:22.43,0:47:23.49,英文,,0,0,0,,I bold it.
Dialogue: 0,0:47:22.43,0:47:23.49,中文,,0,0,0,,我加粗它
Dialogue: 0,0:47:23.49,0:47:25.71,英文,,0,0,0,,Welcome to the minimum spanning tree.
Dialogue: 0,0:47:23.49,0:47:25.71,中文,,0,0,0,,欢迎来到最小生成树
Dialogue: 0,0:47:25.71,0:47:27.15,英文,,0,0,0,,OK, good.
Dialogue: 0,0:47:25.71,0:47:27.15,中文,,0,0,0,,好的 很好
Dialogue: 0,0:47:27.15,0:47:29.03,英文,,0,0,0,,Now I'm going to mark C. Why do I mark C?
Dialogue: 0,0:47:27.15,0:47:29.03,中文,,0,0,0,,现在我要标记 C 我为什么要标记 C
Dialogue: 0,0:47:29.03,0:47:30.79,英文,,0,0,0,,Because it's part of the minimum spanning tree.
Dialogue: 0,0:47:29.03,0:47:30.79,中文,,0,0,0,,因为它是最小生成树的一部分
Dialogue: 0,0:47:30.79,0:47:34.13,英文,,0,0,0,,It's being touched by one of the bold vertices.
Dialogue: 0,0:47:30.79,0:47:34.13,中文,,0,0,0,,它被一个加粗顶点触及
Dialogue: 0,0:47:34.13,0:47:38.32,英文,,0,0,0,,So I'm going to mark C because it's part of the minimum spanning tree.
Dialogue: 0,0:47:34.13,0:47:38.32,中文,,0,0,0,,我要标记C 因为它是最小生成树的一部分
Dialogue: 0,0:47:38.32,0:47:39.46,英文,,0,0,0,,And guess what?
Dialogue: 0,0:47:38.32,0:47:39.46,中文,,0,0,0,,猜猜看
Dialogue: 0,0:47:39.46,0:47:41.45,英文,,0,0,0,,I have another cut.
Dialogue: 0,0:47:39.46,0:47:41.45,中文,,0,0,0,,我有另一个切口
Dialogue: 0,0:47:41.45,0:47:42.59,英文,,0,0,0,,And do you see the cut?
Dialogue: 0,0:47:41.45,0:47:42.59,中文,,0,0,0,,你看到切口了吗
Dialogue: 0,0:47:42.59,0:47:57.61,英文,,0,0,0,,It's the cut between all the visited vertices or the marked vertices that are inside the minimum spanning tree, that are being touched by the bold edges, and everybody who is unmarked, who is not touched by one of the bold edges.
Dialogue: 0,0:47:42.59,0:47:57.61,中文,,0,0,0,,这是所有已访问的顶点或最小生成树内被粗体边缘触及的标记顶点之间的切口 以及所有未标记的未被粗体边缘触及的顶点
Dialogue: 0,0:47:57.61,0:47:58.97,英文,,0,0,0,,Try and predict who's part of the cut.
Dialogue: 0,0:47:57.61,0:47:58.97,中文,,0,0,0,,试着预测谁是切口的一部分
Dialogue: 0,0:47:58.97,0:48:07.99,英文,,0,0,0,,Like A to B is part of the cut, I think, because it's got one foot in marked vertex, one foot in an unmarked vertex, five is part of the cut, one, and 15.
Dialogue: 0,0:47:58.97,0:48:07.99,中文,,0,0,0,,像A到B可能是切口的一部分 因为它一只脚在标记顶点 一只脚在未标记顶点 五是切口的一部分 一和15
Dialogue: 0,0:48:07.99,0:48:09.44,英文,,0,0,0,,Those are part of the cut.
Dialogue: 0,0:48:07.99,0:48:09.44,中文,,0,0,0,,这些是切割的一部分
Dialogue: 0,0:48:09.44,0:48:15.50,英文,,0,0,0,,So using my new cut, the second one I've come up with, I can choose an edge to join the family.
Dialogue: 0,0:48:09.44,0:48:15.50,中文,,0,0,0,,利用我的新切割 这是我想出的第二种 我可以选择一个边加入这个家庭
Dialogue: 0,0:48:15.50,0:48:18.56,英文,,0,0,0,,I'm going to choose the one of lowest weight, which is 1.
Dialogue: 0,0:48:15.50,0:48:18.56,中文,,0,0,0,,我要选择最小权重的那个 也就是1
Dialogue: 0,0:48:18.56,0:48:19.94,英文,,0,0,0,,So now it's part of the family.
Dialogue: 0,0:48:18.56,0:48:19.94,中文,,0,0,0,,现在它是这个家庭的一部分
Dialogue: 0,0:48:19.94,0:48:25.57,英文,,0,0,0,,And my cut changed, because my cut is always everybody inside the minimum spanning tree.
Dialogue: 0,0:48:19.94,0:48:25.57,中文,,0,0,0,,我的切割改变了 因为我的切割总是所有人都在最小生成树内
Dialogue: 0,0:48:25.57,0:48:29.93,英文,,0,0,0,,That is, everyone touched by a bolded used edge.
Dialogue: 0,0:48:25.57,0:48:29.93,中文,,0,0,0,,也就是说 所有被加粗使用的边接触的人
Dialogue: 0,0:48:29.93,0:48:33.44,英文,,0,0,0,,So it's A, C, and E are the ones touched by my bolded edges.
Dialogue: 0,0:48:29.93,0:48:33.44,中文,,0,0,0,,被我的加粗边接触的是A、C和E
Dialogue: 0,0:48:33.44,0:48:34.98,英文,,0,0,0,,And then everyone else is unmarked.
Dialogue: 0,0:48:33.44,0:48:34.98,中文,,0,0,0,,然后其他人都是未标记的
Dialogue: 0,0:48:34.98,0:48:36.73,英文,,0,0,0,,There's my cut.
Dialogue: 0,0:48:34.98,0:48:36.73,中文,,0,0,0,,这是我的份额
Dialogue: 0,0:48:36.73,0:48:38.63,英文,,0,0,0,,So now it's your turn.
Dialogue: 0,0:48:36.73,0:48:38.63,中文,,0,0,0,,现在轮到你了
Dialogue: 0,0:48:38.63,0:48:42.66,英文,,0,0,0,,These are all the pink edges that are crossing the cut.
Dialogue: 0,0:48:38.63,0:48:42.66,中文,,0,0,0,,这些都是穿过切割的所有粉红边缘
Dialogue: 0,0:48:42.66,0:48:52.72,英文,,0,0,0,,That is, they have one foot touching a marked vertex that's inside the MST and one foot touching an unmarked vertex that's not in the MST.
Dialogue: 0,0:48:42.66,0:48:52.72,中文,,0,0,0,,也就是说 它们有一个脚接触到了最小生成树内的标记顶点 另一个脚接触到了不在最小生成树内的未标记顶点
Dialogue: 0,0:48:52.72,0:48:55.50,英文,,0,0,0,,So which of these should I add?
Dialogue: 0,0:48:52.72,0:48:55.50,中文,,0,0,0,,那么我应该添加哪一个呢
Dialogue: 0,0:48:55.50,0:48:59.76,英文,,0,0,0,,And this is the point that someone asked about earlier, which is there's actually a tie.
Dialogue: 0,0:48:55.50,0:48:59.76,中文,,0,0,0,,这是之前有人问过的一个点 也就是说实际上有一个平局
Dialogue: 0,0:48:59.76,0:49:01.02,英文,,0,0,0,,There are two winners.
Dialogue: 0,0:48:59.76,0:49:01.02,中文,,0,0,0,,有两个赢家
Dialogue: 0,0:49:01.02,0:49:02.88,英文,,0,0,0,,You could add A to B.
Dialogue: 0,0:49:01.02,0:49:02.88,中文,,0,0,0,,你可以把A加到B上
Dialogue: 0,0:49:02.88,0:49:07.37,英文,,0,0,0,,Or you could add E to D. Both of them would be valid choices.
Dialogue: 0,0:49:02.88,0:49:07.37,中文,,0,0,0,,或者你可以把E加到D上 两个选择都是有效的
Dialogue: 0,0:49:07.37,0:49:13.71,英文,,0,0,0,,Now, you shouldn't add both, because only one of these edges is guaranteed to be in the MST.
Dialogue: 0,0:49:07.37,0:49:13.71,中文,,0,0,0,,但现在 你不应该同时添加两个 因为在MST中只保证有一个边缘
Dialogue: 0,0:49:13.71,0:49:17.09,英文,,0,0,0,,But it turns out you can choose either one, and you'll get the right answer.
Dialogue: 0,0:49:13.71,0:49:17.09,中文,,0,0,0,,但事实证明 你选择任何一个都可以得到正确答案
Dialogue: 0,0:49:17.09,0:49:19.02,英文,,0,0,0,,Or you'll get a right answer.
Dialogue: 0,0:49:17.09,0:49:19.02,中文,,0,0,0,,或者你会得到一个正确的答案
Dialogue: 0,0:49:19.02,0:49:21.60,英文,,0,0,0,,It may no longer be unique, because there's a tie.
Dialogue: 0,0:49:19.02,0:49:21.60,中文,,0,0,0,,因为有了平局 答案可能不再是唯一的
Dialogue: 0,0:49:21.60,0:49:28.28,英文,,0,0,0,,So all of this is to say, if there's two edges that are tied for being the smallest crossing edge, you can just pick either of them.
Dialogue: 0,0:49:21.60,0:49:28.28,中文,,0,0,0,,这一切都是为了说 如果有两条边同时是最小的交叉边 你可以随便选其中一条
Dialogue: 0,0:49:28.28,0:49:30.76,英文,,0,0,0,,Algorithm will work just fine.
Dialogue: 0,0:49:28.28,0:49:30.76,中文,,0,0,0,,算法会正常运行
Dialogue: 0,0:49:30.76,0:49:35.93,英文,,0,0,0,,So I'll pick D to E. But if you want to, you can pick A to B. Finish the algorithm.
Dialogue: 0,0:49:30.76,0:49:35.93,中文,,0,0,0,,我会选择从 D 到 E 但如果你愿意的话 你也可以选择从 A 到 B 完成算法
Dialogue: 0,0:49:35.93,0:49:37.61,英文,,0,0,0,,Have fun with it.
Dialogue: 0,0:49:35.93,0:49:37.61,中文,,0,0,0,,玩得开心
Dialogue: 0,0:49:37.61,0:49:38.73,英文,,0,0,0,,So let's wrap up.
Dialogue: 0,0:49:37.61,0:49:38.73,中文,,0,0,0,,那我们就结束吧
Dialogue: 0,0:49:38.73,0:49:41.95,英文,,0,0,0,,Here are my four edges that are being touched by the minimum spanning tree.
Dialogue: 0,0:49:38.73,0:49:41.95,中文,,0,0,0,,这里是我的四条被最小生成树所触及的边
Dialogue: 0,0:49:41.95,0:49:43.83,英文,,0,0,0,,So I need to consider another cut.
Dialogue: 0,0:49:41.95,0:49:43.83,中文,,0,0,0,,我需要考虑另一个切口
Dialogue: 0,0:49:43.83,0:49:47.46,英文,,0,0,0,,And remember, the cut says I need to look at all the edges crossing the cut.
Dialogue: 0,0:49:43.83,0:49:47.46,中文,,0,0,0,,记住 切口说我需要看所有穿过切口的边缘
Dialogue: 0,0:49:47.46,0:49:49.30,英文,,0,0,0,,Those are all the edges crossing the cut.
Dialogue: 0,0:49:47.46,0:49:49.30,中文,,0,0,0,,那些都是穿过切口的边缘
Dialogue: 0,0:49:49.30,0:49:52.90,英文,,0,0,0,,By the way, does anybody have a bad feeling about this?
Dialogue: 0,0:49:49.30,0:49:52.90,中文,,0,0,0,,顺便问一句 有人对此感到不好吗
Dialogue: 0,0:49:52.90,0:49:56.30,英文,,0,0,0,,Because this is a lot of pink edges to consider.
Dialogue: 0,0:49:52.90,0:49:56.30,中文,,0,0,0,,因为要考虑的粉色边太多了
Dialogue: 0,0:49:56.30,0:49:59.10,英文,,0,0,0,,So our algorithm next time will make this a little bit faster.
Dialogue: 0,0:49:56.30,0:49:59.10,中文,,0,0,0,,我们的算法下次会快一点
Dialogue: 0,0:49:59.10,0:50:01.27,英文,,0,0,0,,But for today, let's just gut this out.
Dialogue: 0,0:49:59.10,0:50:01.27,中文,,0,0,0,,但是今天 让我们拼尽全力
Dialogue: 0,0:50:01.27,0:50:03.21,英文,,0,0,0,,That's a lot of edges to consider.
Dialogue: 0,0:50:01.27,0:50:03.21,中文,,0,0,0,,要考虑的边太多了
Dialogue: 0,0:50:03.21,0:50:05.29,英文,,0,0,0,,Those are all the edges crossing the cut.
Dialogue: 0,0:50:03.21,0:50:05.29,中文,,0,0,0,,那些都是穿过切割的边缘
Dialogue: 0,0:50:05.29,0:50:07.11,英文,,0,0,0,,Which one has smallest weight?
Dialogue: 0,0:50:05.29,0:50:07.11,中文,,0,0,0,,哪一个重量最小
Dialogue: 0,0:50:07.11,0:50:10.63,英文,,0,0,0,,D to G, U. So I'll add you to the family.
Dialogue: 0,0:50:07.11,0:50:10.63,中文,,0,0,0,,从D到G 我会把你加入到家庭里
Dialogue: 0,0:50:10.63,0:50:12.34,英文,,0,0,0,,Now I have another cut.
Dialogue: 0,0:50:10.63,0:50:12.34,中文,,0,0,0,,现在我又有了一个切割
Dialogue: 0,0:50:12.34,0:50:13.56,英文,,0,0,0,,I consider all of the edges.
Dialogue: 0,0:50:12.34,0:50:13.56,中文,,0,0,0,,我考虑所有的边缘
Dialogue: 0,0:50:13.56,0:50:22.01,英文,,0,0,0,,And again, I hope you have a bad feeling about this, because that's a lot of edges to consider, including some edges we've already considered like five times.
Dialogue: 0,0:50:13.56,0:50:22.01,中文,,0,0,0,,而且 我希望你对此有不好的感觉 因为这是要考虑的很多边缘 包括我们已经考虑过的一些边缘 像五次那样
Dialogue: 0,0:50:22.01,0:50:25.95,英文,,0,0,0,,But we're going to consider it again today, because this is the conceptual version.
Dialogue: 0,0:50:22.01,0:50:25.95,中文,,0,0,0,,但是今天我们会再次考虑 因为这是概念版本
Dialogue: 0,0:50:25.95,0:50:29.79,英文,,0,0,0,,So of all these edges, f to g is the smallest edge crossing the cut.
Dialogue: 0,0:50:25.95,0:50:29.79,中文,,0,0,0,,在所有这些边中 从f到g的边是穿过切割的最小边
Dialogue: 0,0:50:29.79,0:50:30.71,英文,,0,0,0,,So I add it.
Dialogue: 0,0:50:29.79,0:50:30.71,中文,,0,0,0,,我添加它
Dialogue: 0,0:50:30.71,0:50:32.68,英文,,0,0,0,,And finally, this is the last cut.
Dialogue: 0,0:50:30.71,0:50:32.68,中文,,0,0,0,,最后 这是最后一个切割
Dialogue: 0,0:50:32.68,0:50:35.86,英文,,0,0,0,,And this cut, a to b, has the smallest weight.
Dialogue: 0,0:50:32.68,0:50:35.86,中文,,0,0,0,,而这个切割 从a到b 具有最小的权重
Dialogue: 0,0:50:35.86,0:50:36.74,英文,,0,0,0,,So I add it.
Dialogue: 0,0:50:35.86,0:50:36.74,中文,,0,0,0,,我添加它
Dialogue: 0,0:50:36.74,0:50:40.10,英文,,0,0,0,,And now I can stop, because all the edges are being touched.
Dialogue: 0,0:50:36.74,0:50:40.10,中文,,0,0,0,,现在我可以停下来了 因为所有的边都被触及了
Dialogue: 0,0:50:40.10,0:50:43.28,英文,,0,0,0,,Equivalently, I have v minus 1 edges.
Dialogue: 0,0:50:40.10,0:50:43.28,中文,,0,0,0,,等价地 我有V-1条边
Dialogue: 0,0:50:43.28,0:50:47.69,英文,,0,0,0,,And I know that if I have v minus 1 edges and there's no cycle, I get a tree.
Dialogue: 0,0:50:43.28,0:50:47.69,中文,,0,0,0,,我知道 如果我有 v - 1 条边而且没有循环 我就得到一棵树
Dialogue: 0,0:50:47.69,0:50:49.27,英文,,0,0,0,,So that's my solution.
Dialogue: 0,0:50:47.69,0:50:49.27,中文,,0,0,0,,这就是我的解决方案
Dialogue: 0,0:50:49.27,0:50:50.17,英文,,0,0,0,,I can stop.
Dialogue: 0,0:50:49.27,0:50:50.17,中文,,0,0,0,,我可以停下来
Dialogue: 0,0:50:50.17,0:50:51.19,英文,,0,0,0,,I'm done.
Dialogue: 0,0:50:50.17,0:50:51.19,中文,,0,0,0,,我完成了
Dialogue: 0,0:50:51.19,0:50:56.83,英文,,0,0,0,,I have a minimum spanning tree using conceptual prints.
Dialogue: 0,0:50:51.19,0:50:56.83,中文,,0,0,0,,我有一个使用概念图打印的最小生成树
Dialogue: 0,0:50:56.83,0:50:59.97,英文,,0,0,0,,In a description, so I pick an arbitrary start vertex.
Dialogue: 0,0:50:56.83,0:50:59.97,中文,,0,0,0,,在一个描述中 我选择一个任意的起始顶点
Dialogue: 0,0:50:59.97,0:51:01.17,英文,,0,0,0,,Very important.
Dialogue: 0,0:50:59.97,0:51:01.17,中文,,0,0,0,,非常重要
Dialogue: 0,0:51:01.17,0:51:05.40,英文,,0,0,0,,The user is not telling me where to start because the user doesn't care where I start.
Dialogue: 0,0:51:01.17,0:51:05.40,中文,,0,0,0,,用户没有告诉我从哪里开始 因为用户不在乎我从哪里开始
Dialogue: 0,0:51:05.40,0:51:07.98,英文,,0,0,0,,The solution has no notion of a start vertex.
Dialogue: 0,0:51:05.40,0:51:07.98,中文,,0,0,0,,解决方案没有开始顶点的概念
Dialogue: 0,0:51:07.98,0:51:11.82,英文,,0,0,0,,It's just the property of the graph, unlike Dijkstra's and shortest paths.
Dialogue: 0,0:51:07.98,0:51:11.82,中文,,0,0,0,,这只是图的属性 不像Dijkstra和最短路径那样
Dialogue: 0,0:51:11.82,0:51:13.16,英文,,0,0,0,,However, I got to start somewhere.
Dialogue: 0,0:51:11.82,0:51:13.16,中文,,0,0,0,,但是 我必须从某个地方开始
Dialogue: 0,0:51:13.16,0:51:26.21,英文,,0,0,0,,So Prim says, let's start somewhere, and let's repeatedly check cuts and add the shortest edge that has one foot inside the MST, or one vertex inside the MST, and one foot outside the MST being constructed.
Dialogue: 0,0:51:13.16,0:51:26.21,中文,,0,0,0,,所以Prim说 让我们从某个地方开始 然后反复检查割和添加具有一个顶点在MST内的最短边 或者一个顶点在MST内 一个顶点在正在构建的MST之外
Dialogue: 0,0:51:26.21,0:51:30.55,英文,,0,0,0,,Do this over and over again until everyone's connected up with v minus 1 edges.
Dialogue: 0,0:51:26.21,0:51:30.55,中文,,0,0,0,,一遍又一遍地做 直到每个人都用v-1条边连接起来
Dialogue: 0,0:51:30.55,0:51:31.65,英文,,0,0,0,,And why does this work?
Dialogue: 0,0:51:30.55,0:51:31.65,中文,,0,0,0,,这为什么有效呢
Dialogue: 0,0:51:31.65,0:51:38.19,英文,,0,0,0,,Hopefully, you feel convinced that it works, because I was simply using the cut property over and over and over again.
Dialogue: 0,0:51:31.65,0:51:38.19,中文,,0,0,0,,希望你觉得它有效 因为我只是一遍又一遍地使用了 cut 属性
Dialogue: 0,0:51:38.19,0:51:41.06,英文,,0,0,0,,Okay, so, am I out of time already?
Dialogue: 0,0:51:38.19,0:51:41.06,中文,,0,0,0,,那么 我时间到了吗
Dialogue: 0,0:51:41.06,0:51:41.90,英文,,0,0,0,,Oh no, okay.
Dialogue: 0,0:51:41.06,0:51:41.90,中文,,0,0,0,,哦不 好吧
Dialogue: 0,0:51:41.90,0:51:44.32,英文,,0,0,0,,I got too excited by the A star and all that good stuff.
Dialogue: 0,0:51:41.90,0:51:44.32,中文,,0,0,0,,我对 A* 和所有好东西太兴奋了
Dialogue: 0,0:51:44.32,0:51:46.70,英文,,0,0,0,,Okay, well, I guess I'll call it here for now.
Dialogue: 0,0:51:44.32,0:51:46.70,中文,,0,0,0,,那么 我想我现在就结束吧
Dialogue: 0,0:51:46.70,0:51:52.93,英文,,0,0,0,,So come back next time to see Prim's algorithm in faster, a faster edition, because this was super slow.
Dialogue: 0,0:51:46.70,0:51:52.93,中文,,0,0,0,,下次再来看看 Prim's 算法的快速版本 因为这个太慢了
Dialogue: 0,0:51:52.93,0:51:56.77,英文,,0,0,0,,All right, see you next time.
Dialogue: 0,0:51:52.93,0:51:56.77,中文,,0,0,0,,好的 下次见
Dialogue: 0,0:51:56.77,0:52:00.77,英文,,0,0,0,,And to go apologize to the TAs for falling behind.
Dialogue: 0,0:51:56.77,0:52:00.77,中文,,0,0,0,,去向助教道歉 因为落后了
Dialogue: 0,0:52:00.77,0:52:02.50,英文,,0,0,0,,Okay, well, I'll see you next time.
Dialogue: 0,0:52:00.77,0:52:02.50,中文,,0,0,0,,那我下次见
