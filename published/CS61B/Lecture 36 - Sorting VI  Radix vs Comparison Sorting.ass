[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 3
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Export Encoding: Unicode (UTF-8)
Audio File: D:/python_code/video_tool/video_tool/result/Lecture 02.1 - Number Representation Intro, Bits can be anything.mp4
Video File: D:/python_code/video_tool/video_tool/result/Lecture 02.1 - Number Representation Intro, Bits can be anything.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.375000
Scroll Position: 749
Active Line: 755
Video Position: 8466

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,14,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.33333,1.33333,2,6,6,8,1
Style: 英文,Arial,24,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1.33333,1.33333,2,2,2,6,1
Style: 中文,微软雅黑,38,&H0029EEF1,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1.33333,1.33333,2,2,2,20,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,
Dialogue: 0,0:00:05.47,0:00:12.32,英文,,0,0,0,,Okay, is everyone ready for the final sorting algorithm?
Dialogue: 0,0:00:05.47,0:00:12.32,中文,,0,0,0,,好的  大家都准备好学习最后一个排序算法了吗？
Dialogue: 0,0:00:12.32,0:00:12.98,英文,,0,0,0,,No?
Dialogue: 0,0:00:12.32,0:00:12.98,中文,,0,0,0,,没有？
Dialogue: 0,0:00:12.98,0:00:20.54,英文,,0,0,0,,You're not ready?
Dialogue: 0,0:00:12.98,0:00:20.54,中文,,0,0,0,,你们还没准备好？
Dialogue: 0,0:00:20.54,0:00:24.80,英文,,0,0,0,,Okay, we gotta get going though, I got stuff to cover.
Dialogue: 0,0:00:20.54,0:00:24.80,中文,,0,0,0,,好吧  我们得继续了  我还有很多东西要讲
Dialogue: 0,0:00:24.80,0:00:27.44,英文,,0,0,0,,All right, here's the calendar, go quick.
Dialogue: 0,0:00:24.80,0:00:27.44,中文,,0,0,0,,好的  这是日历  快速看一下
Dialogue: 0,0:00:27.44,0:00:29.41,英文,,0,0,0,,Just say it out.
Dialogue: 0,0:00:27.44,0:00:29.41,中文,,0,0,0,,直接说出来
Dialogue: 0,0:00:29.41,0:00:31.71,英文,,0,0,0,,Hello. Here's what to do.
Dialogue: 0,0:00:29.41,0:00:31.71,中文,,0,0,0,,你好   要做的事情如下
Dialogue: 0,0:00:31.71,0:00:35.76,英文,,0,0,0,,You just have Project 3, B, and C. That's basically it.
Dialogue: 0,0:00:31.71,0:00:35.76,中文,,0,0,0,,你们只需要完成项目3  B和C  基本上就是这样
Dialogue: 0,0:00:35.76,0:00:42.08,英文,,0,0,0,,Chill. I'll tell you about counting sort.
Dialogue: 0,0:00:35.76,0:00:42.08,中文,,0,0,0,,放松   我会给你们讲计数排序
Dialogue: 0,0:00:42.08,0:00:47.54,英文,,0,0,0,,You've got to finish your conversations so I can talk about counting sort.
Dialogue: 0,0:00:42.08,0:00:47.54,中文,,0,0,0,,你们得先结束你们的谈话  这样我才能讲计数排序
Dialogue: 0,0:00:47.54,0:00:52.30,英文,,0,0,0,,When we left you last time, we said quicksort was n log n runtime.
Dialogue: 0,0:00:47.54,0:00:52.30,中文,,0,0,0,,上次我们讲到快速排序是N log N的运行时间
Dialogue: 0,0:00:52.30,0:00:59.79,英文,,0,0,0,,And we also showed you via proof that there was no better sorting algorithm if your sorting algorithm is comparing two items over
Dialogue: 0,0:00:52.30,0:00:59.79,中文,,0,0,0,,我们还通过证明向你们展示了  如果你们的排序算法为了将所有项目排序而反复比较两个项目
Dialogue: 0,0:00:59.79,0:01:06.68,英文,,0,0,0,,and over again in order to put all of the items in order.
Dialogue: 0,0:00:59.79,0:01:06.68,中文,,0,0,0,,那么就不存在比快速排序更好的排序算法了
Dialogue: 0,0:01:06.68,0:01:15.69,英文,,0,0,0,,That means even if we invented some new algorithm that's even better than quicksort, it will algorithmically be n log n in the worst case.
Dialogue: 0,0:01:06.68,0:01:15.69,中文,,0,0,0,,这意味着即使我们发明了一种比快速排序更好的新算法  它在最坏情况下在算法上也是N log N
Dialogue: 0,0:01:15.69,0:01:18.19,英文,,0,0,0,,So can we do better?
Dialogue: 0,0:01:15.69,0:01:18.19,中文,,0,0,0,,那么我们能做得更好吗？
Dialogue: 0,0:01:18.19,0:01:19.99,英文,,0,0,0,,That's the question we want to solve today.
Dialogue: 0,0:01:18.19,0:01:19.99,中文,,0,0,0,,这就是我们今天要解决的问题
Dialogue: 0,0:01:19.99,0:01:28.28,英文,,0,0,0,,Can we beat this n log n bound by maybe doing things that aren't comparing the numbers at all or the items that we're trying to sort?
Dialogue: 0,0:01:19.99,0:01:28.28,中文,,0,0,0,,我们是否可以通过不比较数字或我们要排序的项目来打破这个N log N的界限？
Dialogue: 0,0:01:28.28,0:01:29.40,英文,,0,0,0,,So that's what we're going to try to do.
Dialogue: 0,0:01:28.28,0:01:29.40,中文,,0,0,0,,所以这就是我们要尝试做的
Dialogue: 0,0:01:29.40,0:01:34.03,英文,,0,0,0,,We're going to beat n log n by avoiding the need to compare items.
Dialogue: 0,0:01:29.40,0:01:34.03,中文,,0,0,0,,我们将通过避免比较项目来打破N log N的限制
Dialogue: 0,0:01:34.03,0:01:35.25,英文,,0,0,0,,So I hope you're ready.
Dialogue: 0,0:01:34.03,0:01:35.25,中文,,0,0,0,,准备好了吗？
Dialogue: 0,0:01:35.25,0:01:37.29,英文,,0,0,0,,So here's our first idea of the day.
Dialogue: 0,0:01:35.25,0:01:37.29,中文,,0,0,0,,我们先来看看第一个想法
Dialogue: 0,0:01:37.29,0:01:38.01,英文,,0,0,0,,It's very silly.
Dialogue: 0,0:01:37.29,0:01:38.01,中文,,0,0,0,,有点傻
Dialogue: 0,0:01:38.01,0:01:40.07,英文,,0,0,0,,I think Justin mentioned it, too.
Dialogue: 0,0:01:38.01,0:01:40.07,中文,,0,0,0,,Justin好像也提过
Dialogue: 0,0:01:40.07,0:01:44.99,英文,,0,0,0,,But we'll start by talking about this one and then try to use it to build something that actually works.
Dialogue: 0,0:01:40.07,0:01:44.99,中文,,0,0,0,,我们先从这个想法开始  然后尝试用它构建一个真正可行的东西
Dialogue: 0,0:01:44.99,0:01:51.75,英文,,0,0,0,,So imagine if on my program, or on my computer, sorry, I started a bunch of programs,
Dialogue: 0,0:01:44.99,0:01:51.75,中文,,0,0,0,,想象一下  如果在我的程序中  或者在我的电脑上  我启动了一堆程序
Dialogue: 0,0:01:51.75,0:01:58.23,英文,,0,0,0,,one for every single number that I am trying to sort, and each program just waits for that number of seconds and then prints out the number.
Dialogue: 0,0:01:51.75,0:01:58.23,中文,,0,0,0,,每个程序对应我想要排序的每个数字  每个程序只需等待相应的秒数  然后打印出该数字
Dialogue: 0,0:01:58.23,0:02:04.88,英文,,0,0,0,,So if I have numbers, you know, like one, two, three, and ten, well then I'll start four programs on my computer.
Dialogue: 0,0:01:58.23,0:02:04.88,中文,,0,0,0,,例如  如果我有数字1、2、3和10  那么我将在我的电脑上启动四个程序
Dialogue: 0,0:02:04.88,0:02:07.84,英文,,0,0,0,,One of them will wait for one second and then shout out one.
Dialogue: 0,0:02:04.88,0:02:07.84,中文,,0,0,0,,其中一个程序将等待1秒  然后喊出1
Dialogue: 0,0:02:07.84,0:02:10.70,英文,,0,0,0,,Another one will wait for two seconds and then shout out two.
Dialogue: 0,0:02:07.84,0:02:10.70,中文,,0,0,0,,另一个程序将等待2秒  然后喊出2
Dialogue: 0,0:02:10.70,0:02:14.26,英文,,0,0,0,,Another one will wait for three seconds and then shout out three, and so forth.
Dialogue: 0,0:02:10.70,0:02:14.26,中文,,0,0,0,,另一个程序将等待3秒  然后喊出3  以此类推
Dialogue: 0,0:02:14.26,0:02:16.74,英文,,0,0,0,,All of them start at the same time.
Dialogue: 0,0:02:14.26,0:02:16.74,中文,,0,0,0,,所有程序同时开始
Dialogue: 0,0:02:16.74,0:02:19.34,英文,,0,0,0,,And it's kind of silly, but like this will work.
Dialogue: 0,0:02:16.74,0:02:19.34,中文,,0,0,0,,这有点傻  但它确实有效
Dialogue: 0,0:02:19.34,0:02:28.77,英文,,0,0,0,,It will Print out the numbers 1, 2, 3, and 10, or any other numbers you want to sort, in runtime that is n,
Dialogue: 0,0:02:19.34,0:02:28.77,中文,,0,0,0,,它会 按1、2、3和10的顺序打印出数字  或者你想排序的任何其他数字  运行时间为n
Dialogue: 0,0:02:28.77,0:02:35.81,英文,,0,0,0,,because you need n time to start n different programs, plus whatever the largest number is.
Dialogue: 0,0:02:28.77,0:02:35.81,中文,,0,0,0,,因为你需要n时间来启动n个不同的程序  加上最大的数字是多少
Dialogue: 0,0:02:35.81,0:02:39.21,英文,,0,0,0,,So if my largest number is 10, I have to wait for 10 seconds.
Dialogue: 0,0:02:35.81,0:02:39.21,中文,,0,0,0,,如果我最大的数字是10  我必须等待10秒
Dialogue: 0,0:02:39.21,0:02:42.63,英文,,0,0,0,,If my largest number is 100, I'd have to wait for 100 seconds.
Dialogue: 0,0:02:39.21,0:02:42.63,中文,,0,0,0,,如果我最大的数字是100  我必须等待100秒
Dialogue: 0,0:02:42.63,0:02:47.72,英文,,0,0,0,,But crucially, this bound, although it's kind of weird, is better than n log n.
Dialogue: 0,0:02:42.63,0:02:47.72,中文,,0,0,0,,但关键是  这个界限虽然有点奇怪  但比N log N要好
Dialogue: 0,0:02:47.72,0:02:53.60,英文,,0,0,0,,So I've defeated the n log n bound that I proved because I'm not really comparing the two numbers.
Dialogue: 0,0:02:47.72,0:02:53.60,中文,,0,0,0,,所以我打破了N log N的界限  因为我没有真正比较这两个数字
Dialogue: 0,0:02:53.60,0:02:58.08,英文,,0,0,0,,I'm not saying between one and three which one is greater than the other.
Dialogue: 0,0:02:53.60,0:02:58.08,中文,,0,0,0,,我没有说1和3之间哪个更大
Dialogue: 0,0:02:58.08,0:03:04.61,英文,,0,0,0,,I am just starting a bunch of programs at the same time and having each program shout out its number sometime in the future.
Dialogue: 0,0:02:58.08,0:03:04.61,中文,,0,0,0,,我只是同时启动了一堆程序  让每个程序在未来的某个时间喊出它的数字
Dialogue: 0,0:03:04.61,0:03:13.21,英文,,0,0,0,,So in some way I am exploiting space to make my sort faster and get around the n log n bound.
Dialogue: 0,0:03:04.61,0:03:13.21,中文,,0,0,0,,所以我在某种程度上是在利用空间来让我的排序更快  并绕过 N log N 的界限
Dialogue: 0,0:03:13.21,0:03:18.43,英文,,0,0,0,,Or I guess I'm exploiting time, because I'm throwing all of my answers to some predetermined point in the future.
Dialogue: 0,0:03:13.21,0:03:18.43,中文,,0,0,0,,或者我猜我是在利用时间  因为我把我的所有答案都扔到了未来某个预定的时间点
Dialogue: 0,0:03:18.43,0:03:22.27,英文,,0,0,0,,And hopefully, far in the future, I can collect all of my answers.
Dialogue: 0,0:03:18.43,0:03:22.27,中文,,0,0,0,,希望在遥远的未来  我可以收集我的所有答案
Dialogue: 0,0:03:22.27,0:03:27.61,英文,,0,0,0,,So as far as we know, maybe this is not true, but we think that sleep sort was invented by 4chan.
Dialogue: 0,0:03:22.27,0:03:27.61,中文,,0,0,0,,据我们所知  这可能不是真的  但我们认为睡眠排序是由 4chan 发明的
Dialogue: 0,0:03:27.61,0:03:29.63,英文,,0,0,0,,At least that's where we found it.
Dialogue: 0,0:03:27.61,0:03:29.63,中文,,0,0,0,,至少我们是在那里找到的
Dialogue: 0,0:03:29.63,0:03:33.56,英文,,0,0,0,,So I guess 4chan is good for racism and sleep sort.
Dialogue: 0,0:03:29.63,0:03:33.56,中文,,0,0,0,,所以我想 4chan 除了种族主义  还擅长睡眠排序
Dialogue: 0,0:03:33.56,0:03:36.43,英文,,0,0,0,,OK, good.
Dialogue: 0,0:03:33.56,0:03:36.43,中文,,0,0,0,,
Dialogue: 0,0:03:36.43,0:03:44.87,英文,,0,0,0,,Now, by the way, you can try to actually implement this, but it turns out that on your computer, this model of running programs in parallel doesn't really exist.
Dialogue: 0,0:03:36.43,0:03:44.87,中文,,0,0,0,,顺便说一下  你可以尝试实际实现它  但结果证明  在你的电脑上  这种并行运行程序的模型并不存在
Dialogue: 0,0:03:44.87,0:03:49.48,英文,,0,0,0,,In practice, your computer probably ends up sorting the numbers anyway, deep down.
Dialogue: 0,0:03:44.87,0:03:49.48,中文,,0,0,0,,实际上  你的电脑可能最终还是会对数字进行排序
Dialogue: 0,0:03:49.48,0:04:02.52,英文,,0,0,0,,But conceptually, I find it an interesting idea that you can use time to throw your answer into the future and get around the n log n bound by avoiding comparisons completely.
Dialogue: 0,0:03:49.48,0:04:02.52,中文,,0,0,0,,但在概念上  我认为这是一个有趣的想法  你可以利用时间把你的答案扔到未来  并通过完全避免比较来绕过 N log N 的界限
Dialogue: 0,0:04:02.52,0:04:09.71,英文,,0,0,0,,Very cool. So here's another example where instead of exploiting time, I'm going to exploit space.
Dialogue: 0,0:04:02.52,0:04:09.71,中文,,0,0,0,,很酷   所以这里还有另一个例子  我将利用空间而不是时间
Dialogue: 0,0:04:09.71,0:04:14.23,英文,,0,0,0,,So let's say I have these 12 pieces of data.
Dialogue: 0,0:04:09.71,0:04:14.23,中文,,0,0,0,,假设我有这 12 个数据
Dialogue: 0,0:04:14.23,0:04:15.71,英文,,0,0,0,,So there's 12 objects.
Dialogue: 0,0:04:14.23,0:04:15.71,中文,,0,0,0,,所以有 12 个对象
Dialogue: 0,0:04:15.71,0:04:18.37,英文,,0,0,0,,Each of them corresponds to some ID.
Dialogue: 0,0:04:15.71,0:04:18.37,中文,,0,0,0,,它们每个都对应一个 ID
Dialogue: 0,0:04:18.37,0:04:19.11,英文,,0,0,0,,There's a name.
Dialogue: 0,0:04:18.37,0:04:19.11,中文,,0,0,0,,还有一个名字
Dialogue: 0,0:04:19.11,0:04:23.12,英文,,0,0,0,,I guess this is their favorite ice cream or whatever, favorite band.
Dialogue: 0,0:04:19.11,0:04:23.12,中文,,0,0,0,,我想这是他们最喜欢的冰淇淋或者别的什么  最喜欢的乐队
Dialogue: 0,0:04:23.12,0:04:25.94,英文,,0,0,0,,But the important thing is I have 12 objects.
Dialogue: 0,0:04:23.12,0:04:25.94,中文,,0,0,0,,但重要的是我有 12 个对象
Dialogue: 0,0:04:25.94,0:04:31.18,英文,,0,0,0,,And it turns out each object has an ID that's a unique number between 0 and 11.
Dialogue: 0,0:04:25.94,0:04:31.18,中文,,0,0,0,,事实证明  每个对象的 ID 都是 0 到 11 之间的唯一数字
Dialogue: 0,0:04:31.18,0:04:39.46,英文,,0,0,0,,So exactly one person is ID 0, one person is ID 1, all the way up to exactly one person with ID number 11.
Dialogue: 0,0:04:31.18,0:04:39.46,中文,,0,0,0,,也就是说  恰好有一个人是ID 0  一个人是ID 1  以此类推  直到ID编号为 11 的人
Dialogue: 0,0:04:39.46,0:04:43.78,英文,,0,0,0,,So if I give you this guarantee ahead of time, I tell you, this isn't just any old array.
Dialogue: 0,0:04:39.46,0:04:43.78,中文,,0,0,0,,所以如果我提前给你这个保证  告诉你  这不是一个普通的数组
Dialogue: 0,0:04:43.78,0:04:50.43,英文,,0,0,0,,It's an array where there are exactly 12 items and everyone has a unique ID from 0 to 11.
Dialogue: 0,0:04:43.78,0:04:50.43,中文,,0,0,0,,这是一个包含 12 个元素的数组  每个元素都有一个从 0 到 11 的唯一 ID
Dialogue: 0,0:04:50.43,0:04:58.31,英文,,0,0,0,,Well, then maybe I can do something smarter than, say, merge sorting or quick sorting, which would require me to compare all the items over and over.
Dialogue: 0,0:04:50.43,0:04:58.31,中文,,0,0,0,,那么  也许我可以做一些比合并排序或快速排序更聪明的事情  后者需要我一遍又一遍地比较所有元素
Dialogue: 0,0:04:58.31,0:05:03.85,英文,,0,0,0,,So if I was doing merge sort, I'd have to compare 9 and 4, which one's greater, and do some swapping.
Dialogue: 0,0:04:58.31,0:05:03.85,中文,,0,0,0,,所以如果我使用合并排序  我必须比较 9 和 4  哪个更大  并进行一些交换
Dialogue: 0,0:05:03.85,0:05:10.96,英文,,0,0,0,,But if I'm telling you that everything is a unique integer between 0 and 11, well, then maybe I can do something smarter.
Dialogue: 0,0:05:03.85,0:05:10.96,中文,,0,0,0,,但是如果我告诉你每个元素都是 0 到 11 之间的唯一整数  那么也许我可以做一些更聪明的事情
Dialogue: 0,0:05:10.96,0:05:13.92,英文,,0,0,0,,So for example, I start at the top.
Dialogue: 0,0:05:10.96,0:05:13.92,中文,,0,0,0,,例如  我从顶部开始
Dialogue: 0,0:05:13.92,0:05:18.42,英文,,0,0,0,,So this item, if I'm sorting by ID, it has ID number 5.
Dialogue: 0,0:05:13.92,0:05:18.42,中文,,0,0,0,,如果我按 ID 排序  这个元素的 ID 编号是 5
Dialogue: 0,0:05:18.42,0:05:20.55,英文,,0,0,0,,And here's my results array.
Dialogue: 0,0:05:18.42,0:05:20.55,中文,,0,0,0,,这是我的结果数组
Dialogue: 0,0:05:20.55,0:05:27.55,英文,,0,0,0,,And I know, I'm telling you ahead of time that there's exactly one ID with 5, and all the IDs from 0 to 11 are unique.
Dialogue: 0,0:05:20.55,0:05:27.55,中文,,0,0,0,,我事先告诉你  ID 为 5 的元素只有一个  并且所有 ID 从 0 到 11 都是唯一的
Dialogue: 0,0:05:27.55,0:05:32.39,英文,,0,0,0,,So if that's true, then what index should item number 5 go in?
Dialogue: 0,0:05:27.55,0:05:32.39,中文,,0,0,0,,那么如果是这样的话  ID 编号为 5 的元素应该放在哪个索引位置？
Dialogue: 0,0:05:32.39,0:05:40.24,英文,,0,0,0,,It's got to go in index number 5, because all the IDs are unique, and we count upwards from 0 to 11.
Dialogue: 0,0:05:32.39,0:05:40.24,中文,,0,0,0,,它必须放在索引编号为 5 的位置  因为所有 ID 都是唯一的  并且我们从 0 到 11 向上计数
Dialogue: 0,0:05:40.24,0:05:43.64,英文,,0,0,0,,Then I go to the next item, which is this Lauren record.
Dialogue: 0,0:05:40.24,0:05:43.64,中文,,0,0,0,,然后我转到下一个元素  这是 Lauren 的记录
Dialogue: 0,0:05:43.64,0:05:45.89,英文,,0,0,0,,Where does Lauren go in this array?
Dialogue: 0,0:05:43.64,0:05:45.89,中文,,0,0,0,,Lauren 应该放在这个数组的哪个位置？
Dialogue: 0,0:05:45.89,0:05:48.28,英文,,0,0,0,,If I just have to look, I don't have to do any comparisons at all.
Dialogue: 0,0:05:45.89,0:05:48.28,中文,,0,0,0,,如果我只需要看一眼  我根本不需要做任何比较
Dialogue: 0,0:05:48.28,0:05:51.30,英文,,0,0,0,,I don't have to think, is this 0 less than 5 greater than 5?
Dialogue: 0,0:05:48.28,0:05:51.30,中文,,0,0,0,,我不需要考虑  这个 0 的 Lauren 记录是小于 5 还是大于 5？
Dialogue: 0,0:05:51.30,0:05:53.18,英文,,0,0,0,,I don't have to think about that at all.
Dialogue: 0,0:05:51.30,0:05:53.18,中文,,0,0,0,,我根本不需要考虑这个问题
Dialogue: 0,0:05:53.18,0:06:00.79,英文,,0,0,0,,If I just ask you, this 0 Lauren record, if I give you what I know about these IDs, where's this Lauren going?
Dialogue: 0,0:05:53.18,0:06:00.79,中文,,0,0,0,,如果我问你  这个 0 的 Lauren 记录  如果我告诉你我对这些 ID 的了解  这个 Lauren 会放在哪里？
Dialogue: 0,0:06:00.79,0:06:03.93,英文,,0,0,0,,You can answer this instantly without having to do any comparisons.
Dialogue: 0,0:06:00.79,0:06:03.93,中文,,0,0,0,,你可以立即回答这个问题  而无需进行任何比较
Dialogue: 0,0:06:03.93,0:06:05.68,英文,,0,0,0,,Where's the Lauren going?
Dialogue: 0,0:06:03.93,0:06:05.68,中文,,0,0,0,,Lauren 会放在哪里？
Dialogue: 0,0:06:05.68,0:06:09.81,英文,,0,0,0,,I think it's going right there, because it's ID number 0.
Dialogue: 0,0:06:05.68,0:06:09.81,中文,,0,0,0,,我觉得它会放在那里  因为它的ID是0
Dialogue: 0,0:06:09.81,0:06:12.73,英文,,0,0,0,,Then I go to the next one, Lisa, ID number 11.
Dialogue: 0,0:06:09.81,0:06:12.73,中文,,0,0,0,,接下来看下一个  Lisa  ID是11
Dialogue: 0,0:06:12.73,0:06:13.61,英文,,0,0,0,,Where is it going?
Dialogue: 0,0:06:12.73,0:06:13.61,中文,,0,0,0,,它会放在哪里？
Dialogue: 0,0:06:13.61,0:06:16.09,英文,,0,0,0,,Again, I don't have to do any sort of comparisons.
Dialogue: 0,0:06:13.61,0:06:16.09,中文,,0,0,0,,同样地  我不用进行任何比较
Dialogue: 0,0:06:16.09,0:06:18.49,英文,,0,0,0,,I know it's going in index number 11.
Dialogue: 0,0:06:16.09,0:06:18.49,中文,,0,0,0,,我知道它会放在索引号为11的位置
Dialogue: 0,0:06:18.49,0:06:20.39,英文,,0,0,0,,And this process goes on and on.
Dialogue: 0,0:06:18.49,0:06:20.39,中文,,0,0,0,,这个过程会一直持续下去
Dialogue: 0,0:06:20.39,0:06:27.90,英文,,0,0,0,,And eventually, I'm able to take every item and put it exactly in its right place without having to do any comparisons at all.
Dialogue: 0,0:06:20.39,0:06:27.90,中文,,0,0,0,,最终  我能够将每个元素都放到正确的位置  而不需要进行任何比较
Dialogue: 0,0:06:27.90,0:06:34.02,英文,,0,0,0,,And I exploited the fact that these numbers are all unique and increasing.
Dialogue: 0,0:06:27.90,0:06:34.02,中文,,0,0,0,,我利用了这些数字都是唯一且递增的这个事实
Dialogue: 0,0:06:34.02,0:06:35.00,英文,,0,0,0,,OK, great.
Dialogue: 0,0:06:34.02,0:06:35.00,中文,,0,0,0,,好的  很好
Dialogue: 0,0:06:35.00,0:06:41.54,英文,,0,0,0,,So in a way, this is exploiting not time, like sleep story where I was throwing the answer into the future.
Dialogue: 0,0:06:35.00,0:06:41.54,中文,,0,0,0,,在某种程度上  这利用的不是时间  就像睡眠故事里我把答案扔到未来一样
Dialogue: 0,0:06:41.54,0:06:48.87,英文,,0,0,0,,Here I'm kind of exploiting space, where I know that my answer is going to be in this predetermined array of size 11,
Dialogue: 0,0:06:41.54,0:06:48.87,中文,,0,0,0,,这里我有点像是在利用空间  因为我知道我的答案会在这个预先设定好的大小为11的数组中
Dialogue: 0,0:06:48.87,0:06:51.89,英文,,0,0,0,,and I'm slotting every single item into its correct space.
Dialogue: 0,0:06:48.87,0:06:51.89,中文,,0,0,0,,我把每个元素都放到了它正确的位置
Dialogue: 0,0:06:51.89,0:06:55.01,英文,,0,0,0,,So somehow exploiting space instead of time.
Dialogue: 0,0:06:51.89,0:06:55.01,中文,,0,0,0,,某种程度上是利用了空间而不是时间
Dialogue: 0,0:06:55.01,0:06:59.85,英文,,0,0,0,,But the really cool thing about what we just did is think about the runtime of what you just did.
Dialogue: 0,0:06:55.01,0:06:59.85,中文,,0,0,0,,但我们刚才做的事情真正酷的地方在于  想想你刚才做的事情的运行时间
Dialogue: 0,0:06:59.85,0:07:06.37,英文,,0,0,0,,The runtime is theta of n, because how long did it take to slot each item into its correct place?
Dialogue: 0,0:06:59.85,0:07:06.37,中文,,0,0,0,,运行时间是Θ(N)  因为把每个元素放到正确的位置需要多长时间？
Dialogue: 0,0:07:06.37,0:07:08.25,英文,,0,0,0,,It took theta of one time.
Dialogue: 0,0:07:06.37,0:07:08.25,中文,,0,0,0,,只需要Θ(1)的时间
Dialogue: 0,0:07:08.25,0:07:11.69,英文,,0,0,0,,I just had to take the index and say, this goes in index number five.
Dialogue: 0,0:07:08.25,0:07:11.69,中文,,0,0,0,,我只需要取索引然后说  这个放在索引号为5的位置
Dialogue: 0,0:07:11.69,0:07:13.76,英文,,0,0,0,,Put it in index number five.
Dialogue: 0,0:07:11.69,0:07:13.76,中文,,0,0,0,,把它放在索引号为5的位置
Dialogue: 0,0:07:13.76,0:07:18.74,英文,,0,0,0,,And so each item took theta of 1 time to put in its correct place.
Dialogue: 0,0:07:13.76,0:07:18.74,中文,,0,0,0,,所以每个元素只需要Θ(1)的时间就可以放到正确的位置
Dialogue: 0,0:07:18.74,0:07:20.14,英文,,0,0,0,,There are n items.
Dialogue: 0,0:07:18.74,0:07:20.14,中文,,0,0,0,,有N个元素
Dialogue: 0,0:07:20.14,0:07:23.89,英文,,0,0,0,,So the total sorting only took me theta of n time.
Dialogue: 0,0:07:20.14,0:07:23.89,中文,,0,0,0,,所以整个排序只需要Θ(N)的时间
Dialogue: 0,0:07:23.89,0:07:28.85,英文,,0,0,0,,And I was able to completely avoid the n log n bound that I saw from earlier.
Dialogue: 0,0:07:23.89,0:07:28.85,中文,,0,0,0,,这样我就完全避免了之前提到的N log N界限
Dialogue: 0,0:07:28.85,0:07:34.88,英文,,0,0,0,,And the reason why I was able to do that is because I don't have to compare any of the items against each other.
Dialogue: 0,0:07:28.85,0:07:34.88,中文,,0,0,0,,之所以能够做到这一点  是因为我不需要将任何项目相互比较
Dialogue: 0,0:07:34.88,0:07:38.34,英文,,0,0,0,,I just had to take every item and put them in the rightful place.
Dialogue: 0,0:07:34.88,0:07:38.34,中文,,0,0,0,,我只需要取每个项目并将它们放在正确的位置
Dialogue: 0,0:07:38.34,0:07:46.04,英文,,0,0,0,,But this required a pretty big assumption ahead of time, which is somebody had to tell you and guarantee to you
Dialogue: 0,0:07:38.34,0:07:45.04,中文,,0,0,0,,但这需要事先做出一个很大的假设  那就是必须有人告诉你并向你保证
Dialogue: 0,0:07:45.04,0:07:50.62,中文,,0,0,0,,你正在排序的所有东西  也就是键  都是从0到N-1的唯一数字
Dialogue: 0,0:07:46.04,0:07:50.62,英文,,0,0,0,,that all of the things you're sorting on, the keys, were unique numbers from 0 to n minus 1.
Dialogue: 0,0:07:50.62,0:07:56.09,英文,,0,0,0,,There's exactly one of each, no duplicates, and they're all consecutive increasing numbers.
Dialogue: 0,0:07:50.62,0:07:56.09,中文,,0,0,0,,每个数字都只有一个  没有重复  而且它们都是连续递增的数字
Dialogue: 0,0:07:56.09,0:08:01.89,英文,,0,0,0,,So if you have that very specific assumption, I can sort in theta of n time.
Dialogue: 0,0:07:56.09,0:08:01.89,中文,,0,0,0,,如果你有这个非常具体的假设  我可以在Θ(N)时间内进行排序
Dialogue: 0,0:08:01.89,0:08:04.83,英文,,0,0,0,,But what if I don't have that very specific assumption?
Dialogue: 0,0:08:01.89,0:08:04.83,中文,,0,0,0,,但如果我没有这个非常具体的假设呢?
Dialogue: 0,0:08:04.83,0:08:06.99,英文,,0,0,0,,So what if there are non-unique keys?
Dialogue: 0,0:08:04.83,0:08:06.99,中文,,0,0,0,,如果存在非唯一键怎么办?
Dialogue: 0,0:08:06.99,0:08:10.66,英文,,0,0,0,,Maybe two people have the same numbers, two people with ID 1.
Dialogue: 0,0:08:06.99,0:08:10.66,中文,,0,0,0,,也许两个人有相同的数字  两个人都有ID 1
Dialogue: 0,0:08:10.66,0:08:12.02,英文,,0,0,0,,How do you sort that?
Dialogue: 0,0:08:10.66,0:08:12.02,中文,,0,0,0,,你如何排序?
Dialogue: 0,0:08:12.02,0:08:13.56,英文,,0,0,0,,What if the keys are non-consecutive?
Dialogue: 0,0:08:12.02,0:08:13.56,中文,,0,0,0,,如果键不连续怎么办?
Dialogue: 0,0:08:13.56,0:08:18.98,英文,,0,0,0,,So for example, instead of the numbers all increasing, you have something like 0, 1, 2, and then 10.
Dialogue: 0,0:08:13.56,0:08:18.98,中文,,0,0,0,,例如  不是所有数字都递增  而是像0、1、2  然后是10这样的数字
Dialogue: 0,0:08:18.98,0:08:20.65,英文,,0,0,0,,How do you sort those numbers?
Dialogue: 0,0:08:18.98,0:08:20.65,中文,,0,0,0,,你如何排序这些数字?
Dialogue: 0,0:08:20.65,0:08:22.03,英文,,0,0,0,,What if the keys aren't even numbers?
Dialogue: 0,0:08:20.65,0:08:22.03,中文,,0,0,0,,如果键不是偶数怎么办?
Dialogue: 0,0:08:22.03,0:08:23.99,英文,,0,0,0,,What if they're strings or pictures?
Dialogue: 0,0:08:22.03,0:08:23.99,中文,,0,0,0,,如果它们是字符串或图片怎么办?
Dialogue: 0,0:08:23.99,0:08:25.51,英文,,0,0,0,,How do you sort those?
Dialogue: 0,0:08:23.99,0:08:25.51,中文,,0,0,0,,你如何排序这些?
Dialogue: 0,0:08:25.51,0:08:34.22,英文,,0,0,0,,So we can generalize this, but is everyone OK with the first idea, which is I have consecutive numbers, I slot them in the right place?
Dialogue: 0,0:08:25.51,0:08:34.22,中文,,0,0,0,,所以我们可以推广这个概念  但是所有人都同意第一个想法吗  也就是我有连续的数字  我把它们放在正确的位置?
Dialogue: 0,0:08:34.22,0:08:37.15,英文,,0,0,0,,OK. Cool.
Dialogue: 0,0:08:34.22,0:08:37.15,中文,,0,0,0,,好的   太棒了
Dialogue: 0,0:08:37.15,0:08:41.01,英文,,0,0,0,,So here's an example where the keys are no longer unique.
Dialogue: 0,0:08:37.15,0:08:41.01,中文,,0,0,0,,这里有一个例子  其中键不再是唯一的
Dialogue: 0,0:08:41.01,0:08:46.02,英文,,0,0,0,,So unlike the previous page, where every single number was unique, now I still have a bunch of names,
Dialogue: 0,0:08:41.01,0:08:46.02,中文,,0,0,0,,与前一页不同的是  前一页每个数字都是唯一的  现在我仍然有一堆名字
Dialogue: 0,0:08:46.02,0:08:50.44,英文,,0,0,0,, and everyone has not a number, but they have a card suit.
Dialogue: 0,0:08:46.02,0:08:50.44,中文,,0,0,0,,每个人都没有数字  但他们都有一个扑克牌花色
Dialogue: 0,0:08:50.44,0:08:53.92,英文,,0,0,0,,And I want you to sort these names in order of card suit.
Dialogue: 0,0:08:50.44,0:08:53.92,中文,,0,0,0,,我希望你按照花色对这些名字进行排序
Dialogue: 0,0:08:53.92,0:09:00.08,英文,,0,0,0,,So the order I want is I want the clubs to come first, then the spades, then the hearts, then the diamonds.
Dialogue: 0,0:08:53.92,0:09:00.08,中文,,0,0,0,,我想要的顺序是梅花优先  然后是黑桃  然后是红桃  最后是方块
Dialogue: 0,0:09:00.08,0:09:01.87,英文,,0,0,0,,And I want to use the same strategy as before.
Dialogue: 0,0:09:00.08,0:09:01.87,中文,,0,0,0,,我想使用和之前相同的策略
Dialogue: 0,0:09:01.87,0:09:06.95,英文,,0,0,0,,So I don't want to compare all these people against each other to see who has the greater card suit.
Dialogue: 0,0:09:01.87,0:09:06.95,中文,,0,0,0,,我不想把所有这些人相互比较  看看谁的花色更大
Dialogue: 0,0:09:06.95,0:09:13.63,英文,,0,0,0,,I want to be able to take each person and slot them into the correct place in the sorted array in constant time.
Dialogue: 0,0:09:06.95,0:09:13.63,中文,,0,0,0,,我希望能够把每个人都放在排序数组中的正确位置  并且时间复杂度是常数级别的
Dialogue: 0,0:09:13.63,0:09:17.66,英文,,0,0,0,,So I want to take, for example, Lauren and immediately put them in the right place.
Dialogue: 0,0:09:13.63,0:09:17.66,中文,,0,0,0,,我想比如把Lauren直接放在正确的位置
Dialogue: 0,0:09:17.66,0:09:21.88,英文,,0,0,0,,And they take Delbert and immediately put them in the right place, and so forth.
Dialogue: 0,0:09:17.66,0:09:21.88,中文,,0,0,0,,然后把Delbert直接放在正确的位置  以此类推
Dialogue: 0,0:09:21.88,0:09:25.58,英文,,0,0,0,,This way, I only have to scan the array front to back exactly once.
Dialogue: 0,0:09:21.88,0:09:25.58,中文,,0,0,0,,这样  我只需要从头到尾扫描数组一次
Dialogue: 0,0:09:25.58,0:09:28.76,英文,,0,0,0,,And hopefully, I get theta of n runtime.
Dialogue: 0,0:09:25.58,0:09:28.76,中文,,0,0,0,,希望我得到 Θ(N) 的运行时间
Dialogue: 0,0:09:28.76,0:09:36.05,英文,,0,0,0,,But this is a little trickier from last time, because last time, if I had someone with index 5, I could just put them in index number 5.
Dialogue: 0,0:09:28.76,0:09:36.05,中文,,0,0,0,,但这比上次有点棘手  因为上次  如果我有一个索引为 5 的人  我可以直接把他们放在索引号 5
Dialogue: 0,0:09:36.05,0:09:45.39,英文,,0,0,0,,But this time, let's say I have Delbert, who is of type heart, except there is no such thing as the heart element of this array.
Dialogue: 0,0:09:36.05,0:09:45.39,中文,,0,0,0,,但这次  假设我有Delbert  他是红桃类型的  除非这个数组没有红桃元素这样的东西
Dialogue: 0,0:09:45.39,0:09:52.60,英文,,0,0,0,,So question for you is, just by looking at this array, maybe you can do some counting ahead of time, what is the index of the first heart?
Dialogue: 0,0:09:45.39,0:09:52.60,中文,,0,0,0,,所以问题是  仅仅通过查看这个数组  也许你可以提前做一些计数  第一个红桃的索引是多少？
Dialogue: 0,0:09:52.60,0:09:56.74,英文,,0,0,0,,I know it's kind of small, hard to read, but where do you think the first heart goes?
Dialogue: 0,0:09:52.60,0:09:56.74,中文,,0,0,0,,我知道它有点小  很难读  但你觉得第一个红桃应该放在哪里？
Dialogue: 0,0:09:56.74,0:09:59.68,英文,,0,0,0,,And you can use this table to maybe help you deduce it.
Dialogue: 0,0:09:56.74,0:09:59.68,中文,,0,0,0,,你可以用这个表格来帮助你推断
Dialogue: 0,0:09:59.68,0:10:03.18,英文,,0,0,0,,So like, is Delber going to go here at index number 0?
Dialogue: 0,0:09:59.68,0:10:03.18,中文,,0,0,0,,比如  Delbert会放在这里索引号 0 吗？
Dialogue: 0,0:10:03.18,0:10:05.75,英文,,0,0,0,,Is Delber going to slot in here at index number 11?
Dialogue: 0,0:10:03.18,0:10:05.75,中文,,0,0,0,,Delbert会放在这里索引号 11 吗？
Dialogue: 0,0:10:05.75,0:10:09.87,英文,,0,0,0,,How do we know where this heart is going to go?
Dialogue: 0,0:10:05.75,0:10:09.87,中文,,0,0,0,,我们怎么知道这个红桃会放在哪里？
Dialogue: 0,0:10:09.87,0:10:18.44,英文,,0,0,0,,Well, one thing I can do is if I look at this ordering, I know that all of the black suits, that is clubs and spades, they come before hearts.
Dialogue: 0,0:10:09.87,0:10:18.44,中文,,0,0,0,,好吧  我能做的一件事是  如果我看看这个顺序  我知道所有的黑色花色  也就是梅花和黑桃  它们都在红桃之前
Dialogue: 0,0:10:18.44,0:10:22.54,英文,,0,0,0,,So how many clubs and spades are there in this list?
Dialogue: 0,0:10:18.44,0:10:22.54,中文,,0,0,0,,那么  这个列表中总共有多少梅花和黑桃呢？
Dialogue: 0,0:10:22.54,0:10:26.20,英文,,0,0,0,,Well, one, two, three, four, five.
Dialogue: 0,0:10:22.54,0:10:26.20,中文,,0,0,0,,嗯  1  2  3  4  5
Dialogue: 0,0:10:26.20,0:10:33.06,英文,,0,0,0,,In other words, I know the indices number 0, 1, 2, 3, and 4 will all be filled with clubs and spades.
Dialogue: 0,0:10:26.20,0:10:33.06,中文,,0,0,0,,换句话说  我知道索引编号0、1、2、3和4都会填满梅花和黑桃
Dialogue: 0,0:10:33.06,0:10:38.31,英文,,0,0,0,,So that the next suit, the red heart, starts here at number 5.
Dialogue: 0,0:10:33.06,0:10:38.31,中文,,0,0,0,,这样下一种花色  红心  就从编号5开始
Dialogue: 0,0:10:38.31,0:10:49.94,英文,,0,0,0,,So somehow by scanning the array and counting the number of black suits, I can tell you that the first heart, that is Delbert, is going to appear in index number 5.
Dialogue: 0,0:10:38.31,0:10:49.94,中文,,0,0,0,,所以通过扫描数组并计算黑色花色的数量  我可以告诉你  第一张红心  也就是Delbert  将出现在索引编号5中
Dialogue: 0,0:10:49.94,0:10:52.09,英文,,0,0,0,,OK, good. So how can I generalize this?
Dialogue: 0,0:10:49.94,0:10:52.09,中文,,0,0,0,,好的   那么我如何将其推广？
Dialogue: 0,0:10:52.09,0:10:56.55,英文,,0,0,0,,Well, maybe I can use the same strategy to figure out, where are the spades going?
Dialogue: 0,0:10:52.09,0:10:56.55,中文,,0,0,0,,嗯  也许我可以使用相同的策略来找出黑桃的位置？
Dialogue: 0,0:10:56.55,0:10:57.69,英文,,0,0,0,,And where are the clubs going?
Dialogue: 0,0:10:56.55,0:10:57.69,中文,,0,0,0,,还有梅花的位置？
Dialogue: 0,0:10:57.69,0:10:59.01,英文,,0,0,0,,And where are the hearts going?
Dialogue: 0,0:10:57.69,0:10:59.01,中文,,0,0,0,,还有红心的位置？
Dialogue: 0,0:10:59.01,0:11:00.83,英文,,0,0,0,,And where are the diamonds going?
Dialogue: 0,0:10:59.01,0:11:00.83,中文,,0,0,0,,还有方块的位置？
Dialogue: 0,0:11:00.83,0:11:09.18,英文,,0,0,0,,And then as I scan through this array a single time, I can put every item in its rightful place without having to do any compares.
Dialogue: 0,0:11:00.83,0:11:09.18,中文,,0,0,0,,然后  当我一次扫描这个数组时  我可以把每个项目都放在它正确的位置上  而不需要进行任何比较
Dialogue: 0,0:11:09.18,0:11:11.34,英文,,0,0,0,,That's the key that makes all of these sorts work.
Dialogue: 0,0:11:09.18,0:11:11.34,中文,,0,0,0,,这就是让所有这些排序工作都奏效的关键
Dialogue: 0,0:11:11.34,0:11:14.48,英文,,0,0,0,,And fast is I don't have to do any comparing.
Dialogue: 0,0:11:11.34,0:11:14.48,中文,,0,0,0,,而且很快  因为我不需要做任何比较
Dialogue: 0,0:11:14.48,0:11:17.59,英文,,0,0,0,,So a question?
Dialogue: 0,0:11:14.48,0:11:17.59,中文,,0,0,0,,有个问题？
Dialogue: 0,0:11:17.59,0:11:19.35,英文,,0,0,0,,Yeah, the question was, do I have to scan twice?
Dialogue: 0,0:11:17.59,0:11:19.35,中文,,0,0,0,,问题是我是否需要扫描两次？
Dialogue: 0,0:11:19.35,0:11:25.53,英文,,0,0,0,,I do, which is what I want to show you right now, which is you have to count the number of times each item occurs
Dialogue: 0,0:11:19.35,0:11:25.53,中文,,0,0,0,,是的  这就是我现在想向你展示的  那就是你必须计算每个项目出现的次数
Dialogue: 0,0:11:25.53,0:11:28.99,英文,,0,0,0,,so that you can figure out what ranges correspond to each suit.
Dialogue: 0,0:11:25.53,0:11:28.99,中文,,0,0,0,,这样你才能弄清楚哪些范围对应于每种花色
Dialogue: 0,0:11:28.99,0:11:35.51,英文,,0,0,0,,And then you'll scan it a second time using your calculations from earlier to decide where everything goes.
Dialogue: 0,0:11:28.99,0:11:35.51,中文,,0,0,0,,然后  你将使用你之前的计算结果再次扫描它  以决定每个项目的位置
Dialogue: 0,0:11:35.51,0:11:37.49,英文,,0,0,0,,So yes, we're going to do two scans.
Dialogue: 0,0:11:35.51,0:11:37.49,中文,,0,0,0,,是的  我们要扫描两次
Dialogue: 0,0:11:37.49,0:11:40.01,英文,,0,0,0,,But still, each scan is theta of n time.
Dialogue: 0,0:11:37.49,0:11:40.01,中文,,0,0,0,,但是  每次扫描仍然是Θ(N)时间
Dialogue: 0,0:11:40.01,0:11:45.18,英文,,0,0,0,,So we're still going to dodge the n log n bound that was causing us so much pain from earlier.
Dialogue: 0,0:11:40.01,0:11:45.18,中文,,0,0,0,,所以我们仍然可以避开之前给我们带来这么多痛苦的N log N边界
Dialogue: 0,0:11:45.18,0:11:46.20,英文,,0,0,0,,Was it causing us pain?
Dialogue: 0,0:11:45.18,0:11:46.20,中文,,0,0,0,,它之前让我们痛苦了吗？
Dialogue: 0,0:11:46.20,0:11:47.96,英文,,0,0,0,,I don't know, but it is now.
Dialogue: 0,0:11:46.20,0:11:47.96,中文,,0,0,0,,不知道  不过现在是的
Dialogue: 0,0:11:47.96,0:11:49.76,英文,,0,0,0,,OK, so let's do it.
Dialogue: 0,0:11:47.96,0:11:49.76,中文,,0,0,0,,好  那我们开始吧
Dialogue: 0,0:11:49.76,0:11:55.62,英文,,0,0,0,,So I go through this array, and I'm going to scan it just once to figure out exactly where all the items go.
Dialogue: 0,0:11:49.76,0:11:55.62,中文,,0,0,0,,我要遍历这个数组  并且只扫描一次  来确定所有项目的去向
Dialogue: 0,0:11:55.62,0:12:05.23,英文,,0,0,0,,So as I scan, I will keep counts of how many spades there are, how many clubs there are, how many hearts, how many diamonds.
Dialogue: 0,0:11:55.62,0:12:05.23,中文,,0,0,0,,在扫描的过程中  我会统计黑桃、梅花、红桃和方块的数量
Dialogue: 0,0:12:05.23,0:12:16.76,英文,,0,0,0,,Hopefully it's not too extraordinary to convince you that I can scan this once and then tell you that there are three clubs, two hearts, four diamonds, four hearts, and three diamonds.
Dialogue: 0,0:12:05.23,0:12:16.76,中文,,0,0,0,,希望不会太难让你相信  我只需扫描一次  就能告诉你这里有三张梅花、两张红桃、四张方块和四张红桃
Dialogue: 0,0:12:16.76,0:12:19.02,英文,,0,0,0,,Scan the array once and just count them all up.
Dialogue: 0,0:12:16.76,0:12:19.02,中文,,0,0,0,,扫描数组一次  然后把它们都数出来
Dialogue: 0,0:12:19.02,0:12:21.20,英文,,0,0,0,,Hopefully not controversial.
Dialogue: 0,0:12:19.02,0:12:21.20,中文,,0,0,0,,希望这没有争议
Dialogue: 0,0:12:21.20,0:12:22.98,英文,,0,0,0,,Okay, good.
Dialogue: 0,0:12:21.20,0:12:22.98,中文,,0,0,0,,
Dialogue: 0,0:12:22.98,0:12:30.74,英文,,0,0,0,,Here's the part that's a little bit weird, which is once I know these counts, I can now give you ranges in which each of the four suits go.
Dialogue: 0,0:12:22.98,0:12:30.74,中文,,0,0,0,,有点奇怪的地方是  一旦我知道了这些数量  我就可以告诉你每种花色的范围
Dialogue: 0,0:12:30.74,0:12:38.06,英文,,0,0,0,,I know that the clubs are the smallest suit, and there's three of them, so I should reserve spots 0, 1, and 2 for the clubs.
Dialogue: 0,0:12:30.74,0:12:38.06,中文,,0,0,0,,我知道梅花是最小的花色  有三张  所以我应该为梅花保留位置 0、1 和 2
Dialogue: 0,0:12:38.06,0:12:47.29,英文,,0,0,0,,And the way I'm going to denote that, you can denote it some other way, but I will denote it as the clubs start at number for index number 0, and they go 0, 1, and 2.
Dialogue: 0,0:12:38.06,0:12:47.29,中文,,0,0,0,,我将这样表示  你也可以用其他方式表示  但我将表示为梅花从索引号 0 开始  范围是 0、1 和 2
Dialogue: 0,0:12:47.29,0:12:49.45,英文,,0,0,0,,And then the spades. There's two of those.
Dialogue: 0,0:12:47.29,0:12:49.45,中文,,0,0,0,,然后是黑桃   有两张
Dialogue: 0,0:12:49.45,0:12:53.05,英文,,0,0,0,,I don't know who they are yet, because I've only scanned the array once.
Dialogue: 0,0:12:49.45,0:12:53.05,中文,,0,0,0,,我还不知道它们是谁  因为我只扫描了数组一次
Dialogue: 0,0:12:53.05,0:12:56.33,英文,,0,0,0,,But I know that the spades will go in indices number three and four.
Dialogue: 0,0:12:53.05,0:12:56.33,中文,,0,0,0,,但我知道黑桃将在索引号 3 和 4 中
Dialogue: 0,0:12:56.33,0:13:02.00,英文,,0,0,0,,So I'll denote that by writing three, the first index of the spade range.
Dialogue: 0,0:12:56.33,0:13:02.00,中文,,0,0,0,,所以我将通过写 3 来表示  它是黑桃范围的第一个索引
Dialogue: 0,0:13:02.00,0:13:03.90,英文,,0,0,0,,Then the hearts come. And there's four of those.
Dialogue: 0,0:13:02.00,0:13:03.90,中文,,0,0,0,,然后是红桃   有四张
Dialogue: 0,0:13:03.90,0:13:06.64,英文,,0,0,0,,I know they're going to take up indices number 5, 6, 7, 8.
Dialogue: 0,0:13:03.90,0:13:06.64,中文,,0,0,0,,我知道它们将占据索引号 5、6、7、8
Dialogue: 0,0:13:06.64,0:13:09.09,英文,,0,0,0,,So I'll write down that the hearts start at number 5.
Dialogue: 0,0:13:06.64,0:13:09.09,中文,,0,0,0,,所以红桃从编号 5 开始
Dialogue: 0,0:13:09.09,0:13:13.73,英文,,0,0,0,,And then finally, the diamonds will take up indices number 9, 10, and 11.
Dialogue: 0,0:13:09.09,0:13:13.73,中文,,0,0,0,,最后  方块将占据编号 9、10 和 11 的位置
Dialogue: 0,0:13:13.73,0:13:18.47,英文,,0,0,0,,So I'll write down 9 to indicate that's where the range of diamonds start.
Dialogue: 0,0:13:13.73,0:13:18.47,中文,,0,0,0,,所以我写下 9 表示方块的范围从这里开始
Dialogue: 0,0:13:18.47,0:13:21.41,英文,,0,0,0,,So so far, I've expended theta of n work.
Dialogue: 0,0:13:18.47,0:13:21.41,中文,,0,0,0,,到目前为止  我已经花费了 Θ(N) 的工作量
Dialogue: 0,0:13:21.41,0:13:23.39,英文,,0,0,0,,I scanned the entire array.
Dialogue: 0,0:13:21.41,0:13:23.39,中文,,0,0,0,,我扫描了整个数组
Dialogue: 0,0:13:23.39,0:13:24.93,英文,,0,0,0,,I put together the counts.
Dialogue: 0,0:13:23.39,0:13:24.93,中文,,0,0,0,,我把计数放在一起
Dialogue: 0,0:13:24.93,0:13:31.90,英文,,0,0,0,,And then I used them to determine exactly where each suit is going to go.
Dialogue: 0,0:13:24.93,0:13:31.90,中文,,0,0,0,,然后我用它们来确定每种花色将要放在哪里
Dialogue: 0,0:13:31.90,0:13:34.87,英文,,0,0,0,,Now here comes the fun part, which is I'm going to scan a second time.
Dialogue: 0,0:13:31.90,0:13:34.87,中文,,0,0,0,,现在有趣的部分来了  我将进行第二次扫描
Dialogue: 0,0:13:34.87,0:13:40.79,英文,,0,0,0,,This time when I scan, I'm going to go through and put every item in its exact rightful place.
Dialogue: 0,0:13:34.87,0:13:40.79,中文,,0,0,0,,这次扫描时  我将遍历并将每个项目放在它正确的位置
Dialogue: 0,0:13:40.79,0:13:42.57,英文,,0,0,0,,So we will start with Lauren.
Dialogue: 0,0:13:40.79,0:13:42.57,中文,,0,0,0,,那么我们将从 Lauren 开始
Dialogue: 0,0:13:42.57,0:13:44.15,英文,,0,0,0,,Lauren is a spade.
Dialogue: 0,0:13:42.57,0:13:44.15,中文,,0,0,0,,Lauren 是一张黑桃
Dialogue: 0,0:13:44.15,0:13:45.23,英文,,0,0,0,,How do I know where the spades go?
Dialogue: 0,0:13:44.15,0:13:45.23,中文,,0,0,0,,我怎么知道黑桃放在哪里？
Dialogue: 0,0:13:45.23,0:13:48.43,英文,,0,0,0,,It's not like there's a spade element of the array.
Dialogue: 0,0:13:45.23,0:13:48.43,中文,,0,0,0,,数组中并没有黑桃元素
Dialogue: 0,0:13:48.43,0:13:54.67,英文,,0,0,0,,But if I look at my starting points array, which I got from my counts array, the counts array and the starting points array tell me,
Dialogue: 0,0:13:48.43,0:13:54.67,中文,,0,0,0,,但如果我查看我的起始点数组  它是从计数数组得到的  计数数组和起始点数组告诉我
Dialogue: 0,0:13:54.67,0:13:55.97,英文,,0,0,0,,Well, there are three clubs.
Dialogue: 0,0:13:54.67,0:13:55.97,中文,,0,0,0,,嗯  有三张梅花
Dialogue: 0,0:13:55.97,0:13:57.99,英文,,0,0,0,,They reserve items 0, 1, and 2.
Dialogue: 0,0:13:55.97,0:13:57.99,中文,,0,0,0,,它们保留了项目 0、1 和 2
Dialogue: 0,0:13:57.99,0:14:01.84,英文,,0,0,0,,So if you have a spade, you should put it starting at item number 3.
Dialogue: 0,0:13:57.99,0:14:01.84,中文,,0,0,0,,所以如果你有一张黑桃  你应该把它放在项目编号 3 开始的地方
Dialogue: 0,0:14:01.84,0:14:04.72,英文,,0,0,0,,So that's where I will put Lauren, item number 3.
Dialogue: 0,0:14:01.84,0:14:04.72,中文,,0,0,0,,所以我将把 Lauren 放在项目编号 3
Dialogue: 0,0:14:04.72,0:14:09.02,英文,,0,0,0,,And I will update my starting points already to say 3 has been used.
Dialogue: 0,0:14:04.72,0:14:09.02,中文,,0,0,0,,我将更新我的起始点数组  说明 3 已经被使用了
Dialogue: 0,0:14:09.02,0:14:10.08,英文,,0,0,0,,You can't use it again.
Dialogue: 0,0:14:09.02,0:14:10.08,中文,,0,0,0,,你不能再使用它了
Dialogue: 0,0:14:10.08,0:14:13.55,英文,,0,0,0,,So if you want another spade, you need to slot it in item number 4.
Dialogue: 0,0:14:10.08,0:14:13.55,中文,,0,0,0,,所以如果你想要另一张黑桃  你需要把它放在物品编号4的位置
Dialogue: 0,0:14:13.55,0:14:17.02,英文,,0,0,0,,That's the next part of the spade range.
Dialogue: 0,0:14:13.55,0:14:17.02,中文,,0,0,0,,那是黑桃范围的下一部分
Dialogue: 0,0:14:17.02,0:14:18.04,英文,,0,0,0,,Now we go to Delbert.
Dialogue: 0,0:14:17.02,0:14:18.04,中文,,0,0,0,,现在我们去Delbert
Dialogue: 0,0:14:18.04,0:14:19.30,英文,,0,0,0,,Delbert is a heart.
Dialogue: 0,0:14:18.04,0:14:19.30,中文,,0,0,0,,Delbert是红桃
Dialogue: 0,0:14:19.30,0:14:25.65,英文,,0,0,0,,According to my starting points array, it tells me that I have five, six, seven, eight reserved for the hearts.
Dialogue: 0,0:14:19.30,0:14:25.65,中文,,0,0,0,,根据我的起始点数组  它告诉我红桃预留了五、六、七、八个位置
Dialogue: 0,0:14:25.65,0:14:31.95,英文,,0,0,0,,So I'll slot Delbert into number five, and I'll increment this to six to remind myself you've already used five.
Dialogue: 0,0:14:25.65,0:14:31.95,中文,,0,0,0,,所以我会把Delbert放在5号位置  然后我会把这个数字加到6  提醒自己已经用了5个位置
Dialogue: 0,0:14:31.95,0:14:35.67,英文,,0,0,0,,The next heart that you see, put it in number six.
Dialogue: 0,0:14:31.95,0:14:35.67,中文,,0,0,0,,你看到的下一张红桃  把它放在6号位置
Dialogue: 0,0:14:35.67,0:14:37.37,英文,,0,0,0,,Then we go to Glaser.
Dialogue: 0,0:14:35.67,0:14:37.37,中文,,0,0,0,,然后我们去Glaser
Dialogue: 0,0:14:37.37,0:14:44.93,英文,,0,0,0,,And Glaser is a diamond, so we'll put the number 9, increment it to 10 to say the next diamond goes in slot number 10.
Dialogue: 0,0:14:37.37,0:14:44.93,中文,,0,0,0,,Glaser是方块  所以我们会把它放在9号位置  然后加到10  表示下一个方块会放在10号位置
Dialogue: 0,0:14:44.93,0:14:48.72,英文,,0,0,0,,And this goes on forever, or I guess until we scan the entire array.
Dialogue: 0,0:14:44.93,0:14:48.72,中文,,0,0,0,,这会一直持续下去  或者我猜直到我们扫描完整个数组
Dialogue: 0,0:14:48.72,0:14:54.54,英文,,0,0,0,,So Edith, index number 0, JS, index number 4.
Dialogue: 0,0:14:48.72,0:14:54.54,中文,,0,0,0,,所以Edith  索引号为0  JS  索引号为4
Dialogue: 0,0:14:54.54,0:14:56.24,英文,,0,0,0,,By the way.
Dialogue: 0,0:14:54.54,0:14:56.24,中文,,0,0,0,,顺便说一句
Dialogue: 0,0:14:56.24,0:15:02.66,英文,,0,0,0,,When I put j as in index number four, this starting points array, which tells me where the next spade goes,
Dialogue: 0,0:14:56.24,0:15:02.66,中文,,0,0,0,,当我把j放在索引号为4的位置时  这个起始点数组告诉我下一张黑桃的位置
Dialogue: 0,0:15:02.66,0:15:06.64,英文,,0,0,0,,it is now telling me that the next spade would go in index number five.
Dialogue: 0,0:15:02.66,0:15:06.64,中文,,0,0,0,,它现在告诉我下一张黑桃会放在索引号为5的位置
Dialogue: 0,0:15:06.64,0:15:08.60,英文,,0,0,0,,Does this cause anyone to panic?
Dialogue: 0,0:15:06.64,0:15:08.60,中文,,0,0,0,,这会让任何人感到恐慌吗？
Dialogue: 0,0:15:08.60,0:15:10.53,英文,,0,0,0,,Are you worried about this?
Dialogue: 0,0:15:08.60,0:15:10.53,中文,,0,0,0,,你担心这个吗？
Dialogue: 0,0:15:10.53,0:15:12.32,英文,,0,0,0,,You know why I'm not worried about this?
Dialogue: 0,0:15:10.53,0:15:12.32,中文,,0,0,0,,你知道我为什么不担心这个吗？
Dialogue: 0,0:15:12.32,0:15:18.32,英文,,0,0,0,,Because if this has reached five and there's already a heart there, it tells me I've already used all the spades.
Dialogue: 0,0:15:12.32,0:15:18.32,中文,,0,0,0,,因为如果这个数字已经达到5  而且那里已经有一张红桃  它告诉我我已经用完了所有的黑桃
Dialogue: 0,0:15:18.32,0:15:19.56,英文,,0,0,0,,So not to worry.
Dialogue: 0,0:15:18.32,0:15:19.56,中文,,0,0,0,,所以不用担心
Dialogue: 0,0:15:19.56,0:15:23.97,英文,,0,0,0,,I know that's kind of scary that this is number five and there's already something there.
Dialogue: 0,0:15:19.56,0:15:23.97,中文,,0,0,0,,我知道这个数字是5  而且那里已经有什么东西了  这有点吓人
Dialogue: 0,0:15:23.97,0:15:27.79,英文,,0,0,0,,But we can relax because we've already placed all the spades in their rightful place.
Dialogue: 0,0:15:23.97,0:15:27.79,中文,,0,0,0,,但我们可以放松  因为我们已经把所有的黑桃都放在了它们应该在的位置
Dialogue: 0,0:15:27.79,0:15:32.69,英文,,0,0,0,,The spade range has been totally exhausted thanks to my counting from earlier.
Dialogue: 0,0:15:27.79,0:15:32.69,中文,,0,0,0,,由于我之前数过  黑桃已经全部用完了
Dialogue: 0,0:15:32.69,0:15:37.86,英文,,0,0,0,,So I know that as I scan through the rest of this array, I do not have to worry about more spades.
Dialogue: 0,0:15:32.69,0:15:37.86,中文,,0,0,0,,所以我知道当我扫描数组的其余部分时  不必担心更多黑桃了
Dialogue: 0,0:15:37.86,0:15:40.48,英文,,0,0,0,,All of them have been placed in the array, so this number being 5.
Dialogue: 0,0:15:37.86,0:15:40.48,中文,,0,0,0,,它们都已放入数组  所以这个数字是5
Dialogue: 0,0:15:40.48,0:15:43.08,英文,,0,0,0,,If it scares you, relax.
Dialogue: 0,0:15:40.48,0:15:43.08,中文,,0,0,0,,如果它吓到你了  别担心
Dialogue: 0,0:15:43.08,0:15:45.74,英文,,0,0,0,,It's all good. OK, so we keep going.
Dialogue: 0,0:15:43.08,0:15:45.74,中文,,0,0,0,,一切顺利   好的  我们继续
Dialogue: 0,0:15:45.74,0:15:49.50,英文,,0,0,0,,I won't spare you some of the details, but the demo is here if you want it.
Dialogue: 0,0:15:45.74,0:15:49.50,中文,,0,0,0,,我不会省略一些细节  但如果你想要演示  它就在这里
Dialogue: 0,0:15:49.50,0:15:51.06,英文,,0,0,0,,So Sandra goes in number 10.
Dialogue: 0,0:15:49.50,0:15:51.06,中文,,0,0,0,,所以Sandra排在第10位
Dialogue: 0,0:15:51.06,0:15:51.96,英文,,0,0,0,,Then we have two hearts.
Dialogue: 0,0:15:51.06,0:15:51.96,中文,,0,0,0,,然后我们有两个红桃
Dialogue: 0,0:15:51.96,0:15:53.56,英文,,0,0,0,,They go in 6 and 7.
Dialogue: 0,0:15:51.96,0:15:53.56,中文,,0,0,0,,它们排在第6位和第7位
Dialogue: 0,0:15:53.56,0:15:56.04,英文,,0,0,0,,Then we have the club, another heart.
Dialogue: 0,0:15:53.56,0:15:56.04,中文,,0,0,0,,然后我们有一个梅花  另一个红桃
Dialogue: 0,0:15:56.04,0:15:59.17,英文,,0,0,0,,And again, this 9 pointing to a diamond.
Dialogue: 0,0:15:56.04,0:15:59.17,中文,,0,0,0,,再一次  这个9指向一个方块
Dialogue: 0,0:15:59.17,0:16:00.31,英文,,0,0,0,,If it scares you, it's OK.
Dialogue: 0,0:15:59.17,0:16:00.31,中文,,0,0,0,,如果它吓到你了  没关系
Dialogue: 0,0:16:00.31,0:16:01.37,英文,,0,0,0,,We're out of hearts.
Dialogue: 0,0:16:00.31,0:16:01.37,中文,,0,0,0,,我们的红桃用完了
Dialogue: 0,0:16:01.37,0:16:04.93,英文,,0,0,0,,And then one club, one diamond, and we're done.
Dialogue: 0,0:16:01.37,0:16:04.93,中文,,0,0,0,,然后一个梅花  一个方块  我们就完成了
Dialogue: 0,0:16:04.93,0:16:05.99,英文,,0,0,0,,Look, it's beautiful.
Dialogue: 0,0:16:04.93,0:16:05.99,中文,,0,0,0,,看  它很漂亮
Dialogue: 0,0:16:05.99,0:16:07.41,英文,,0,0,0,,Everything is sorted.
Dialogue: 0,0:16:05.99,0:16:07.41,中文,,0,0,0,,一切都排序好了
Dialogue: 0,0:16:07.41,0:16:10.33,英文,,0,0,0,,And I did not have to compare any of the two people.
Dialogue: 0,0:16:07.41,0:16:10.33,中文,,0,0,0,,而且我不必比较任何两个人
Dialogue: 0,0:16:10.33,0:16:12.75,英文,,0,0,0,,There was no judging of who was better than the other.
Dialogue: 0,0:16:10.33,0:16:12.75,中文,,0,0,0,,没有评判谁比谁更好
Dialogue: 0,0:16:12.75,0:16:20.20,英文,,0,0,0,,All I had to do was figure out what ranges each of the alphabet characters go in.
Dialogue: 0,0:16:12.75,0:16:20.20,中文,,0,0,0,,我所要做的就是弄清楚每个字母字符的范围
Dialogue: 0,0:16:20.20,0:16:21.30,英文,,0,0,0,,So where do the hearts go?
Dialogue: 0,0:16:20.20,0:16:21.30,中文,,0,0,0,,那红桃放哪？
Dialogue: 0,0:16:21.30,0:16:22.58,英文,,0,0,0,,Where do the clubs go?
Dialogue: 0,0:16:21.30,0:16:22.58,中文,,0,0,0,,梅花放哪？
Dialogue: 0,0:16:22.58,0:16:24.76,英文,,0,0,0,,And then slot everyone into their rightful place.
Dialogue: 0,0:16:22.58,0:16:24.76,中文,,0,0,0,,然后把每张牌放到正确的位置
Dialogue: 0,0:16:24.76,0:16:26.00,英文,,0,0,0,,There were two scans.
Dialogue: 0,0:16:24.76,0:16:26.00,中文,,0,0,0,,扫描了两次
Dialogue: 0,0:16:26.00,0:16:28.14,英文,,0,0,0,,Each one took theta of n time.
Dialogue: 0,0:16:26.00,0:16:28.14,中文,,0,0,0,,每次扫描花费Θ(N) 时间
Dialogue: 0,0:16:28.14,0:16:30.84,英文,,0,0,0,,So we had theta of n runtime.
Dialogue: 0,0:16:28.14,0:16:30.84,中文,,0,0,0,,所以运行时间是Θ(N)
Dialogue: 0,0:16:30.84,0:16:31.66,英文,,0,0,0,,Awesome.
Dialogue: 0,0:16:30.84,0:16:31.66,中文,,0,0,0,,太棒了
Dialogue: 0,0:16:31.66,0:16:33.06,英文,,0,0,0,,OK. Thoughts?
Dialogue: 0,0:16:31.66,0:16:33.06,中文,,0,0,0,,好的   有什么想法吗？
Dialogue: 0,0:16:33.06,0:16:34.16,英文,,0,0,0,,Questions?
Dialogue: 0,0:16:33.06,0:16:34.16,中文,,0,0,0,,有问题吗？
Dialogue: 0,0:16:34.16,0:16:34.84,英文,,0,0,0,,How do you feel about it?
Dialogue: 0,0:16:34.16,0:16:34.84,中文,,0,0,0,,你觉得怎么样？
Dialogue: 0,0:16:34.84,0:16:38.18,英文,,0,0,0,,Yeah.
Dialogue: 0,0:16:34.84,0:16:38.18,中文,,0,0,0,,嗯
Dialogue: 0,0:16:38.18,0:16:38.90,英文,,0,0,0,,That's a good question.
Dialogue: 0,0:16:38.18,0:16:38.90,中文,,0,0,0,,这个问题问得好
Dialogue: 0,0:16:38.90,0:16:40.08,英文,,0,0,0,,What if you used a hash map?
Dialogue: 0,0:16:38.90,0:16:40.08,中文,,0,0,0,,如果用哈希表呢？
Dialogue: 0,0:16:40.08,0:16:44.74,英文,,0,0,0,,You could, but I guess the question would be, what operation are you trying to speed up necessarily?
Dialogue: 0,0:16:40.08,0:16:44.74,中文,,0,0,0,,可以  但问题是  你想加快哪个操作的速度？
Dialogue: 0,0:16:44.74,0:16:50.11,英文,,0,0,0,,Because in this case, if I have an array, putting things in an array is already constant time.
Dialogue: 0,0:16:44.74,0:16:50.11,中文,,0,0,0,,因为在这种情况下  如果我有一个数组  把东西放进数组已经是常数时间了
Dialogue: 0,0:16:50.11,0:16:54.12,英文,,0,0,0,,So if you wanted to, I guess you could try and stick a hashmap in there somewhere,
Dialogue: 0,0:16:50.11,0:16:54.12,中文,,0,0,0,,如果你想的话  我猜你可以在某个地方插入一个哈希表
Dialogue: 0,0:16:54.12,0:16:59.62,英文,,0,0,0,,but I think the array already gives me constant-time inserts, so I'm not too concerned about inserting having to take forever.
Dialogue: 0,0:16:54.12,0:16:59.62,中文,,0,0,0,,但我认为数组已经给了我常数时间的插入  所以我不太担心插入需要花费很长时间
Dialogue: 0,0:16:59.62,0:17:00.74,英文,,0,0,0,,It's an interesting thought, though.
Dialogue: 0,0:16:59.62,0:17:00.74,中文,,0,0,0,,不过  这倒是个有趣的想法
Dialogue: 0,0:17:00.74,0:17:04.04,英文,,0,0,0,,Maybe you can invent something hashmap-based?
Dialogue: 0,0:17:00.74,0:17:04.04,中文,,0,0,0,,也许你可以发明一些基于哈希表的东西？
Dialogue: 0,0:17:04.04,0:17:05.90,英文,,0,0,0,,Okay.
Dialogue: 0,0:17:04.04,0:17:05.90,中文,,0,0,0,,好的
Dialogue: 0,0:17:05.90,0:17:10.27,英文,,0,0,0,,Yeah, Justin points out they have to go in an array eventually, so might as well just put them there first
Dialogue: 0,0:17:05.90,0:17:10.27,中文,,0,0,0,,嗯  Justin 指出它们最终必须放入数组中  所以还不如直接把它们放在那里
Dialogue: 0,0:17:10.27,0:17:14.41,英文,,0,0,0,,instead of transferring them to a hashmap and then into an array, but who knows?
Dialogue: 0,0:17:10.27,0:17:14.41,中文,,0,0,0,,而不是先把它们转移到哈希表中  然后再转移到数组中  但谁知道呢？
Dialogue: 0,0:17:14.41,0:17:17.21,英文,,0,0,0,,Maybe there's a hashmap-based sort out there.
Dialogue: 0,0:17:14.41,0:17:17.21,中文,,0,0,0,,也许存在基于哈希表的排序方法
Dialogue: 0,0:17:17.21,0:17:20.59,英文,,0,0,0,,Okay, I'm gonna do runtime one more time.
Dialogue: 0,0:17:17.21,0:17:20.59,中文,,0,0,0,,好的  我再运行一次
Dialogue: 0,0:17:20.59,0:17:29.38,英文,,0,0,0,,And this time, as I do it, I will also introduce to you the case that we talked about earlier, which is, what if the keys aren't all consecutive?
Dialogue: 0,0:17:20.59,0:17:29.38,中文,,0,0,0,,这次  在我运行时  我还会向你介绍我们之前讨论过的情况  那就是  如果键不是连续的怎么办？
Dialogue: 0,0:17:29.38,0:17:32.96,英文,,0,0,0,,So let's say I have the hundred largest cities by population.
Dialogue: 0,0:17:29.38,0:17:32.96,中文,,0,0,0,,假设我有按人口排名的前一百个最大城市
Dialogue: 0,0:17:32.96,0:17:37.12,英文,,0,0,0,,And you can imagine these numbers are really big, and they're probably not consecutive.
Dialogue: 0,0:17:32.96,0:17:37.12,中文,,0,0,0,,你可以想象这些数字非常大  而且它们可能不是连续的
Dialogue: 0,0:17:37.12,0:17:41.40,英文,,0,0,0,,So if, I don't know, San Francisco's population, what's an accurate number?
Dialogue: 0,0:17:37.12,0:17:41.40,中文,,0,0,0,,如果旧金山的人口  我不知道  准确的数字是多少？
Dialogue: 0,0:17:41.40,0:17:43.56,英文,,0,0,0,,I don't know.
Dialogue: 0,0:17:41.40,0:17:43.56,中文,,0,0,0,,我不知道
Dialogue: 0,0:17:43.56,0:17:45.40,英文,,0,0,0,,It's like 7,230,512.
Dialogue: 0,0:17:43.56,0:17:45.40,中文,,0,0,0,,是 7,230,512
Dialogue: 0,0:17:45.40,0:17:52.46,英文,,0,0,0,,You can imagine there's probably not a city out there with like 7,230,513, one greater than us.
Dialogue: 0,0:17:45.40,0:17:52.46,中文,,0,0,0,,你可以想象  可能没有一个城市的人口是 7,230,513  比我们多一个
Dialogue: 0,0:17:52.46,0:17:53.52,英文,,0,0,0,,Probably not.
Dialogue: 0,0:17:52.46,0:17:53.52,中文,,0,0,0,,可能没有
Dialogue: 0,0:17:53.52,0:17:56.18,英文,,0,0,0,,So here's a case where we have all these really big numbers.
Dialogue: 0,0:17:53.52,0:17:56.18,中文,,0,0,0,,所以这是一个我们拥有所有这些非常大的数字的情况
Dialogue: 0,0:17:56.18,0:18:00.64,英文,,0,0,0,,They're not consecutive, but I still want to sort the largest cities by population.
Dialogue: 0,0:17:56.18,0:18:00.64,中文,,0,0,0,,它们不是连续的  但我仍然想按人口对最大的城市进行排序
Dialogue: 0,0:18:00.64,0:18:04.30,英文,,0,0,0,,So the question for you is, what do you think counting sort would do?
Dialogue: 0,0:18:00.64,0:18:04.30,中文,,0,0,0,,所以问题是  你认为计数排序会做什么？
Dialogue: 0,0:18:04.30,0:18:09.25,英文,,0,0,0,,And another question that's kind of related is, do you think quicksort would do better or worse?
Dialogue: 0,0:18:04.30,0:18:09.25,中文,,0,0,0,,另一个相关的问题是  你认为快速排序会做得更好还是更差？
Dialogue: 0,0:18:09.25,0:18:10.99,英文,,0,0,0,,We kind of saw that asymptotically.
Dialogue: 0,0:18:09.25,0:18:10.99,中文,,0,0,0,,我们有点看到了渐近线
Dialogue: 0,0:18:10.99,0:18:19.41,英文,,0,0,0,,It kind of felt like, well, quicksort's n log n. But what about a case like this, where I have the largest cities, and I want to sort them by population?
Dialogue: 0,0:18:10.99,0:18:19.41,中文,,0,0,0,,感觉就像  嗯  快速排序是 N log N  但是像这种情况  我拥有最大的城市  我想按人口对它们进行排序  该怎么办？
Dialogue: 0,0:18:19.41,0:18:23.01,英文,,0,0,0,,So I guess the first question to ask you is, what kind of array are you making?
Dialogue: 0,0:18:19.41,0:18:23.01,中文,,0,0,0,,所以我想问你的第一个问题是  你正在制作什么样的数组？
Dialogue: 0,0:18:23.01,0:18:29.02,英文,,0,0,0,,So in the first example, I made the array with 12 items, and everyone slotted between 0 and 11.
Dialogue: 0,0:18:23.01,0:18:29.02,中文,,0,0,0,,所以在第一个例子中  我创建了一个包含 12 个项目的数组  每个人都插在 0 到 11 之间
Dialogue: 0,0:18:29.02,0:18:33.68,英文,,0,0,0,,In the next case, with the card suits, I made the array, and everyone slotted into exactly one place.
Dialogue: 0,0:18:29.02,0:18:33.68,中文,,0,0,0,,在下一个例子中  使用卡片花色  我创建了数组  每个人都插到了一个确切的位置
Dialogue: 0,0:18:33.68,0:18:41.17,英文,,0,0,0,,But now that the keys are not consecutive, am I able to slot every single number into consecutive indices?
Dialogue: 0,0:18:33.68,0:18:41.17,中文,,0,0,0,,但是现在这些键不是连续的  我还能把每个数字都放到连续的索引中吗？
Dialogue: 0,0:18:41.17,0:18:42.59,英文,,0,0,0,,Probably not.
Dialogue: 0,0:18:41.17,0:18:42.59,中文,,0,0,0,,可能不行
Dialogue: 0,0:18:42.59,0:18:46.25,英文,,0,0,0,,So what would my counting array look like?
Dialogue: 0,0:18:42.59,0:18:46.25,中文,,0,0,0,,那么我的计数数组会是什么样子呢？
Dialogue: 0,0:18:46.25,0:18:53.01,英文,,0,0,0,,How do I make an array so that each city, when I encounter it, I can immediately throw it into the right part of the array?
Dialogue: 0,0:18:46.25,0:18:53.01,中文,,0,0,0,,如何创建一个数组  以便当我遇到每个城市时  可以立即将其放入数组的正确部分？
Dialogue: 0,0:18:53.01,0:18:54.61,英文,,0,0,0,,Whatever that means.
Dialogue: 0,0:18:53.01,0:18:54.61,中文,,0,0,0,,无论这意味着什么
Dialogue: 0,0:18:54.61,0:19:02.74,英文,,0,0,0,,So maybe you have something different in mind, but here's the array picture that I have in mind, which is if I have all of these cities, I guess just
Dialogue: 0,0:18:54.61,0:19:02.74,中文,,0,0,0,,所以也许你还有其他想法  但我想象中的数组图片是这样的  如果我拥有所有这些城市  我想就
Dialogue: 0,0:19:02.74,0:19:04.52,英文,,0,0,0,,The first few on this slide.
Dialogue: 0,0:19:02.74,0:19:04.52,中文,,0,0,0,,这张幻灯片上的前几个
Dialogue: 0,0:19:04.52,0:19:13.12,英文,,0,0,0,,Well, in this case, I'd have to create an array of size 37 million, because that's the population of the largest city.
Dialogue: 0,0:19:04.52,0:19:13.12,中文,,0,0,0,,好吧  在这种情况下  我必须创建一个大小为 3700 万的数组  因为这是最大城市的人口
Dialogue: 0,0:19:13.12,0:19:18.90,英文,,0,0,0,,So I'll have a big array from index 0 all the way up to index 37 million and change.
Dialogue: 0,0:19:13.12,0:19:18.90,中文,,0,0,0,,所以我将拥有一个从索引 0 一直到索引 3700 万以上的大数组
Dialogue: 0,0:19:18.90,0:19:24.84,英文,,0,0,0,,And the idea here is now, if I go through each city, I see Ahmedabad and its population 6,352,254.
Dialogue: 0,0:19:18.90,0:19:24.84,中文,,0,0,0,,现在的想法是  如果我遍历每个城市  我看到艾哈迈达巴德及其人口 6,352,254
Dialogue: 0,0:19:24.84,0:19:25.62,英文,,0,0,0,,Well, that's great.
Dialogue: 0,0:19:24.84,0:19:25.62,中文,,0,0,0,,好吧  那太好了
Dialogue: 0,0:19:25.62,0:19:30.21,英文,,0,0,0,,Where do I put it?
Dialogue: 0,0:19:25.62,0:19:30.21,中文,,0,0,0,,我把它放在哪里？
Dialogue: 0,0:19:30.21,0:19:32.83,英文,,0,0,0,,I stick it in index number 6,352,254.
Dialogue: 0,0:19:30.21,0:19:32.83,中文,,0,0,0,,我把它放在索引号 6,352,254
Dialogue: 0,0:19:32.83,0:19:36.89,英文,,0,0,0,,So it's kind of the same idea from earlier.
Dialogue: 0,0:19:32.83,0:19:36.89,中文,,0,0,0,,所以这和之前差不多的想法
Dialogue: 0,0:19:36.89,0:19:40.69,英文,,0,0,0,,I'm just adapting it to the case where the keys are not consecutive.
Dialogue: 0,0:19:36.89,0:19:40.69,中文,,0,0,0,,我只是把它改编成键不连续的情况
Dialogue: 0,0:19:40.69,0:19:44.59,英文,,0,0,0,,And likewise, if I see Alexandria, well, that has population 4,778,000.
Dialogue: 0,0:19:40.69,0:19:44.59,中文,,0,0,0,,同样  如果我看到亚历山大  好吧  它的人口是 4,778,000
Dialogue: 0,0:19:44.59,0:19:46.07,英文,,0,0,0,,So I put it in index number 4,778,000.
Dialogue: 0,0:19:44.59,0:19:46.07,中文,,0,0,0,,所以我把它放在索引号 4,778,000
Dialogue: 0,0:19:46.07,0:19:55.25,英文,,0,0,0,,I do this for all 100 cities.
Dialogue: 0,0:19:46.07,0:19:55.25,中文,,0,0,0,,我对所有 100 个城市都这样做
Dialogue: 0,0:19:55.25,0:19:57.09,英文,,0,0,0,,What's the resulting picture?
Dialogue: 0,0:19:55.25,0:19:57.09,中文,,0,0,0,,结果图是什么？
Dialogue: 0,0:19:57.09,0:19:59.31,英文,,0,0,0,,What's the resulting array that you see?
Dialogue: 0,0:19:57.09,0:19:59.31,中文,,0,0,0,,你看到的最终数组是什么？
Dialogue: 0,0:19:59.31,0:20:06.11,英文,,0,0,0,,Well, the resulting array is going to have tons and tons of zeros, because there is no city with this population, or that one, or that one.
Dialogue: 0,0:19:59.31,0:20:06.11,中文,,0,0,0,,最终得到的数组里会有很多很多的零  因为没有哪个城市的人口是这个数  那个数  或者那个数
Dialogue: 0,0:20:06.11,0:20:08.83,英文,,0,0,0,,There's just a single city with population, this one.
Dialogue: 0,0:20:06.11,0:20:08.83,中文,,0,0,0,,只有一个城市的人口是这个数
Dialogue: 0,0:20:08.83,0:20:18.64,英文,,0,0,0,,So this array will be very sparse, which means almost all the array entries are zero, and just a few of them, like 100 of them, have entry one.
Dialogue: 0,0:20:08.83,0:20:18.64,中文,,0,0,0,,所以这个数组会非常稀疏  这意味着几乎所有的数组条目都是零  只有少数几个  比如100个  条目是1
Dialogue: 0,0:20:18.64,0:20:21.28,英文,,0,0,0,,Let me finish sorting, and then I'll get to your question.
Dialogue: 0,0:20:18.64,0:20:21.28,中文,,0,0,0,,我先把排序做完  然后再来回答你的问题
Dialogue: 0,0:20:21.28,0:20:29.70,英文,,0,0,0,,So and then eventually I can just scan through the array and just call out all of the items in order and that will give me a sorted version of all the hundred cities.
Dialogue: 0,0:20:21.28,0:20:29.70,中文,,0,0,0,,最后我可以扫描数组  并按顺序读出所有项目  这将给我一个所有100个城市的排序版本
Dialogue: 0,0:20:29.70,0:20:40.20,英文,,0,0,0,,But you can imagine this is kind of slow because in terms of runtime, and I'm not doing a careful analysis here, but I had to create an array of size 37 million.
Dialogue: 0,0:20:29.70,0:20:40.20,中文,,0,0,0,,但你可以想象  这有点慢  因为在运行时间方面  我没有在这里进行仔细的分析  但我必须创建一个大小为3700万的数组
Dialogue: 0,0:20:40.20,0:20:47.96,英文,,0,0,0,,And I don't know about you, but I think if I was to quicksort 100 different numbers, I would not have to do 37 million operations.
Dialogue: 0,0:20:40.20,0:20:47.96,中文,,0,0,0,,我不知道你怎么想  但我想如果我要对100个不同的数字进行快速排序  我不需要做3700万次操作
Dialogue: 0,0:20:47.96,0:20:50.86,英文,,0,0,0,,I would do roughly, what, n log n operations?
Dialogue: 0,0:20:47.96,0:20:50.86,中文,,0,0,0,,我大概会做N log N次操作？
Dialogue: 0,0:20:50.86,0:20:56.10,英文,,0,0,0,,And if I do n log n times n is 100, that's probably less than 37 million.
Dialogue: 0,0:20:50.86,0:20:56.10,中文,,0,0,0,,如果我做N log N次  N是100  那可能不到3700万
Dialogue: 0,0:20:56.10,0:20:58.09,英文,,0,0,0,,Maybe it's not a super convincing argument.
Dialogue: 0,0:20:56.10,0:20:58.09,中文,,0,0,0,,也许这不是一个很有说服力的论点
Dialogue: 0,0:20:58.09,0:21:06.11,英文,,0,0,0,,But I think here's a case where quicksort would actually do better, because it does not have to create this massive array, fill it in, and scan through it.
Dialogue: 0,0:20:58.09,0:21:06.11,中文,,0,0,0,,但我认为这里有一个例子  快速排序实际上会做得更好  因为它不需要创建这个庞大的数组  填充它  然后扫描它
Dialogue: 0,0:21:06.11,0:21:14.18,英文,,0,0,0,,The quicksort would just compare all these numbers and swap the items around till you get them in the right order, which I think ends up being faster.
Dialogue: 0,0:21:06.11,0:21:14.18,中文,,0,0,0,,快速排序只会比较所有这些数字  并交换项目的位置  直到你把它们按正确的顺序排列  我认为这样最终会更快
Dialogue: 0,0:21:14.18,0:21:16.36,英文,,0,0,0,,Do you have a question still?
Dialogue: 0,0:21:14.18,0:21:16.36,中文,,0,0,0,,你还有问题吗？
Dialogue: 0,0:21:16.36,0:21:28.20,英文,,0,0,0,,Yeah.
Dialogue: 0,0:21:16.36,0:21:28.20,中文,,0,0,0,,
Dialogue: 0,0:21:28.20,0:21:30.70,英文,,0,0,0,,So do it based on digits soon.
Dialogue: 0,0:21:28.20,0:21:30.70,中文,,0,0,0,,所以很快就会根据数字来进行排序
Dialogue: 0,0:21:30.70,0:21:31.78,英文,,0,0,0,,It's a good thought.
Dialogue: 0,0:21:30.70,0:21:31.78,中文,,0,0,0,,这是个好想法
Dialogue: 0,0:21:31.78,0:21:33.51,英文,,0,0,0,,You will see it very soon.
Dialogue: 0,0:21:31.78,0:21:33.51,中文,,0,0,0,,你很快就会看到它
Dialogue: 0,0:21:33.51,0:21:39.05,英文,,0,0,0,,But for now, just based on kind of naive counting sort, what you've seen so far, this is the best you'd be able to do.
Dialogue: 0,0:21:33.51,0:21:39.05,中文,,0,0,0,,但现在  只是基于这种简单的计数排序  你目前看到的  这是你能做的最好的了
Dialogue: 0,0:21:39.05,0:21:44.74,英文,,0,0,0,,It's kind of silly, and quicksort would beat it in this particular case.
Dialogue: 0,0:21:39.05,0:21:44.74,中文,,0,0,0,,这有点傻  在这种情况下  快速排序会胜过它
Dialogue: 0,0:21:44.74,0:21:50.12,英文,,0,0,0,,So let's be a little bit more formal, which is, in this case, if I was just using one variable that is n,
Dialogue: 0,0:21:44.74,0:21:50.12,中文,,0,0,0,,所以让我们更正式一点  在这种情况下  如果我只使用一个变量N
Dialogue: 0,0:21:50.12,0:21:55.90,英文,,0,0,0,,the number of items, then I'd maybe say counting sort is better because n is 100.
Dialogue: 0,0:21:50.12,0:21:55.90,中文,,0,0,0,,即项目数量  那么我可能会说计数排序更好  因为N是100
Dialogue: 0,0:21:55.90,0:22:00.78,英文,,0,0,0,,So how do I definitively prove to you that here's a case where counting sort does worse?
Dialogue: 0,0:21:55.90,0:22:00.78,中文,,0,0,0,,那么  我要如何确切地向你证明  在某些情况下  计数排序的效率会更低呢？
Dialogue: 0,0:22:00.78,0:22:06.75,英文,,0,0,0,,Hopefully, we're kind of convinced just by the picture that creating a 37 million size array for 100 items
Dialogue: 0,0:22:00.78,0:22:06.75,中文,,0,0,0,,希望我们从图中可以看出  为 100 个项目创建一个大小为 3700 万的数组
Dialogue: 0,0:22:06.75,0:22:13.03,英文,,0,0,0,,is just not worth it compared to swapping the items around in the original size 100 array.
Dialogue: 0,0:22:06.75,0:22:13.03,中文,,0,0,0,,与在原始大小为 100 的数组中交换项目相比  是不值得的
Dialogue: 0,0:22:13.03,0:22:20.25,英文,,0,0,0,,So to do that, turns out, I actually have to introduce a second variable.
Dialogue: 0,0:22:13.03,0:22:20.25,中文,,0,0,0,,为了做到这一点  我实际上需要引入第二个变量
Dialogue: 0,0:22:20.25,0:22:26.23,英文,,0,0,0,,Because if I ask you, how does counting sort do as my problem grows bigger?
Dialogue: 0,0:22:20.25,0:22:26.23,中文,,0,0,0,,因为如果我问你  随着问题的规模变大  计数排序的效果如何？
Dialogue: 0,0:22:26.23,0:22:29.44,英文,,0,0,0,,Well, suddenly, it's kind of like the graphs from a couple weeks ago.
Dialogue: 0,0:22:26.23,0:22:29.44,中文,,0,0,0,,嗯  突然之间  这有点像几周前的图表
Dialogue: 0,0:22:29.44,0:22:33.46,英文,,0,0,0,,How do you quantify what it means for the problem to get bigger?
Dialogue: 0,0:22:29.44,0:22:33.46,中文,,0,0,0,,你如何量化问题的规模变大意味着什么？
Dialogue: 0,0:22:33.46,0:22:36.40,英文,,0,0,0,,So in this case,
Dialogue: 0,0:22:33.46,0:22:36.40,中文,,0,0,0,,在这种情况下
Dialogue: 0,0:22:36.40,0:22:39.42,英文,,0,0,0,,When my problem gets bigger, does it mean I have more items?
Dialogue: 0,0:22:36.40,0:22:39.42,中文,,0,0,0,,当我的问题规模变大时  这是否意味着我有更多的项目？
Dialogue: 0,0:22:39.42,0:22:40.96,英文,,0,0,0,,Like I have 1,000 cities instead of 100?
Dialogue: 0,0:22:39.42,0:22:40.96,中文,,0,0,0,,比如我有 1000 个城市而不是 100 个？
Dialogue: 0,0:22:40.96,0:22:43.72,英文,,0,0,0,,Or I have 10,000 cities?
Dialogue: 0,0:22:40.96,0:22:43.72,中文,,0,0,0,,或者我有 10000 个城市？
Dialogue: 0,0:22:43.72,0:22:48.12,英文,,0,0,0,,Or when I say the problem gets bigger, do I mean that the numbers are getting bigger?
Dialogue: 0,0:22:43.72,0:22:48.12,中文,,0,0,0,,或者  当我说问题规模变大时  我的意思是数字变得更大吗？
Dialogue: 0,0:22:48.12,0:22:52.99,英文,,0,0,0,,So for example, the cities have population 30 million or 300 million.
Dialogue: 0,0:22:48.12,0:22:52.99,中文,,0,0,0,,例如  这些城市的人口是 3000 万或 3 亿
Dialogue: 0,0:22:52.99,0:23:01.15,英文,,0,0,0,,So I actually need two variables to represent counting sort, because I need one variable to tell me about the number of items growing larger.
Dialogue: 0,0:22:52.99,0:23:01.15,中文,,0,0,0,,所以我实际上需要两个变量来表示计数排序  因为我需要一个变量来告诉我项目的数量在增加
Dialogue: 0,0:23:01.15,0:23:05.45,英文,,0,0,0,,And I need a second variable to tell me all about the alphabet growing larger.
Dialogue: 0,0:23:01.15,0:23:05.45,中文,,0,0,0,,我还需要第二个变量来告诉我字母表的大小在增加
Dialogue: 0,0:23:05.45,0:23:08.92,英文,,0,0,0,,And here, the alphabet is the number of different things that you might be sorting.
Dialogue: 0,0:23:05.45,0:23:08.92,中文,,0,0,0,,这里  字母表是指你可能要排序的不同事物的数量
Dialogue: 0,0:23:08.92,0:23:13.28,英文,,0,0,0,,So in the diamonds, hearts, clubs, spades example, the alphabet was four.
Dialogue: 0,0:23:08.92,0:23:13.28,中文,,0,0,0,,所以在方块、红桃、梅花、黑桃的例子中  字母表是 4
Dialogue: 0,0:23:13.28,0:23:17.58,英文,,0,0,0,,In the cities example, the alphabet was like 37 million.
Dialogue: 0,0:23:13.28,0:23:17.58,中文,,0,0,0,,在城市的例子中  字母表就像 3700 万
Dialogue: 0,0:23:17.58,0:23:23.03,英文,,0,0,0,,Now we have to use two variables, because the problem can grow in two different ways, which happens sometimes.
Dialogue: 0,0:23:17.58,0:23:23.03,中文,,0,0,0,,现在我们必须使用两个变量  因为问题可以以两种不同的方式增长  这有时会发生
Dialogue: 0,0:23:23.03,0:23:27.89,英文,,0,0,0,,So here's the sum that I came up with for how long it takes.
Dialogue: 0,0:23:23.03,0:23:27.89,中文,,0,0,0,,所以这就是我想出的计算时间长短的公式
Dialogue: 0,0:23:27.89,0:23:37.54,英文,,0,0,0,,It's a little bit similar to the summation that you saw in graphs, where we did v plus e. And the reason why I'm adding the two together, there's a couple of different ways to kind of see it.
Dialogue: 0,0:23:27.89,0:23:37.54,中文,,0,0,0,,它有点类似于你在图表中看到的求和公式  我们做了R+N  我将两者相加的原因  有几种不同的理解方式
Dialogue: 0,0:23:37.54,0:23:41.16,英文,,0,0,0,,One way that I like to see it is if these two items grow,
Dialogue: 0,0:23:37.54,0:23:41.16,中文,,0,0,0,,我个人理解是这样的  如果这两个项目都在增长
Dialogue: 0,0:23:41.16,0:23:43.64,英文,,0,0,0,,Well, one of them is going to dominate the other eventually.
Dialogue: 0,0:23:41.16,0:23:43.64,中文,,0,0,0,,那最终其中一个一定会占据主导地位
Dialogue: 0,0:23:43.64,0:23:46.10,英文,,0,0,0,,So let's say I hold R constant.
Dialogue: 0,0:23:43.64,0:23:46.10,中文,,0,0,0,,假设我把R保持不变
Dialogue: 0,0:23:46.10,0:23:50.81,英文,,0,0,0,,So I use a really small alphabet like the card suits, but I crank up N really far.
Dialogue: 0,0:23:46.10,0:23:50.81,中文,,0,0,0,,也就是使用像扑克牌花色这样非常小的字母表  但把N调得非常大
Dialogue: 0,0:23:50.81,0:23:55.07,英文,,0,0,0,,So I have to sort, you know, 100 million items and they're all of the four card suits.
Dialogue: 0,0:23:50.81,0:23:55.07,中文,,0,0,0,,所以我必须对1亿个项目进行排序  它们都是四种花色
Dialogue: 0,0:23:55.07,0:23:59.93,英文,,0,0,0,,Well, in that case, the N would dominate because I spend most of my time scaling.
Dialogue: 0,0:23:55.07,0:23:59.93,中文,,0,0,0,,在这种情况下  N将占据主导地位  因为我大部分时间都花在缩放上
Dialogue: 0,0:23:59.93,0:24:05.51,英文,,0,0,0,,And the count array is pretty small. It's just four things.
Dialogue: 0,0:23:59.93,0:24:05.51,中文,,0,0,0,,而计数数组非常小   只有四种东西
Dialogue: 0,0:24:05.51,0:24:07.95,英文,,0,0,0,,I just have to count the number of each card suit.
Dialogue: 0,0:24:05.51,0:24:07.95,中文,,0,0,0,,我只需要数一下每种花色的数量
Dialogue: 0,0:24:07.95,0:24:09.09,英文,,0,0,0,,So there's only four of those.
Dialogue: 0,0:24:07.95,0:24:09.09,中文,,0,0,0,,所以只有四种
Dialogue: 0,0:24:09.09,0:24:10.03,英文,,0,0,0,,That's not too bad.
Dialogue: 0,0:24:09.09,0:24:10.03,中文,,0,0,0,,这不算太糟糕
Dialogue: 0,0:24:10.03,0:24:14.18,英文,,0,0,0,,But I have to scan the 100 million items to put each one in its right place.
Dialogue: 0,0:24:10.03,0:24:14.18,中文,,0,0,0,,但我必须扫描这1亿个项目  把每一个都放在正确的位置
Dialogue: 0,0:24:14.18,0:24:19.22,英文,,0,0,0,,So if n grows really large, but r stays constant, then n is going to dominate.
Dialogue: 0,0:24:14.18,0:24:19.22,中文,,0,0,0,,所以如果 N 变得非常大  而 R 保持不变  那么 N 就会占据主导地位
Dialogue: 0,0:24:19.22,0:24:28.32,英文,,0,0,0,,And if I write something like n plus r, and I use asymptotic analysis, the n dominates over the r, and I end up having theta of n runtime.
Dialogue: 0,0:24:19.22,0:24:28.32,中文,,0,0,0,,如果我写成 N + R   然后使用渐进分析   N 会超过 R   最终得到Θ(N)的运行时间
Dialogue: 0,0:24:28.32,0:24:37.03,英文,,0,0,0,,By contrast, if I hold n constant, I say it's 100 cities no matter what, and I crank up r, so it's 100 cities with populations in the millions.
Dialogue: 0,0:24:28.32,0:24:37.03,中文,,0,0,0,,相反  如果我把 N 保持不变  比如无论如何都是100个城市  然后把 R 调大  就变成了100个百万人口的城市
Dialogue: 0,0:24:37.03,0:24:40.47,英文,,0,0,0,,Now it's 100 cities in the populations of the billions.
Dialogue: 0,0:24:37.03,0:24:40.47,中文,,0,0,0,,现在是100个数十亿人口的城市
Dialogue: 0,0:24:40.47,0:24:43.32,英文,,0,0,0,,Now it's 100 cities and they all have trillions of people.
Dialogue: 0,0:24:40.47,0:24:43.32,中文,,0,0,0,,现在是100个城市  每个城市都有数万亿人口
Dialogue: 0,0:24:43.32,0:24:50.94,英文,,0,0,0,,In that case, the R is going to end up dominating because my array that I have to scan with the cities is always 100 items.
Dialogue: 0,0:24:43.32,0:24:50.94,中文,,0,0,0,,在这种情况下  R最终会占据主导地位  因为我必须扫描的城市数组始终是100个项目
Dialogue: 0,0:24:50.94,0:25:00.31,英文,,0,0,0,,But my results array, the one that you saw earlier, this one, this one's going to grow massive because this one's going to go from a million to a billion to trillions.
Dialogue: 0,0:24:50.94,0:25:00.31,中文,,0,0,0,,但是我的结果数组  你之前看到的那个  这个会变得非常大  因为它会从百万变成十亿再变成万亿
Dialogue: 0,0:25:00.31,0:25:08.94,英文,,0,0,0,,So in that case, the R ends up dominating because you have to waste the time creating this really big array and mostly filling it with zeros.
Dialogue: 0,0:25:00.31,0:25:08.94,中文,,0,0,0,,所以在这种情况下  R最终占据主导地位  因为你必须浪费时间创建这个非常大的数组  并且大部分都用零填充
Dialogue: 0,0:25:08.94,0:25:18.00,英文,,0,0,0,,So the reason why I write n plus r, sometimes people like to write max of n and r, is because there's two terms, and each one could dominate separately.
Dialogue: 0,0:25:08.94,0:25:18.00,中文,,0,0,0,,我写 N + R 的原因  有些人喜欢写 N 和 R 中的最大值  是因为有两个项  每个项都可能分别占主导地位
Dialogue: 0,0:25:18.00,0:25:24.53,英文,,0,0,0,,And because I know someone's going to ask, I don't write n times r, because it's not the case that for every item, I have to check all the card suits.
Dialogue: 0,0:25:18.00,0:25:24.53,中文,,0,0,0,,而且因为我知道有人会问  我不会写 N 乘以  R   因为并不是说对于每个项目  我都必须检查所有的花色
Dialogue: 0,0:25:24.53,0:25:27.99,英文,,0,0,0,,There's no crossing of the two operations.
Dialogue: 0,0:25:24.53,0:25:27.99,中文,,0,0,0,,这两个操作之间没有交叉
Dialogue: 0,0:25:27.99,0:25:29.77,英文,,0,0,0,,It's kind of two separate operations.
Dialogue: 0,0:25:27.99,0:25:29.77,中文,,0,0,0,,这算是两个独立的操作
Dialogue: 0,0:25:29.77,0:25:32.55,英文,,0,0,0,,So another way to see it is, there are two things I have to do.
Dialogue: 0,0:25:29.77,0:25:32.55,中文,,0,0,0,,所以另一种看待它的方式是  我必须做两件事
Dialogue: 0,0:25:32.55,0:25:36.31,英文,,0,0,0,,The first thing I have to do is create and fill the count-related array.
Dialogue: 0,0:25:32.55,0:25:36.31,中文,,0,0,0,,我要做的第一件事是创建和填充与计数相关的数组
Dialogue: 0,0:25:36.31,0:25:38.63,英文,,0,0,0,,Sometimes it's four items if I have four card suits.
Dialogue: 0,0:25:36.31,0:25:38.63,中文,,0,0,0,,如果我有四种花色  有时是四个项目
Dialogue: 0,0:25:38.63,0:25:41.56,英文,,0,0,0,,Sometimes it's 37 million items if it's the cities.
Dialogue: 0,0:25:38.63,0:25:41.56,中文,,0,0,0,,如果它是城市  有时是 3700 万个项目
Dialogue: 0,0:25:41.56,0:25:43.88,英文,,0,0,0,,But in either case, that's theta of our time.
Dialogue: 0,0:25:41.56,0:25:43.88,中文,,0,0,0,,但无论哪种情况  时间复杂度都是 Θ(R )
Dialogue: 0,0:25:43.88,0:25:50.40,英文,,0,0,0,,And then completely separately from that, I have to scan the entire array and copy every element into the new array.
Dialogue: 0,0:25:43.88,0:25:50.40,中文,,0,0,0,,然后  我必须完全独立地扫描整个数组  并将每个元素复制到新数组中
Dialogue: 0,0:25:50.40,0:25:52.50,英文,,0,0,0,,And that is theta of n time.
Dialogue: 0,0:25:50.40,0:25:52.50,中文,,0,0,0,,时间复杂度为 Θ(N)
Dialogue: 0,0:25:52.50,0:25:54.08,英文,,0,0,0,,And those two things are separate.
Dialogue: 0,0:25:52.50,0:25:54.08,中文,,0,0,0,,这两件事是分开的
Dialogue: 0,0:25:54.08,0:25:57.16,英文,,0,0,0,,It's not like I'm creating one count-related array per item.
Dialogue: 0,0:25:54.08,0:25:57.16,中文,,0,0,0,,我并不是为每个项目创建一个与计数相关的数组
Dialogue: 0,0:25:57.16,0:26:04.69,英文,,0,0,0,,I'm creating the count-related array once, setting it aside, and then scanning the entire array a second time completely separately.
Dialogue: 0,0:25:57.16,0:26:04.69,中文,,0,0,0,,我创建了与计数相关的数组一次  将其放在一边  然后完全独立地再次扫描整个数组
Dialogue: 0,0:26:04.69,0:26:06.91,英文,,0,0,0,,That's another way to see the addition here.
Dialogue: 0,0:26:04.69,0:26:06.91,中文,,0,0,0,,这是看待这里加法的另一种方式
Dialogue: 0,0:26:06.91,0:26:10.01,英文,,0,0,0,,But I will admit, it's a little bit strange.
Dialogue: 0,0:26:06.91,0:26:10.01,中文,,0,0,0,,但我承认  这有点奇怪
Dialogue: 0,0:26:10.01,0:26:12.55,英文,,0,0,0,,So anyway, the bottom line is I have these two terms.
Dialogue: 0,0:26:10.01,0:26:12.55,中文,,0,0,0,,总之  底线是我有两个项
Dialogue: 0,0:26:12.55,0:26:19.92,英文,,0,0,0,,And if I assume r is pretty small, so let's say it's not 37 million, I should get pretty good performance, like we saw in the kartsuit example.
Dialogue: 0,0:26:12.55,0:26:19.92,中文,,0,0,0,,如果我假设 R 很小  比如它不是 3700 万  我应该会得到很好的性能  就像我们在花色示例中看到的那样
Dialogue: 0,0:26:19.92,0:26:23.66,英文,,0,0,0,,Because if n is greater than r, my n term will dominate.
Dialogue: 0,0:26:19.92,0:26:23.66,中文,,0,0,0,,因为如果 N >  R   我的 N 项将占主导地位
Dialogue: 0,0:26:23.66,0:26:27.98,英文,,0,0,0,,So I'll get a rough runtime of theta of n, assuming r is small.
Dialogue: 0,0:26:23.66,0:26:27.98,中文,,0,0,0,,所以假设 R 很小  我将得到大约 Θ(N) 的运行时间
Dialogue: 0,0:26:27.98,0:26:33.98,英文,,0,0,0,,And that's good, because we beat the quicksort runtime.
Dialogue: 0,0:26:27.98,0:26:33.98,中文,,0,0,0,,这很好  因为我们击败了快速排序的运行时间
Dialogue: 0,0:26:33.98,0:26:35.76,英文,,0,0,0,,So that's counting sort.
Dialogue: 0,0:26:33.98,0:26:35.76,中文,,0,0,0,,这就是计数排序
Dialogue: 0,0:26:35.76,0:26:39.69,英文,,0,0,0,,Any thoughts before I make it even better?
Dialogue: 0,0:26:35.76,0:26:39.69,中文,,0,0,0,,在我改进它之前  有什么想法吗？
Dialogue: 0,0:26:39.69,0:26:40.77,英文,,0,0,0,,OK.
Dialogue: 0,0:26:39.69,0:26:40.77,中文,,0,0,0,,好的
Dialogue: 0,0:26:40.77,0:26:41.81,英文,,0,0,0,,There are some other examples.
Dialogue: 0,0:26:40.77,0:26:41.81,中文,,0,0,0,,还有一些其他的例子
Dialogue: 0,0:26:41.81,0:26:43.75,英文,,0,0,0,,So I will not go through this slide.
Dialogue: 0,0:26:41.81,0:26:43.75,中文,,0,0,0,,所以我不会再讲这张幻灯片了
Dialogue: 0,0:26:43.75,0:26:45.41,英文,,0,0,0,,But you can come up with other examples.
Dialogue: 0,0:26:43.75,0:26:45.41,中文,,0,0,0,,但你可以想出其他的例子
Dialogue: 0,0:26:45.41,0:26:49.31,英文,,0,0,0,,There are some cases where counting sort is faster, like when I had the card suits.
Dialogue: 0,0:26:45.41,0:26:49.31,中文,,0,0,0,,在某些情况下  计数排序更快  比如当我排序扑克牌花色的时候
Dialogue: 0,0:26:49.31,0:26:52.83,英文,,0,0,0,,There are some examples where quicksort is faster, like when I had the cities.
Dialogue: 0,0:26:49.31,0:26:52.83,中文,,0,0,0,,在某些情况下  快速排序更快  比如当我排序城市名称的时候
Dialogue: 0,0:26:52.83,0:26:55.33,英文,,0,0,0,,So sometimes one is better than the other.
Dialogue: 0,0:26:52.83,0:26:55.33,中文,,0,0,0,,所以有时候这个比那个好
Dialogue: 0,0:26:55.33,0:26:59.31,英文,,0,0,0,,But hopefully, we can see that counting sort has its uses.
Dialogue: 0,0:26:55.33,0:26:59.31,中文,,0,0,0,,但希望我们能看到计数排序有它的用途
Dialogue: 0,0:26:59.31,0:27:03.03,英文,,0,0,0,,For example, the card suit case.
Dialogue: 0,0:26:59.31,0:27:03.03,中文,,0,0,0,,例如  扑克牌花色的情况
Dialogue: 0,0:27:03.03,0:27:05.14,英文,,0,0,0,,OK, so counting sort is good.
Dialogue: 0,0:27:03.03,0:27:05.14,中文,,0,0,0,,好的  所以计数排序很好
Dialogue: 0,0:27:05.14,0:27:06.72,英文,,0,0,0,,We can add it to our list of sorts.
Dialogue: 0,0:27:05.14,0:27:06.72,中文,,0,0,0,,我们可以把它添加到我们的排序列表中
Dialogue: 0,0:27:06.72,0:27:07.88,英文,,0,0,0,,That's great.
Dialogue: 0,0:27:06.72,0:27:07.88,中文,,0,0,0,,那太好了
Dialogue: 0,0:27:07.88,0:27:16.17,英文,,0,0,0,,But as someone mentioned earlier, it's kind of annoying because sometimes you have a really big alphabet, like the case where I wanted to sort the cities.
Dialogue: 0,0:27:07.88,0:27:16.17,中文,,0,0,0,,但正如有人之前提到的  这有点烦人  因为有时候你的字母表非常大  比如我想排序城市名称的时候
Dialogue: 0,0:27:16.17,0:27:18.79,英文,,0,0,0,,So what if I combine this?
Dialogue: 0,0:27:16.17,0:27:18.79,中文,,0,0,0,,如果我把这个结合起来呢？
Dialogue: 0,0:27:18.79,0:27:27.28,英文,,0,0,0,,With my idea from last time, so do you remember last time as our final topic, I showed you digit by digit sorting,
Dialogue: 0,0:27:18.79,0:27:27.28,中文,,0,0,0,,结合我上次的想法  还记得上次我们最后的话题吗？我向你们展示了按位排序  我按一位数字对整个数组进行排序
Dialogue: 0,0:27:27.28,0:27:32.90,英文,,0,0,0,,where I sorted the entire array by one digit, and then the next digit, and then the next digit, and eventually I got everything in order.
Dialogue: 0,0:27:27.28,0:27:32.90,中文,,0,0,0,,然后是下一位数字  然后是再下一位数字  最终我把所有东西都排好了顺序
Dialogue: 0,0:27:32.90,0:27:38.45,英文,,0,0,0,,So if I take my first idea from last time, which is digit by digit sorting, and I take the second idea,
Dialogue: 0,0:27:32.90,0:27:38.45,中文,,0,0,0,,如果我把上次的第一个想法  也就是按位排序  和第二个想法
Dialogue: 0,0:27:38.45,0:27:41.87,英文,,0,0,0,, is counting sort, and I put them together, something really pretty happens.
Dialogue: 0,0:27:38.45,0:27:41.87,中文,,0,0,0,,也就是计数排序  结合起来  就会发生一些非常漂亮的事情
Dialogue: 0,0:27:41.87,0:27:48.81,英文,,0,0,0,,So that's what we're going to do last, which is we're going to put those two ideas together and invent something called radix sort.
Dialogue: 0,0:27:41.87,0:27:48.81,中文,,0,0,0,,所以这就是我们要做的最后一件事  我们将把这两个想法结合起来  发明一种叫做基数排序的东西
Dialogue: 0,0:27:48.81,0:27:52.40,英文,,0,0,0,,But before that, are we all feeling OK about counting sort?
Dialogue: 0,0:27:48.81,0:27:52.40,中文,,0,0,0,,不过在那之前  我们对计数排序感觉如何？
Dialogue: 0,0:27:52.40,0:27:53.12,英文,,0,0,0,,It's good about it.
Dialogue: 0,0:27:52.40,0:27:53.12,中文,,0,0,0,,感觉还不错
Dialogue: 0,0:27:53.12,0:27:55.26,英文,,0,0,0,,It's bad about it.
Dialogue: 0,0:27:53.12,0:27:55.26,中文,,0,0,0,,还是感觉不怎么样
Dialogue: 0,0:27:55.26,0:27:59.30,英文,,0,0,0,,OK, so here are some examples of things I want to sort on.
Dialogue: 0,0:27:55.26,0:27:59.30,中文,,0,0,0,,好的  以下是一些我想排序的例子
Dialogue: 0,0:27:59.30,0:28:03.89,英文,,0,0,0,,Strings, maybe instead of sorting on one suit, I want to sort on two card suits.
Dialogue: 0,0:27:59.30,0:28:03.89,中文,,0,0,0,,字符串  也许我不想按一种花色排序  我想按两种花色排序
Dialogue: 0,0:28:03.89,0:28:07.97,英文,,0,0,0,,Maybe instead of sorting on numbers, I can sort on numbers again.
Dialogue: 0,0:28:03.89,0:28:07.97,中文,,0,0,0,,也许我不用对数字进行排序  而是可以再次对数字进行排序
Dialogue: 0,0:28:07.97,0:28:10.39,英文,,0,0,0,,But they could be non-consecutive and all over the place.
Dialogue: 0,0:28:07.97,0:28:10.39,中文,,0,0,0,,但它们可能不是连续的  而且到处都是
Dialogue: 0,0:28:10.39,0:28:13.02,英文,,0,0,0,,But if I look at the things I'm sorting on,
Dialogue: 0,0:28:10.39,0:28:13.02,中文,,0,0,0,,但如果我看看我正在排序的东西
Dialogue: 0,0:28:13.02,0:28:20.16,英文,,0,0,0,,Doesn't it seem like, for example, in this case with the strings, I could say that my alphabet is all the strings in the world.
Dialogue: 0,0:28:13.02,0:28:20.16,中文,,0,0,0,,例如  在这种情况下  使用字符串  我是否可以认为我的字母表是世界上所有的字符串
Dialogue: 0,0:28:20.16,0:28:21.90,英文,,0,0,0,,There's a lot of strings in the world.
Dialogue: 0,0:28:20.16,0:28:21.90,中文,,0,0,0,,世界上有很多字符串
Dialogue: 0,0:28:21.90,0:28:27.58,英文,,0,0,0,,But if I look at this, there's actually another more fundamental alphabet that I can use.
Dialogue: 0,0:28:21.90,0:28:27.58,中文,,0,0,0,,但如果我看看这个  实际上我可以使用另一个更基本的字母表
Dialogue: 0,0:28:27.58,0:28:28.44,英文,,0,0,0,,What is that alphabet?
Dialogue: 0,0:28:27.58,0:28:28.44,中文,,0,0,0,,那个字母表是什么？
Dialogue: 0,0:28:28.44,0:28:35.55,英文,,0,0,0,,It's like A through Z. And yeah, the entire word is an A through Z. But the entire word is made up of small digits.
Dialogue: 0,0:28:28.44,0:28:35.55,中文,,0,0,0,,它就像 A 到 Z  是的  整个单词是 A 到 Z  但整个单词是由小数字组成的
Dialogue: 0,0:28:35.55,0:28:39.95,英文,,0,0,0,,And each digit is A through Z. And likewise, in this example,
Dialogue: 0,0:28:35.55,0:28:39.95,中文,,0,0,0,,每个数字都是 A 到 Z  同样地  在这个例子中
Dialogue: 0,0:28:39.95,0:28:45.45,英文,,0,0,0,,I could do regular old counting sort, and I'd have to create an array of size 50,000 or something.
Dialogue: 0,0:28:39.95,0:28:45.45,中文,,0,0,0,,我可以进行常规的计数排序  我必须创建一个大小为 50,000 或什么的数组
Dialogue: 0,0:28:45.45,0:28:53.15,英文,,0,0,0,,But if I look at this, it seems like each of the items is an individual digit, and each digit is only 0 through 9.
Dialogue: 0,0:28:45.45,0:28:53.15,中文,,0,0,0,,但如果我看看这个  似乎每个项目都是一个单独的数字  每个数字只有 0 到 9
Dialogue: 0,0:28:53.15,0:29:02.84,英文,,0,0,0,,So maybe I can decompose these keys, which are long strings or long numbers, into individual digits, and then do digit by digit sorting.
Dialogue: 0,0:28:53.15,0:29:02.84,中文,,0,0,0,,所以也许我可以将这些键（它们是长字符串或长数字）分解成单个数字  然后进行逐位排序
Dialogue: 0,0:29:02.84,0:29:06.38,英文,,0,0,0,,That's the last thing we're going to do, and it's going to put all the pieces together.
Dialogue: 0,0:29:02.84,0:29:06.38,中文,,0,0,0,,这是我们要做的最后一件事  它将把所有的部分放在一起
Dialogue: 0,0:29:06.38,0:29:08.16,英文,,0,0,0,,So you've actually already seen the slide.
Dialogue: 0,0:29:06.38,0:29:08.16,中文,,0,0,0,,所以你实际上已经看过这张幻灯片了
Dialogue: 0,0:29:08.16,0:29:09.72,英文,,0,0,0,,I'm not doing anything new here.
Dialogue: 0,0:29:08.16,0:29:09.72,中文,,0,0,0,,我在这里没有做什么新的事情
Dialogue: 0,0:29:09.72,0:29:21.44,英文,,0,0,0,,If you remember digit-by-digit sorting from last time, what you do is you just sort in the least significant digit, which in this case would be the rightmost suit.
Dialogue: 0,0:29:09.72,0:29:21.44,中文,,0,0,0,,如果你还记得上次讲的逐位排序  它的做法就是按最低有效位排序  在本例中也就是最右边的花色
Dialogue: 0,0:29:21.44,0:29:26.52,英文,,0,0,0,,So I put all the things ending in clubs before all the things ending in spades and so forth.
Dialogue: 0,0:29:21.44,0:29:26.52,中文,,0,0,0,,所以我把所有梅花结尾的牌放在所有黑桃结尾的牌之前  以此类推
Dialogue: 0,0:29:26.52,0:29:30.82,英文,,0,0,0,,And then completely separately from that, now I sort by the top digit.
Dialogue: 0,0:29:26.52,0:29:30.82,中文,,0,0,0,,然后完全独立地  现在我按最高位排序
Dialogue: 0,0:29:30.82,0:29:36.87,英文,,0,0,0,,And I say, let's put all the hearts or all the clubs in the top digit before all the spades in the top digit and so on.
Dialogue: 0,0:29:30.82,0:29:36.87,中文,,0,0,0,,我说  让我们把所有红桃或所有梅花放在最高位的前面  然后是所有黑桃等等
Dialogue: 0,0:29:36.87,0:29:43.37,英文,,0,0,0,,And the idea is if I use a stable sort, this is all from last time, none of the items will cross over, which is what I want.
Dialogue: 0,0:29:36.87,0:29:43.37,中文,,0,0,0,,想法是  如果我使用稳定的排序  这些都是上次讲过的  没有一个项目会交叉  这就是我想要的
Dialogue: 0,0:29:43.37,0:29:51.88,英文,,0,0,0,,Because when I sort it by the lower digit, I solved all of the inversions and all the problems in the lower digit, all the clubs before the spades, before the hearts.
Dialogue: 0,0:29:43.37,0:29:51.88,中文,,0,0,0,,因为当我按较低位排序时  我解决了较低位的所有倒置和所有问题  所有梅花都在黑桃和红桃之前
Dialogue: 0,0:29:51.88,0:29:58.12,英文,,0,0,0,,So then if I sort by the upper digit, well then, if there's ever a tie, let's say, here we have an upper digit diamond.
Dialogue: 0,0:29:51.88,0:29:58.12,中文,,0,0,0,,所以如果我按高位排序  那么  如果有平局  比如说  这里我们有一个高位方块
Dialogue: 0,0:29:58.12,0:29:59.18,英文,,0,0,0,,Or let's find another one.
Dialogue: 0,0:29:58.12,0:29:59.18,中文,,0,0,0,,或者让我们再找一个
Dialogue: 0,0:29:59.18,0:30:00.72,英文,,0,0,0,,Here we have an upper digit heart.
Dialogue: 0,0:29:59.18,0:30:00.72,中文,,0,0,0,,这里我们有一个高位红桃
Dialogue: 0,0:30:00.72,0:30:01.92,英文,,0,0,0,,That's Dave.
Dialogue: 0,0:30:00.72,0:30:01.92,中文,,0,0,0,,那是Dave
Dialogue: 0,0:30:01.92,0:30:05.48,英文,,0,0,0,,And here we have an upper digit heart, who is swimp.
Dialogue: 0,0:30:01.92,0:30:05.48,中文,,0,0,0,,这里我们有一个高位红桃  是swimp
Dialogue: 0,0:30:05.48,0:30:07.00,英文,,0,0,0,,I guess that's a name.
Dialogue: 0,0:30:05.48,0:30:07.00,中文,,0,0,0,,我猜那是个名字
Dialogue: 0,0:30:07.00,0:30:09.96,英文,,0,0,0,,Well, in that case, these two will not cross over.
Dialogue: 0,0:30:07.00,0:30:09.96,中文,,0,0,0,,那么  在这种情况下  这两个不会交叉
Dialogue: 0,0:30:09.96,0:30:13.65,英文,,0,0,0,,They are still preserving their relative order on the lower digit.
Dialogue: 0,0:30:09.96,0:30:13.65,中文,,0,0,0,,它们仍然保持着它们在较低位上的相对顺序
Dialogue: 0,0:30:13.65,0:30:17.35,英文,,0,0,0,,Even though they tied in the upper digit, that's what we want.
Dialogue: 0,0:30:13.65,0:30:17.35,中文,,0,0,0,,即使他们在高位上平了  这也是我们想要的
Dialogue: 0,0:30:17.35,0:30:20.73,英文,,0,0,0,,If this sort was not stable, these two might swap and cross places.
Dialogue: 0,0:30:17.35,0:30:20.73,中文,,0,0,0,,如果这个排序不稳定  这两个可能会交换和交叉位置
Dialogue: 0,0:30:20.73,0:30:22.82,英文,,0,0,0,,That would be bad.
Dialogue: 0,0:30:20.73,0:30:22.82,中文,,0,0,0,,那就不好了
Dialogue: 0,0:30:22.82,0:30:24.78,英文,,0,0,0,,So this is just digit by digit sorting.
Dialogue: 0,0:30:22.82,0:30:24.78,中文,,0,0,0,,所以这只是逐位排序
Dialogue: 0,0:30:24.78,0:30:26.04,英文,,0,0,0,,You've already seen it.
Dialogue: 0,0:30:24.78,0:30:26.04,中文,,0,0,0,,你已经看过了
Dialogue: 0,0:30:26.04,0:30:30.45,英文,,0,0,0,,I can even swap out the Diamonds Club's hard space with numbers if it makes it look nicer.
Dialogue: 0,0:30:26.04,0:30:30.45,中文,,0,0,0,,我甚至可以用数字替换方块梅花硬空格  如果它看起来更好
Dialogue: 0,0:30:30.45,0:30:31.77,英文,,0,0,0,,The idea is basically the same.
Dialogue: 0,0:30:30.45,0:30:31.77,中文,,0,0,0,,思路基本一样
Dialogue: 0,0:30:31.77,0:30:34.27,英文,,0,0,0,,I sort by the lower digit, then the higher digit.
Dialogue: 0,0:30:31.77,0:30:34.27,中文,,0,0,0,,我先按低位排序  再按高位排序
Dialogue: 0,0:30:34.27,0:30:42.17,英文,,0,0,0,,The only improvement, the thing I'm combining is that last time, I did digit by digit sorting where I did, say, merge sort on every digit.
Dialogue: 0,0:30:34.27,0:30:42.17,中文,,0,0,0,,唯一的改进之处  我结合了上次的做法  我进行了逐位排序  比如对每一位数字进行归并排序
Dialogue: 0,0:30:42.17,0:30:47.10,英文,,0,0,0,,But if instead of using merge sort, let's say we did counting sort on the first digit, and then counting sort on the next digit,
Dialogue: 0,0:30:42.17,0:30:47.10,中文,,0,0,0,,但如果我们不使用归并排序  而是对第一位进行计数排序  然后对下一位进行计数排序
Dialogue: 0,0:30:47.10,0:30:51.96,英文,,0,0,0,,and so forth, then you get something truly pretty.
Dialogue: 0,0:30:47.10,0:30:51.96,中文,,0,0,0,,以此类推  那么你会得到一个非常漂亮的排序结果
Dialogue: 0,0:30:51.96,0:30:55.56,英文,,0,0,0,,Which is what you see here.
Dialogue: 0,0:30:51.96,0:30:55.56,中文,,0,0,0,,就像你在这里看到的这样
Dialogue: 0,0:30:55.56,0:30:57.90,英文,,0,0,0,,So we combine the two ideas, and we get something new.
Dialogue: 0,0:30:55.56,0:30:57.90,中文,,0,0,0,,所以我们结合这两种思路  就得到了一个新的排序算法
Dialogue: 0,0:30:57.90,0:30:59.45,英文,,0,0,0,,It's got its own term.
Dialogue: 0,0:30:57.90,0:30:59.45,中文,,0,0,0,,它有自己的术语
Dialogue: 0,0:30:59.45,0:31:00.87,英文,,0,0,0,,It's called radix sort.
Dialogue: 0,0:30:59.45,0:31:00.87,中文,,0,0,0,,它被称为基数排序
Dialogue: 0,0:31:00.87,0:31:07.62,英文,,0,0,0,,And the idea behind radix sort is that I'm using counting sort, and I'm doing so digit by digit.
Dialogue: 0,0:31:00.87,0:31:07.62,中文,,0,0,0,,基数排序的思想是  我使用计数排序  并且逐位进行排序
Dialogue: 0,0:31:07.62,0:31:10.48,英文,,0,0,0,,And that's great, because each individual sort
Dialogue: 0,0:31:07.62,0:31:10.48,中文,,0,0,0,,这很棒  因为每个独立的排序
Dialogue: 0,0:31:10.48,0:31:16.70,英文,,0,0,0,,is over a very small alphabet, in this case 0 through 9 or A through Z. And I do it digit by digit.
Dialogue: 0,0:31:10.48,0:31:16.70,中文,,0,0,0,,都基于一个非常小的字母表  在本例中是0到9或A到Z  我逐位进行排序
Dialogue: 0,0:31:16.70,0:31:20.87,英文,,0,0,0,,So combining those two ideas gives me something really pretty called radix sort.
Dialogue: 0,0:31:16.70,0:31:20.87,中文,,0,0,0,,所以结合这两种思路  就得到了一个非常漂亮的排序算法  叫做基数排序
Dialogue: 0,0:31:20.87,0:31:26.69,英文,,0,0,0,,The one we've been seeing is LSD radix sort, or least significant digit, because I start in the ones place.
Dialogue: 0,0:31:20.87,0:31:26.69,中文,,0,0,0,,我们一直在看到的这种排序是LSD基数排序  或者称为最低有效位排序  因为我从个位开始排序
Dialogue: 0,0:31:26.69,0:31:28.60,英文,,0,0,0,,And then I sort by the tens place.
Dialogue: 0,0:31:26.69,0:31:28.60,中文,,0,0,0,,然后我按十位排序
Dialogue: 0,0:31:28.60,0:31:32.70,英文,,0,0,0,,And if I had a hundreds place, I would sort by that last.
Dialogue: 0,0:31:28.60,0:31:32.70,中文,,0,0,0,,如果我有百位  我会最后按百位排序
Dialogue: 0,0:31:32.70,0:31:38.03,英文,,0,0,0,,So final question, maybe not final question, but one of the final questions is,
Dialogue: 0,0:31:32.70,0:31:38.03,中文,,0,0,0,,所以最后一个问题  也许不是最后一个问题  但其中一个最后一个问题是
Dialogue: 0,0:31:38.03,0:31:40.33,英文,,0,0,0,,How do you think this does, runtime-wise?
Dialogue: 0,0:31:38.03,0:31:40.33,中文,,0,0,0,,你认为这个排序算法在运行时间方面表现如何？
Dialogue: 0,0:31:40.33,0:31:47.24,英文,,0,0,0,,Well, in this case, runtime-wise, turns out, I know it's annoying, but there's going to be a third variable.
Dialogue: 0,0:31:40.33,0:31:47.24,中文,,0,0,0,,嗯  在这种情况下  就运行时间而言  事实证明  我知道这很烦人  但会有第三个变量
Dialogue: 0,0:31:47.24,0:31:49.74,英文,,0,0,0,,You're like, I had no trouble with two.
Dialogue: 0,0:31:47.24,0:31:49.74,中文,,0,0,0,,你会想  我处理两个变量没问题
Dialogue: 0,0:31:49.74,0:31:51.20,英文,,0,0,0,,Now you want to show me three.
Dialogue: 0,0:31:49.74,0:31:51.20,中文,,0,0,0,,现在你想给我看三个变量
Dialogue: 0,0:31:51.20,0:31:52.18,英文,,0,0,0,,OK.
Dialogue: 0,0:31:51.20,0:31:52.18,中文,,0,0,0,,
Dialogue: 0,0:31:52.18,0:31:54.42,英文,,0,0,0,,There's actually a third variable you have to deal with.
Dialogue: 0,0:31:52.18,0:31:54.42,中文,,0,0,0,,实际上还有第三个变量需要考虑
Dialogue: 0,0:31:54.42,0:31:58.10,英文,,0,0,0,,So we still need n, because you can imagine if this table grows larger.
Dialogue: 0,0:31:54.42,0:31:58.10,中文,,0,0,0,,我们仍然需要  N   因为你可以想象如果这个表格变得更大
Dialogue: 0,0:31:58.10,0:32:01.27,英文,,0,0,0,,Instead of 10 people, I have 100 people.
Dialogue: 0,0:31:58.10,0:32:01.27,中文,,0,0,0,,假设我有 100 个人  而不是 10 个人
Dialogue: 0,0:32:01.27,0:32:03.59,英文,,0,0,0,,Then my sort is going to be slower.
Dialogue: 0,0:32:01.27,0:32:03.59,中文,,0,0,0,,那么我的排序速度就会变慢
Dialogue: 0,0:32:03.59,0:32:03.59,英文,,0,0,0,,I still have to grow with the alphabet, because instead of using 10 digits, if I have 26 digits,
Dialogue: 0,0:32:03.59,0:32:12.45,英文,,0,0,0,, or somehow I have 100 digits, then it's going to be slower.
Dialogue: 0,0:32:03.59,0:32:07.95,中文,,0,0,0,,我仍然需要随着字母表的增长而增长  因为如果我有 26 个字母
Dialogue: 0,0:32:07.95,0:32:12.45,中文,,0,0,0,,或者我有 100 个字母  而不是使用 10 个数字  那么它就会变慢
Dialogue: 0,0:32:12.45,0:32:17.03,英文,,0,0,0,,But there's actually one more way in which I can make this sort slower.
Dialogue: 0,0:32:12.45,0:32:17.03,中文,,0,0,0,,但实际上还有一种方法可以让这种排序变得更慢
Dialogue: 0,0:32:17.03,0:32:19.05,英文,,0,0,0,,And it doesn't involve adding more people.
Dialogue: 0,0:32:17.03,0:32:19.05,中文,,0,0,0,,而且它不涉及增加更多的人
Dialogue: 0,0:32:19.05,0:32:24.24,英文,,0,0,0,,And it doesn't involve changing my alphabet from 0 through 9 to A to Z or something else.
Dialogue: 0,0:32:19.05,0:32:24.24,中文,,0,0,0,,而且它不涉及将我的字母表从 0 到 9 更改为 A 到 Z 或其他字母
Dialogue: 0,0:32:24.24,0:32:25.92,英文,,0,0,0,,So what is the final way?
Dialogue: 0,0:32:24.24,0:32:25.92,中文,,0,0,0,,那么最后一种方法是什么？
Dialogue: 0,0:32:25.92,0:32:28.26,英文,,0,0,0,,I'll give you 10 seconds to puzzle it over.
Dialogue: 0,0:32:25.92,0:32:28.26,中文,,0,0,0,,我给你 10 秒钟的时间来思考
Dialogue: 0,0:32:28.26,0:32:31.95,英文,,0,0,0,,What is the final way in which this sort can grow slower?
Dialogue: 0,0:32:28.26,0:32:31.95,中文,,0,0,0,,这种排序变慢的最后一种方法是什么？
Dialogue: 0,0:32:31.95,0:32:33.07,英文,,0,0,0,,It's not adding more students.
Dialogue: 0,0:32:31.95,0:32:33.07,中文,,0,0,0,,不是增加更多的学生
Dialogue: 0,0:32:33.07,0:32:34.75,英文,,0,0,0,,We already have n for that.
Dialogue: 0,0:32:33.07,0:32:34.75,中文,,0,0,0,,我们已经有了 N 来表示它
Dialogue: 0,0:32:34.75,0:32:36.88,英文,,0,0,0,,It's not changing the alphabet.
Dialogue: 0,0:32:34.75,0:32:36.88,中文,,0,0,0,,不是改变字母表
Dialogue: 0,0:32:36.88,0:32:38.38,英文,,0,0,0,,We already have r for that.
Dialogue: 0,0:32:36.88,0:32:38.38,中文,,0,0,0,,我们已经有了 R 来表示它
Dialogue: 0,0:32:38.38,0:32:40.06,英文,,0,0,0,,I have one more variable.
Dialogue: 0,0:32:38.38,0:32:40.06,中文,,0,0,0,,我还有一个变量
Dialogue: 0,0:32:40.06,0:32:42.80,英文,,0,0,0,,I'm probably going to call it w. How do I make it slower?
Dialogue: 0,0:32:40.06,0:32:42.80,中文,,0,0,0,,我可能会把它叫做 W  如何让它变慢？
Dialogue: 0,0:32:42.80,0:32:43.64,英文,,0,0,0,,I have answers.
Dialogue: 0,0:32:42.80,0:32:43.64,中文,,0,0,0,,我有答案
Dialogue: 0,0:32:43.64,0:32:46.87,英文,,0,0,0,,Yeah.
Dialogue: 0,0:32:43.64,0:32:46.87,中文,,0,0,0,,是的
Dialogue: 0,0:32:46.87,0:32:51.69,英文,,0,0,0,,Yeah, the number of chunks that I have to look at, the number of times I have to do a digit by digit sort.
Dialogue: 0,0:32:46.87,0:32:51.69,中文,,0,0,0,,对  我要查看的区块数量  也就是我需要进行逐位排序的次数
Dialogue: 0,0:32:51.69,0:33:01.28,英文,,0,0,0,,I agree, because what if instead of these being two digits long, they were five digit long numbers, or 10 digit long numbers, or 100 digit long numbers?
Dialogue: 0,0:32:51.69,0:33:01.28,中文,,0,0,0,,我同意  因为如果这些数字不是两位长  而是五位长  十位长  甚至一百位长呢？
Dialogue: 0,0:33:01.28,0:33:02.88,英文,,0,0,0,,Well, in that case,
Dialogue: 0,0:33:01.28,0:33:02.88,中文,,0,0,0,,嗯  那样的话
Dialogue: 0,0:33:02.88,0:33:10.09,英文,,0,0,0,,I have to do more passes of counting sort, because I have to do counting sort on the first digit, and then the next digit over, and then the next digit over.
Dialogue: 0,0:33:02.88,0:33:10.09,中文,,0,0,0,,我需要进行更多轮次的计数排序  因为我需要对第一位数字进行计数排序  然后是下一位  再下一位
Dialogue: 0,0:33:10.09,0:33:15.03,英文,,0,0,0,,And if I have many, many digits, then I have to do lots of different passes of counting sort.
Dialogue: 0,0:33:10.09,0:33:15.03,中文,,0,0,0,,如果有很多很多位数  那么我就要进行很多轮不同的计数排序
Dialogue: 0,0:33:15.03,0:33:16.19,英文,,0,0,0,,That's the great answer.
Dialogue: 0,0:33:15.03,0:33:16.19,中文,,0,0,0,,回答得非常好
Dialogue: 0,0:33:16.19,0:33:20.86,英文,,0,0,0,,So it turns out there's a third variable, which is the width of each item.
Dialogue: 0,0:33:16.19,0:33:20.86,中文,,0,0,0,,所以实际上还有第三个变量  那就是每个项目的宽度
Dialogue: 0,0:33:20.86,0:33:24.28,英文,,0,0,0,,In this example, it would be the number of digits in my number.
Dialogue: 0,0:33:20.86,0:33:24.28,中文,,0,0,0,,在这个例子中  它就是我数字中的位数
Dialogue: 0,0:33:24.28,0:33:25.56,英文,,0,0,0,,I didn't change the alphabet.
Dialogue: 0,0:33:24.28,0:33:25.56,中文,,0,0,0,,我没有改变字母表
Dialogue: 0,0:33:25.56,0:33:26.76,英文,,0,0,0,,I didn't add more students.
Dialogue: 0,0:33:25.56,0:33:26.76,中文,,0,0,0,,我也没有增加学生人数
Dialogue: 0,0:33:26.76,0:33:32.91,英文,,0,0,0,,But I changed the width of these numbers from 23 to 5-digit numbers to 10-digit numbers.
Dialogue: 0,0:33:26.76,0:33:32.91,中文,,0,0,0,,但是我把这些数字的宽度从23位改成了5位数、10位数
Dialogue: 0,0:33:32.91,0:33:36.31,英文,,0,0,0,,And if I do so, I would actually make this sort slower.
Dialogue: 0,0:33:32.91,0:33:36.31,中文,,0,0,0,,如果我这样做  实际上会让这个排序变慢
Dialogue: 0,0:33:36.31,0:33:40.97,英文,,0,0,0,,So the final runtime is w times n plus r.
Dialogue: 0,0:33:36.31,0:33:40.97,中文,,0,0,0,,所以最终的运行时间是WN + WR
Dialogue: 0,0:33:40.97,0:33:47.15,英文,,0,0,0,,Because we already said from last time, like from 10 minutes ago, that each counting sort takes n plus r time.
Dialogue: 0,0:33:40.97,0:33:47.15,中文,,0,0,0,,因为我们之前说过  比如十分钟前  每次计数排序都需要 N + R 的时间
Dialogue: 0,0:33:47.15,0:33:49.55,英文,,0,0,0,,We already did all that work, so I trust that it's correct.
Dialogue: 0,0:33:47.15,0:33:49.55,中文,,0,0,0,,我们已经做了所有这些工作  所以我相信它是正确的
Dialogue: 0,0:33:49.55,0:33:51.11,英文,,0,0,0,,And I have to do w passes of it.
Dialogue: 0,0:33:49.55,0:33:51.11,中文,,0,0,0,,我需要做 W 轮这样的操作
Dialogue: 0,0:33:51.11,0:33:52.97,英文,,0,0,0,,In this case, w is 2.
Dialogue: 0,0:33:51.11,0:33:52.97,中文,,0,0,0,,在这个例子中  W 是 2
Dialogue: 0,0:33:52.97,0:33:55.22,英文,,0,0,0,,I have to do two passes of counting sort.
Dialogue: 0,0:33:52.97,0:33:55.22,中文,,0,0,0,,我需要进行两轮计数排序
Dialogue: 0,0:33:55.22,0:33:58.60,英文,,0,0,0,,If these were 10-digit numbers, I would do 10 passes of counting sort.
Dialogue: 0,0:33:55.22,0:33:58.60,中文,,0,0,0,,如果这些是10位数  我就要进行10轮计数排序
Dialogue: 0,0:33:58.60,0:34:07.64,英文,,0,0,0,,So it would be 10 times n plus r. Sorry, I know this expression is kind of gross, but it's the last one you have to stare at for the day.
Dialogue: 0,0:33:58.60,0:34:07.64,中文,,0,0,0,,所以它将是10 ×（N + R）  抱歉  我知道这个表达式有点难看  但这是你今天要看的最后一个了
Dialogue: 0,0:34:07.64,0:34:09.24,英文,,0,0,0,,So I hope it's OK.
Dialogue: 0,0:34:07.64,0:34:09.24,中文,,0,0,0,,希望这样可以
Dialogue: 0,0:34:09.24,0:34:11.10,英文,,0,0,0,,But that's LSD radix sort.
Dialogue: 0,0:34:09.24,0:34:11.10,中文,,0,0,0,,这就是 LSD 基数排序
Dialogue: 0,0:34:11.10,0:34:12.90,英文,,0,0,0,,You do counting sort.
Dialogue: 0,0:34:11.10,0:34:12.90,中文,,0,0,0,,使用计数排序
Dialogue: 0,0:34:12.90,0:34:14.34,英文,,0,0,0,,And you do it digit by digit.
Dialogue: 0,0:34:12.90,0:34:14.34,中文,,0,0,0,,并且逐位进行排序
Dialogue: 0,0:34:14.34,0:34:19.62,英文,,0,0,0,,And I introduce an extra variable for the cases where there's lots of digits to look at.
Dialogue: 0,0:34:14.34,0:34:19.62,中文,,0,0,0,,我引入了一个额外的变量  用于处理需要查看很多位数的情况
Dialogue: 0,0:34:19.62,0:34:21.18,英文,,0,0,0,,OK.
Dialogue: 0,0:34:19.62,0:34:21.18,中文,,0,0,0,,
Dialogue: 0,0:34:21.18,0:34:30.02,英文,,0,0,0,,By the way, if you're ever doing radix sort and you ever find yourself in a tough spot where you're like, uh-oh, some of these are three digits and some of these are one digit, what do you do?
Dialogue: 0,0:34:21.18,0:34:30.02,中文,,0,0,0,,顺便说一句  如果你在进行基数排序时遇到困难  比如  有些数字是三位数  有些数字是一位数  你该怎么办？
Dialogue: 0,0:34:30.02,0:34:31.90,英文,,0,0,0,,It kind of depends on what you're sorting.
Dialogue: 0,0:34:30.02,0:34:31.90,中文,,0,0,0,,这取决于你要排序的内容
Dialogue: 0,0:34:31.90,0:34:39.41,英文,,0,0,0,,In this case, since you're sorting numbers, I think it makes sense to represent the 9 as, for example, 009.
Dialogue: 0,0:34:31.90,0:34:39.41,中文,,0,0,0,,在这种情况下  由于你排序的是数字  我认为将 9 表示为 009 是有意义的
Dialogue: 0,0:34:39.41,0:34:42.37,英文,,0,0,0,,Or the 43 could be represented as a 043.
Dialogue: 0,0:34:39.41,0:34:42.37,中文,,0,0,0,,或者将 43 表示为 043
Dialogue: 0,0:34:42.37,0:34:47.81,英文,,0,0,0,,But if you're sorting something else, maybe you decide to deal with numbers that are different lengths differently.
Dialogue: 0,0:34:42.37,0:34:47.81,中文,,0,0,0,,但如果你排序的是其他内容  你可能会决定以不同的方式处理长度不同的数字
Dialogue: 0,0:34:47.81,0:34:50.15,英文,,0,0,0,,But in this case, that's how I would choose to do it.
Dialogue: 0,0:34:47.81,0:34:50.15,中文,,0,0,0,,但在这种情况下  这就是我会选择的方式
Dialogue: 0,0:34:50.15,0:34:53.27,英文,,0,0,0,,Instead of sorting 9, I would sort 009.
Dialogue: 0,0:34:50.15,0:34:53.27,中文,,0,0,0,,我不会排序 9  而是排序 009
Dialogue: 0,0:34:53.27,0:34:57.19,英文,,0,0,0,,That way, I have enough digits to run counting sort all the way to the end.
Dialogue: 0,0:34:53.27,0:34:57.19,中文,,0,0,0,,这样  我就有足够的位数来运行计数排序直到结束
Dialogue: 0,0:34:57.19,0:34:59.09,英文,,0,0,0,,But it is up to you.
Dialogue: 0,0:34:57.19,0:34:59.09,中文,,0,0,0,,但这取决于你
Dialogue: 0,0:34:59.09,0:35:01.85,英文,,0,0,0,,For example, in strings, maybe you want to do something different.
Dialogue: 0,0:34:59.09,0:35:01.85,中文,,0,0,0,,例如  对于字符串  你可能想做一些不同的事情
Dialogue: 0,0:35:01.85,0:35:03.95,英文,,0,0,0,,That's what I do for numbers.
Dialogue: 0,0:35:01.85,0:35:03.95,中文,,0,0,0,,这就是我对数字的处理方式
Dialogue: 0,0:35:03.95,0:35:12.50,英文,,0,0,0,,So I just wanted to raise the point in case you're ever faced with a situation where you have different number of digits per thing you want to sort.
Dialogue: 0,0:35:03.95,0:35:12.50,中文,,0,0,0,,我只是想提出这一点  以防你遇到每个要排序的对象都有不同位数的情况
Dialogue: 0,0:35:12.50,0:35:15.32,英文,,0,0,0,,All right, so we're almost done.
Dialogue: 0,0:35:12.50,0:35:15.32,中文,,0,0,0,,好的  我们快完成了
Dialogue: 0,0:35:15.32,0:35:17.24,英文,,0,0,0,,We came up with this last sort.
Dialogue: 0,0:35:15.32,0:35:17.24,中文,,0,0,0,,我们提出了最后一个排序算法
Dialogue: 0,0:35:17.24,0:35:24.62,英文,,0,0,0,,But at this point, if I want to compare LSD sort or radix sort to all of my previous sorts, well, now I'm kind of cheating.
Dialogue: 0,0:35:17.24,0:35:24.62,中文,,0,0,0,,但现在  如果我想比较 LSD 排序或基数排序与我之前所有排序算法的效率  那就有点作弊了
Dialogue: 0,0:35:24.62,0:35:30.30,英文,,0,0,0,,Because in LSD sort or radix sort, I consider the length of the numbers.
Dialogue: 0,0:35:24.62,0:35:30.30,中文,,0,0,0,,因为在 LSD 排序或基数排序中  我考虑了数字的长度
Dialogue: 0,0:35:30.30,0:35:42.27,英文,,0,0,0,,So I said, for example, sorting a 10-digit string with 10 characters is slower than sorting a number with five digits.
Dialogue: 0,0:35:30.30,0:35:42.27,中文,,0,0,0,,例如  我说过  对一个包含 10 个字符的 10 位字符串进行排序比对一个 5 位数字进行排序要慢
Dialogue: 0,0:35:42.27,0:35:47.53,英文,,0,0,0,,So I introduced extra variables for things like length of the string.
Dialogue: 0,0:35:42.27,0:35:47.53,中文,,0,0,0,,所以我引入了额外的变量  例如字符串的长度
Dialogue: 0,0:35:47.53,0:35:52.39,英文,,0,0,0,,But if I go back to merge sort, did I ever consider the length of the string when I was talking about merge sort?
Dialogue: 0,0:35:47.53,0:35:52.39,中文,,0,0,0,,但是如果我回到归并排序  当我讨论归并排序时  我是否考虑过字符串的长度？
Dialogue: 0,0:35:52.39,0:35:53.31,英文,,0,0,0,,I mean, not really.
Dialogue: 0,0:35:52.39,0:35:53.31,中文,,0,0,0,,我的意思是  并没有
Dialogue: 0,0:35:53.31,0:35:57.82,英文,,0,0,0,,We just kind of magically assumed that you can compare two strings in constant time.
Dialogue: 0,0:35:53.31,0:35:57.82,中文,,0,0,0,,我们只是神奇地假设你可以在常数时间内比较两个字符串
Dialogue: 0,0:35:57.82,0:36:05.02,英文,,0,0,0,,So now, I'm not really being honest, because I'm saying LSD sort could go really slow if my strings are long.
Dialogue: 0,0:35:57.82,0:36:05.02,中文,,0,0,0,,所以现在  我不是很诚实  因为我说如果我的字符串很长  LSD 排序可能会变得非常慢
Dialogue: 0,0:36:05.02,0:36:07.40,英文,,0,0,0,,But if I have really long strings in merge sort,
Dialogue: 0,0:36:05.02,0:36:07.40,中文,,0,0,0,,但是如果我在归并排序中有很长的字符串
Dialogue: 0,0:36:07.40,0:36:09.58,英文,,0,0,0,,Couldn't that also be slow?
Dialogue: 0,0:36:07.40,0:36:09.58,中文,,0,0,0,,那会不会也很慢？
Dialogue: 0,0:36:09.58,0:36:15.83,英文,,0,0,0,,Imagine doing merge sort on strings that are short, and imagine doing merge sort on strings that are very long.
Dialogue: 0,0:36:09.58,0:36:15.83,中文,,0,0,0,,想象一下对短字符串进行归并排序  再想象一下对非常长的字符串进行归并排序
Dialogue: 0,0:36:15.83,0:36:22.13,英文,,0,0,0,,Can't merge sort maybe get slower on the longer strings, because you have to compare all the letters in cases where there are ties.
Dialogue: 0,0:36:15.83,0:36:22.13,中文,,0,0,0,,归并排序会不会在较长的字符串上变慢  因为在出现相等情况时  你必须比较所有字母
Dialogue: 0,0:36:22.13,0:36:24.39,英文,,0,0,0,,So I'm not being totally honest here.
Dialogue: 0,0:36:22.13,0:36:24.39,中文,,0,0,0,,所以在这里我不是完全诚实的
Dialogue: 0,0:36:24.39,0:36:31.99,英文,,0,0,0,,And to be really honest, I'd have to go through and add extra variables to some of these to do a true apples-to-apples comparison.
Dialogue: 0,0:36:24.39,0:36:31.99,中文,,0,0,0,,为了真正做到诚实  我必须仔细检查并为其中一些算法添加额外的变量  以便进行真正的同类比较
Dialogue: 0,0:36:31.99,0:36:37.38,英文,,0,0,0,,But for now, that's the picture that we have.
Dialogue: 0,0:36:31.99,0:36:37.38,中文,,0,0,0,,但目前  这就是我们所了解的情况
Dialogue: 0,0:36:37.38,0:36:38.08,英文,,0,0,0,,Cool.
Dialogue: 0,0:36:37.38,0:36:38.08,中文,,0,0,0,,
Dialogue: 0,0:36:38.08,0:36:41.52,英文,,0,0,0,,If you're interested in this, by the way, I might not get to it today, so I won't test you on it.
Dialogue: 0,0:36:38.08,0:36:41.52,中文,,0,0,0,,顺便说一句  如果你对此感兴趣  我今天可能不会讲到它  所以我不会考你
Dialogue: 0,0:36:41.52,0:36:47.57,英文,,0,0,0,,But there's a cool video that Josh helped put together where you can watch these being compared, which I think is pretty cool.
Dialogue: 0,0:36:41.52,0:36:47.57,中文,,0,0,0,,但是 Josh 帮助制作了一个很酷的视频  你可以观看这些算法的比较  我认为这很酷
Dialogue: 0,0:36:47.57,0:36:51.19,英文,,0,0,0,,One more idea, which is most significant digits sort.
Dialogue: 0,0:36:47.57,0:36:51.19,中文,,0,0,0,,还有一个想法  就是最高有效位排序
Dialogue: 0,0:36:51.19,0:36:55.19,英文,,0,0,0,,So far, I've been going from the least significant digit to the most significant digit.
Dialogue: 0,0:36:51.19,0:36:55.19,中文,,0,0,0,,到目前为止  我一直是从最低有效位到最高有效位进行排序的
Dialogue: 0,0:36:55.19,0:36:57.37,英文,,0,0,0,,What if I went in the opposite order?
Dialogue: 0,0:36:55.19,0:36:57.37,中文,,0,0,0,,如果我反过来呢？
Dialogue: 0,0:36:57.37,0:37:01.77,英文,,0,0,0,,So here's an example with some very hard to say words.
Dialogue: 0,0:36:57.37,0:37:01.77,中文,,0,0,0,,举个例子  有些词很难说
Dialogue: 0,0:37:01.77,0:37:03.12,英文,,0,0,0,,Shall we try to say one?
Dialogue: 0,0:37:01.77,0:37:03.12,中文,,0,0,0,,我们要不要试着说一个？
Dialogue: 0,0:37:03.12,0:37:07.04,英文,,0,0,0,,Let's say pseudo-pseudo-hypo-para-thyroidism.
Dialogue: 0,0:37:03.12,0:37:07.04,中文,,0,0,0,,比如说“假性假性甲状旁腺功能减退症”
Dialogue: 0,0:37:07.04,0:37:07.54,英文,,0,0,0,,Look at that.
Dialogue: 0,0:37:07.04,0:37:07.54,中文,,0,0,0,,看那个
Dialogue: 0,0:37:07.54,0:37:11.98,英文,,0,0,0,,OK, so I don't know what that means, but that's a word that you can try and sort.
Dialogue: 0,0:37:07.54,0:37:11.98,中文,,0,0,0,,好吧  我不知道那是什么意思  但那是一个你可以尝试整理的词
Dialogue: 0,0:37:11.98,0:37:16.16,英文,,0,0,0,,So in this case, we could try to do least significant digit sort.
Dialogue: 0,0:37:11.98,0:37:16.16,中文,,0,0,0,,在这种情况下  我们可以尝试进行最低有效位排序
Dialogue: 0,0:37:16.16,0:37:17.93,英文,,0,0,0,,And what would we be doing?
Dialogue: 0,0:37:16.16,0:37:17.93,中文,,0,0,0,,那我们在做什么？
Dialogue: 0,0:37:17.93,0:37:22.93,英文,,0,0,0,,We would look at this character, and then sort by this one, and then sort by this one, and then sort by this one.
Dialogue: 0,0:37:17.93,0:37:22.93,中文,,0,0,0,,我们会看这个字符  然后按这个排序  然后按这个排序  然后按这个排序
Dialogue: 0,0:37:22.93,0:37:25.39,英文,,0,0,0,,And we do tons and tons of digit sorting.
Dialogue: 0,0:37:22.93,0:37:25.39,中文,,0,0,0,,我们做了大量的数字排序
Dialogue: 0,0:37:25.39,0:37:27.71,英文,,0,0,0,,Would any of them be useful?
Dialogue: 0,0:37:25.39,0:37:27.71,中文,,0,0,0,,它们中哪些有用？
Dialogue: 0,0:37:27.71,0:37:34.43,英文,,0,0,0,,Well, not really, because by the time you get here, you just end up sorting by these top ones anyway, and you get a pretty good answer.
Dialogue: 0,0:37:27.71,0:37:34.43,中文,,0,0,0,,嗯  其实不是  因为当你到这里的时候  你最终还是会按这些最上面的排序  你会得到一个很好的答案
Dialogue: 0,0:37:34.43,0:37:43.19,英文,,0,0,0,,So, if I do least significant digit sort, turns out most of the characters on this side, they don't matter at all, because all I had to do was sort by the first letter,
Dialogue: 0,0:37:34.43,0:37:43.19,中文,,0,0,0,,如果我做最低有效位排序  结果证明这边的字母大部分都无关紧要  因为我只需要按第一个字母排序
Dialogue: 0,0:37:43.19,0:37:51.73,英文,,0,0,0,,and I guess in the case of these two ties, sort by the second letter, and there was no point doing digit by digit sorting on the rest of this word.
Dialogue: 0,0:37:43.19,0:37:51.73,中文,,0,0,0,,我猜在这些并列的情况下  按第二个字母排序  没有必要对这个词的其余部分进行逐位排序
Dialogue: 0,0:37:51.73,0:37:59.93,英文,,0,0,0,,So what if I tried doing digit by digit radix sort in the other direction, start with the most significant, and work my way down?
Dialogue: 0,0:37:51.73,0:37:59.93,中文,,0,0,0,,那么  如果我尝试从另一个方向进行逐位基数排序  从最高位开始  一直向下进行呢？
Dialogue: 0,0:37:59.93,0:38:01.07,英文,,0,0,0,,Let's try it.
Dialogue: 0,0:37:59.93,0:38:01.07,中文,,0,0,0,,让我们试试吧
Dialogue: 0,0:38:01.07,0:38:02.15,英文,,0,0,0,,Here are a bunch of strings.
Dialogue: 0,0:38:01.07,0:38:02.15,中文,,0,0,0,,这里有一堆字符串
Dialogue: 0,0:38:02.15,0:38:03.35,英文,,0,0,0,,They're like three.
Dialogue: 0,0:38:02.15,0:38:03.35,中文,,0,0,0,,它们就像三个
Dialogue: 0,0:38:03.35,0:38:11.49,英文,,0,0,0,,And instead of doing LSD sort, which is to start from the ones digit and work my way to the left, I'm going to start with the most significant digit,
Dialogue: 0,0:38:03.35,0:38:11.49,中文,,0,0,0,,与其做LSD排序  也就是从个位数开始向左进行  我将从最高位数开始
Dialogue: 0,0:38:11.49,0:38:15.70,英文,,0,0,0,,Which in this case would be the hundreds digit and work my way to the right.
Dialogue: 0,0:38:11.49,0:38:15.70,中文,,0,0,0,,在这种情况下是百位数  然后向右进行
Dialogue: 0,0:38:15.70,0:38:19.72,英文,,0,0,0,,So I'll put everything in order, A's before B's before C's before F's.
Dialogue: 0,0:38:15.70,0:38:19.72,中文,,0,0,0,,所以我将把所有东西按顺序排列  A在B之前  B在C之前  C在F之前
Dialogue: 0,0:38:19.72,0:38:25.37,英文,,0,0,0,,Now it is time to sort by the tens digit, the one in the middle, with no regard for the top digit.
Dialogue: 0,0:38:19.72,0:38:25.37,中文,,0,0,0,,现在  我们要根据十位数（中间那个数字）进行排序  不用管最高位数字
Dialogue: 0,0:38:25.37,0:38:27.55,英文,,0,0,0,,I've already finished sorting by the top digit.
Dialogue: 0,0:38:25.37,0:38:27.55,中文,,0,0,0,,我已经按照最高位数字排好序了
Dialogue: 0,0:38:27.55,0:38:29.17,英文,,0,0,0,,My counting sort is complete.
Dialogue: 0,0:38:27.55,0:38:29.17,中文,,0,0,0,,我的计数排序完成了
Dialogue: 0,0:38:29.17,0:38:30.81,英文,,0,0,0,,I will never touch these again.
Dialogue: 0,0:38:29.17,0:38:30.81,中文,,0,0,0,,我再也不会碰这些了
Dialogue: 0,0:38:30.81,0:38:34.12,英文,,0,0,0,,So what happens with the middle digit?
Dialogue: 0,0:38:30.81,0:38:34.12,中文,,0,0,0,,那么中间数字会发生什么呢？
Dialogue: 0,0:38:34.12,0:38:35.68,英文,,0,0,0,,Well, let's try it.
Dialogue: 0,0:38:34.12,0:38:35.68,中文,,0,0,0,,好吧  让我们试试看
Dialogue: 0,0:38:35.68,0:38:42.86,英文,,0,0,0,,So I try it, and, well, this doesn't look so good, because if I sort by the middle digit, bad, which has an A in the middle,
Dialogue: 0,0:38:35.68,0:38:42.86,中文,,0,0,0,,所以我试了一下  结果看起来不太好  因为如果我按中间数字排序  “bad”这个词中间是a
Dialogue: 0,0:38:42.86,0:38:48.78,英文,,0,0,0,, goes up here, and add, which has a D in the middle, goes over here.
Dialogue: 0,0:38:42.86,0:38:48.78,中文,,0,0,0,,它会跑到上面去  而“add”这个词中间是d  它会跑到这边来
Dialogue: 0,0:38:48.78,0:38:51.73,英文,,0,0,0,,Is this the right place to put bad and add?
Dialogue: 0,0:38:48.78,0:38:51.73,中文,,0,0,0,,这是放置“bad”和“add”的正确位置吗？
Dialogue: 0,0:38:51.73,0:38:56.79,英文,,0,0,0,,Well, no, because B shouldn't come before A. So it looks like I actually messed up.
Dialogue: 0,0:38:51.73,0:38:56.79,中文,,0,0,0,,当然不是  因为B不应该在A之前  所以看起来我实际上搞砸了
Dialogue: 0,0:38:56.79,0:39:01.03,英文,,0,0,0,,If I go in the opposite order, and it's kind of weird, things actually get messed up.
Dialogue: 0,0:38:56.79,0:39:01.03,中文,,0,0,0,,如果我按相反的顺序进行排序  这有点奇怪  事情实际上会变得更糟
Dialogue: 0,0:39:01.03,0:39:05.08,英文,,0,0,0,,And if I sort by the ones digit, this actually will not be fixed.
Dialogue: 0,0:39:01.03,0:39:05.08,中文,,0,0,0,,如果我按个位数字排序  这实际上也无法解决问题
Dialogue: 0,0:39:05.08,0:39:09.17,英文,,0,0,0,,So if I'm doing MSD sort, I have to be more careful.
Dialogue: 0,0:39:05.08,0:39:09.17,中文,,0,0,0,,所以如果我进行MSD排序  我必须更加小心
Dialogue: 0,0:39:09.17,0:39:18.40,英文,,0,0,0,,Because when I was doing LSD sort, the best 10-second explanation I can give for this weird phenomenon, and I think trying it out on paper is also super helpful,
Dialogue: 0,0:39:09.17,0:39:18.40,中文,,0,0,0,,因为当我进行LSD排序时  对于这种奇怪现象  我能给出的最好的10秒解释是  我认为在纸上尝试一下也超级有用
Dialogue: 0,0:39:18.40,0:39:23.86,英文,,0,0,0,,if I was doing LSD sort, I was breaking the ties on the least significant digit side first.
Dialogue: 0,0:39:18.40,0:39:23.86,中文,,0,0,0,,如果我进行LSD排序  我首先打破了最低有效位数上的平局
Dialogue: 0,0:39:23.86,0:39:27.12,英文,,0,0,0,,And then I was doing the most significant digit last.
Dialogue: 0,0:39:23.86,0:39:27.12,中文,,0,0,0,,然后我最后处理最高有效位数
Dialogue: 0,0:39:27.12,0:39:35.13,英文,,0,0,0,,By contrast, if I do the most significant digit here, and then I ignore the most significant digit to go and break the ties, I will actually get things out of order.
Dialogue: 0,0:39:27.12,0:39:35.13,中文,,0,0,0,,相反  如果我在这里先处理最高有效位数  然后忽略最高有效位数去打破平局  我实际上会把事情搞乱
Dialogue: 0,0:39:35.13,0:39:38.17,英文,,0,0,0,,Because this most significant digit stuff, it mattered.
Dialogue: 0,0:39:35.13,0:39:38.17,中文,,0,0,0,,因为这个最高有效位数的东西  它很重要
Dialogue: 0,0:39:38.17,0:39:40.43,英文,,0,0,0,,That was my top choice of sort.
Dialogue: 0,0:39:38.17,0:39:40.43,中文,,0,0,0,,这是我排序的首选
Dialogue: 0,0:39:40.43,0:39:42.93,英文,,0,0,0,,So I needed to do it last.
Dialogue: 0,0:39:40.43,0:39:42.93,中文,,0,0,0,,所以我需要把它放到最后
Dialogue: 0,0:39:42.93,0:39:45.75,英文,,0,0,0,,Sorry, that might have not been the greatest of all explanations.
Dialogue: 0,0:39:42.93,0:39:45.75,中文,,0,0,0,,抱歉  这可能不是最好的解释
Dialogue: 0,0:39:45.75,0:39:54.73,英文,,0,0,0,,But here's the idea, which is, if I know that these start with As, and then here are some Bs, here's a C, here's an F, well, I do not want these things crossing over.
Dialogue: 0,0:39:45.75,0:39:54.73,中文,,0,0,0,,但重点是  如果我知道这些单词以A开头  然后这里有一些B  这里有一个C  这里有一个F  那么我不想让这些东西交叉排列
Dialogue: 0,0:39:54.73,0:39:59.09,英文,,0,0,0,,So the idea is I would just split them up into subproblems.
Dialogue: 0,0:39:54.73,0:39:59.09,中文,,0,0,0,,所以我的想法是将它们分解成子问题
Dialogue: 0,0:39:59.09,0:40:06.75,英文,,0,0,0,,So once I have all the things starting with A, I will sort this subproblem by itself, refusing to let these items cross over into the B range.
Dialogue: 0,0:39:59.09,0:40:06.75,中文,,0,0,0,,一旦我将所有以 A 开头的单词归类  我就会对这个子问题进行排序  并确保这些单词不会越界到 B 的范围
Dialogue: 0,0:40:06.75,0:40:08.69,英文,,0,0,0,,Same thing with these B words.
Dialogue: 0,0:40:06.75,0:40:08.69,中文,,0,0,0,,对这些 B 开头的单词也是一样
Dialogue: 0,0:40:08.69,0:40:11.60,英文,,0,0,0,,I will sort them separately without letting them cross over.
Dialogue: 0,0:40:08.69,0:40:11.60,中文,,0,0,0,,我会将它们分别排序  而不会让它们越界
Dialogue: 0,0:40:11.60,0:40:15.58,英文,,0,0,0,,And then same with the C word, same with the F words.
Dialogue: 0,0:40:11.60,0:40:15.58,中文,,0,0,0,,然后对 C 开头的单词和 F 开头的单词也一样
Dialogue: 0,0:40:15.58,0:40:22.76,英文,,0,0,0,,Not bad words, but the F words, the ones that start with F. So then I sort by the middle digit, and I get more subproblems.
Dialogue: 0,0:40:15.58,0:40:22.76,中文,,0,0,0,,不是脏话  而是指以 F 开头的单词  然后我按照中间的数字排序  得到了更多的子问题
Dialogue: 0,0:40:22.76,0:40:24.64,英文,,0,0,0,,In this case, I get more subproblems.
Dialogue: 0,0:40:22.76,0:40:24.64,中文,,0,0,0,,在这种情况下  我得到了更多的子问题
Dialogue: 0,0:40:24.64,0:40:30.95,英文,,0,0,0,,In this case, because two things tie with the B and the E, this would be a subproblem of size 2 that I have to solve.
Dialogue: 0,0:40:24.64,0:40:30.95,中文,,0,0,0,,在这种情况下  因为有两个单词以 B 和 E 打头  这将是一个大小为 2 的子问题  我需要解决它
Dialogue: 0,0:40:30.95,0:40:33.45,英文,,0,0,0,,And I'd solve that, too.
Dialogue: 0,0:40:30.95,0:40:33.45,中文,,0,0,0,,我也会解决这个问题
Dialogue: 0,0:40:33.45,0:40:35.41,英文,,0,0,0,,I would do digit by digit sorting.
Dialogue: 0,0:40:33.45,0:40:35.41,中文,,0,0,0,,我会按位排序
Dialogue: 0,0:40:35.41,0:40:43.94,英文,,0,0,0,,But along the way, unlike an LSD sort where I can just go right to left and be done with everything, in this case, because I'm sorting by the most important thing first
Dialogue: 0,0:40:35.41,0:40:43.94,中文,,0,0,0,,与 LSD 排序不同的是  我可以从右到左完成所有操作  在这种情况下  我首先按最重要的内容排序
Dialogue: 0,0:40:43.94,0:40:51.90,英文,,0,0,0,, and I want to keep the most important sort sticking around, I have to actually split the problem into smaller subproblems.
Dialogue: 0,0:40:43.94,0:40:51.90,中文,,0,0,0,,并且希望保持最重要的排序结果  所以我必须将问题分解成更小的子问题
Dialogue: 0,0:40:51.90,0:40:52.70,英文,,0,0,0,,Kind of funky.
Dialogue: 0,0:40:51.90,0:40:52.70,中文,,0,0,0,,有点奇怪
Dialogue: 0,0:40:52.70,0:40:59.91,英文,,0,0,0,,But this would also totally work, although maybe a little bit trickier to implement than LSD radix sort.
Dialogue: 0,0:40:52.70,0:40:59.91,中文,,0,0,0,,但这完全可行  尽管实现起来可能比 LSD 基数排序稍微复杂一些
Dialogue: 0,0:40:59.91,0:41:03.99,英文,,0,0,0,,OK, I'm not going to make this all of the entire best and worst case.
Dialogue: 0,0:40:59.91,0:41:03.99,中文,,0,0,0,,好的  我不会把所有这些都作为最好的和最坏的情况
Dialogue: 0,0:41:03.99,0:41:10.40,英文,,0,0,0,,But the idea behind MSD sort, we're still doing multiple passes of counting sort, just like we were doing from earlier.
Dialogue: 0,0:41:03.99,0:41:10.40,中文,,0,0,0,,但 MSD 排序背后的思想是  我们仍然像之前一样进行多次计数排序
Dialogue: 0,0:41:10.40,0:41:12.97,英文,,0,0,0,,So we can think about the best and worst case.
Dialogue: 0,0:41:10.40,0:41:12.97,中文,,0,0,0,,所以我们可以考虑最好和最坏的情况
Dialogue: 0,0:41:12.97,0:41:15.51,英文,,0,0,0,,Here's an example that I think is pretty close to best case.
Dialogue: 0,0:41:12.97,0:41:15.51,中文,,0,0,0,,这是一个我认为非常接近最佳情况的例子
Dialogue: 0,0:41:15.51,0:41:18.71,英文,,0,0,0,,Because what would you do if you were doing MSD sort?
Dialogue: 0,0:41:15.51,0:41:18.71,中文,,0,0,0,,因为如果你进行 MSD 排序  你会怎么做？
Dialogue: 0,0:41:18.71,0:41:20.47,英文,,0,0,0,,You would sort by the top letter.
Dialogue: 0,0:41:18.71,0:41:20.47,中文,,0,0,0,,你会按第一个字母排序
Dialogue: 0,0:41:20.47,0:41:24.71,英文,,0,0,0,,And you'd get the A first, and then the F, and then the H. And there's two Ps.
Dialogue: 0,0:41:20.47,0:41:24.71,中文,,0,0,0,,你会先得到 A  然后是 F  然后是 H  还有两个 P
Dialogue: 0,0:41:24.71,0:41:27.53,英文,,0,0,0,,You have to do one more pass of counting sort to break that tie.
Dialogue: 0,0:41:24.71,0:41:27.53,中文,,0,0,0,,你需要再进行一次计数排序来打破平局
Dialogue: 0,0:41:27.53,0:41:28.69,英文,,0,0,0,,And then you're done.
Dialogue: 0,0:41:27.53,0:41:28.69,中文,,0,0,0,,然后就完成了
Dialogue: 0,0:41:28.69,0:41:30.91,英文,,0,0,0,,You don't have to look at the rest of these letters.
Dialogue: 0,0:41:28.69,0:41:30.91,中文,,0,0,0,,你不需要再看剩下的这些字母了
Dialogue: 0,0:41:30.91,0:41:34.35,英文,,0,0,0,,So you can actually solve this in two passes of counting sort.
Dialogue: 0,0:41:30.91,0:41:34.35,中文,,0,0,0,,所以实际上你可以通过两次计数排序来解决这个问题
Dialogue: 0,0:41:34.35,0:41:37.97,英文,,0,0,0,,Because you look at the top digit, then the second digit, everything is sorted.
Dialogue: 0,0:41:34.35,0:41:37.97,中文,,0,0,0,,因为你看一下最高位  然后是第二位  所有东西都排序好了
Dialogue: 0,0:41:37.97,0:41:40.61,英文,,0,0,0,,There's no more ties, nothing else to do.
Dialogue: 0,0:41:37.97,0:41:40.61,中文,,0,0,0,,没有平局了  也没有别的事情可做了
Dialogue: 0,0:41:40.61,0:41:45.22,英文,,0,0,0,,So in the best case, if all of the words started with a different character,
Dialogue: 0,0:41:40.61,0:41:45.22,中文,,0,0,0,,所以在最好的情况下  如果所有的单词都以不同的字符开头
Dialogue: 0,0:41:45.22,0:41:49.18,英文,,0,0,0,,I could actually finish the whole thing in a single counting sort pass.
Dialogue: 0,0:41:45.22,0:41:49.18,中文,,0,0,0,,我实际上可以在一次计数排序过程中完成整个过程
Dialogue: 0,0:41:49.18,0:41:54.94,英文,,0,0,0,,But in the worst case, imagine if all the characters were the same and they only differed in the final character.
Dialogue: 0,0:41:49.18,0:41:54.94,中文,,0,0,0,,但在最坏的情况下  假设所有字符都相同  并且它们仅在最后一个字符上有所不同
Dialogue: 0,0:41:54.94,0:41:56.48,英文,,0,0,0,,Then I'd have to check the first character.
Dialogue: 0,0:41:54.94,0:41:56.48,中文,,0,0,0,,那么我必须检查第一个字符
Dialogue: 0,0:41:56.48,0:41:57.44,英文,,0,0,0,,Oh, they're all the same.
Dialogue: 0,0:41:56.48,0:41:57.44,中文,,0,0,0,,哦  它们都一样
Dialogue: 0,0:41:57.44,0:41:58.76,英文,,0,0,0,,Check the next character.
Dialogue: 0,0:41:57.44,0:41:58.76,中文,,0,0,0,,检查下一个字符
Dialogue: 0,0:41:58.76,0:41:59.82,英文,,0,0,0,,Oh, they're all the same.
Dialogue: 0,0:41:58.76,0:41:59.82,中文,,0,0,0,,哦  它们都一样
Dialogue: 0,0:41:59.82,0:42:00.74,英文,,0,0,0,,Check the next one.
Dialogue: 0,0:41:59.82,0:42:00.74,中文,,0,0,0,,检查下一个
Dialogue: 0,0:42:00.74,0:42:01.81,英文,,0,0,0,,Oh, they're all the same.
Dialogue: 0,0:42:00.74,0:42:01.81,中文,,0,0,0,,哦  它们都一样
Dialogue: 0,0:42:01.81,0:42:11.09,英文,,0,0,0,,And eventually get to the last digit and get a runtime of w times n plus r, because I had to scan through the entire word and do w passes of counting sort.
Dialogue: 0,0:42:01.81,0:42:11.09,中文,,0,0,0,,最终到达最后一位数字  得到运行时间为WN 加R  因为我必须扫描整个单词并进行W次计数排序
Dialogue: 0,0:42:11.09,0:42:14.17,英文,,0,0,0,,Question?
Dialogue: 0,0:42:11.09,0:42:14.17,中文,,0,0,0,,提问？
Dialogue: 0,0:42:14.17,0:42:17.11,英文,,0,0,0,,With the supply for numbers, I guess it depends on what the numbers are.
Dialogue: 0,0:42:14.17,0:42:17.11,中文,,0,0,0,,对于数字的供应  我想这取决于数字是什么
Dialogue: 0,0:42:17.11,0:42:25.82,英文,,0,0,0,,You could have a lot of numbers that are the same, but they differ in the last digit.
Dialogue: 0,0:42:17.11,0:42:25.82,中文,,0,0,0,,你可能有很多相同的数字  但它们在最后一位数字上有所不同
Dialogue: 0,0:42:25.82,0:42:27.06,英文,,0,0,0,,What if the numbers were different lengths?
Dialogue: 0,0:42:25.82,0:42:27.06,中文,,0,0,0,,如果数字长度不同怎么办？
Dialogue: 0,0:42:27.06,0:42:28.12,英文,,0,0,0,,I had a slide for that.
Dialogue: 0,0:42:27.06,0:42:28.12,中文,,0,0,0,,我之前准备了一张幻灯片来解释这个
Dialogue: 0,0:42:28.12,0:42:28.70,英文,,0,0,0,,Let's go find it.
Dialogue: 0,0:42:28.12,0:42:28.70,中文,,0,0,0,,我们去找找看
Dialogue: 0,0:42:28.70,0:42:35.44,英文,,0,0,0,,So if the numbers are different lengths, you can do something like this, where instead of 9, make it like 009, and then sort it like that.
Dialogue: 0,0:42:28.70,0:42:35.44,中文,,0,0,0,,如果数字长度不同  你可以这样做：把 9 变成 009  然后按这种方式排序
Dialogue: 0,0:42:35.44,0:42:38.40,英文,,0,0,0,,It's a good question, though.
Dialogue: 0,0:42:35.44,0:42:38.40,中文,,0,0,0,,这个问题问得好
Dialogue: 0,0:42:38.40,0:42:39.96,英文,,0,0,0,,Anything else you want to know?
Dialogue: 0,0:42:38.40,0:42:39.96,中文,,0,0,0,,还有其他想问的吗？
Dialogue: 0,0:42:39.96,0:42:41.32,英文,,0,0,0,,All right, so here's the sorting analysis.
Dialogue: 0,0:42:39.96,0:42:41.32,中文,,0,0,0,,好的  这是排序分析
Dialogue: 0,0:42:41.32,0:42:44.55,英文,,0,0,0,,Again, it's not totally apples to apples yet.
Dialogue: 0,0:42:41.32,0:42:44.55,中文,,0,0,0,,同样  这还不是完全的同类比较
Dialogue: 0,0:42:44.55,0:42:47.79,英文,,0,0,0,,I will make it so in the final seven minutes.
Dialogue: 0,0:42:44.55,0:42:47.79,中文,,0,0,0,,我会在最后的七分钟内把它变成同类比较
Dialogue: 0,0:42:47.79,0:42:55.53,英文,,0,0,0,,But if I was to do a truly apples to apples comparison, I would have to go back to my original sorts
Dialogue: 0,0:42:47.79,0:42:55.53,中文,,0,0,0,,但如果我要做一个真正的同类比较  我必须回到我最初的排序
Dialogue: 0,0:42:55.53,0:43:06.49,英文,,0,0,0,,and throw in extra variables to account for the fact that checking two strings that are very long can be slower than checking two strings that are the same.
Dialogue: 0,0:42:55.53,0:43:06.49,中文,,0,0,0,,并加入额外的变量来解释检查两个很长的字符串可能比检查两个相同的字符串慢
Dialogue: 0,0:43:06.49,0:43:08.27,英文,,0,0,0,,Or that are very short, that is.
Dialogue: 0,0:43:06.49,0:43:08.27,中文,,0,0,0,,或者说  检查两个很短的字符串可能更快
Dialogue: 0,0:43:08.27,0:43:10.13,英文,,0,0,0,,So for now, this is our picture.
Dialogue: 0,0:43:08.27,0:43:10.13,中文,,0,0,0,,所以现在  这是我们的图
Dialogue: 0,0:43:10.13,0:43:12.99,英文,,0,0,0,,Hopefully, we're OK with these expressions so far.
Dialogue: 0,0:43:10.13,0:43:12.99,中文,,0,0,0,,希望到目前为止  我们对这些表达式都没问题
Dialogue: 0,0:43:12.99,0:43:14.86,英文,,0,0,0,,I know there are a lot of variables in them.
Dialogue: 0,0:43:12.99,0:43:14.86,中文,,0,0,0,,我知道它们里面有很多变量
Dialogue: 0,0:43:14.86,0:43:20.42,英文,,0,0,0,,But I have faith by staring at it some more, it will be OK.
Dialogue: 0,0:43:14.86,0:43:20.42,中文,,0,0,0,,但我相信  多看几眼  就会理解的
Dialogue: 0,0:43:20.42,0:43:22.44,英文,,0,0,0,,Ready for the final topics of the day?
Dialogue: 0,0:43:20.42,0:43:22.44,中文,,0,0,0,,准备好学习今天的最后几个主题了吗？
Dialogue: 0,0:43:22.44,0:43:24.52,英文,,0,0,0,,All right. Here's the lecture.
Dialogue: 0,0:43:22.44,0:43:24.52,中文,,0,0,0,,好的   这是讲义
Dialogue: 0,0:43:24.52,0:43:26.76,英文,,0,0,0,,I will go through as much of it as I can.
Dialogue: 0,0:43:24.52,0:43:26.76,中文,,0,0,0,,我会尽可能多地讲一些
Dialogue: 0,0:43:26.76,0:43:28.80,英文,,0,0,0,,Anything that we don't cover, you can skip.
Dialogue: 0,0:43:26.76,0:43:28.80,中文,,0,0,0,,任何我们没有涵盖的内容  你都可以跳过
Dialogue: 0,0:43:28.80,0:43:30.63,英文,,0,0,0,,So you are welcome.
Dialogue: 0,0:43:28.80,0:43:30.63,中文,,0,0,0,,不用谢
Dialogue: 0,0:43:30.63,0:43:32.56,英文,,0,0,0,,OK.
Dialogue: 0,0:43:30.63,0:43:32.56,中文,,0,0,0,,
Dialogue: 0,0:43:32.56,0:43:43.87,英文,,0,0,0,,So here's an example where the problem from earlier was I said merge sort takes n log n compares, but I was making the assumption that comparing strings was instant.
Dialogue: 0,0:43:32.56,0:43:43.87,中文,,0,0,0,,这里有一个例子  之前的问题是我说归并排序需要 N log N 次比较  但我假设比较字符串是瞬时的
Dialogue: 0,0:43:43.87,0:43:46.61,英文,,0,0,0,,If I give you two strings, comparing them is instant.
Dialogue: 0,0:43:43.87,0:43:46.61,中文,,0,0,0,,如果我给你两个字符串  比较它们是瞬时的
Dialogue: 0,0:43:46.61,0:43:48.93,英文,,0,0,0,,I never introduced a variable to say,
Dialogue: 0,0:43:46.61,0:43:48.93,中文,,0,0,0,,我从来没有引入一个变量来说明
Dialogue: 0,0:43:48.93,0:43:55.32,英文,,0,0,0,,Don't you think merge sorting would be slower if the strings were really long than if I was merge sorting strings that were very short?
Dialogue: 0,0:43:48.93,0:43:55.32,中文,,0,0,0,,你不觉得如果字符串真的很长  归并排序会比排序非常短的字符串慢吗？
Dialogue: 0,0:43:55.32,0:43:59.90,英文,,0,0,0,,And it feels like the answer should be yes, we just didn't include it in our analysis.
Dialogue: 0,0:43:55.32,0:43:59.90,中文,,0,0,0,,感觉答案应该是肯定的  只是我们没有把它包括在分析中
Dialogue: 0,0:43:59.90,0:44:05.94,英文,,0,0,0,,So let's go back and redo our merge sort analysis and throw in the extra variable.
Dialogue: 0,0:43:59.90,0:44:05.94,中文,,0,0,0,,所以让我们回去重做归并排序分析  并加入额外的变量
Dialogue: 0,0:44:05.94,0:44:09.68,英文,,0,0,0,,for the case where I'm comparing strings that are longer.
Dialogue: 0,0:44:05.94,0:44:09.68,中文,,0,0,0,,针对比较较长字符串的情况
Dialogue: 0,0:44:09.68,0:44:12.62,英文,,0,0,0,,So the question is, how long does it take to compare two strings?
Dialogue: 0,0:44:09.68,0:44:12.62,中文,,0,0,0,,所以问题是  比较两个字符串需要多长时间？
Dialogue: 0,0:44:12.62,0:44:16.51,英文,,0,0,0,,If I give you one string and another string, how long does it take to compare them?
Dialogue: 0,0:44:12.62,0:44:16.51,中文,,0,0,0,,如果我给你一个字符串和另一个字符串  比较它们需要多长时间？
Dialogue: 0,0:44:16.51,0:44:18.87,英文,,0,0,0,,Well, it turns out, doesn't it kind of depend?
Dialogue: 0,0:44:16.51,0:44:18.87,中文,,0,0,0,,嗯  事实证明  这取决于具体情况  不是吗？
Dialogue: 0,0:44:18.87,0:44:23.55,英文,,0,0,0,,Because if the two strings are different in the top character, I give you a really long word starting with A
Dialogue: 0,0:44:18.87,0:44:23.55,中文,,0,0,0,,因为如果两个字符串在第一个字符上不同  我给你一个以 A 开头的很长的单词
Dialogue: 0,0:44:23.55,0:44:27.57,英文,,0,0,0,,and a really long word starting with Z, you can compare that instantly.
Dialogue: 0,0:44:23.55,0:44:27.57,中文,,0,0,0,,和一个以 Z 开头的很长的单词  你可以立即比较它们
Dialogue: 0,0:44:27.57,0:44:31.20,英文,,0,0,0,,You're like, that one starts with A. That one starts with Z. They're different.
Dialogue: 0,0:44:27.57,0:44:31.20,中文,,0,0,0,,你会说  那个以 A 开头  那个以 Z 开头  它们不同
Dialogue: 0,0:44:31.20,0:44:32.66,英文,,0,0,0,,And I'm done comparing.
Dialogue: 0,0:44:31.20,0:44:32.66,中文,,0,0,0,,然后我就比较完了
Dialogue: 0,0:44:32.66,0:44:36.40,英文,,0,0,0,,By contrast, what if the strings were identical but also very long?
Dialogue: 0,0:44:32.66,0:44:36.40,中文,,0,0,0,,相反  如果字符串相同但也很长呢？
Dialogue: 0,0:44:36.40,0:44:42.76,英文,,0,0,0,,Then you have to check, oh, the first character is the same, and so is the second character, and so is the third character, and so is the fourth character.
Dialogue: 0,0:44:36.40,0:44:42.76,中文,,0,0,0,,然后你必须检查  哦  第一个字符相同  第二个字符也相同  第三个字符也相同  第四个字符也相同
Dialogue: 0,0:44:42.76,0:44:49.63,英文,,0,0,0,,And you would spend w time checking that the strings are equal, where w is the length of the string.
Dialogue: 0,0:44:42.76,0:44:49.63,中文,,0,0,0,,你将花费 W 时间来检查字符串是否相等  其中 W 是字符串的长度
Dialogue: 0,0:44:49.63,0:44:57.27,英文,,0,0,0,,So in the worst case, a more honest runtime for merge sort, if I was doing a comparison, is to say merge sort is w times n log n,
Dialogue: 0,0:44:49.63,0:44:57.27,中文,,0,0,0,,在最坏的情况下  如果我进行比较  归并排序更真实的运行时间是说归并排序是 WN log N
Dialogue: 0,0:44:57.27,0:45:00.49,英文,,0,0,0,,because I know I'm doing n log n compares.
Dialogue: 0,0:44:57.27,0:45:00.49,中文,,0,0,0,,因为我知道我做了 N log N 次比较
Dialogue: 0,0:45:00.49,0:45:02.44,英文,,0,0,0,,That's the analysis we did last time.
Dialogue: 0,0:45:00.49,0:45:02.44,中文,,0,0,0,,这就是我们上次做的分析
Dialogue: 0,0:45:02.44,0:45:07.26,英文,,0,0,0,,But now I'm adding in a variable to say, those comparisons, they might not be instant.
Dialogue: 0,0:45:02.44,0:45:07.26,中文,,0,0,0,,但现在我添加了一个变量来说明  这些比较可能不是瞬时的
Dialogue: 0,0:45:07.26,0:45:13.00,英文,,0,0,0,,They might take w time if I have a really long string and I have to check every character.
Dialogue: 0,0:45:07.26,0:45:13.00,中文,,0,0,0,,如果我的字符串很长  而且我需要检查每一个字符  它们可能需要W时间
Dialogue: 0,0:45:13.00,0:45:19.83,英文,,0,0,0,,So to be more honest, I have to say merge sort is w times n log n if I want to compare it to radix sorts.
Dialogue: 0,0:45:13.00,0:45:19.83,中文,,0,0,0,,所以更准确地说  如果我想把它与基数排序进行比较  我必须说归并排序是WN log  N
Dialogue: 0,0:45:19.83,0:45:25.44,英文,,0,0,0,,Because radix sorts, I added in the w. So merge sorts, I need to add in the w as well so
Dialogue: 0,0:45:19.83,0:45:25.44,中文,,0,0,0,,因为在基数排序中  我加上了W  所以在归并排序中  我也需要加上W
Dialogue: 0,0:45:25.44,0:45:29.98,英文,,0,0,0,,that I'm being more honest and I'm not cheating and giving either sort an advantage.
Dialogue: 0,0:45:25.44,0:45:29.98,中文,,0,0,0,,这样我才能更诚实  不作弊  也不给任何一种排序带来优势
Dialogue: 0,0:45:29.98,0:45:34.22,英文,,0,0,0,,So I'm using the same type of analysis to solve both of these problems.
Dialogue: 0,0:45:29.98,0:45:34.22,中文,,0,0,0,,所以我用相同类型的分析来解决这两个问题
Dialogue: 0,0:45:34.22,0:45:39.80,英文,,0,0,0,,And so once you have these expressions, you can now start diving into trying to figure out which one is faster.
Dialogue: 0,0:45:34.22,0:45:39.80,中文,,0,0,0,,一旦你有了这些表达式  你就可以开始深入研究  试图找出哪一个更快
Dialogue: 0,0:45:39.80,0:45:41.65,英文,,0,0,0,,So here are some examples.
Dialogue: 0,0:45:39.80,0:45:41.65,中文,,0,0,0,,以下是一些例子
Dialogue: 0,0:45:41.65,0:45:43.51,英文,,0,0,0,,I won't go through them in too much detail.
Dialogue: 0,0:45:41.65,0:45:43.51,中文,,0,0,0,,我不会讲得太详细
Dialogue: 0,0:45:43.51,0:45:51.03,英文,,0,0,0,,But hopefully, just by looking at these two expressions, it's not too controversial to say if n blows up.
Dialogue: 0,0:45:43.51,0:45:51.03,中文,,0,0,0,,但希望通过观察这两个表达式  如果 N 爆炸式增长  说计数排序会更快  应该不会有太多争议
Dialogue: 0,0:45:51.03,0:45:53.15,英文,,0,0,0,,So let's say w is not too large.
Dialogue: 0,0:45:51.03,0:45:53.15,中文,,0,0,0,,假设W不是太大
Dialogue: 0,0:45:53.15,0:45:54.58,英文,,0,0,0,,It stays constant, whatever.
Dialogue: 0,0:45:53.15,0:45:54.58,中文,,0,0,0,,它保持不变  无论如何
Dialogue: 0,0:45:54.58,0:45:58.74,英文,,0,0,0,,But if n blows up, I'm comparing a million items. Billion items.
Dialogue: 0,0:45:54.58,0:45:58.74,中文,,0,0,0,,但如果 N 爆炸式增长  我就要比较一百万个项目   十亿个项目
Dialogue: 0,0:45:58.74,0:46:06.29,英文,,0,0,0,,Hopefully, it doesn't seem too controversial to say that counting sort, LSD sort, would win by quite a lot.
Dialogue: 0,0:45:58.74,0:46:06.29,中文,,0,0,0,,希望说计数排序  也就是LSD排序  会赢很多  应该不会有太多争议
Dialogue: 0,0:46:06.29,0:46:15.39,英文,,0,0,0,,Because here, I only have a term of n. Here, I have a term of n log n. And if we assume w is pretty small, I think counting sort would win by a lot.
Dialogue: 0,0:46:06.29,0:46:15.39,中文,,0,0,0,,因为在这里  我只有一项 N   这里我有一项N log N  如果我们假设W非常小  我认为计数排序会赢很多
Dialogue: 0,0:46:15.39,0:46:18.61,英文,,0,0,0,,So here's an example where there's tons and tons of strings.
Dialogue: 0,0:46:15.39,0:46:18.61,中文,,0,0,0,,所以这里有一个例子  有很多很多的字符串
Dialogue: 0,0:46:18.61,0:46:25.93,英文,,0,0,0,,Because I don't have to do nlog n compares, I just have to do that one scan of size n, I think that LSD sort would win.
Dialogue: 0,0:46:18.61,0:46:25.93,中文,,0,0,0,,因为我不需要做N log N的比较  我只需要做一次大小为 N 的扫描  我认为LSD排序会赢
Dialogue: 0,0:46:25.93,0:46:32.53,英文,,0,0,0,,But there are some cases, because of these expressions having two different variables, where I actually think merge sort would win.
Dialogue: 0,0:46:25.93,0:46:32.53,中文,,0,0,0,,但是由于这些表达式有两个不同的变量  我认为在某些情况下归并排序会赢
Dialogue: 0,0:46:32.53,0:46:33.79,英文,,0,0,0,,It's a little bit harder to see.
Dialogue: 0,0:46:32.53,0:46:33.79,中文,,0,0,0,,这有点难看出来
Dialogue: 0,0:46:33.79,0:46:37.95,英文,,0,0,0,,There's an example where I'm just not comparing things over and over again.
Dialogue: 0,0:46:33.79,0:46:37.95,中文,,0,0,0,,有一个例子  我不会一遍又一遍地比较东西
Dialogue: 0,0:46:37.95,0:46:41.47,英文,,0,0,0,,But roughly speaking, that's the analysis you'd have to do.
Dialogue: 0,0:46:37.95,0:46:41.47,中文,,0,0,0,,但粗略地说  这就是你必须做的分析
Dialogue: 0,0:46:41.47,0:46:43.36,英文,,0,0,0,,It would involve two variables.
Dialogue: 0,0:46:41.47,0:46:43.36,中文,,0,0,0,,这将涉及两个变量
Dialogue: 0,0:46:43.36,0:46:48.30,英文,,0,0,0,,And there are some cases where, for example, if n blows up, I think that lsdsort is a clear winner.
Dialogue: 0,0:46:43.36,0:46:48.30,中文,,0,0,0,,在某些情况下  例如  如果 N 变得很大  我认为lsdsort是明显的赢家
Dialogue: 0,0:46:48.30,0:46:52.88,英文,,0,0,0,,But sometimes if w and n are related in some way, maybe merge sort is the winner.
Dialogue: 0,0:46:48.30,0:46:52.88,中文,,0,0,0,,但有时如果W和 N 以某种方式相关  也许归并排序是赢家
Dialogue: 0,0:46:52.88,0:46:55.52,英文,,0,0,0,,And we kind of saw that when we saw the cities example.
Dialogue: 0,0:46:52.88,0:46:55.52,中文,,0,0,0,,我们在城市示例中看到了这一点
Dialogue: 0,0:46:55.52,0:46:58.46,英文,,0,0,0,,Sometimes radix sorts are not the clear winner.
Dialogue: 0,0:46:55.52,0:46:58.46,中文,,0,0,0,,有时基数排序并不是明显的赢家
Dialogue: 0,0:46:58.46,0:47:01.82,英文,,0,0,0,,If you really wanted to analyze this very closely, which you can.
Dialogue: 0,0:46:58.46,0:47:01.82,中文,,0,0,0,,如果你真的想仔细分析一下  你可以
Dialogue: 0,0:47:01.82,0:47:03.54,英文,,0,0,0,,I'm not going to do it, but you can.
Dialogue: 0,0:47:01.82,0:47:03.54,中文,,0,0,0,,我不会这样做  但你可以
Dialogue: 0,0:47:03.54,0:47:04.94,英文,,0,0,0,,You can go through these slides.
Dialogue: 0,0:47:03.54,0:47:04.94,中文,,0,0,0,,你可以浏览这些幻灯片
Dialogue: 0,0:47:04.94,0:47:07.70,英文,,0,0,0,,I don't think I'll test you on it since I'm not covering them in detail.
Dialogue: 0,0:47:04.94,0:47:07.70,中文,,0,0,0,,因为我没有详细介绍它们  所以我想我不会考你
Dialogue: 0,0:47:07.70,0:47:14.09,英文,,0,0,0,,But if you wanted to, you can go through and exactly count the number of operations that you're doing and get exact numbers.
Dialogue: 0,0:47:07.70,0:47:14.09,中文,,0,0,0,,但如果你愿意  你可以仔细计算你正在执行的操作数量并得到确切的数字
Dialogue: 0,0:47:14.09,0:47:16.01,英文,,0,0,0,,So here, they got an exact number.
Dialogue: 0,0:47:14.09,0:47:16.01,中文,,0,0,0,,所以在这里  他们得到了一个确切的数字
Dialogue: 0,0:47:16.01,0:47:20.87,英文,,0,0,0,,There, they got an exact number, which I think is kind of cool if you wanted to try it.
Dialogue: 0,0:47:16.01,0:47:20.87,中文,,0,0,0,,在那里  他们得到了一个确切的数字  如果你想尝试的话  我认为这很酷
Dialogue: 0,0:47:20.87,0:47:24.29,英文,,0,0,0,,Something else you can do in analysis is you can run experiments.
Dialogue: 0,0:47:20.87,0:47:24.29,中文,,0,0,0,,在分析中  你可以做的另一件事是进行实验
Dialogue: 0,0:47:24.29,0:47:26.55,英文,,0,0,0,,Kind of like those quick sort experiments that we ran.
Dialogue: 0,0:47:24.29,0:47:26.55,中文,,0,0,0,,有点像我们运行的快速排序实验
Dialogue: 0,0:47:26.55,0:47:31.59,英文,,0,0,0,,So you can actually run experiments in time, how long things take, to see which one is faster.
Dialogue: 0,0:47:26.55,0:47:31.59,中文,,0,0,0,,所以你实际上可以在时间上进行实验  看看哪些东西花费的时间更长  看看哪个更快
Dialogue: 0,0:47:31.59,0:47:39.30,英文,,0,0,0,,So oftentimes, when we're doing asymptotic analysis in theory, we have to actually go to the real world and see which one is faster.
Dialogue: 0,0:47:31.59,0:47:39.30,中文,,0,0,0,,所以很多时候  当我们在理论上进行渐近分析时  我们必须实际进入现实世界  看看哪个更快
Dialogue: 0,0:47:39.30,0:47:42.64,英文,,0,0,0,,And again, if you want to see this in detail, I promise you there's a video.
Dialogue: 0,0:47:39.30,0:47:42.64,中文,,0,0,0,,再说一次  如果你想详细了解这一点  我保证有一个视频
Dialogue: 0,0:47:42.64,0:47:47.52,英文,,0,0,0,,And it turns out that in real life, even more complicated stuff confounds the problem.
Dialogue: 0,0:47:42.64,0:47:47.52,中文,,0,0,0,,事实证明  在现实生活中  更复杂的东西会使问题变得更加复杂
Dialogue: 0,0:47:47.52,0:47:51.64,英文,,0,0,0,,So there's this really fancy thing that I won't even talk about called the just-in-time compiler
Dialogue: 0,0:47:47.52,0:47:51.64,中文,,0,0,0,,所以有一个我甚至不会谈论的非常奇特的东西  叫做即时编译器
Dialogue: 0,0:47:51.64,0:47:56.16,英文,,0,0,0,,that actually changes the way that your code runs and optimizes your code as it's going.
Dialogue: 0,0:47:51.64,0:47:56.16,中文,,0,0,0,,它实际上改变了你的代码运行的方式  并在你的代码运行时对其进行优化
Dialogue: 0,0:47:56.16,0:47:59.45,英文,,0,0,0,,And somehow, it makes your code faster as it's running.
Dialogue: 0,0:47:56.16,0:47:59.45,中文,,0,0,0,,不知何故  它使你的代码在运行时更快
Dialogue: 0,0:47:59.45,0:48:02.27,英文,,0,0,0,,It's very cool stuff that I don't have time to talk about.
Dialogue: 0,0:47:59.45,0:48:02.27,中文,,0,0,0,,这些内容很酷  但我没时间细讲
Dialogue: 0,0:48:02.27,0:48:05.13,英文,,0,0,0,,But if you're interested, those are the experiments that you can run.
Dialogue: 0,0:48:02.27,0:48:05.13,中文,,0,0,0,,如果你感兴趣  可以自己去尝试这些实验
Dialogue: 0,0:48:05.13,0:48:08.81,英文,,0,0,0,,And sometimes, you get results that are a little bit unexpected.
Dialogue: 0,0:48:05.13,0:48:08.81,中文,,0,0,0,,有时候  你会得到一些出乎意料的结果
Dialogue: 0,0:48:08.81,0:48:13.13,英文,,0,0,0,,So that's my two-second speed run of three topics that I'll never test you on.
Dialogue: 0,0:48:08.81,0:48:13.13,中文,,0,0,0,,这就是我对三个主题的两秒钟速通  我不会考你们的
Dialogue: 0,0:48:13.13,0:48:14.51,英文,,0,0,0,,But it's kind of cool.
Dialogue: 0,0:48:13.13,0:48:14.51,中文,,0,0,0,,但这确实挺酷的
Dialogue: 0,0:48:14.51,0:48:19.82,英文,,0,0,0,,The summary of what I do care about from this lecture is, which is better, MSD or merge sort?
Dialogue: 0,0:48:14.51,0:48:19.82,中文,,0,0,0,,这节课我真正关心的是  归并排序和MSD排序哪个更好？
Dialogue: 0,0:48:19.82,0:48:22.26,英文,,0,0,0,,I would say it usually depends.
Dialogue: 0,0:48:19.82,0:48:22.26,中文,,0,0,0,,我觉得这通常取决于具体情况
Dialogue: 0,0:48:22.26,0:48:23.94,英文,,0,0,0,,Sometimes you have to run experiments.
Dialogue: 0,0:48:22.26,0:48:23.94,中文,,0,0,0,,有时候你需要做实验
Dialogue: 0,0:48:23.94,0:48:29.45,英文,,0,0,0,,Sometimes you have to do more deep analysis between the two variables and think about your specific problem.
Dialogue: 0,0:48:23.94,0:48:29.45,中文,,0,0,0,,有时候你需要对这两个变量进行更深入的分析  并考虑你的具体问题
Dialogue: 0,0:48:29.45,0:48:32.47,英文,,0,0,0,,So there's not always one clear winner.
Dialogue: 0,0:48:29.45,0:48:32.47,中文,,0,0,0,,所以并不总是有一个明显的赢家
Dialogue: 0,0:48:32.47,0:48:35.66,英文,,0,0,0,,Both of them are very good for specific use cases.
Dialogue: 0,0:48:32.47,0:48:35.66,中文,,0,0,0,,它们都非常适合特定的用例
Dialogue: 0,0:48:35.66,0:48:40.06,英文,,0,0,0,,And comparing algorithms can often be very hard because you have to perform experiments.
Dialogue: 0,0:48:35.66,0:48:40.06,中文,,0,0,0,,比较算法通常很困难  因为你必须进行实验
Dialogue: 0,0:48:40.06,0:48:48.27,英文,,0,0,0,,And there are things deep down in the computer that you'll learn in later classes that can confound your experiments and make them more complicated.
Dialogue: 0,0:48:40.06,0:48:48.27,中文,,0,0,0,,而且在计算机的底层还有一些东西  你将在以后的课程中学习  这些东西会混淆你的实验  使它们变得更加复杂
Dialogue: 0,0:48:48.27,0:48:51.81,英文,,0,0,0,,The final thing I'll mention, I wanted to show you this video, but the audio wasn't working.
Dialogue: 0,0:48:48.27,0:48:51.81,中文,,0,0,0,,最后我要提一下  我想给你们看这个视频  但音频无法正常工作
Dialogue: 0,0:48:51.81,0:48:54.45,英文,,0,0,0,,So you'll have to watch the Obama video later.
Dialogue: 0,0:48:51.81,0:48:54.45,中文,,0,0,0,,所以你们以后得自己去看奥巴马的视频了
Dialogue: 0,0:48:54.45,0:48:56.89,英文,,0,0,0,,A couple of final things that I just wanted to raise the point.
Dialogue: 0,0:48:54.45,0:48:56.89,中文,,0,0,0,,最后还有几件事我想提一下
Dialogue: 0,0:48:56.89,0:49:02.10,英文,,0,0,0,,If you're interested, you're going to see this in 61C, so I don't feel the obligation to show it to you now.
Dialogue: 0,0:48:56.89,0:49:02.10,中文,,0,0,0,,如果你感兴趣  你会在61C课程中看到这个  所以我觉得现在没有必要展示给你们
Dialogue: 0,0:49:02.10,0:49:06.12,英文,,0,0,0,,But you can actually do radius sorting with different bases as well.
Dialogue: 0,0:49:02.10,0:49:06.12,中文,,0,0,0,,但实际上你也可以用不同的基数进行基数排序
Dialogue: 0,0:49:06.12,0:49:14.54,英文,,0,0,0,,So for example, you can be clever and say, what if, instead of radius sorting each digit, I treated the pair of digits 1, 2 as one unit?
Dialogue: 0,0:49:06.12,0:49:14.54,中文,,0,0,0,,例如  你可以很聪明地说  如果我不是对每个数字进行基数排序  而是将1和2这两个数字作为一个单元来处理呢？
Dialogue: 0,0:49:14.54,0:49:20.28,英文,,0,0,0,,And I did radix sorting on those pair of digits from 0, 0 through 9, 9.
Dialogue: 0,0:49:14.54,0:49:20.28,中文,,0,0,0,,我对这些数字对进行基数排序  从00到99
Dialogue: 0,0:49:20.28,0:49:24.84,英文,,0,0,0,,And then I did another digit by digit sorting on these two digits from 0, 0 to 9, 9.
Dialogue: 0,0:49:20.28,0:49:24.84,中文,,0,0,0,,然后我对这两位数进行了逐位排序  从 0, 0 到 9, 9
Dialogue: 0,0:49:24.84,0:49:27.70,英文,,0,0,0,,And then I did it on these two from 0, 0 to 9, 9.
Dialogue: 0,0:49:24.84,0:49:27.70,中文,,0,0,0,,然后我对这两位数进行了同样的操作  从 0, 0 到 9, 9
Dialogue: 0,0:49:27.70,0:49:28.72,英文,,0,0,0,,You can do that.
Dialogue: 0,0:49:27.70,0:49:28.72,中文,,0,0,0,,你可以这样做
Dialogue: 0,0:49:28.72,0:49:30.90,英文,,0,0,0,,That's the kind of thing that you'll see in 61C.
Dialogue: 0,0:49:28.72,0:49:30.90,中文,,0,0,0,,这是你在 61C 中会看到的那种东西
Dialogue: 0,0:49:30.90,0:49:37.23,英文,,0,0,0,,You can even be more clever and try different bases, like base 16 or base 256.
Dialogue: 0,0:49:30.90,0:49:37.23,中文,,0,0,0,,你甚至可以更聪明  尝试不同的进制  比如 16 进制或 256 进制
Dialogue: 0,0:49:37.23,0:49:38.77,英文,,0,0,0,,And here I would have, for example,
Dialogue: 0,0:49:37.23,0:49:38.77,中文,,0,0,0,,例如  在这里我将有
Dialogue: 0,0:49:38.77,0:49:43.61,英文,,0,0,0,,Three digits, where each digit is between 0 and 256.
Dialogue: 0,0:49:38.77,0:49:43.61,中文,,0,0,0,,三位数  每位数都在 0 到 256 之间
Dialogue: 0,0:49:43.61,0:49:45.03,英文,,0,0,0,,You'll see this in 61C.
Dialogue: 0,0:49:43.61,0:49:45.03,中文,,0,0,0,,你会在 61C 中看到这个
Dialogue: 0,0:49:45.03,0:49:45.99,英文,,0,0,0,,It's kind of cool.
Dialogue: 0,0:49:45.03,0:49:45.99,中文,,0,0,0,,这很酷
Dialogue: 0,0:49:45.99,0:49:49.77,英文,,0,0,0,,And you can actually run experiments to see which one is best.
Dialogue: 0,0:49:45.99,0:49:49.77,中文,,0,0,0,,你实际上可以运行实验  看看哪一种是最好的
Dialogue: 0,0:49:49.77,0:49:52.86,英文,,0,0,0,,So turns out you don't have to do this in base 10.
Dialogue: 0,0:49:49.77,0:49:52.86,中文,,0,0,0,,所以事实证明你不必在 10 进制中做这个
Dialogue: 0,0:49:52.86,0:50:00.97,英文,,0,0,0,,You can actually do it in different bases and choose different radices and get different runtimes, which I think is pretty cool.
Dialogue: 0,0:49:52.86,0:50:00.97,中文,,0,0,0,,你实际上可以在不同的进制中做这个  选择不同的基数  得到不同的运行时间  我认为这很酷
Dialogue: 0,0:50:00.97,0:50:05.39,英文,,0,0,0,,OK, do you have any final thoughts before everybody goes home?
Dialogue: 0,0:50:00.97,0:50:05.39,中文,,0,0,0,,好  在大伙回家之前  你们还有什么想法吗？
Dialogue: 0,0:50:05.39,0:50:06.75,英文,,0,0,0,,We saw lots of different sorts.
Dialogue: 0,0:50:05.39,0:50:06.75,中文,,0,0,0,,我们看到了很多不同的排序方法
Dialogue: 0,0:50:06.75,0:50:10.11,英文,,0,0,0,,I probably will not go through the summary, but there's a video if you want it.
Dialogue: 0,0:50:06.75,0:50:10.11,中文,,0,0,0,,我可能不会进行总结  但如果你想要的话  可以看视频
Dialogue: 0,0:50:10.11,0:50:12.83,英文,,0,0,0,,If not, it's the end of sorting.
Dialogue: 0,0:50:10.11,0:50:12.83,中文,,0,0,0,,如果没有  这就是排序的结束
Dialogue: 0,0:50:12.83,0:50:13.79,英文,,0,0,0,,There's no more sorting.
Dialogue: 0,0:50:12.83,0:50:13.79,中文,,0,0,0,,没有更多的排序了
Dialogue: 0,0:50:13.79,0:50:16.11,英文,,0,0,0,,But if you come back next time, there are more fun topics.
Dialogue: 0,0:50:13.79,0:50:16.11,中文,,0,0,0,,但如果你下次再来  还有更多有趣的话题
Dialogue: 0,0:50:16.11,0:50:18.10,英文,,0,0,0,,So don't go home just yet.
Dialogue: 0,0:50:16.11,0:50:18.10,中文,,0,0,0,,所以先别回家
Dialogue: 0,0:50:18.10,0:50:20.90,英文,,0,0,0,,Well, you can go home today, but come back next time for more fun topics.
Dialogue: 0,0:50:18.10,0:50:20.90,中文,,0,0,0,,好吧  你今天可以回家  但下次再来学习更多有趣的话题
Dialogue: 0,0:50:20.90,0:50:22.88,英文,,0,0,0,,All right, see you next time.
Dialogue: 0,0:50:20.90,0:50:22.88,中文,,0,0,0,,好的  下次再见
Dialogue: 0,0:50:22.88,0:50:23.64,英文,,0,0,0,,Oh, I got applause.
Dialogue: 0,0:50:22.88,0:50:23.64,中文,,0,0,0,,哦  我获得了掌声
Dialogue: 0,0:50:23.64,0:50:26.22,英文,,0,0,0,,Thank you.
Dialogue: 0,0:50:23.64,0:50:26.22,中文,,0,0,0,,谢谢
Dialogue: 0,0:50:26.22,0:50:26.84,英文,,0,0,0,,Thank you for coming.
Dialogue: 0,0:50:26.22,0:50:26.84,中文,,0,0,0,,谢谢你们来
