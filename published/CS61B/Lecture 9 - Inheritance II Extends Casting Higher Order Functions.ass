[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 3
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1152
PlayResY: 720

[Aegisub Project Garbage]
Export Encoding: Unicode (UTF-8)
Audio File: D:/python_code/video_tool/video_tool/result/Lecture 5 - Lists 3 DLLists and Arrays.mp4
Video File: D:/python_code/video_tool/video_tool/result/Lecture 5 - Lists 3 DLLists and Arrays.mp4
Video AR Mode: 4
Video AR Value: 1.600000
Video Zoom Percent: 0.500000
Scroll Position: 1305
Active Line: 970
Video Position: 57565

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,13,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,90,100,0,0,1,1.33333,1.33333,2,6,6,7,1
Style: 英文,Arial,24,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,90,100,0,0,1,1.33333,1.33333,2,1,1,5,1
Style: 中文,微软雅黑,38,&H0029EEF1,&H000000FF,&H00000000,&H00000000,-1,0,0,0,90,100,0,0,1,1.33333,1.33333,2,2,2,30,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,
Dialogue: 0,0:00:03.08,0:00:04.17,英文,,0,0,0,,OK.
Dialogue: 0,0:00:04.17,0:00:05.31,英文,,0,0,0,,Hi.
Dialogue: 0,0:00:04.17,0:00:05.31,中文,,0,0,0,,嗨
Dialogue: 0,0:00:05.31,0:00:06.66,英文,,0,0,0,,Let's keep talking about inheritance.
Dialogue: 0,0:00:05.31,0:00:06.66,中文,,0,0,0,,咱们继续聊聊继承
Dialogue: 0,0:00:06.66,0:00:09.92,英文,,0,0,0,,I hope you're excited.
Dialogue: 0,0:00:06.66,0:00:09.92,中文,,0,0,0,,希望你很兴奋
Dialogue: 0,0:00:09.92,0:00:10.98,英文,,0,0,0,,Okay, here we go.
Dialogue: 0,0:00:09.92,0:00:10.98,中文,,0,0,0,,开始吧
Dialogue: 0,0:00:10.98,0:00:12.56,英文,,0,0,0,,So, this is the slide from last time.
Dialogue: 0,0:00:10.98,0:00:12.56,中文,,0,0,0,,这是上次的幻灯片
Dialogue: 0,0:00:12.56,0:00:15.06,英文,,0,0,0,,Remember, last time we talked about two types of inheritance.
Dialogue: 0,0:00:12.56,0:00:15.06,中文,,0,0,0,,记得 上次我们讲了两种继承
Dialogue: 0,0:00:15.06,0:00:18.52,英文,,0,0,0,,We talked about interface inheritance, and this was inheriting what?
Dialogue: 0,0:00:15.06,0:00:18.52,中文,,0,0,0,,我们谈到了接口继承 这是继承什么
Dialogue: 0,0:00:18.52,0:00:24.72,英文,,0,0,0,,It was inheriting a list of all the methods that every List61b ever has to have.
Dialogue: 0,0:00:18.52,0:00:24.72,中文,,0,0,0,,它继承了每个 List61B 必须具有的所有方法的列表
Dialogue: 0,0:00:24.72,0:00:39.05,英文,,0,0,0,,So we wrote a list of all the methods, we did not write any implementation for them, and then all the subclasses, SList, DList, AList, all of them inherited the signatures of the interface.
Dialogue: 0,0:00:24.72,0:00:39.05,中文,,0,0,0,,我们列出了所有方法 没有为它们编写任何实现 然后所有的子类 SLList、DList、AList 它们都继承了接口的签名
Dialogue: 0,0:00:39.05,0:00:44.65,英文,,0,0,0,,And then we overrode those signatures with actual implementations of each of those methods.
Dialogue: 0,0:00:39.05,0:00:44.65,中文,,0,0,0,,然后我们用这些签名覆盖了实际的方法实现
Dialogue: 0,0:00:44.65,0:00:50.73,英文,,0,0,0,,By contrast, when we added that default keyword to write the default print method, that was implementation inheritance.
Dialogue: 0,0:00:44.65,0:00:50.73,中文,,0,0,0,,相比之下 当我们添加了 default 关键字来编写默认的 print 方法时 那就是实现继承
Dialogue: 0,0:00:50.73,0:00:53.26,英文,,0,0,0,,So here, the thing we're inheriting is tau.
Dialogue: 0,0:00:50.73,0:00:53.26,中文,,0,0,0,,在这里 我们要继承的is-a
Dialogue: 0,0:00:53.26,0:00:56.46,英文,,0,0,0,,It tells us how you implement this print method.
Dialogue: 0,0:00:53.26,0:00:56.46,中文,,0,0,0,,它告诉我们如何实现这个 print 方法
Dialogue: 0,0:00:56.46,0:01:04.00,英文,,0,0,0,,And so what happened was we wrote one default print method, and everybody, the S-list, the A-list, they all inherited that print method.
Dialogue: 0,0:00:56.46,0:01:04.00,中文,,0,0,0,,发生的是 我们写了一个默认的打印方法 所有的SLList、ALlist都继承了那个打印方法
Dialogue: 0,0:01:04.00,0:01:08.52,英文,,0,0,0,,So this one print method was inherited by all the different classes, which was great.
Dialogue: 0,0:01:04.00,0:01:08.52,中文,,0,0,0,,这个打印方法被所有不同的类继承了 这太棒了
Dialogue: 0,0:01:08.52,0:01:17.79,英文,,0,0,0,,And if you wanted to, you could choose to overwrite the print method just like we did, because we decided the print method was not super efficient for SLLists, so we overwrote it.
Dialogue: 0,0:01:08.52,0:01:17.79,中文,,0,0,0,,如果你想的话 你可以选择覆盖打印方法 就像我们做的那样 因为我们决定对SLList来说 打印方法不是特别高效 我们覆盖了它
Dialogue: 0,0:01:17.79,0:01:19.15,英文,,0,0,0,,Okay, this is important.
Dialogue: 0,0:01:17.79,0:01:19.15,中文,,0,0,0,,这很重要
Dialogue: 0,0:01:19.15,0:01:23.71,英文,,0,0,0,,I'll show it to you a little bit more later today, but that's what happened last time.
Dialogue: 0,0:01:19.15,0:01:23.71,中文,,0,0,0,,我稍后会给你展示更多 但这就是上次发生的事情
Dialogue: 0,0:01:23.71,0:01:26.23,英文,,0,0,0,,So today, we get to keep talking about inheritance.
Dialogue: 0,0:01:23.71,0:01:26.23,中文,,0,0,0,,今天 我们可以继续谈论继承
Dialogue: 0,0:01:26.23,0:01:32.16,英文,,0,0,0,,So I'll start by showing you a second version or a different version of implementation inheritance.
Dialogue: 0,0:01:26.23,0:01:32.16,中文,,0,0,0,,我会从给你展示第二个版本或不同版本的实现继承开始
Dialogue: 0,0:01:32.16,0:01:41.25,英文,,0,0,0,,So just like the default keyword from last time, we're going to be inheriting an implementation and not just signatures telling us what the list should be able to do.
Dialogue: 0,0:01:32.16,0:01:41.25,中文,,0,0,0,,就像上次的默认关键字一样 我们将继承一个实现 而不仅仅是签名告诉我们列表应该能做什么
Dialogue: 0,0:01:41.25,0:01:42.81,英文,,0,0,0,,So we saw this last time.
Dialogue: 0,0:01:41.25,0:01:42.81,中文,,0,0,0,,我们上次看到过这个
Dialogue: 0,0:01:42.81,0:01:50.96,英文,,0,0,0,,If you have an interface like list61b, it's got all these method signatures telling you list should be able to add first, they should be able to add last.
Dialogue: 0,0:01:42.81,0:01:50.96,中文,,0,0,0,,如果你有一个像List61B这样的接口 它有所有这些方法签名告诉你列表应该能够添加第一个 它们应该能够添加最后一个
Dialogue: 0,0:01:50.96,0:01:54.40,英文,,0,0,0,,And I said SLList implements list61b.
Dialogue: 0,0:01:50.96,0:01:54.40,中文,,0,0,0,,我说过SLList实现了List61B
Dialogue: 0,0:01:54.40,0:02:04.92,英文,,0,0,0,,And what I'm saying is that the SLList needs to override all of those method signatures and implement the methods in list61b, which were all blank.
Dialogue: 0,0:01:54.40,0:02:04.92,中文,,0,0,0,,我所说的是SLList需要覆盖所有这些方法签名 并在List61B中实现这些方法 它们都是空白的
Dialogue: 0,0:02:04.92,0:02:07.73,英文,,0,0,0,,By contrast, let's try to build something a little bit different.
Dialogue: 0,0:02:04.92,0:02:07.73,中文,,0,0,0,,相比之下 让我们尝试构建一些稍微不同的东西
Dialogue: 0,0:02:07.73,0:02:11.01,英文,,0,0,0,,And then I'll come back and explain this slide a little bit more.
Dialogue: 0,0:02:07.73,0:02:11.01,中文,,0,0,0,,然后我会回来解释一下这张幻灯片
Dialogue: 0,0:02:11.01,0:02:14.13,英文,,0,0,0,,So let's try to build something called a rotating SLList.
Dialogue: 0,0:02:11.01,0:02:14.13,中文,,0,0,0,,让我们尝试构建一个叫做旋转的SLList
Dialogue: 0,0:02:14.13,0:02:15.65,英文,,0,0,0,,What's a rotating SLList?
Dialogue: 0,0:02:14.13,0:02:15.65,中文,,0,0,0,,旋转的SLList是什么
Dialogue: 0,0:02:15.65,0:02:18.47,英文,,0,0,0,,A rotating SLList is just like an SLList.
Dialogue: 0,0:02:15.65,0:02:18.47,中文,,0,0,0,,旋转的SLList就像一个SLList
Dialogue: 0,0:02:18.47,0:02:21.21,英文,,0,0,0,,It's a list of items with a front and a back.
Dialogue: 0,0:02:18.47,0:02:21.21,中文,,0,0,0,,它是一个具有前面和后面的项目列表
Dialogue: 0,0:02:21.21,0:02:22.49,英文,,0,0,0,,It's extensible.
Dialogue: 0,0:02:21.21,0:02:22.49,中文,,0,0,0,,它是可扩展的
Dialogue: 0,0:02:22.49,0:02:26.67,英文,,0,0,0,,But the difference is the rotating SLList, it can do everything an SLList can do.
Dialogue: 0,0:02:22.49,0:02:26.67,中文,,0,0,0,,但不同的是 旋转的SLList可以做SLList能做的一切
Dialogue: 0,0:02:26.67,0:02:30.47,英文,,0,0,0,,But it's got one extra feature, which is called rotate right.
Dialogue: 0,0:02:26.67,0:02:30.47,中文,,0,0,0,,但它有一个额外的功能 叫做向右旋转
Dialogue: 0,0:02:30.47,0:02:31.57,英文,,0,0,0,,Let's rotate right.
Dialogue: 0,0:02:30.47,0:02:31.57,中文,,0,0,0,,让我们向右旋转
Dialogue: 0,0:02:31.57,0:02:36.99,英文,,0,0,0,,It means I take a list, like 5, 9, 15, 22, and I rotate it to the right.
Dialogue: 0,0:02:31.57,0:02:36.99,中文,,0,0,0,,这意味着我拿一个列表 比如5、9、15、22 然后把它向右旋转
Dialogue: 0,0:02:36.99,0:02:38.03,英文,,0,0,0,,What does that look like?
Dialogue: 0,0:02:36.99,0:02:38.03,中文,,0,0,0,,那是什么样子
Dialogue: 0,0:02:38.03,0:02:45.70,英文,,0,0,0,,The 5 steps over to the right, the 9 steps over to the right, the 15 steps over to the right, and the 22 rotates all the way back to the front.
Dialogue: 0,0:02:38.03,0:02:45.70,中文,,0,0,0,,5向右移动5步 9向右移动9步 15向右移动15步 22向右旋转回到最前面
Dialogue: 0,0:02:45.70,0:02:47.32,英文,,0,0,0,,That's the operation that I want.
Dialogue: 0,0:02:45.70,0:02:47.32,中文,,0,0,0,,这就是我想要的操作
Dialogue: 0,0:02:47.32,0:02:52.38,英文,,0,0,0,,So a rotating SLList is an SLList, but it's got an extra feature.
Dialogue: 0,0:02:47.32,0:02:52.38,中文,,0,0,0,,一个旋转的SLList就是一个SLList 但它多了一个额外的特性
Dialogue: 0,0:02:52.38,0:02:54.77,英文,,0,0,0,,So how do I implement this?
Dialogue: 0,0:02:52.38,0:02:54.77,中文,,0,0,0,,那么我该怎么实现这个
Dialogue: 0,0:02:54.77,0:02:59.85,英文,,0,0,0,,Well, I could just take SLList, copy-paste it, and then add a new method.
Dialogue: 0,0:02:54.77,0:02:59.85,中文,,0,0,0,,我可以简单地拿 SLList 复制粘贴它 然后再添加一个新的方法
Dialogue: 0,0:02:59.85,0:03:01.25,英文,,0,0,0,,But that seems kind of gross.
Dialogue: 0,0:02:59.85,0:03:01.25,中文,,0,0,0,,但那看起来有点不好
Dialogue: 0,0:03:01.25,0:03:03.09,英文,,0,0,0,,I don't want to copy-paste all that code.
Dialogue: 0,0:03:01.25,0:03:03.09,中文,,0,0,0,,我不想复制粘贴所有那些代码
Dialogue: 0,0:03:03.09,0:03:10.58,英文,,0,0,0,,So I'm going to try writing a new class called RotatingSLList and use a little bit of implementation inheritance to see what I can do.
Dialogue: 0,0:03:03.09,0:03:10.58,中文,,0,0,0,,我要尝试写一个叫做 RotatingSLList 的新类 并使用一点实现继承 看看我能做什么
Dialogue: 0,0:03:10.58,0:03:12.04,英文,,0,0,0,,So I'll uncomment this.
Dialogue: 0,0:03:10.58,0:03:12.04,中文,,0,0,0,,我会取消注释这个
Dialogue: 0,0:03:12.04,0:03:14.02,英文,,0,0,0,,And immediately, I have some problems.
Dialogue: 0,0:03:12.04,0:03:14.02,中文,,0,0,0,,但马上 就有些问题了
Dialogue: 0,0:03:14.02,0:03:17.34,英文,,0,0,0,,It says, rotating SLLists don't have an addLast method.
Dialogue: 0,0:03:14.02,0:03:17.34,中文,,0,0,0,,它说 旋转的 SLList 没有 addLast 方法
Dialogue: 0,0:03:17.34,0:03:19.90,英文,,0,0,0,,They don't have a print method, which is kind of weird.
Dialogue: 0,0:03:17.34,0:03:19.90,中文,,0,0,0,,他们没有一个叫做print的方法 有点奇怪
Dialogue: 0,0:03:19.90,0:03:22.88,英文,,0,0,0,,I thought rotating SLLists were SLLists.
Dialogue: 0,0:03:19.90,0:03:22.88,中文,,0,0,0,,我以为旋转的SLList就是SLList
Dialogue: 0,0:03:22.88,0:03:25.58,英文,,0,0,0,,So how come they don't have all these SLList methods?
Dialogue: 0,0:03:22.88,0:03:25.58,中文,,0,0,0,,那为什么他们没有所有这些SLList方法呢
Dialogue: 0,0:03:25.58,0:03:31.96,英文,,0,0,0,,Well, the reason why is because you and I know that a rotating SLList is an SLList, but Java doesn't know.
Dialogue: 0,0:03:25.58,0:03:31.96,中文,,0,0,0,,原因是因为你和我知道旋转的SLList就是SLList 但Java不知道
Dialogue: 0,0:03:31.96,0:03:33.48,英文,,0,0,0,,So we have to tell Java.
Dialogue: 0,0:03:31.96,0:03:33.48,中文,,0,0,0,,我们要告诉Java
Dialogue: 0,0:03:33.48,0:03:36.24,英文,,0,0,0,,So to do that, we're going to add another magic keyword.
Dialogue: 0,0:03:33.48,0:03:36.24,中文,,0,0,0,,为了做到这一点 我们将添加另一个魔术关键字
Dialogue: 0,0:03:36.24,0:03:38.37,英文,,0,0,0,,This time, we're going to write extends.
Dialogue: 0,0:03:36.24,0:03:38.37,中文,,0,0,0,,这一次 我们将写上extends
Dialogue: 0,0:03:38.37,0:03:42.49,英文,,0,0,0,,And then we're going to write rotating SLList extends SLList.
Dialogue: 0,0:03:38.37,0:03:42.49,中文,,0,0,0,,然后我们要编写一个旋转的SLList扩展了SLList
Dialogue: 0,0:03:42.49,0:03:43.13,英文,,0,0,0,,Great.
Dialogue: 0,0:03:42.49,0:03:43.13,中文,,0,0,0,,太好了
Dialogue: 0,0:03:43.13,0:03:46.97,英文,,0,0,0,,So now we've told Java that a rotating SLList is an SLList.
Dialogue: 0,0:03:43.13,0:03:46.97,中文,,0,0,0,,现在我们告诉Java 旋转的SLList就是一个SLList
Dialogue: 0,0:03:46.97,0:03:54.91,英文,,0,0,0,,And now we've inherited all the methods that an SLList has, addLast, print, and all the other ones, too.
Dialogue: 0,0:03:46.97,0:03:54.91,中文,,0,0,0,,现在我们继承了SLList拥有的所有方法 比如addLast、print 还有其他的方法
Dialogue: 0,0:03:54.91,0:03:55.95,英文,,0,0,0,,OK, great.
Dialogue: 0,0:03:54.91,0:03:55.95,中文,,0,0,0,,太好了
Dialogue: 0,0:03:55.95,0:03:57.55,英文,,0,0,0,,But Java is still complaining.
Dialogue: 0,0:03:55.95,0:03:57.55,中文,,0,0,0,,但是Java还在抱怨
Dialogue: 0,0:03:57.55,0:03:59.55,英文,,0,0,0,,It says, I don't know how to rotate right.
Dialogue: 0,0:03:57.55,0:03:59.55,中文,,0,0,0,,它说 我不知道如何向右旋转
Dialogue: 0,0:03:59.55,0:04:00.37,英文,,0,0,0,,So we're going to write one.
Dialogue: 0,0:03:59.55,0:04:00.37,中文,,0,0,0,,那我们要写一个
Dialogue: 0,0:04:00.37,0:04:03.61,英文,,0,0,0,,We're going to write public void rotateRight.
Dialogue: 0,0:04:00.37,0:04:03.61,中文,,0,0,0,,我们要写 public void_rotateRight
Dialogue: 0,0:04:03.61,0:04:07.33,英文,,0,0,0,,You might be tempted to put overwrite like we were doing last time, but be careful.
Dialogue: 0,0:04:03.61,0:04:07.33,中文,,0,0,0,,你可能会像上次那样放置覆盖 但要小心
Dialogue: 0,0:04:07.33,0:04:10.18,英文,,0,0,0,,RotateRight does not overwrite a method from the parent.
Dialogue: 0,0:04:07.33,0:04:10.18,中文,,0,0,0,,RotateRight 不覆盖父类的方法
Dialogue: 0,0:04:10.18,0:04:11.84,英文,,0,0,0,,The SLList did not have a rotateRight.
Dialogue: 0,0:04:10.18,0:04:11.84,中文,,0,0,0,,SLList 没有 rotateRight
Dialogue: 0,0:04:11.84,0:04:12.80,英文,,0,0,0,,This is new.
Dialogue: 0,0:04:11.84,0:04:12.80,中文,,0,0,0,,这是新的
Dialogue: 0,0:04:12.80,0:04:15.36,英文,,0,0,0,,So we're going to write a new rotateRight method.
Dialogue: 0,0:04:12.80,0:04:15.36,中文,,0,0,0,,我们要写一个新的 rotateRight 方法
Dialogue: 0,0:04:15.36,0:04:17.64,英文,,0,0,0,,So I look, and you can try to spot the pattern.
Dialogue: 0,0:04:15.36,0:04:17.64,中文,,0,0,0,,我看一看 你可以试着找出规律
Dialogue: 0,0:04:17.64,0:04:18.96,英文,,0,0,0,,It's a fun little puzzle.
Dialogue: 0,0:04:17.64,0:04:18.96,中文,,0,0,0,,这是一个有趣的小谜题
Dialogue: 0,0:04:18.96,0:04:22.74,英文,,0,0,0,,So how do I take this list, and how do I rotate it to the right?
Dialogue: 0,0:04:18.96,0:04:22.74,中文,,0,0,0,,那么我怎么处理这个列表 如何将它向右旋转
Dialogue: 0,0:04:22.74,0:04:23.94,英文,,0,0,0,,I can stare at it.
Dialogue: 0,0:04:22.74,0:04:23.94,中文,,0,0,0,,我可以盯着它看
Dialogue: 0,0:04:23.94,0:04:29.65,英文,,0,0,0,,What seems like the fastest solution is to just take the item at the end and stick it at the front.
Dialogue: 0,0:04:23.94,0:04:29.65,中文,,0,0,0,,似乎最快的解决方案是将末尾的项目取出并放在最前面
Dialogue: 0,0:04:29.65,0:04:30.35,英文,,0,0,0,,So I'm going to do that.
Dialogue: 0,0:04:29.65,0:04:30.35,中文,,0,0,0,,我要这样做
Dialogue: 0,0:04:30.35,0:04:33.77,英文,,0,0,0,,I'll say itemX equals getLast.
Dialogue: 0,0:04:30.35,0:04:33.77,中文,,0,0,0,,我会说Item x等于getLast
Dialogue: 0,0:04:33.77,0:04:35.79,英文,,0,0,0,,What allows me to use getLast?
Dialogue: 0,0:04:33.77,0:04:35.79,中文,,0,0,0,,什么允许我使用 getLast
Dialogue: 0,0:04:35.79,0:04:37.05,英文,,0,0,0,,Why is this OK?
Dialogue: 0,0:04:35.79,0:04:37.05,中文,,0,0,0,,这为什么可以
Dialogue: 0,0:04:37.05,0:04:39.53,英文,,0,0,0,,Because a rotating SLList is an SLList.
Dialogue: 0,0:04:37.05,0:04:39.53,中文,,0,0,0,,因为旋转的 SLList 是一个 SLList
Dialogue: 0,0:04:39.53,0:04:44.34,英文,,0,0,0,,It's inherited all of the methods from the SLList, including getLast.
Dialogue: 0,0:04:39.53,0:04:44.34,中文,,0,0,0,,它继承了 SLList 的所有方法 包括 getLast
Dialogue: 0,0:04:44.34,0:04:46.12,英文,,0,0,0,,So this is OK.
Dialogue: 0,0:04:44.34,0:04:46.12,中文,,0,0,0,,这样是可以的
Dialogue: 0,0:04:46.12,0:04:49.68,英文,,0,0,0,,And then I'll call addFirst, maybe, on X.
Dialogue: 0,0:04:46.12,0:04:49.68,中文,,0,0,0,,然后我可能会在 X 上调用 addFirst
Dialogue: 0,0:04:49.68,0:04:51.44,英文,,0,0,0,,OK, looks good.
Dialogue: 0,0:04:49.68,0:04:51.44,中文,,0,0,0,,看起来不错
Dialogue: 0,0:04:51.44,0:04:52.58,英文,,0,0,0,,So I run this.
Dialogue: 0,0:04:51.44,0:04:52.58,中文,,0,0,0,,运行这个
Dialogue: 0,0:04:52.58,0:04:57.28,英文,,0,0,0,,Hopefully, when I print out the rotated list, I get that, and everyone's happy.
Dialogue: 0,0:04:52.58,0:04:57.28,中文,,0,0,0,,希望 当我打印出旋转后的列表时 我得到那个 大家都高兴
Dialogue: 0,0:04:57.28,0:04:59.66,英文,,0,0,0,,And if not, we'll have a bit of a headache.
Dialogue: 0,0:04:57.28,0:04:59.66,中文,,0,0,0,,如果不是这样 我们会有点头疼
Dialogue: 0,0:04:59.66,0:05:02.14,英文,,0,0,0,,What did I do?
Dialogue: 0,0:04:59.66,0:05:02.14,中文,,0,0,0,,我做了什么
Dialogue: 0,0:05:02.14,0:05:07.23,英文,,0,0,0,,I should call not getLast, but removeLast, because I want to remove the 13 from the end.
Dialogue: 0,0:05:02.14,0:05:07.23,中文,,0,0,0,,我应该调用removeLast而不是getLast 因为我想从末尾移除13
Dialogue: 0,0:05:07.23,0:05:09.58,英文,,0,0,0,,OK.
Dialogue: 0,0:05:09.58,0:05:12.39,英文,,0,0,0,,See, live debugging, beautiful.
Dialogue: 0,0:05:09.58,0:05:12.39,中文,,0,0,0,,看 实时调试 很美
Dialogue: 0,0:05:12.39,0:05:13.03,英文,,0,0,0,,So there it is.
Dialogue: 0,0:05:12.39,0:05:13.03,中文,,0,0,0,,就是这样
Dialogue: 0,0:05:13.03,0:05:14.61,英文,,0,0,0,,There's my rotating S list.
Dialogue: 0,0:05:13.03,0:05:14.61,中文,,0,0,0,,这就是我的旋转SLList
Dialogue: 0,0:05:14.61,0:05:18.93,英文,,0,0,0,,So what did we learn besides that I don't know where my slides went?
Dialogue: 0,0:05:14.61,0:05:18.93,中文,,0,0,0,,那么除了我不知道我的幻灯片去哪里了 我们还学到了什么
Dialogue: 0,0:05:18.93,0:05:25.08,英文,,0,0,0,,So we learned that if you would like to extend another class, use the keyword extends.
Dialogue: 0,0:05:18.93,0:05:25.08,中文,,0,0,0,,我们学到了如果你想要扩展另一个类 就使用关键字extends
Dialogue: 0,0:05:25.08,0:05:26.28,英文,,0,0,0,,So what does that mean?
Dialogue: 0,0:05:25.08,0:05:26.28,中文,,0,0,0,,那是什么意思
Dialogue: 0,0:05:26.28,0:05:27.76,英文,,0,0,0,,Why do you choose implement sometimes?
Dialogue: 0,0:05:26.28,0:05:27.76,中文,,0,0,0,,有时候为什么要选择implement呢
Dialogue: 0,0:05:27.76,0:05:29.22,英文,,0,0,0,,Why do you choose extends?
Dialogue: 0,0:05:27.76,0:05:29.22,中文,,0,0,0,,为什么要选择extends呢
Dialogue: 0,0:05:29.22,0:05:31.93,英文,,0,0,0,,So where's my slide here?
Dialogue: 0,0:05:29.22,0:05:31.93,中文,,0,0,0,,那我的幻灯片在哪里呢
Dialogue: 0,0:05:31.93,0:05:34.81,英文,,0,0,0,,So how do you tell when you want to use implements, when you want to use extends?
Dialogue: 0,0:05:31.93,0:05:34.81,中文,,0,0,0,,那么你怎么知道你想要使用 implements 你什么时候想要使用 extends
Dialogue: 0,0:05:34.81,0:05:36.77,英文,,0,0,0,,Turns out it's not really a choice.
Dialogue: 0,0:05:34.81,0:05:36.77,中文,,0,0,0,,事实证明这并不是一个选择
Dialogue: 0,0:05:36.77,0:05:42.79,英文,,0,0,0,,If it is the case that you have an interface and then the subclass is a class, you have to use the word implements.
Dialogue: 0,0:05:36.77,0:05:42.79,中文,,0,0,0,,如果你有一个接口然后子类是一个类的情况 你必须使用 implements 这个词
Dialogue: 0,0:05:42.79,0:05:46.43,英文,,0,0,0,,So like last time we said, a list implements list.
Dialogue: 0,0:05:42.79,0:05:46.43,中文,,0,0,0,,就像上次我们说的那样 一个列表实现了列表
Dialogue: 0,0:05:46.43,0:05:52.05,英文,,0,0,0,,We use the word implements because list was an interface, had all those blank method signatures.
Dialogue: 0,0:05:46.43,0:05:52.05,中文,,0,0,0,,我们使用 implements 这个词是因为列表是一个接口 有所有那些空方法签名
Dialogue: 0,0:05:52.05,0:05:57.33,英文,,0,0,0,,By contrast, When we said rotating SLList is a subclass of List, it is a list.
Dialogue: 0,0:05:52.05,0:05:57.33,中文,,0,0,0,,相比之下  当我们说旋转的SLList是List的子类时 它就是一个列表
Dialogue: 0,0:05:57.33,0:06:00.73,英文,,0,0,0,,SLList was already a class, so we used the word extends.
Dialogue: 0,0:05:57.33,0:06:00.73,中文,,0,0,0,,SLList已经是一个类 我们使用了extends这个词
Dialogue: 0,0:06:00.73,0:06:02.01,英文,,0,0,0,,Is this super interesting?
Dialogue: 0,0:06:00.73,0:06:02.01,中文,,0,0,0,,这很有趣吗
Dialogue: 0,0:06:02.01,0:06:02.87,英文,,0,0,0,,Not really.
Dialogue: 0,0:06:02.01,0:06:02.87,中文,,0,0,0,,不太是
Dialogue: 0,0:06:02.87,0:06:05.60,英文,,0,0,0,,But it's kind of Java trivia which one you want to use.
Dialogue: 0,0:06:02.87,0:06:05.60,中文,,0,0,0,,但这有点是Java的小知识 你可以选择使用哪个
Dialogue: 0,0:06:05.60,0:06:08.00,英文,,0,0,0,,So you don't have to choose.
Dialogue: 0,0:06:05.60,0:06:08.00,中文,,0,0,0,,你不必纠结
Dialogue: 0,0:06:08.00,0:06:10.94,英文,,0,0,0,,Java designers just chose different keywords for the two cases.
Dialogue: 0,0:06:08.00,0:06:10.94,中文,,0,0,0,,Java的设计者只是为这两种情况选择了不同的关键词
Dialogue: 0,0:06:10.94,0:06:16.62,英文,,0,0,0,,But they both kind of mean the same thing, which is that you're specifying this hypernym-hyponym relationship.
Dialogue: 0,0:06:10.94,0:06:16.62,中文,,0,0,0,,但它们在某种程度上都意味着同样的事情 就是你在指定这个超类-子类关系
Dialogue: 0,0:06:16.62,0:06:17.97,英文,,0,0,0,,OK.
Dialogue: 0,0:06:17.97,0:06:19.53,英文,,0,0,0,,So there's our rotating SLList.
Dialogue: 0,0:06:17.97,0:06:19.53,中文,,0,0,0,,这就是我们的RotatingSLLis
Dialogue: 0,0:06:19.53,0:06:29.33,英文,,0,0,0,,Thanks to this extends keyword, we have inherited all the implementation details of SLList, including all the instance variables, like the sentinel and the size.
Dialogue: 0,0:06:19.53,0:06:29.33,中文,,0,0,0,,多亏了这个extends关键字 我们继承了SLList的所有实现细节 包括所有的实例变量 比如哨兵和大小
Dialogue: 0,0:06:29.33,0:06:34.44,英文,,0,0,0,,We inherited all the methods, like add last, remove first, whatever.
Dialogue: 0,0:06:29.33,0:06:34.44,中文,,0,0,0,,我们继承了所有的方法 比如add last remove first 等等
Dialogue: 0,0:06:34.44,0:06:36.70,英文,,0,0,0,,We inherited all the nested classes, like the nodes.
Dialogue: 0,0:06:34.44,0:06:36.70,中文,,0,0,0,,我们继承了所有的嵌套类 比如节点
Dialogue: 0,0:06:36.70,0:06:38.86,英文,,0,0,0,,So everything got inherited, which is great.
Dialogue: 0,0:06:36.70,0:06:38.86,中文,,0,0,0,,一切都被继承了 这太棒了
Dialogue: 0,0:06:38.86,0:06:43.15,英文,,0,0,0,,It means we did not have to copy-paste all the things in the SLList.
Dialogue: 0,0:06:38.86,0:06:43.15,中文,,0,0,0,,这意味着我们不必在SLList中复制粘贴所有的东西
Dialogue: 0,0:06:43.15,0:06:47.57,英文,,0,0,0,,OK, questions, thoughts on rotating SLList before we do another one?
Dialogue: 0,0:06:43.15,0:06:47.57,中文,,0,0,0,,对于在做另一个之前RotatingSLLis有什么问题或想法吗
Dialogue: 0,0:06:47.57,0:06:51.04,英文,,0,0,0,,Question?
Dialogue: 0,0:06:47.57,0:06:51.04,中文,,0,0,0,,有疑问吗
Dialogue: 0,0:06:51.04,0:06:55.02,英文,,0,0,0,,Sorry, can you say that but louder?
Dialogue: 0,0:06:51.04,0:06:55.02,中文,,0,0,0,,抱歉 你能再大声点说一遍吗
Dialogue: 0,0:06:55.02,0:06:57.12,英文,,0,0,0,,Yeah, the question was, what about the nested classes?
Dialogue: 0,0:06:55.02,0:06:57.12,中文,,0,0,0,,是的 问题是 嵌套类呢
Dialogue: 0,0:06:57.12,0:07:03.79,英文,,0,0,0,,I think the reason why this is here is because rotating SLList inherited the node nested class from SLList.
Dialogue: 0,0:06:57.12,0:07:03.79,中文,,0,0,0,,我认为这里之这样做是因为RotatingSLLis继承了SLList中的节点嵌套类
Dialogue: 0,0:07:03.79,0:07:07.38,英文,,0,0,0,,Question?
Dialogue: 0,0:07:03.79,0:07:07.38,中文,,0,0,0,,有疑问吗
Dialogue: 0,0:07:07.38,0:07:09.95,英文,,0,0,0,,Oh, can I write nested classes in a rotating SLList?
Dialogue: 0,0:07:07.38,0:07:09.95,中文,,0,0,0,,我能在旋转的SLList中写嵌套类吗
Dialogue: 0,0:07:09.95,0:07:12.55,英文,,0,0,0,,I believe the answer is yes, right?
Dialogue: 0,0:07:09.95,0:07:12.55,中文,,0,0,0,,我相信答案是肯定的 对吧
Dialogue: 0,0:07:12.55,0:07:14.41,英文,,0,0,0,,Okay, so I think you can.
Dialogue: 0,0:07:12.55,0:07:14.41,中文,,0,0,0,,我认为你可以
Dialogue: 0,0:07:14.41,0:07:17.69,英文,,0,0,0,,You can try it later if you want to, but... Oh, in the interface.
Dialogue: 0,0:07:14.41,0:07:17.69,中文,,0,0,0,,如果你想的话 你可以稍后尝试一下 但是...在接口中
Dialogue: 0,0:07:17.69,0:07:19.91,英文,,0,0,0,,Can I write nested classes in the interface?
Dialogue: 0,0:07:17.69,0:07:19.91,中文,,0,0,0,,我能在接口中写嵌套类吗
Dialogue: 0,0:07:19.91,0:07:20.21,英文,,0,0,0,,I don't know.
Dialogue: 0,0:07:19.91,0:07:20.21,中文,,0,0,0,,我不知道
Dialogue: 0,0:07:20.21,0:07:22.13,英文,,0,0,0,,We'll have to try it later.
Dialogue: 0,0:07:20.21,0:07:22.13,中文,,0,0,0,,我们以后再试试
Dialogue: 0,0:07:22.13,0:07:31.33,英文,,0,0,0,,Yeah, Justin says you shouldn't because it's more like an implementation detail, and interfaces are supposed to specify the what, but I don't know.
Dialogue: 0,0:07:22.13,0:07:31.33,中文,,0,0,0,,是的 Justin说你不应该这样做 因为这更像是一个实现细节 而接口应该指定做什么 但我不知道
Dialogue: 0,0:07:31.33,0:07:32.69,英文,,0,0,0,,Maybe Java allows it.
Dialogue: 0,0:07:31.33,0:07:32.69,中文,,0,0,0,,也许Java允许这样做
Dialogue: 0,0:07:32.69,0:07:33.89,英文,,0,0,0,,We will have to try it later.
Dialogue: 0,0:07:32.69,0:07:33.89,中文,,0,0,0,,我们以后再试试
Dialogue: 0,0:07:33.89,0:07:35.83,英文,,0,0,0,,It's a good question, though.
Dialogue: 0,0:07:33.89,0:07:35.83,中文,,0,0,0,,不过这是一个很好的问题
Dialogue: 0,0:07:35.83,0:07:36.53,英文,,0,0,0,,You stumped me.
Dialogue: 0,0:07:35.83,0:07:36.53,中文,,0,0,0,,你把我难住了
Dialogue: 0,0:07:36.53,0:07:46.30,英文,,0,0,0,,OK, one more.
Dialogue: 0,0:07:36.53,0:07:46.30,中文,,0,0,0,,再来一个
Dialogue: 0,0:07:46.30,0:07:47.42,英文,,0,0,0,,Yeah, it's a great question.
Dialogue: 0,0:07:46.30,0:07:47.42,中文,,0,0,0,,是的 这是一个很棒的问题
Dialogue: 0,0:07:47.42,0:07:50.10,英文,,0,0,0,,So the question was, when do you use extends versus implements?
Dialogue: 0,0:07:47.42,0:07:50.10,中文,,0,0,0,,问题是 何时使用extends而不是implements
Dialogue: 0,0:07:50.10,0:07:54.46,英文,,0,0,0,,So I don't know why Java designers chose to have two different keywords instead of one.
Dialogue: 0,0:07:50.10,0:07:54.46,中文,,0,0,0,,我不知道为什么Java设计者选择有两个不同的关键字而不是一个
Dialogue: 0,0:07:54.46,0:07:58.51,英文,,0,0,0,,Basically, the idea is, if this thing here is a class, then write the word extends.
Dialogue: 0,0:07:54.46,0:07:58.51,中文,,0,0,0,,基本上 这个想法是 如果这个东西是一个类 那就写extends这个词
Dialogue: 0,0:07:58.51,0:08:01.97,英文,,0,0,0,,If this thing here is an interface, write the word implements.
Dialogue: 0,0:07:58.51,0:08:01.97,中文,,0,0,0,,如果这个东西是一个接口 就写implements这个词
Dialogue: 0,0:08:01.97,0:08:03.63,英文,,0,0,0,,That's it.
Dialogue: 0,0:08:01.97,0:08:03.63,中文,,0,0,0,,就这样
Dialogue: 0,0:08:03.63,0:08:06.21,英文,,0,0,0,,In both cases, you're inheriting the stuff from the parent class.
Dialogue: 0,0:08:03.63,0:08:06.21,中文,,0,0,0,,在这两种情况下 你都是从父类继承东西
Dialogue: 0,0:08:06.21,0:08:19.99,英文,,0,0,0,,Question?
Dialogue: 0,0:08:06.21,0:08:19.99,中文,,0,0,0,,有疑问吗
Dialogue: 0,0:08:19.99,0:08:20.75,英文,,0,0,0,,Yeah, that's a great question.
Dialogue: 0,0:08:19.99,0:08:20.75,中文,,0,0,0,,是的 这是个很棒的问题
Dialogue: 0,0:08:20.75,0:08:23.11,英文,,0,0,0,,So it was about multi-generational inheritance.
Dialogue: 0,0:08:20.75,0:08:23.11,中文,,0,0,0,,这涉及到多代继承
Dialogue: 0,0:08:23.11,0:08:24.23,英文,,0,0,0,,Sorry for all the tabbing.
Dialogue: 0,0:08:23.11,0:08:24.23,中文,,0,0,0,,抱歉 我一直在按制表符
Dialogue: 0,0:08:24.23,0:08:32.18,英文,,0,0,0,,So the question was, because rotating SLList is an SLList, which is a List61B, do you also get the methods from List61B?
Dialogue: 0,0:08:24.23,0:08:32.18,中文,,0,0,0,,问题是 因为旋转的SLList是一个SLList 它是一个List61B 你也会得到List61B的方法吗
Dialogue: 0,0:08:32.18,0:08:34.20,英文,,0,0,0,,And I believe the answer is yes.
Dialogue: 0,0:08:32.18,0:08:34.20,中文,,0,0,0,,我相信答案是肯定的
Dialogue: 0,0:08:34.20,0:08:38.80,英文,,0,0,0,,In fact, I think the print method that we used was from List61B.
Dialogue: 0,0:08:34.20,0:08:38.80,中文,,0,0,0,,事实上 我认为我们使用的打印方法是从List61B来的
Dialogue: 0,0:08:38.80,0:08:40.26,英文,,0,0,0,,Great question.
Dialogue: 0,0:08:38.80,0:08:40.26,中文,,0,0,0,,好问题
Dialogue: 0,0:08:40.26,0:08:42.32,英文,,0,0,0,,OK.
Dialogue: 0,0:08:42.32,0:08:43.30,英文,,0,0,0,,Fun.
Dialogue: 0,0:08:42.32,0:08:43.30,中文,,0,0,0,,有趣
Dialogue: 0,0:08:43.30,0:08:45.28,英文,,0,0,0,,So that was rotating SLList.
Dialogue: 0,0:08:43.30,0:08:45.28,中文,,0,0,0,,那就是旋转的SLList
Dialogue: 0,0:08:45.28,0:08:46.54,英文,,0,0,0,,Now I want to do another one here.
Dialogue: 0,0:08:45.28,0:08:46.54,中文,,0,0,0,,现在我想在这里做另一个
Dialogue: 0,0:08:46.54,0:08:50.76,英文,,0,0,0,,Let me drag these around so I don't keep tabbing between these and giving you a headache.
Dialogue: 0,0:08:46.54,0:08:50.76,中文,,0,0,0,,让我把这些拖动一下 这样我就不用在它们之间切换 让你头疼了
Dialogue: 0,0:08:50.76,0:08:53.12,英文,,0,0,0,,OK, so we did rotating SLList.
Dialogue: 0,0:08:50.76,0:08:53.12,中文,,0,0,0,,我们做了旋转的SLList
Dialogue: 0,0:08:53.12,0:08:53.88,英文,,0,0,0,,Let's do another one.
Dialogue: 0,0:08:53.12,0:08:53.88,中文,,0,0,0,,我们来做另一个吧
Dialogue: 0,0:08:53.88,0:08:57.12,英文,,0,0,0,,This one's going to be called Vengeful SLList.
Dialogue: 0,0:08:53.88,0:08:57.12,中文,,0,0,0,,这个将被称为Vengeful性SLList
Dialogue: 0,0:08:57.12,0:09:01.73,英文,,0,0,0,,So remember, in a regular SLList, if you remove items from the SLList,
Dialogue: 0,0:08:57.12,0:09:01.73,中文,,0,0,0,,记住 在普通的SLList中 如果你从SLList中移除项目
Dialogue: 0,0:09:01.73,0:09:06.01,英文,,0,0,0,,The SLList, it doesn't really care, it throws the items away, never to be seen again.
Dialogue: 0,0:09:01.73,0:09:06.01,中文,,0,0,0,,SLList对此并不在意 它会将项目丢弃 永远不再出现
Dialogue: 0,0:09:06.01,0:09:08.37,英文,,0,0,0,,But the Vengeful SLList, it remembers.
Dialogue: 0,0:09:06.01,0:09:08.37,中文,,0,0,0,,但是Vengeful性SLList会记住
Dialogue: 0,0:09:08.37,0:09:19.33,英文,,0,0,0,,Anytime you delete an item, the Vengeful SLList will remember the item that was deleted, and then you can ask the Vengeful SLList to print all of its lost items, and it will tell you what was deleted.
Dialogue: 0,0:09:08.37,0:09:19.33,中文,,0,0,0,,每当你删除一个项目 Vengeful性SLList会记住被删除的项目 然后你可以要求Vengeful性SLList打印所有丢失的项目 它会告诉你删除了什么
Dialogue: 0,0:09:19.33,0:09:22.00,英文,,0,0,0,,So here's the Vengeful SLList, it never forgets.
Dialogue: 0,0:09:19.33,0:09:22.00,中文,,0,0,0,,这就是Vengeful性SLList 它永远不会忘记
Dialogue: 0,0:09:22.00,0:09:26.30,英文,,0,0,0,,This isn't really practically useful, but it's a fun exercise, so let's do it.
Dialogue: 0,0:09:22.00,0:09:26.30,中文,,0,0,0,,这并不是真正实用的 但这是一个有趣的练习 让我们做吧
Dialogue: 0,0:09:26.30,0:09:28.64,英文,,0,0,0,,So here's the code, just like before.
Dialogue: 0,0:09:26.30,0:09:28.64,中文,,0,0,0,,这是代码 就像以前一样
Dialogue: 0,0:09:28.64,0:09:31.70,英文,,0,0,0,,And we saw earlier, we add a bunch of things to the list.
Dialogue: 0,0:09:28.64,0:09:31.70,中文,,0,0,0,,而且我们之前看到 我们向列表中添加了一堆东西
Dialogue: 0,0:09:31.70,0:09:40.41,英文,,0,0,0,,If you remove the 10 and the 13, and you ask, what are the things that have been lost, the Vengeful S list should tell you, I lost 10 and I lost 13.
Dialogue: 0,0:09:31.70,0:09:40.41,中文,,0,0,0,,如果你移除了10和13 并且问 失去了什么东西 报复性的SLList应该告诉你 我失去了10和我失去了13
Dialogue: 0,0:09:40.41,0:09:42.87,英文,,0,0,0,,So let's give it a try.
Dialogue: 0,0:09:40.41,0:09:42.87,中文,,0,0,0,,让我们试试吧
Dialogue: 0,0:09:42.87,0:09:44.35,英文,,0,0,0,,That's not what I wanted to happen.
Dialogue: 0,0:09:42.87,0:09:44.35,中文,,0,0,0,,这不是我想要发生的事情
Dialogue: 0,0:09:44.35,0:09:46.45,英文,,0,0,0,,That is also not what I wanted to happen.
Dialogue: 0,0:09:44.35,0:09:46.45,中文,,0,0,0,,这也不是我想要发生的事情
Dialogue: 0,0:09:46.45,0:09:48.52,英文,,0,0,0,,I will try one more time.
Dialogue: 0,0:09:46.45,0:09:48.52,中文,,0,0,0,,我再试一次
Dialogue: 0,0:09:48.52,0:09:50.22,英文,,0,0,0,,OK, that's also not what I wanted.
Dialogue: 0,0:09:48.52,0:09:50.22,中文,,0,0,0,,好吧 这也不是我想要的
Dialogue: 0,0:09:50.22,0:09:51.98,英文,,0,0,0,,OK, there we go.
Dialogue: 0,0:09:50.22,0:09:51.98,中文,,0,0,0,,现在可以了
Dialogue: 0,0:09:51.98,0:09:53.60,英文,,0,0,0,,So I uncommented everything.
Dialogue: 0,0:09:51.98,0:09:53.60,中文,,0,0,0,,我把所有东西都取消注释了
Dialogue: 0,0:09:53.60,0:09:56.03,英文,,0,0,0,,And just like before, Java is complaining.
Dialogue: 0,0:09:53.60,0:09:56.03,中文,,0,0,0,,就像之前一样 Java又在抱怨了
Dialogue: 0,0:09:56.03,0:09:58.83,英文,,0,0,0,,It says, Vengeful SLList, I don't know how to add last.
Dialogue: 0,0:09:56.03,0:09:58.83,中文,,0,0,0,,它说 VengefulSLList 我不知道如何添加最后一个
Dialogue: 0,0:09:58.83,0:10:00.45,英文,,0,0,0,,I don't know how to remove last.
Dialogue: 0,0:09:58.83,0:10:00.45,中文,,0,0,0,,我不知道如何移除最后一个
Dialogue: 0,0:10:00.45,0:10:02.09,英文,,0,0,0,,And again, it's the same problem.
Dialogue: 0,0:10:00.45,0:10:02.09,中文,,0,0,0,,而且 问题还是一样的
Dialogue: 0,0:10:02.09,0:10:07.66,英文,,0,0,0,,We know that Vengeful SLList are a specific type of SLList, but Java doesn't know.
Dialogue: 0,0:10:02.09,0:10:07.66,中文,,0,0,0,,我们知道 VengefulSLList 是 SLList 的一种特定类型 但 Java 不知道
Dialogue: 0,0:10:07.66,0:10:09.38,英文,,0,0,0,,So we add the keyword extends.
Dialogue: 0,0:10:07.66,0:10:09.38,中文,,0,0,0,,我们添加关键字 extends
Dialogue: 0,0:10:09.38,0:10:11.16,英文,,0,0,0,,And we say it extends an SLList.
Dialogue: 0,0:10:09.38,0:10:11.16,中文,,0,0,0,,然后我们说它扩展了一个 SLList
Dialogue: 0,0:10:11.16,0:10:12.52,英文,,0,0,0,,Why do we use extends?
Dialogue: 0,0:10:11.16,0:10:12.52,中文,,0,0,0,,为什么我们使用 extends
Dialogue: 0,0:10:12.52,0:10:14.15,英文,,0,0,0,,Because SLList is a class.
Dialogue: 0,0:10:12.52,0:10:14.15,中文,,0,0,0,,因为 SLList 是一个类
Dialogue: 0,0:10:14.15,0:10:17.31,英文,,0,0,0,,If SLList were an interface, I would put the word implements.
Dialogue: 0,0:10:14.15,0:10:17.31,中文,,0,0,0,,如果 SLList 是一个接口 我会使用 implements 这个词
Dialogue: 0,0:10:17.31,0:10:18.41,英文,,0,0,0,,That's more trivia.
Dialogue: 0,0:10:17.31,0:10:18.41,中文,,0,0,0,,这更多是琐事
Dialogue: 0,0:10:18.41,0:10:20.55,英文,,0,0,0,,So don't worry too much about it.
Dialogue: 0,0:10:18.41,0:10:20.55,中文,,0,0,0,,不要太担心
Dialogue: 0,0:10:20.55,0:10:21.43,英文,,0,0,0,,OK.
Dialogue: 0,0:10:21.43,0:10:23.25,英文,,0,0,0,,So anyway, it looks good so far.
Dialogue: 0,0:10:21.43,0:10:23.25,中文,,0,0,0,,总之 目前看起来还不错
Dialogue: 0,0:10:23.25,0:10:25.71,英文,,0,0,0,,But the problem is, we don't know how to print lost items.
Dialogue: 0,0:10:23.25,0:10:25.71,中文,,0,0,0,,但问题是 我们不知道如何打印丢失的物品
Dialogue: 0,0:10:25.71,0:10:27.78,英文,,0,0,0,,So we're going to have to write that.
Dialogue: 0,0:10:25.71,0:10:27.78,中文,,0,0,0,,我们得写那部分代码
Dialogue: 0,0:10:27.78,0:10:31.98,英文,,0,0,0,,So I'll say public void printLostItems.
Dialogue: 0,0:10:27.78,0:10:31.98,中文,,0,0,0,,我会写上 public void printlostItems s
Dialogue: 0,0:10:31.98,0:10:35.34,英文,,0,0,0,,And again, you might be tempted to put, I'm overwriting.
Dialogue: 0,0:10:31.98,0:10:35.34,中文,,0,0,0,,而且 你可能会想覆盖
Dialogue: 0,0:10:35.34,0:10:36.46,英文,,0,0,0,,But remember, this is new.
Dialogue: 0,0:10:35.34,0:10:36.46,中文,,0,0,0,,但记住 这是新的
Dialogue: 0,0:10:36.46,0:10:37.98,英文,,0,0,0,,We're not overwriting this.
Dialogue: 0,0:10:36.46,0:10:37.98,中文,,0,0,0,,我们不会覆盖这个
Dialogue: 0,0:10:37.98,0:10:39.41,英文,,0,0,0,,So what do I put?
Dialogue: 0,0:10:37.98,0:10:39.41,中文,,0,0,0,,那我要放什么
Dialogue: 0,0:10:39.41,0:10:41.39,英文,,0,0,0,,Hmm, it's kind of a fun puzzle.
Dialogue: 0,0:10:39.41,0:10:41.39,中文,,0,0,0,,这有点像一个有趣的谜题
Dialogue: 0,0:10:41.39,0:10:47.43,英文,,0,0,0,,So at first, I'm thinking, well, I have to have somewhere to store the lost items.
Dialogue: 0,0:10:41.39,0:10:47.43,中文,,0,0,0,,起初 我在想 好吧 我必须有一个地方来存放丢失的物品
Dialogue: 0,0:10:47.43,0:10:54.85,英文,,0,0,0,,So somehow, every VengefulS list, maybe I'm going to give the VengefulS list a place to store all of its lost items.
Dialogue: 0,0:10:47.43,0:10:54.85,中文,,0,0,0,,以某种方式 每个VengefulSLList 也许我要给VengefulSLList一个存放所有丢失物品的地方
Dialogue: 0,0:10:54.85,0:10:56.95,英文,,0,0,0,,So I'll say, lost items.
Dialogue: 0,0:10:54.85,0:10:56.95,中文,,0,0,0,,我会说 丢失的物品
Dialogue: 0,0:10:56.95,0:11:00.31,英文,,0,0,0,,Every VengefulS list has an instance variable called lost items.
Dialogue: 0,0:10:56.95,0:11:00.31,中文,,0,0,0,,每个 VengefulSLList都有一个叫做 lost items 的实例变量
Dialogue: 0,0:11:00.31,0:11:03.12,英文,,0,0,0,,That's where I'm going to put all the lost items.
Dialogue: 0,0:11:00.31,0:11:03.12,中文,,0,0,0,,那就是我要放所有丢失物品的地方
Dialogue: 0,0:11:03.12,0:11:09.74,英文,,0,0,0,,And when someone asks me to print my lost items, I will simply take my lost items list, and I'll print it.
Dialogue: 0,0:11:03.12,0:11:09.74,中文,,0,0,0,,当有人要求我打印我的丢失物品时 我只需拿出我的丢失物品列表 然后打印出来
Dialogue: 0,0:11:09.74,0:11:12.48,英文,,0,0,0,,OK, looks pretty good.
Dialogue: 0,0:11:09.74,0:11:12.48,中文,,0,0,0,,看起来挺不错的
Dialogue: 0,0:11:12.48,0:11:17.49,英文,,0,0,0,,But one more problem, which is, how do I add things to this lost items list?
Dialogue: 0,0:11:12.48,0:11:17.49,中文,,0,0,0,,但还有一个问题 那就是 我如何向这个丢失物品列表添加东西呢
Dialogue: 0,0:11:17.49,0:11:21.73,英文,,0,0,0,,You might be tempted to start adding things here, like OVS1.lossSet.
Dialogue: 0,0:11:17.49,0:11:21.73,中文,,0,0,0,,你可能会想要在这里开始添加东西 比如 OVS1.lossSet
Dialogue: 0,0:11:21.73,0:11:25.51,英文,,0,0,0,,But remember, we want the Vengeful SLList to remember automatically.
Dialogue: 0,0:11:21.73,0:11:25.51,中文,,0,0,0,,但请记住 我们希望 VengefulSLList 能够自动记住
Dialogue: 0,0:11:25.51,0:11:29.06,英文,,0,0,0,,Every time you remove something, the Vengeful SLList should remember.
Dialogue: 0,0:11:25.51,0:11:29.06,中文,,0,0,0,,每次你删除东西时 VengefulSLList都应该记住
Dialogue: 0,0:11:29.06,0:11:30.42,英文,,0,0,0,,So how should I do that?
Dialogue: 0,0:11:29.06,0:11:30.42,中文,,0,0,0,,那我应该怎么做呢
Dialogue: 0,0:11:30.42,0:11:34.76,英文,,0,0,0,,Well, maybe what I'll do is, every time someone calls removeLast,
Dialogue: 0,0:11:30.42,0:11:34.76,中文,,0,0,0,,也许我会这样做 每当有人调用removeLast时
Dialogue: 0,0:11:34.76,0:11:37.18,英文,,0,0,0,,It's no longer enough to just delete the item from the list.
Dialogue: 0,0:11:34.76,0:11:37.18,中文,,0,0,0,,仅仅从列表中删除项目已经不再足够
Dialogue: 0,0:11:37.18,0:11:38.81,英文,,0,0,0,,I want to remember it, too.
Dialogue: 0,0:11:37.18,0:11:38.81,中文,,0,0,0,,我想要记住它
Dialogue: 0,0:11:38.81,0:11:42.99,英文,,0,0,0,,So what I'm going to do, I'm going to overwrite what the removeLast method was doing from earlier.
Dialogue: 0,0:11:38.81,0:11:42.99,中文,,0,0,0,,我要做的是 我要重写之前removeLast方法的操作
Dialogue: 0,0:11:42.99,0:11:45.15,英文,,0,0,0,,So I'll say, override.
Dialogue: 0,0:11:42.99,0:11:45.15,中文,,0,0,0,,我会说 覆盖
Dialogue: 0,0:11:45.15,0:11:47.15,英文,,0,0,0,,Oops, that was also not intended.
Dialogue: 0,0:11:45.15,0:11:47.15,中文,,0,0,0,,哎呀 这也不是打算中的
Dialogue: 0,0:11:47.15,0:11:50.44,英文,,0,0,0,,I'm going to overwrite what the original removeLast method was.
Dialogue: 0,0:11:47.15,0:11:50.44,中文,,0,0,0,,我要覆盖原来的removeLast方法
Dialogue: 0,0:11:50.44,0:11:53.14,英文,,0,0,0,,So I could say, removeLast, what was it?
Dialogue: 0,0:11:50.44,0:11:53.14,中文,,0,0,0,,那我可以说 removeLast 是什么来着
Dialogue: 0,0:11:53.14,0:11:54.44,英文,,0,0,0,,ItemX.
Dialogue: 0,0:11:53.14,0:11:54.44,中文,,0,0,0,,Item x
Dialogue: 0,0:11:54.44,0:11:57.50,英文,,0,0,0,,And then I can override, but aha, what is Java telling me?
Dialogue: 0,0:11:54.44,0:11:57.50,中文,,0,0,0,,然后我可以重写 但是 哎呀 Java在告诉我什么
Dialogue: 0,0:11:57.50,0:12:00.04,英文,,0,0,0,,It says, override in red.
Dialogue: 0,0:11:57.50,0:12:00.04,中文,,0,0,0,,它说 红色的override
Dialogue: 0,0:12:00.04,0:12:01.08,英文,,0,0,0,,You're not overriding.
Dialogue: 0,0:12:00.04,0:12:01.08,中文,,0,0,0,,你没有覆盖
Dialogue: 0,0:12:01.08,0:12:02.30,英文,,0,0,0,,Why am I not overriding?
Dialogue: 0,0:12:01.08,0:12:02.30,中文,,0,0,0,,为什么我没有覆盖
Dialogue: 0,0:12:02.30,0:12:04.20,英文,,0,0,0,,Because that's supposed to be item.
Dialogue: 0,0:12:02.30,0:12:04.20,中文,,0,0,0,,因为那应该是项目
Dialogue: 0,0:12:04.20,0:12:11.00,英文,,0,0,0,,So override, it's a nice little reminder that even if you make a typo somewhere here, override will catch it for you.
Dialogue: 0,0:12:04.20,0:12:11.00,中文,,0,0,0,,覆盖 这是一个很好的提醒 即使你在这里某处犯了一个拼写错误 覆盖会帮你找出来
Dialogue: 0,0:12:11.00,0:12:11.82,英文,,0,0,0,,OK.
Dialogue: 0,0:12:11.82,0:12:17.35,英文,,0,0,0,,Great so I'm going to override remove last so I look and I think how do I remove last?
Dialogue: 0,0:12:11.82,0:12:17.35,中文,,0,0,0,,很好 我要覆盖删除最后一个 我看着然后我想我怎么删除最后一个
Dialogue: 0,0:12:17.35,0:12:25.13,英文,,0,0,0,,How do I override it so that not only am I removing something but I'm also adding it to this lost items list well?
Dialogue: 0,0:12:17.35,0:12:25.13,中文,,0,0,0,,我如何覆盖它 以便不仅删除了某物 还将其添加到这个丢失项目列表中呢
Dialogue: 0,0:12:25.13,0:12:25.75,英文,,0,0,0,,Let me try something.
Dialogue: 0,0:12:25.13,0:12:25.75,中文,,0,0,0,,让我试试
Dialogue: 0,0:12:25.75,0:12:27.69,英文,,0,0,0,,So what if I just go into SList?
Dialogue: 0,0:12:25.75,0:12:27.69,中文,,0,0,0,,那我只要进入SLList怎么样
Dialogue: 0,0:12:27.69,0:12:29.47,英文,,0,0,0,,We wrote this last time.
Dialogue: 0,0:12:27.69,0:12:29.47,中文,,0,0,0,,我们上次写过这个
Dialogue: 0,0:12:29.47,0:12:31.27,英文,,0,0,0,,And I'll go find Remove Last.
Dialogue: 0,0:12:29.47,0:12:31.27,中文,,0,0,0,,我去找removeLast
Dialogue: 0,0:12:31.27,0:12:32.13,英文,,0,0,0,,OK, there you are.
Dialogue: 0,0:12:31.27,0:12:32.13,中文,,0,0,0,,你在那里
Dialogue: 0,0:12:32.13,0:12:34.07,英文,,0,0,0,,OK, I guess I also missed that.
Dialogue: 0,0:12:32.13,0:12:34.07,中文,,0,0,0,,我想我也错过了那个
Dialogue: 0,0:12:34.07,0:12:35.61,英文,,0,0,0,,OK, now it's overwriting.
Dialogue: 0,0:12:34.07,0:12:35.61,中文,,0,0,0,,现在它正在覆盖
Dialogue: 0,0:12:35.61,0:12:36.53,英文,,0,0,0,,Great.
Dialogue: 0,0:12:35.61,0:12:36.53,中文,,0,0,0,,太棒了
Dialogue: 0,0:12:36.53,0:12:38.32,英文,,0,0,0,,So maybe I can just take this.
Dialogue: 0,0:12:36.53,0:12:38.32,中文,,0,0,0,,也许我可以就这样做
Dialogue: 0,0:12:38.32,0:12:39.10,英文,,0,0,0,,I'll just copy-paste.
Dialogue: 0,0:12:38.32,0:12:39.10,中文,,0,0,0,,我只是复制粘贴
Dialogue: 0,0:12:39.10,0:12:43.58,英文,,0,0,0,,And I'll say, well, when I remove something, I still want all this stuff to happen.
Dialogue: 0,0:12:39.10,0:12:43.58,中文,,0,0,0,,而且我会说 好吧 当我删除某些东西时 我仍然希望所有这些事情发生
Dialogue: 0,0:12:43.58,0:12:49.74,英文,,0,0,0,,So I'll just copy-paste it here and then add some more stuff to put the new item in the lost items list.
Dialogue: 0,0:12:43.58,0:12:49.74,中文,,0,0,0,,我只是在这里复制粘贴它 然后添加一些更多的东西来将新项目放入丢失项目列表中
Dialogue: 0,0:12:49.74,0:12:53.82,英文,,0,0,0,,But Java's complaining, and it says, Sentinel has private access.
Dialogue: 0,0:12:49.74,0:12:53.82,中文,,0,0,0,,但是Java在抱怨 并且它说 Sentinel具有私有访问权限
Dialogue: 0,0:12:53.82,0:12:56.10,英文,,0,0,0,,Size has private access.
Dialogue: 0,0:12:53.82,0:12:56.10,中文,,0,0,0,,Size具有私有访问权限
Dialogue: 0,0:12:56.10,0:13:03.61,英文,,0,0,0,,So it turns out, in Java, the word private means so private that not even your subclasses can access those elements.
Dialogue: 0,0:12:56.10,0:13:03.61,中文,,0,0,0,,事实证明 在Java中 私有一词的意思是如此私有 甚至你的子类也无法访问这些元素
Dialogue: 0,0:13:03.61,0:13:06.23,英文,,0,0,0,,So Sentinel, it's defined in SLList.
Dialogue: 0,0:13:03.61,0:13:06.23,中文,,0,0,0,, Sentinel 在 SLList 中定义了它
Dialogue: 0,0:13:06.23,0:13:13.35,英文,,0,0,0,,Even though eventual SLList is an SLList and it has a Sentinel, because we define it as private, we don't get to access it.
Dialogue: 0,0:13:06.23,0:13:13.35,中文,,0,0,0,,即使最终 SLList 是一个 SLList 并且它有一个 Sentinel 但因为我们将其定义为私有的 我们无法访问它
Dialogue: 0,0:13:13.35,0:13:14.73,英文,,0,0,0,,And the same thing for size.
Dialogue: 0,0:13:13.35,0:13:14.73,中文,,0,0,0,,对于 size 也是同样的情况
Dialogue: 0,0:13:14.73,0:13:17.11,英文,,0,0,0,,We don't get to access size.
Dialogue: 0,0:13:14.73,0:13:17.11,中文,,0,0,0,,我们无法访问 size
Dialogue: 0,0:13:17.11,0:13:19.21,英文,,0,0,0,,So what do we do?
Dialogue: 0,0:13:17.11,0:13:19.21,中文,,0,0,0,,那我们该怎么办呢
Dialogue: 0,0:13:19.21,0:13:27.21,英文,,0,0,0,,I still want all this code to run, but I can't copy-paste it because it's gross, and the private keyword stops me from accessing things in the parent class.
Dialogue: 0,0:13:19.21,0:13:27.21,中文,,0,0,0,,我仍然希望所有这些代码都能运行 但我无法复制粘贴它 因为它很丑陋 并且私有关键字阻止了我访问父类中的内容
Dialogue: 0,0:13:27.21,0:13:29.71,英文,,0,0,0,,So I'm going to bust out another special keyword.
Dialogue: 0,0:13:27.21,0:13:29.71,中文,,0,0,0,,我要使用另一个特殊关键字
Dialogue: 0,0:13:29.71,0:13:31.54,英文,,0,0,0,,Maybe you've seen it before, maybe not.
Dialogue: 0,0:13:29.71,0:13:31.54,中文,,0,0,0,,也许你以前见过 也可能没有
Dialogue: 0,0:13:31.54,0:13:33.50,英文,,0,0,0,,I'm going to bust out the keyword super.
Dialogue: 0,0:13:31.54,0:13:33.50,中文,,0,0,0,,我要用关键字 super 突出重点
Dialogue: 0,0:13:33.50,0:13:34.58,英文,,0,0,0,,What does super do?
Dialogue: 0,0:13:33.50,0:13:34.58,中文,,0,0,0,,super 是做什么的
Dialogue: 0,0:13:34.58,0:13:36.50,英文,,0,0,0,,It's a reference to the parent object.
Dialogue: 0,0:13:34.58,0:13:36.50,中文,,0,0,0,,它是对父对象的引用
Dialogue: 0,0:13:36.50,0:13:40.50,英文,,0,0,0,,So if I say something like super.removeLast,
Dialogue: 0,0:13:36.50,0:13:40.50,中文,,0,0,0,,如果我说像 super.removeLast 这样的话
Dialogue: 0,0:13:40.50,0:13:43.26,英文,,0,0,0,,Then I'm saying, go to the parent class, which is SLList.
Dialogue: 0,0:13:40.50,0:13:43.26,中文,,0,0,0,,那么我是在说 去到父类 也就是 SLList
Dialogue: 0,0:13:43.26,0:13:45.50,英文,,0,0,0,,There's a removeLast method there.
Dialogue: 0,0:13:43.26,0:13:45.50,中文,,0,0,0,,那里有一个 removeLast 方法
Dialogue: 0,0:13:45.50,0:13:46.64,英文,,0,0,0,,Do that stuff.
Dialogue: 0,0:13:45.50,0:13:46.64,中文,,0,0,0,,做那些事情
Dialogue: 0,0:13:46.64,0:13:51.37,英文,,0,0,0,,So when I say super.removeLast, I'm going into the parent class, doing all this stuff.
Dialogue: 0,0:13:46.64,0:13:51.37,中文,,0,0,0,,当我说super.removeLast时 我进入父类 做所有这些事情
Dialogue: 0,0:13:51.37,0:13:53.03,英文,,0,0,0,,That's a special new keyword.
Dialogue: 0,0:13:51.37,0:13:53.03,中文,,0,0,0,,这是一个特殊的新关键字
Dialogue: 0,0:13:53.03,0:13:53.59,英文,,0,0,0,,OK.
Dialogue: 0,0:13:53.59,0:13:55.59,英文,,0,0,0,,When I removeLast, I also get an item back.
Dialogue: 0,0:13:53.59,0:13:55.59,中文,,0,0,0,,当我removeLast时 我也会得到一个项目回来
Dialogue: 0,0:13:55.59,0:13:59.50,英文,,0,0,0,,So I will get the item that was removed.
Dialogue: 0,0:13:55.59,0:13:59.50,中文,,0,0,0,,我会得到被移除的项目
Dialogue: 0,0:13:59.50,0:14:01.24,英文,,0,0,0,,And I'll go to lostItems.
Dialogue: 0,0:13:59.50,0:14:01.24,中文,,0,0,0,,然后我会去lostItems s
Dialogue: 0,0:14:01.24,0:14:04.68,英文,,0,0,0,,And I'll add the item that I just removed.
Dialogue: 0,0:14:01.24,0:14:04.68,中文,,0,0,0,,然后我会添加我刚刚移除的项目
Dialogue: 0,0:14:04.68,0:14:08.60,英文,,0,0,0,,And I also have to return the item that was removed, so I'll do that too.
Dialogue: 0,0:14:04.68,0:14:08.60,中文,,0,0,0,,而且我还必须返回被移除的项目 我也会这样做
Dialogue: 0,0:14:08.60,0:14:09.90,英文,,0,0,0,,That's my remove last.
Dialogue: 0,0:14:08.60,0:14:09.90,中文,,0,0,0,,这是我最后删除的
Dialogue: 0,0:14:09.90,0:14:20.01,英文,,0,0,0,,Do everything that the parent class does, but also do an extra thing, which is add the removed item to the lost items list, and then return the item that was removed.
Dialogue: 0,0:14:09.90,0:14:20.01,中文,,0,0,0,,做所有父类做的事情 但还要做一件额外的事情 就是将被移除的项目添加到丢失项目列表中 然后返回被移除的项目
Dialogue: 0,0:14:20.01,0:14:20.89,英文,,0,0,0,,OK.
Dialogue: 0,0:14:20.89,0:14:22.19,英文,,0,0,0,,Looks pretty good.
Dialogue: 0,0:14:20.89,0:14:22.19,中文,,0,0,0,,看起来相当不错
Dialogue: 0,0:14:22.19,0:14:23.33,英文,,0,0,0,,Questions, thoughts?
Dialogue: 0,0:14:22.19,0:14:23.33,中文,,0,0,0,,有问题 想法吗
Dialogue: 0,0:14:23.33,0:14:25.15,英文,,0,0,0,,Maybe I'll run it, see what happens.
Dialogue: 0,0:14:23.33,0:14:25.15,中文,,0,0,0,,也许我会运行它 看看会发生什么
Dialogue: 0,0:14:25.15,0:14:25.97,英文,,0,0,0,,OK.
Dialogue: 0,0:14:25.97,0:14:29.25,英文,,0,0,0,,So I'm expecting to find out that the fallen items are 10 and 13.
Dialogue: 0,0:14:25.97,0:14:29.25,中文,,0,0,0,,我期望发现掉落物品是10和13
Dialogue: 0,0:14:29.25,0:14:33.07,英文,,0,0,0,,However, huh.
Dialogue: 0,0:14:29.25,0:14:33.07,中文,,0,0,0,,然而
Dialogue: 0,0:14:33.07,0:14:33.71,英文,,0,0,0,,Crash.
Dialogue: 0,0:14:33.07,0:14:33.71,中文,,0,0,0,,让人崩溃
Dialogue: 0,0:14:33.71,0:14:34.81,英文,,0,0,0,,So what do I do?
Dialogue: 0,0:14:33.71,0:14:34.81,中文,,0,0,0,,那我该怎么办呢
Dialogue: 0,0:14:34.81,0:14:43.25,英文,,0,0,0,,Remember, Pro 61B tip is when you see an error message like this, don't get tempted to just immediately copy paste on it and hope someone knows.
Dialogue: 0,0:14:34.81,0:14:43.25,中文,,0,0,0,,记住 61B的建议是当你看到这样的错误消息时 不要急于复制粘贴 希望有人知道
Dialogue: 0,0:14:43.25,0:14:45.23,英文,,0,0,0,,Maybe we should read it through and see.
Dialogue: 0,0:14:43.25,0:14:45.23,中文,,0,0,0,,也许我们应该仔细阅读一下
Dialogue: 0,0:14:45.23,0:14:47.00,英文,,0,0,0,,Well, says something about null pointers.
Dialogue: 0,0:14:45.23,0:14:47.00,中文,,0,0,0,,好吧 关于空指针的一些内容
Dialogue: 0,0:14:47.00,0:14:50.82,英文,,0,0,0,,So maybe somewhere I'm starting to think something about nulls.
Dialogue: 0,0:14:47.00,0:14:50.82,中文,,0,0,0,,也许在某个地方 我开始考虑一些关于空值的事情
Dialogue: 0,0:14:50.82,0:14:54.66,英文,,0,0,0,,I keep reading and it says lost items is null.
Dialogue: 0,0:14:50.82,0:14:54.66,中文,,0,0,0,,我继续阅读 它说丢失的物品是空的
Dialogue: 0,0:14:54.66,0:14:55.16,英文,,0,0,0,,Interesting.
Dialogue: 0,0:14:54.66,0:14:55.16,中文,,0,0,0,,有趣
Dialogue: 0,0:14:55.16,0:14:57.10,英文,,0,0,0,,Why would lost items be null?
Dialogue: 0,0:14:55.16,0:14:57.10,中文,,0,0,0,,为什么丢失的物品会是空的呢
Dialogue: 0,0:14:57.10,0:14:59.10,英文,,0,0,0,,And it even gives me a link.
Dialogue: 0,0:14:57.10,0:14:59.10,中文,,0,0,0,,甚至给了我一个链接
Dialogue: 0,0:14:59.10,0:15:00.71,英文,,0,0,0,,It says, go here, line 16.
Dialogue: 0,0:14:59.10,0:15:00.71,中文,,0,0,0,,它说 去这里 第16行
Dialogue: 0,0:15:00.71,0:15:04.03,英文,,0,0,0,,I click on it, and it says right here, lost items is null.
Dialogue: 0,0:15:00.71,0:15:04.03,中文,,0,0,0,,我点击它 然后它显示在这里 丢失的物品为null
Dialogue: 0,0:15:04.03,0:15:07.55,英文,,0,0,0,,You're trying to add to a list that you never instantiated.
Dialogue: 0,0:15:04.03,0:15:07.55,中文,,0,0,0,,你试图向一个从未实例化的列表中添加内容
Dialogue: 0,0:15:07.55,0:15:10.48,英文,,0,0,0,,So I read the error message, and I'm like, ah.
Dialogue: 0,0:15:07.55,0:15:10.48,中文,,0,0,0,,我读了错误消息 我就像 啊
Dialogue: 0,0:15:10.48,0:15:14.36,英文,,0,0,0,,Even though I'm using LostItems, I never actually created a new list.
Dialogue: 0,0:15:10.48,0:15:14.36,中文,,0,0,0,,即使我正在使用lostItems 我实际上从未创建过一个新列表
Dialogue: 0,0:15:14.36,0:15:15.48,英文,,0,0,0,,LostItems is null.
Dialogue: 0,0:15:14.36,0:15:15.48,中文,,0,0,0,,lostItems为空
Dialogue: 0,0:15:15.48,0:15:16.64,英文,,0,0,0,,There's no list there.
Dialogue: 0,0:15:15.48,0:15:16.64,中文,,0,0,0,,那里没有列表
Dialogue: 0,0:15:16.64,0:15:22.00,英文,,0,0,0,,I need to use the new keyword to create an actual list so I can add things to it.
Dialogue: 0,0:15:16.64,0:15:22.00,中文,,0,0,0,,我需要使用新关键字来创建一个实际的列表 这样我就可以向其中添加东西
Dialogue: 0,0:15:22.00,0:15:23.66,英文,,0,0,0,,So where should I do that?
Dialogue: 0,0:15:22.00,0:15:23.66,中文,,0,0,0,,那我应该在哪里做呢
Dialogue: 0,0:15:23.66,0:15:26.94,英文,,0,0,0,,At what point should I create a brand new LostItems list?
Dialogue: 0,0:15:23.66,0:15:26.94,中文,,0,0,0,,在什么时候应该创建一个全新的lostItems SLList
Dialogue: 0,0:15:26.94,0:15:33.56,英文,,0,0,0,,Well, maybe when I create a brand new VengefulS list, I should also instantiate the LostItems list at the same time.
Dialogue: 0,0:15:26.94,0:15:33.56,中文,,0,0,0,,也许当我创建一个全新的VengefulSLList时 我应该同时实例化lostItems SLList
Dialogue: 0,0:15:33.56,0:15:34.88,英文,,0,0,0,,So where do I do that?
Dialogue: 0,0:15:33.56,0:15:34.88,中文,,0,0,0,,那我应该在哪里做呢
Dialogue: 0,0:15:34.88,0:15:36.70,英文,,0,0,0,,Maybe I'll do it in the constructor.
Dialogue: 0,0:15:34.88,0:15:36.70,中文,,0,0,0,,也许我会在构造函数中做
Dialogue: 0,0:15:36.70,0:15:38.34,英文,,0,0,0,,Remember the constructor?
Dialogue: 0,0:15:36.70,0:15:38.34,中文,,0,0,0,,还记得构造函数吗
Dialogue: 0,0:15:38.34,0:15:41.17,英文,,0,0,0,,tells me how to set up a brand new Vengeful SLList.
Dialogue: 0,0:15:38.34,0:15:41.17,中文,,0,0,0,,告诉我如何设置一个全新的VengefulSLList
Dialogue: 0,0:15:41.17,0:15:45.43,英文,,0,0,0,,So when I call the constructor, I get a brand new shiny Vengeful SLList.
Dialogue: 0,0:15:41.17,0:15:45.43,中文,,0,0,0,,当我调用构造函数时 我会得到一个全新闪亮的VengefulSLList
Dialogue: 0,0:15:45.43,0:15:51.15,英文,,0,0,0,,And when I do that, I will actually instantiate lost items to be a new SLList.
Dialogue: 0,0:15:45.43,0:15:51.15,中文,,0,0,0,,当我这样做时 我将实际上将丢失的项目实例化为一个新的SLList
Dialogue: 0,0:15:51.15,0:15:52.73,英文,,0,0,0,,OK, great.
Dialogue: 0,0:15:51.15,0:15:52.73,中文,,0,0,0,,很好
Dialogue: 0,0:15:52.73,0:15:54.61,英文,,0,0,0,,Now I'll try it one more time.
Dialogue: 0,0:15:52.73,0:15:54.61,中文,,0,0,0,,现在我再试一次
Dialogue: 0,0:15:54.61,0:15:59.36,英文,,0,0,0,,Hopefully this time it tells me that the fallen items are 10.
Dialogue: 0,0:15:54.61,0:15:59.36,中文,,0,0,0,,希望这次它告诉我掉落的物品有10个
Dialogue: 0,0:15:59.36,0:15:59.82,英文,,0,0,0,,What are they?
Dialogue: 0,0:15:59.36,0:15:59.82,中文,,0,0,0,,它们是什么
Dialogue: 0,0:15:59.82,0:16:00.98,英文,,0,0,0,,They're 10 and 13?
Dialogue: 0,0:15:59.82,0:16:00.98,中文,,0,0,0,,他们分别是10岁和13岁
Dialogue: 0,0:16:00.98,0:16:02.76,英文,,0,0,0,,OK, 13 and 10.
Dialogue: 0,0:16:00.98,0:16:02.76,中文,,0,0,0,,13岁和10岁
Dialogue: 0,0:16:02.76,0:16:03.76,英文,,0,0,0,,Good enough.
Dialogue: 0,0:16:02.76,0:16:03.76,中文,,0,0,0,,够好了
Dialogue: 0,0:16:03.76,0:16:05.66,英文,,0,0,0,,That's my Vengeful SLList.
Dialogue: 0,0:16:03.76,0:16:05.66,中文,,0,0,0,,这是我的VengefulSLList
Dialogue: 0,0:16:05.66,0:16:06.76,英文,,0,0,0,,I overrode a method.
Dialogue: 0,0:16:05.66,0:16:06.76,中文,,0,0,0,,我重写了一个方法
Dialogue: 0,0:16:06.76,0:16:08.98,英文,,0,0,0,,I used the super keyword.
Dialogue: 0,0:16:06.76,0:16:08.98,中文,,0,0,0,,我使用了super关键字
Dialogue: 0,0:16:08.98,0:16:11.01,英文,,0,0,0,,Okay, that's not what I want.
Dialogue: 0,0:16:08.98,0:16:11.01,中文,,0,0,0,,那不是我想要的
Dialogue: 0,0:16:11.01,0:16:13.29,英文,,0,0,0,,Okay, so there it is.
Dialogue: 0,0:16:11.01,0:16:13.29,中文,,0,0,0,,就是这样
Dialogue: 0,0:16:13.29,0:16:19.12,英文,,0,0,0,,I use the special keyword super and this called super class the S list version of remove last.
Dialogue: 0,0:16:13.29,0:16:19.12,中文,,0,0,0,,我使用特殊关键字super 这被称为父类SLList版本的removeLast
Dialogue: 0,0:16:19.12,0:16:20.88,英文,,0,0,0,,Then I did some extra stuff.
Dialogue: 0,0:16:19.12,0:16:20.88,中文,,0,0,0,,然后我做了一些额外的事情
Dialogue: 0,0:16:20.88,0:16:22.09,英文,,0,0,0,,Okay.
Dialogue: 0,0:16:22.09,0:16:22.77,英文,,0,0,0,,Great.
Dialogue: 0,0:16:22.09,0:16:22.77,中文,,0,0,0,,很棒
Dialogue: 0,0:16:22.77,0:16:27.43,英文,,0,0,0,,So this next section, according to Josh, who made the slides, is kind of boring.
Dialogue: 0,0:16:22.77,0:16:27.43,中文,,0,0,0,,这下一部分 根据制作幻灯片的Josh说 有点无聊
Dialogue: 0,0:16:27.43,0:16:29.31,英文,,0,0,0,,But it will mess you up sometimes.
Dialogue: 0,0:16:27.43,0:16:29.31,中文,,0,0,0,,但有时它会让你困扰
Dialogue: 0,0:16:29.31,0:16:30.67,英文,,0,0,0,,So we have to talk about it.
Dialogue: 0,0:16:29.31,0:16:30.67,中文,,0,0,0,,我们得谈谈这件事
Dialogue: 0,0:16:30.67,0:16:39.62,英文,,0,0,0,,So it turns out, when you write a constructor like this, the Java rule is that you're also going to call the superclass's constructor.
Dialogue: 0,0:16:30.67,0:16:39.62,中文,,0,0,0,,结果是 当你写一个像这样的构造函数时 Java的规则是你也会调用超类的构造函数
Dialogue: 0,0:16:39.62,0:16:40.80,英文,,0,0,0,,What the heck does that mean?
Dialogue: 0,0:16:39.62,0:16:40.80,中文,,0,0,0,,这是什么意思
Dialogue: 0,0:16:40.80,0:16:43.80,英文,,0,0,0,,So let's do some debugging to figure out what's going on.
Dialogue: 0,0:16:40.80,0:16:43.80,中文,,0,0,0,,让我们进行一些调试 弄清楚到底发生了什么
Dialogue: 0,0:16:43.80,0:16:50.54,英文,,0,0,0,,So I'm going to set a breakpoint at the constructor right there, where I'm calling new VengefulSlist, because I want to see what happens.
Dialogue: 0,0:16:43.80,0:16:50.54,中文,,0,0,0,,我要在那里调用new VengefulSLList的构造函数处设置一个断点 因为我想看看会发生什么
Dialogue: 0,0:16:50.54,0:16:51.76,英文,,0,0,0,,So I'm going to call.
Dialogue: 0,0:16:50.54,0:16:51.76,中文,,0,0,0,,我要调用
Dialogue: 0,0:16:51.76,0:16:53.30,英文,,0,0,0,,I'm going to run the debugger.
Dialogue: 0,0:16:51.76,0:16:53.30,中文,,0,0,0,,我要运行调试器
Dialogue: 0,0:16:53.30,0:16:56.46,英文,,0,0,0,,OK, I'm stopped right here on this line.
Dialogue: 0,0:16:53.30,0:16:56.46,中文,,0,0,0,,我就停在这一行
Dialogue: 0,0:16:56.46,0:16:57.04,英文,,0,0,0,,Great.
Dialogue: 0,0:16:56.46,0:16:57.04,中文,,0,0,0,,太好了
Dialogue: 0,0:16:57.04,0:16:58.20,英文,,0,0,0,,Now, I could step over.
Dialogue: 0,0:16:57.04,0:16:58.20,中文,,0,0,0,,现在 我可以单步执行
Dialogue: 0,0:16:58.20,0:17:03.85,英文,,0,0,0,,But if I step over, I don't get to see all the fun, boring stuff inside the Vengeful SLLess Constructor.
Dialogue: 0,0:16:58.20,0:17:03.85,中文,,0,0,0,,但是如果我单步执行 我就看不到 VengefulSLList 构造函数内部所有有趣但无聊的东西
Dialogue: 0,0:17:03.85,0:17:05.37,英文,,0,0,0,,I want to see the boring stuff.
Dialogue: 0,0:17:03.85,0:17:05.37,中文,,0,0,0,,我想看看这些无聊的东西
Dialogue: 0,0:17:05.37,0:17:08.51,英文,,0,0,0,,So I'm going to step into the Vengeful SLLess Constructor.
Dialogue: 0,0:17:05.37,0:17:08.51,中文,,0,0,0,,我要进入 VengefulSLList 构造函数
Dialogue: 0,0:17:08.51,0:17:09.57,英文,,0,0,0,,And here we are.
Dialogue: 0,0:17:08.51,0:17:09.57,中文,,0,0,0,,然后我们就到这里了
Dialogue: 0,0:17:09.57,0:17:10.75,英文,,0,0,0,,No great surprises.
Dialogue: 0,0:17:09.57,0:17:10.75,中文,,0,0,0,,没有太大的惊喜
Dialogue: 0,0:17:10.75,0:17:13.11,英文,,0,0,0,,We're in the Vengeful SLLess Constructor.
Dialogue: 0,0:17:10.75,0:17:13.11,中文,,0,0,0,,我们在VengefulSLList 构造函数中
Dialogue: 0,0:17:13.11,0:17:16.35,英文,,0,0,0,,But if I step again, this next part might be kind of surprising.
Dialogue: 0,0:17:13.11,0:17:16.35,中文,,0,0,0,,但是如果我再次迈出步伐 接下来的部分可能会有点惊讶
Dialogue: 0,0:17:16.35,0:17:19.30,英文,,0,0,0,,You might expect, while I'm here, if I step,
Dialogue: 0,0:17:16.35,0:17:19.30,中文,,0,0,0,,你可能期望 当我在这里时 如果我迈出步伐
Dialogue: 0,0:17:19.30,0:17:20.92,英文,,0,0,0,,Shouldn't I be on the next line?
Dialogue: 0,0:17:19.30,0:17:20.92,中文,,0,0,0,,我应该在下一行吗
Dialogue: 0,0:17:20.92,0:17:21.98,英文,,0,0,0,,Well, maybe.
Dialogue: 0,0:17:20.92,0:17:21.98,中文,,0,0,0,,也许
Dialogue: 0,0:17:21.98,0:17:26.38,英文,,0,0,0,,But if I step, aha, I find myself in the SLList constructor.
Dialogue: 0,0:17:21.98,0:17:26.38,中文,,0,0,0,,但是如果我迈出步伐 啊哈 我发现自己在 SLList 构造函数中
Dialogue: 0,0:17:26.38,0:17:28.46,英文,,0,0,0,,And what does the SLList constructor do?
Dialogue: 0,0:17:26.38,0:17:28.46,中文,,0,0,0,,SLList构造函数做什么
Dialogue: 0,0:17:28.46,0:17:30.24,英文,,0,0,0,,It sets up size to be 0.
Dialogue: 0,0:17:28.46,0:17:30.24,中文,,0,0,0,,它将size设置为0
Dialogue: 0,0:17:30.24,0:17:31.90,英文,,0,0,0,,It sets up the sentinel.
Dialogue: 0,0:17:30.24,0:17:31.90,中文,,0,0,0,,它设置了sentinel
Dialogue: 0,0:17:31.90,0:17:37.60,英文,,0,0,0,,And then it pops back out to the Vengeful SLList, where I finish setting up all the Vengeful SLList things.
Dialogue: 0,0:17:31.90,0:17:37.60,中文,,0,0,0,,然后它弹回到VengefulSLList 在那里我完成了所有VengefulSLList的设置
Dialogue: 0,0:17:37.60,0:17:40.00,英文,,0,0,0,,And then I'm done with the constructor.
Dialogue: 0,0:17:37.60,0:17:40.00,中文,,0,0,0,,然后我完成了构造函数
Dialogue: 0,0:17:40.00,0:17:41.16,英文,,0,0,0,,Interesting.
Dialogue: 0,0:17:40.00,0:17:41.16,中文,,0,0,0,,有趣
Dialogue: 0,0:17:41.16,0:17:52.67,英文,,0,0,0,,So what just happened is that every time you call the Vengeful SLList constructor, you're actually also going to call the superclass's SLList constructor as well.
Dialogue: 0,0:17:41.16,0:17:52.67,中文,,0,0,0,,刚才发生的是 每次调用VengefulSLList构造函数时 实际上也会调用超类的SLList构造函数
Dialogue: 0,0:17:52.67,0:17:53.39,英文,,0,0,0,,And this makes sense.
Dialogue: 0,0:17:52.67,0:17:53.39,中文,,0,0,0,,这是有道理的
Dialogue: 0,0:17:53.39,0:17:54.43,英文,,0,0,0,,This is a good idea.
Dialogue: 0,0:17:53.39,0:17:54.43,中文,,0,0,0,,这是一个好主意
Dialogue: 0,0:17:54.43,0:18:03.59,英文,,0,0,0,,Because if every Vengeful SLList is an SLList, which they are, then every Vengeful SLList should also have the same setup as an SLList.
Dialogue: 0,0:17:54.43,0:18:03.59,中文,,0,0,0,,因为如果每个VengefulSLList 都是一个 SLList 它们确实是 那么每个VengefulSLList 也应该有与 SLList 相同的设置
Dialogue: 0,0:18:03.59,0:18:04.49,英文,,0,0,0,,That's good.
Dialogue: 0,0:18:03.59,0:18:04.49,中文,,0,0,0,,那很好
Dialogue: 0,0:18:04.49,0:18:08.64,英文,,0,0,0,,Imagine if we didn't call the SLList constructor, then we would forget to set up size.
Dialogue: 0,0:18:04.49,0:18:08.64,中文,,0,0,0,,想象一下 如果我们不调用 SLList 构造函数 那么我们就会忘记设置大小
Dialogue: 0,0:18:08.64,0:18:09.58,英文,,0,0,0,,That would be bad.
Dialogue: 0,0:18:08.64,0:18:09.58,中文,,0,0,0,,那将是糟糕的
Dialogue: 0,0:18:09.58,0:18:11.14,英文,,0,0,0,,We'd forget to set up Sentinel.
Dialogue: 0,0:18:09.58,0:18:11.14,中文,,0,0,0,,我们会忘记设置 Sentinel
Dialogue: 0,0:18:11.14,0:18:12.36,英文,,0,0,0,,That would also be bad.
Dialogue: 0,0:18:11.14,0:18:12.36,中文,,0,0,0,,那也不好
Dialogue: 0,0:18:12.36,0:18:18.86,英文,,0,0,0,,So it's a good thing that when I set up the Vengeful SLList, Java remembers, well, a Vengeful SLList is an SLList.
Dialogue: 0,0:18:12.36,0:18:18.86,中文,,0,0,0,,当我设置VengefulSLList时 Java会记住 VengefulSLList就是一个SLList
Dialogue: 0,0:18:18.86,0:18:22.60,英文,,0,0,0,,So I'd better go and set up all the SLList things as well.
Dialogue: 0,0:18:18.86,0:18:22.60,中文,,0,0,0,,我最好去设置所有的SLList事情
Dialogue: 0,0:18:22.60,0:18:24.26,英文,,0,0,0,,You can even make this explicit.
Dialogue: 0,0:18:22.60,0:18:24.26,中文,,0,0,0,,你甚至可以明确地做出这个
Dialogue: 0,0:18:24.26,0:18:31.90,英文,,0,0,0,,So if you really want to let the reader of your code know, I'm calling the superclasses constructor, then you can add an extra line.
Dialogue: 0,0:18:24.26,0:18:31.90,中文,,0,0,0,,如果你真的想让你代码的读者知道 我在调用超类的构造函数 那么你可以添加一行额外的代码
Dialogue: 0,0:18:31.90,0:18:32.66,英文,,0,0,0,,Super.
Dialogue: 0,0:18:31.90,0:18:32.66,中文,,0,0,0,,super()
Dialogue: 0,0:18:32.66,0:18:37.75,英文,,0,0,0,,And all this does is what we just saw, which is it's going to call the super classes constructor.
Dialogue: 0,0:18:32.66,0:18:37.75,中文,,0,0,0,,而所有这些所做的就是我们刚才看到的 它会调用超类的构造函数
Dialogue: 0,0:18:37.75,0:18:39.59,英文,,0,0,0,,So this works just like before.
Dialogue: 0,0:18:37.75,0:18:39.59,中文,,0,0,0,,这就像以前一样工作
Dialogue: 0,0:18:39.59,0:18:40.91,英文,,0,0,0,,I can even show it to you.
Dialogue: 0,0:18:39.59,0:18:40.91,中文,,0,0,0,,我甚至可以给你看
Dialogue: 0,0:18:40.91,0:18:43.67,英文,,0,0,0,,So I can step in when I call super.
Dialogue: 0,0:18:40.91,0:18:43.67,中文,,0,0,0,,当我调用super时我可以介入
Dialogue: 0,0:18:43.67,0:18:45.53,英文,,0,0,0,,It takes me to the SLList constructor.
Dialogue: 0,0:18:43.67,0:18:45.53,中文,,0,0,0,,它把我带到SLList构造函数
Dialogue: 0,0:18:45.53,0:18:46.89,英文,,0,0,0,,Everything is good.
Dialogue: 0,0:18:45.53,0:18:46.89,中文,,0,0,0,,一切都很好
Dialogue: 0,0:18:46.89,0:18:48.27,英文,,0,0,0,,SLList is set up correctly.
Dialogue: 0,0:18:46.89,0:18:48.27,中文,,0,0,0,,SLList设置正确
Dialogue: 0,0:18:48.27,0:18:49.93,英文,,0,0,0,,Then I can set up lost items.
Dialogue: 0,0:18:48.27,0:18:49.93,中文,,0,0,0,,然后我可以设置丢失的项目
Dialogue: 0,0:18:49.93,0:18:52.53,英文,,0,0,0,,But even if I didn't put the super keyword,
Dialogue: 0,0:18:49.93,0:18:52.53,中文,,0,0,0,,但是即使我没有放super关键字
Dialogue: 0,0:18:52.53,0:19:00.81,英文,,0,0,0,,The tricky thing about Java is if you don't put this keyword, Java will still call the parent class's constructor implicitly, without telling you.
Dialogue: 0,0:18:52.53,0:19:00.81,中文,,0,0,0,,Java的棘手之处在于如果你不放这个关键字 Java仍然会隐式地调用父类的构造函数 而不告诉你
Dialogue: 0,0:19:00.81,0:19:06.74,英文,,0,0,0,,So even if I don't have this line here, we're still going to call the SLList's parent class constructor.
Dialogue: 0,0:19:00.81,0:19:06.74,中文,,0,0,0,,即使我这里没有这行代码 我们仍然会调用SLList的父类构造函数
Dialogue: 0,0:19:06.74,0:19:07.34,英文,,0,0,0,,That's a good thing.
Dialogue: 0,0:19:06.74,0:19:07.34,中文,,0,0,0,,这是一件好事
Dialogue: 0,0:19:07.34,0:19:08.40,英文,,0,0,0,,We want that.
Dialogue: 0,0:19:07.34,0:19:08.40,中文,,0,0,0,,我们希望如此
Dialogue: 0,0:19:08.40,0:19:09.32,英文,,0,0,0,,OK.
Dialogue: 0,0:19:09.32,0:19:11.22,英文,,0,0,0,,So that's this slide.
Dialogue: 0,0:19:09.32,0:19:11.22,中文,,0,0,0,,这就是这个幻灯片
Dialogue: 0,0:19:11.22,0:19:12.14,英文,,0,0,0,,Oh, I keep messing it up.
Dialogue: 0,0:19:11.22,0:19:12.14,中文,,0,0,0,,哦 我老是搞错了
Dialogue: 0,0:19:12.14,0:19:12.52,英文,,0,0,0,,OK.
Dialogue: 0,0:19:12.52,0:19:13.60,英文,,0,0,0,,I'll switch these around.
Dialogue: 0,0:19:12.52,0:19:13.60,中文,,0,0,0,,我会把它们调换一下
Dialogue: 0,0:19:13.60,0:19:15.54,英文,,0,0,0,,So that's this slide.
Dialogue: 0,0:19:13.60,0:19:15.54,中文,,0,0,0,,这就是这张幻灯片
Dialogue: 0,0:19:15.54,0:19:19.50,英文,,0,0,0,,It basically says these are the same, whether you put the super keyword or not.
Dialogue: 0,0:19:15.54,0:19:19.50,中文,,0,0,0,,基本上它说这些是一样的 无论你是否加了 super 关键字
Dialogue: 0,0:19:19.50,0:19:20.52,英文,,0,0,0,,OK.
Dialogue: 0,0:19:20.52,0:19:24.62,英文,,0,0,0,,But here's the part that's a little bit tricky, which is you can actually have multiple constructors.
Dialogue: 0,0:19:20.52,0:19:24.62,中文,,0,0,0,,但这里有个有点棘手的部分 就是你实际上可以有多个构造函数
Dialogue: 0,0:19:24.62,0:19:26.84,英文,,0,0,0,,When we built the SLList, we saw this.
Dialogue: 0,0:19:24.62,0:19:26.84,中文,,0,0,0,,当我们构建SLList时 我们看到了这个
Dialogue: 0,0:19:26.84,0:19:27.64,英文,,0,0,0,,Remember the SLList?
Dialogue: 0,0:19:26.84,0:19:27.64,中文,,0,0,0,,记得SLList吗
Dialogue: 0,0:19:27.64,0:19:29.29,英文,,0,0,0,,There were two constructors.
Dialogue: 0,0:19:27.64,0:19:29.29,中文,,0,0,0,,有两个构造函数
Dialogue: 0,0:19:29.29,0:19:31.85,英文,,0,0,0,,One of them took no arguments, made an empty list.
Dialogue: 0,0:19:29.29,0:19:31.85,中文,,0,0,0,,其中一个不带参数 生成一个空列表
Dialogue: 0,0:19:31.85,0:19:36.07,英文,,0,0,0,,One of them took a single argument, made a list with one item.
Dialogue: 0,0:19:31.85,0:19:36.07,中文,,0,0,0,,其中一个带一个参数 生成一个带有一个项目的列表
Dialogue: 0,0:19:36.07,0:19:39.49,英文,,0,0,0,,So what if I want to do the same thing in Vengeful SLList?
Dialogue: 0,0:19:36.07,0:19:39.49,中文,,0,0,0,,那么如果我想在VengefulSLList中做同样的事情呢
Dialogue: 0,0:19:39.49,0:19:44.48,英文,,0,0,0,,I'm like, I'm going to have a second Vengeful SLList constructor, and this one's going to take in a single item.
Dialogue: 0,0:19:39.49,0:19:44.48,中文,,0,0,0,,我是说 我要有第二个VengefulSLList构造函数 这个函数将接受一个项目
Dialogue: 0,0:19:44.48,0:19:46.78,英文,,0,0,0,,So hey, maybe I'll even add a comment.
Dialogue: 0,0:19:44.48,0:19:46.78,中文,,0,0,0,,嘿 也许我甚至会添加一条注释
Dialogue: 0,0:19:46.78,0:19:51.32,英文,,0,0,0,,Creates an empty Vengeful. S list.
Dialogue: 0,0:19:46.78,0:19:51.32,中文,,0,0,0,,创建一个空的 Vengeful SLList
Dialogue: 0,0:19:51.32,0:19:52.08,英文,,0,0,0,,OK.
Dialogue: 0,0:19:52.08,0:19:53.72,英文,,0,0,0,,And then this one, what does it do?
Dialogue: 0,0:19:52.08,0:19:53.72,中文,,0,0,0,,然后这个 它是做什么的
Dialogue: 0,0:19:53.72,0:20:01.10,英文,,0,0,0,,It creates a vengeful S list with one item, which is x. OK.
Dialogue: 0,0:19:53.72,0:20:01.10,中文,,0,0,0,,它创建一个具有一个项目 x 的Vengeful SLList
Dialogue: 0,0:20:01.10,0:20:01.87,英文,,0,0,0,,Looks great.
Dialogue: 0,0:20:01.10,0:20:01.87,中文,,0,0,0,,看起来不错
Dialogue: 0,0:20:01.87,0:20:10.51,英文,,0,0,0,,So I can try to do the same thing, which is, oh, maybe I'll just put this, and I'll just hope that it implicitly calls the parent constructor like we saw earlier.
Dialogue: 0,0:20:01.87,0:20:10.51,中文,,0,0,0,,我可以尝试做同样的事情 也就是 也许我只是放这个 然后我只希望它隐式调用父构造函数 就像我们之前看到的那样
Dialogue: 0,0:20:10.51,0:20:16.49,英文,,0,0,0,,And maybe if I come down here and I create a new list with some item inside, well, I'd hope to call the right constructor.
Dialogue: 0,0:20:10.51,0:20:16.49,中文,,0,0,0,,也许如果我到这里来 然后我用一些项目在里面创建一个新列表 那么 我希望调用正确的构造函数
Dialogue: 0,0:20:16.49,0:20:18.20,英文,,0,0,0,,So I'll debug again.
Dialogue: 0,0:20:16.49,0:20:18.20,中文,,0,0,0,,我会再次调试
Dialogue: 0,0:20:18.20,0:20:22.30,英文,,0,0,0,,And again, I know it's not the most exciting topic, but it's going to mess you up now and then.
Dialogue: 0,0:20:18.20,0:20:22.30,中文,,0,0,0,,而且 我知道这不是最令人兴奋的话题 但它现在会偶尔把你搞糊涂
Dialogue: 0,0:20:22.30,0:20:23.72,英文,,0,0,0,,So let's get the double check.
Dialogue: 0,0:20:22.30,0:20:23.72,中文,,0,0,0,,让我们再次仔细检查一下
Dialogue: 0,0:20:23.72,0:20:31.68,英文,,0,0,0,,So I find myself in the new constructor, the one with the single item, because I want to build an SLList with one new item.
Dialogue: 0,0:20:23.72,0:20:31.68,中文,,0,0,0,,我发现自己在新的构造函数中 那个只有一个项目的构造函数 因为我想用一个新项目来构建一个 SLList
Dialogue: 0,0:20:31.68,0:20:33.99,英文,,0,0,0,,But here comes the part that's a little weird.
Dialogue: 0,0:20:31.68,0:20:33.99,中文,,0,0,0,,但这里出现了一个有点奇怪的部分
Dialogue: 0,0:20:33.99,0:20:37.85,英文,,0,0,0,,When I step inside, Java's going to automatically call the constructor for me, right?
Dialogue: 0,0:20:33.99,0:20:37.85,中文,,0,0,0,,当我进入时 Java会自动为我调用构造函数 对吧
Dialogue: 0,0:20:37.85,0:20:39.25,英文,,0,0,0,,It's going to set up the SLList.
Dialogue: 0,0:20:37.85,0:20:39.25,中文,,0,0,0,,它会设置SLList
Dialogue: 0,0:20:39.25,0:20:42.87,英文,,0,0,0,,But I step, and uh-oh, I'm in the wrong constructor.
Dialogue: 0,0:20:39.25,0:20:42.87,中文,,0,0,0,,但是我一步 哎呀 我进入了错误的构造函数
Dialogue: 0,0:20:42.87,0:20:48.15,英文,,0,0,0,,And the key trick here, the thing that's going to mess you up, is if you do not write
Dialogue: 0,0:20:42.87,0:20:48.15,中文,,0,0,0,,关键的技巧在于 会让你困扰的事情是 如果你没有写
Dialogue: 0,0:20:48.15,0:20:52.50,英文,,0,0,0,,The call to super, Java is going to implicitly call the default constructor.
Dialogue: 0,0:20:48.15,0:20:52.50,中文,,0,0,0,,对super的调用 Java会隐式调用默认构造函数
Dialogue: 0,0:20:52.50,0:20:53.64,英文,,0,0,0,,And which one is that?
Dialogue: 0,0:20:52.50,0:20:53.64,中文,,0,0,0,,那个是什么
Dialogue: 0,0:20:53.64,0:20:55.34,英文,,0,0,0,,It's the one with no arguments.
Dialogue: 0,0:20:53.64,0:20:55.34,中文,,0,0,0,,就是没有参数的那个
Dialogue: 0,0:20:55.34,0:21:02.33,英文,,0,0,0,,So if you do something like this, where you don't explicitly say super, Java is going to assume you want the constructor with no arguments.
Dialogue: 0,0:20:55.34,0:21:02.33,中文,,0,0,0,,如果你像这样做 不明确地说super Java会认为你想要没有参数的构造函数
Dialogue: 0,0:21:02.33,0:21:03.99,英文,,0,0,0,,And in this case, that's bad.
Dialogue: 0,0:21:02.33,0:21:03.99,中文,,0,0,0,,而在这种情况下 那是不好的
Dialogue: 0,0:21:03.99,0:21:06.75,英文,,0,0,0,,I'm trying to build a vengeful SLList with one item.
Dialogue: 0,0:21:03.99,0:21:06.75,中文,,0,0,0,,我正在尝试构建一个带有一个项目的Vengeful性SLList
Dialogue: 0,0:21:06.75,0:21:10.27,英文,,0,0,0,,But when I'm setting up the SLList, I'm using the zero-item constructor.
Dialogue: 0,0:21:06.75,0:21:10.27,中文,,0,0,0,,但当我设置SLList时 我使用的是零项目构造函数
Dialogue: 0,0:21:10.27,0:21:11.20,英文,,0,0,0,,That's bad.
Dialogue: 0,0:21:10.27,0:21:11.20,中文,,0,0,0,,那是不好的
Dialogue: 0,0:21:11.20,0:21:12.10,英文,,0,0,0,,I don't want it.
Dialogue: 0,0:21:11.20,0:21:12.10,中文,,0,0,0,,我不想要它
Dialogue: 0,0:21:12.10,0:21:15.52,英文,,0,0,0,,So to fix it, I need to explicitly call super.
Dialogue: 0,0:21:12.10,0:21:15.52,中文,,0,0,0,,为了解决这个问题 我需要明确调用super
Dialogue: 0,0:21:15.52,0:21:23.51,英文,,0,0,0,,And by passing in an argument x, now Java knows, ah, you want the constructor with one argument, because you want to set up an SLList with one argument.
Dialogue: 0,0:21:15.52,0:21:23.51,中文,,0,0,0,,通过传入参数 x 现在 Java 知道了 啊 你想要一个带有一个参数的构造函数 因为你想要用一个参数来设置 SLList
Dialogue: 0,0:21:23.51,0:21:24.75,英文,,0,0,0,,So I step in.
Dialogue: 0,0:21:23.51,0:21:24.75,中文,,0,0,0,,我介入
Dialogue: 0,0:21:24.75,0:21:25.69,英文,,0,0,0,,I step in.
Dialogue: 0,0:21:25.69,0:21:26.49,英文,,0,0,0,,Oops.
Dialogue: 0,0:21:25.69,0:21:26.49,中文,,0,0,0,,哎呀
Dialogue: 0,0:21:26.49,0:21:28.07,英文,,0,0,0,,I'll do that one more time.
Dialogue: 0,0:21:26.49,0:21:28.07,中文,,0,0,0,,我再做一次
Dialogue: 0,0:21:28.07,0:21:30.60,英文,,0,0,0,,I promise you the boring section is almost over.
Dialogue: 0,0:21:28.07,0:21:30.60,中文,,0,0,0,,我向你保证 无聊的部分快结束了
Dialogue: 0,0:21:30.60,0:21:31.64,英文,,0,0,0,,So I step in.
Dialogue: 0,0:21:30.60,0:21:31.64,中文,,0,0,0,,我介入
Dialogue: 0,0:21:31.64,0:21:32.46,英文,,0,0,0,,I step into super.
Dialogue: 0,0:21:31.64,0:21:32.46,中文,,0,0,0,,我进入super
Dialogue: 0,0:21:32.46,0:21:39.68,英文,,0,0,0,,And now, because I explicitly called super with one argument, I'm in the right place.
Dialogue: 0,0:21:32.46,0:21:39.68,中文,,0,0,0,,现在 因为我显式地使用一个参数调用了 super 我在正确的位置
Dialogue: 0,0:21:39.68,0:21:42.22,英文,,0,0,0,,Again, I know it's boring, but it might trip you up sometimes.
Dialogue: 0,0:21:39.68,0:21:42.22,中文,,0,0,0,,再次 我知道这很无聊 但有时候这可能会让你感到困惑
Dialogue: 0,0:21:42.22,0:21:54.79,英文,,0,0,0,,Question?
Dialogue: 0,0:21:42.22,0:21:54.79,中文,,0,0,0,,有疑问吗
Dialogue: 0,0:21:54.79,0:22:01.03,英文,,0,0,0,,Yeah, the question was, why can't Java just be designed so that it would call the parent constructor with one variable?
Dialogue: 0,0:21:54.79,0:22:01.03,中文,,0,0,0,,是的 问题是 为什么 Java 不能被设计成调用父构造函数并传递一个变量呢
Dialogue: 0,0:22:01.03,0:22:04.73,英文,,0,0,0,,Well, the problem is, how would Java know what you're trying to do?
Dialogue: 0,0:22:01.03,0:22:04.73,中文,,0,0,0,,问题在于 Java 怎么知道你想要做什么呢
Dialogue: 0,0:22:04.73,0:22:05.39,英文,,0,0,0,,You were looking at me.
Dialogue: 0,0:22:04.73,0:22:05.39,中文,,0,0,0,,你在看着我
Dialogue: 0,0:22:05.39,0:22:06.63,英文,,0,0,0,,Did you have anything to add?
Dialogue: 0,0:22:05.39,0:22:06.63,中文,,0,0,0,,你有什么要补充的吗
Dialogue: 0,0:22:06.63,0:22:08.23,英文,,0,0,0,,Oh, OK.
Dialogue: 0,0:22:06.63,0:22:08.23,中文,,0,0,0,,哦 好的
Dialogue: 0,0:22:08.23,0:22:09.46,英文,,0,0,0,,OK, just reading.
Dialogue: 0,0:22:08.23,0:22:09.46,中文,,0,0,0,,继续阅读
Dialogue: 0,0:22:09.46,0:22:12.44,英文,,0,0,0,,Yeah, so the problem here is that Java would not know which one to call.
Dialogue: 0,0:22:09.46,0:22:12.44,中文,,0,0,0,,是啊 问题在于 Java 不知道该调用哪一个
Dialogue: 0,0:22:12.44,0:22:15.86,英文,,0,0,0,,Maybe in this case, when we're writing the S list, you and I can kind of tell.
Dialogue: 0,0:22:12.44,0:22:15.86,中文,,0,0,0,,也许在这种情况下 当我们编写 SLList时 你和我可以大致知道
Dialogue: 0,0:22:15.86,0:22:20.96,英文,,0,0,0,,But for Java, there's no way to always try and guess which constructor the programmer wants.
Dialogue: 0,0:22:15.86,0:22:20.96,中文,,0,0,0,,但对于 Java 来说 它无法始终尝试猜测程序员想要哪个构造函数
Dialogue: 0,0:22:20.96,0:22:23.70,英文,,0,0,0,,So all it can do is default to the no-argument constructor.
Dialogue: 0,0:22:20.96,0:22:23.70,中文,,0,0,0,,它只能默认使用无参数的构造函数
Dialogue: 0,0:22:23.70,0:22:27.09,英文,,0,0,0,,And if you want a different one, you have to say so explicitly.
Dialogue: 0,0:22:23.70,0:22:27.09,中文,,0,0,0,,如果你想要另一个 你必须明确说出来
Dialogue: 0,0:22:27.09,0:22:29.39,英文,,0,0,0,,Yeah, that's a great question.
Dialogue: 0,0:22:27.09,0:22:29.39,中文,,0,0,0,,是的 这是个好问题
Dialogue: 0,0:22:29.39,0:22:30.45,英文,,0,0,0,,Other great questions?
Dialogue: 0,0:22:29.39,0:22:30.45,中文,,0,0,0,,还有其他好问题吗
Dialogue: 0,0:22:30.45,0:22:32.05,英文,,0,0,0,,Anything on Zoom?
Dialogue: 0,0:22:30.45,0:22:32.05,中文,,0,0,0,,Zoom 上有什么吗
Dialogue: 0,0:22:32.05,0:22:33.66,英文,,0,0,0,,OK.
Dialogue: 0,0:22:33.66,0:22:35.04,英文,,0,0,0,,OK, no more boring stuff.
Dialogue: 0,0:22:33.66,0:22:35.04,中文,,0,0,0,,不再讲无聊的东西了
Dialogue: 0,0:22:35.04,0:22:36.60,英文,,0,0,0,,So we talked about extends.
Dialogue: 0,0:22:35.04,0:22:36.60,中文,,0,0,0,,我们谈论了 extends
Dialogue: 0,0:22:36.60,0:22:39.11,英文,,0,0,0,,It's a new type of implementation inheritance.
Dialogue: 0,0:22:36.60,0:22:39.11,中文,,0,0,0,,这是一种新型的实现继承
Dialogue: 0,0:22:39.11,0:22:45.35,英文,,0,0,0,,So for the rest of today, we get to get philosophical and start talking about how do you like implementation inheritance?
Dialogue: 0,0:22:39.11,0:22:45.35,中文,,0,0,0,,今天的剩下时间 我们可以开始思考并讨论你对实现继承的喜好
Dialogue: 0,0:22:45.35,0:22:46.29,英文,,0,0,0,,Do you like it?
Dialogue: 0,0:22:45.35,0:22:46.29,中文,,0,0,0,,你喜欢吗
Dialogue: 0,0:22:46.29,0:22:47.24,英文,,0,0,0,,Do you not like it?
Dialogue: 0,0:22:46.29,0:22:47.24,中文,,0,0,0,,你不喜欢吗
Dialogue: 0,0:22:47.24,0:22:48.48,英文,,0,0,0,,What are your thoughts on it?
Dialogue: 0,0:22:47.24,0:22:48.48,中文,,0,0,0,,你对此有什么想法
Dialogue: 0,0:22:48.48,0:22:53.22,英文,,0,0,0,,So let's do a bit of reflecting and talk about some extra inheritance.
Dialogue: 0,0:22:48.48,0:22:53.22,中文,,0,0,0,,让我们做一些反思 谈谈一些额外的继承特性
Dialogue: 0,0:22:53.22,0:22:54.68,英文,,0,0,0,,features along the way.
Dialogue: 0,0:22:53.22,0:22:54.68,中文,,0,0,0,,一路上的特性
Dialogue: 0,0:22:54.68,0:23:01.60,英文,,0,0,0,,So one kind of cool thing is remember how in lecture one we said Java is a very object-oriented program?
Dialogue: 0,0:22:54.68,0:23:01.60,中文,,0,0,0,,记得我们在第一讲中提到Java是一个非常面向对象的程序吗 这点非常酷
Dialogue: 0,0:23:01.60,0:23:06.67,英文,,0,0,0,,It really cares about objects and classes and forces you to be object-oriented.
Dialogue: 0,0:23:01.60,0:23:06.67,中文,,0,0,0,,它非常关注对象和类 并迫使你必须进行面向对象编程
Dialogue: 0,0:23:06.67,0:23:12.27,英文,,0,0,0,,Well, it turns out objects are so important in Java that every class that you ever define
Dialogue: 0,0:23:06.67,0:23:12.27,中文,,0,0,0,,事实证明 在Java中对象如此重要 以至于你定义的每一个类
Dialogue: 0,0:23:12.27,0:23:20.57,英文,,0,0,0,,Dog, IntList, SList, Walrus, every class that you ever define is actually a subclass of something called the object class.
Dialogue: 0,0:23:12.27,0:23:20.57,中文,,0,0,0,,无论是Dog、IntList、SLList还是Walrus 你定义的每一个类实际上都是所谓object类的子类
Dialogue: 0,0:23:20.57,0:23:22.31,英文,,0,0,0,,And this is baked into Java.
Dialogue: 0,0:23:20.57,0:23:22.31,中文,,0,0,0,,这是Java内置的特性
Dialogue: 0,0:23:22.31,0:23:25.04,英文,,0,0,0,,It's been there since Java 1.0.
Dialogue: 0,0:23:22.31,0:23:25.04,中文,,0,0,0,,这从Java 1.0起就有了
Dialogue: 0,0:23:25.04,0:23:37.10,英文,,0,0,0,,So even if you declare a new class, like we did public class Dog in one of the earlier lectures, even though we did not say that Dog extends object, it nonetheless extends object.
Dialogue: 0,0:23:25.04,0:23:37.10,中文,,0,0,0,,即便你声明了一个新类 就像我们在早期的课程中做的public class Dog 尽管我们没有声明Dog extends object 它仍然继承自object
Dialogue: 0,0:23:37.10,0:23:45.91,英文,,0,0,0,,So every class you ever write will always implicitly be a subclass of object, even if you don't say the words extends object.
Dialogue: 0,0:23:37.10,0:23:45.91,中文,,0,0,0,,你写的每个类都隐式地是 object 的子类 即使你没有说 extends object 这几个词
Dialogue: 0,0:23:45.91,0:23:46.71,英文,,0,0,0,,So what does that mean?
Dialogue: 0,0:23:45.91,0:23:46.71,中文,,0,0,0,,那么这意味着什么呢
Dialogue: 0,0:23:46.71,0:23:56.88,英文,,0,0,0,,Well, it means that because everybody ever is a descendant or a subclass of object, it means that everybody has inherited the methods that object defines.
Dialogue: 0,0:23:46.71,0:23:56.88,中文,,0,0,0,,这意味着因为每个人都是 object 的后代或子类 这意味着每个人都继承了 object 定义的方法
Dialogue: 0,0:23:56.88,0:24:02.10,英文,,0,0,0,,So any objects that are in method, they're gonna be inherited into every class that I ever write.
Dialogue: 0,0:23:56.88,0:24:02.10,中文,,0,0,0,,任何在方法中的对象都会被继承到我所写的每个类中
Dialogue: 0,0:24:02.10,0:24:04.83,英文,,0,0,0,,So what are the methods in object?
Dialogue: 0,0:24:02.10,0:24:04.83,中文,,0,0,0,,那么 object 中有哪些方法呢
Dialogue: 0,0:24:04.83,0:24:05.89,英文,,0,0,0,,Let's go find out.
Dialogue: 0,0:24:04.83,0:24:05.89,中文,,0,0,0,,让我们去找找看
Dialogue: 0,0:24:05.89,0:24:07.43,英文,,0,0,0,,Here are the methods in object.
Dialogue: 0,0:24:05.89,0:24:07.43,中文,,0,0,0,,这是对象中的方法
Dialogue: 0,0:24:07.43,0:24:13.27,英文,,0,0,0,,And because object has all of these methods, all the descendants of object will also have these methods.
Dialogue: 0,0:24:07.43,0:24:13.27,中文,,0,0,0,,因为对象拥有所有这些方法 对象的所有子类也会有这些方法
Dialogue: 0,0:24:13.27,0:24:17.47,英文,,0,0,0,,So you make a dog, even if you don't define any methods, it's got all these methods.
Dialogue: 0,0:24:13.27,0:24:17.47,中文,,0,0,0,,你创建一个狗 即使你不定义任何方法 它也有所有这些方法
Dialogue: 0,0:24:17.47,0:24:20.46,英文,,0,0,0,,You make a walrus, the walrus has all of these methods.
Dialogue: 0,0:24:17.47,0:24:20.46,中文,,0,0,0,,你创建一个海象 海象也有所有这些方法
Dialogue: 0,0:24:20.46,0:24:22.70,英文,,0,0,0,,In this class, we'll talk about three of them.
Dialogue: 0,0:24:20.46,0:24:22.70,中文,,0,0,0,,在这个课程中 我们会讲解其中的三种方法
Dialogue: 0,0:24:22.70,0:24:29.11,英文,,0,0,0,,The rest of these, at least in this class, we don't care, but do know that they exist.
Dialogue: 0,0:24:22.70,0:24:29.11,中文,,0,0,0,,这些剩下的方法 至少在这个课程中 我们不关心 但要知道它们存在
Dialogue: 0,0:24:29.11,0:24:35.55,英文,,0,0,0,,Apparently, some of these are also hilariously outdated, but that's the thing with Java, I guess.
Dialogue: 0,0:24:29.11,0:24:35.55,中文,,0,0,0,,显然 其中一些方法已经过时得可笑 但这就是 Java 的特点 我想
Dialogue: 0,0:24:35.55,0:24:37.40,英文,,0,0,0,,They're in there, and we can't get rid of them.
Dialogue: 0,0:24:35.55,0:24:37.40,中文,,0,0,0,,它们在那里 而且我们无法摆脱它们
Dialogue: 0,0:24:37.40,0:24:39.65,英文,,0,0,0,,Oh well.
Dialogue: 0,0:24:37.40,0:24:39.65,中文,,0,0,0,,噢 好吧
Dialogue: 0,0:24:39.65,0:24:41.31,英文,,0,0,0,,Great, so that's the object class.
Dialogue: 0,0:24:39.65,0:24:41.31,中文,,0,0,0,,太好了 那就是对象类
Dialogue: 0,0:24:41.31,0:24:44.07,英文,,0,0,0,,So now we're going to get a little bit more philosophical.
Dialogue: 0,0:24:41.31,0:24:44.07,中文,,0,0,0,,现在我们要再深入一点点哲学
Dialogue: 0,0:24:44.07,0:24:51.12,英文,,0,0,0,,And remember, the thing we've been saying over and over and over again, I even say it in the funny, exaggerated way to make you remember,
Dialogue: 0,0:24:44.07,0:24:51.12,中文,,0,0,0,,记住 我们一遍又一遍地说的那件事 我甚至用滑稽夸张的方式说 让你记住
Dialogue: 0,0:24:51.12,0:24:58.58,英文,,0,0,0,,every time we use extends or implements and we create these inheritance relationships, we're creating these is-a relationships.
Dialogue: 0,0:24:51.12,0:24:58.58,中文,,0,0,0,,每当我们使用extends或implements并创建这些继承关系时 我们都在创建这些is-a关系
Dialogue: 0,0:24:58.58,0:25:03.60,英文,,0,0,0,,So an SLList is a list, or a dog is an animal.
Dialogue: 0,0:24:58.58,0:25:03.60,中文,,0,0,0,,一个SLList是一个列表 或者一只狗是一只动物
Dialogue: 0,0:25:03.60,0:25:04.28,英文,,0,0,0,,Those are good.
Dialogue: 0,0:25:03.60,0:25:04.28,中文,,0,0,0,,那些都很好
Dialogue: 0,0:25:04.28,0:25:05.24,英文,,0,0,0,,We like those.
Dialogue: 0,0:25:04.28,0:25:05.24,中文,,0,0,0,,我们喜欢那些
Dialogue: 0,0:25:05.24,0:25:07.78,英文,,0,0,0,,Those are the ways that we should be using inheritance.
Dialogue: 0,0:25:05.24,0:25:07.78,中文,,0,0,0,,这些是我们应该使用继承的方式
Dialogue: 0,0:25:07.78,0:25:15.15,英文,,0,0,0,,But a really common mistake, especially if you're just seeing this for the first time, is to try and use inheritance for has-a relationships.
Dialogue: 0,0:25:07.78,0:25:15.15,中文,,0,0,0,,但一个非常常见的错误 特别是如果你是第一次看到这个 就是试图在 has-a 关系中使用继承
Dialogue: 0,0:25:15.15,0:25:16.25,英文,,0,0,0,,And that's no good.
Dialogue: 0,0:25:15.15,0:25:16.25,中文,,0,0,0,,那是不好的
Dialogue: 0,0:25:16.25,0:25:19.41,英文,,0,0,0,,So you do not want to use inheritance for has-a relationships.
Dialogue: 0,0:25:16.25,0:25:19.41,中文,,0,0,0,,你不想在 has-a 关系中使用继承
Dialogue: 0,0:25:19.41,0:25:21.41,英文,,0,0,0,,This is the danger that we saw earlier.
Dialogue: 0,0:25:19.41,0:25:21.41,中文,,0,0,0,,这就是我们之前看到的危险
Dialogue: 0,0:25:21.41,0:25:22.87,英文,,0,0,0,,So a dog is an animal.
Dialogue: 0,0:25:21.41,0:25:22.87,中文,,0,0,0,,狗是一种动物
Dialogue: 0,0:25:22.87,0:25:23.39,英文,,0,0,0,,That's good.
Dialogue: 0,0:25:22.87,0:25:23.39,中文,,0,0,0,,这很好
Dialogue: 0,0:25:23.39,0:25:24.31,英文,,0,0,0,,We like that.
Dialogue: 0,0:25:23.39,0:25:24.31,中文,,0,0,0,,我们喜欢这个
Dialogue: 0,0:25:24.31,0:25:26.71,英文,,0,0,0,,An S-list is a list60.umb.
Dialogue: 0,0:25:24.31,0:25:26.71,中文,,0,0,0,,一个SLList是一个List61B
Dialogue: 0,0:25:26.71,0:25:27.45,英文,,0,0,0,,That's good.
Dialogue: 0,0:25:26.71,0:25:27.45,中文,,0,0,0,,这很好
Dialogue: 0,0:25:27.45,0:25:29.31,英文,,0,0,0,,These are good ways to use inheritance.
Dialogue: 0,0:25:27.45,0:25:29.31,中文,,0,0,0,,这些是使用继承的好方法
Dialogue: 0,0:25:29.31,0:25:33.36,英文,,0,0,0,,But one bad example would be, well, cats have claws.
Dialogue: 0,0:25:29.31,0:25:33.36,中文,,0,0,0,,但是一个不好的例子会是 猫有爪子
Dialogue: 0,0:25:33.36,0:25:33.94,英文,,0,0,0,,That is true.
Dialogue: 0,0:25:33.36,0:25:33.94,中文,,0,0,0,,这是真的
Dialogue: 0,0:25:33.94,0:25:35.42,英文,,0,0,0,,A cat has a claw.
Dialogue: 0,0:25:33.94,0:25:35.42,中文,,0,0,0,,猫有爪子
Dialogue: 0,0:25:35.42,0:25:37.30,英文,,0,0,0,,But a cat is not a claw.
Dialogue: 0,0:25:35.42,0:25:37.30,中文,,0,0,0,,但猫不是爪子
Dialogue: 0,0:25:37.30,0:25:42.98,英文,,0,0,0,,So you don't want to say something like cat implements claw, because a cat is not a claw.
Dialogue: 0,0:25:37.30,0:25:42.98,中文,,0,0,0,,你不会说猫实现了爪子 因为猫不是爪子
Dialogue: 0,0:25:42.98,0:25:46.80,英文,,0,0,0,,And you look at this, and you're like, why would I ever do something like cats are claws?
Dialogue: 0,0:25:42.98,0:25:46.80,中文,,0,0,0,,看到这个 你会想 我为什么会说猫是爪子呢
Dialogue: 0,0:25:46.80,0:25:48.54,英文,,0,0,0,,Why would I ever say something like that?
Dialogue: 0,0:25:46.80,0:25:48.54,中文,,0,0,0,,我为什么会那么说呢
Dialogue: 0,0:25:48.54,0:25:54.64,英文,,0,0,0,,But here's an example that I think is more realistic and something that people often fall into.
Dialogue: 0,0:25:48.54,0:25:54.64,中文,,0,0,0,,但这里有一个更现实的例子 是人们经常会遇到的
Dialogue: 0,0:25:54.64,0:25:55.26,英文,,0,0,0,,What's a set?
Dialogue: 0,0:25:54.64,0:25:55.26,中文,,0,0,0,,什么是集合
Dialogue: 0,0:25:55.26,0:25:57.11,英文,,0,0,0,,Well, we haven't talked too much about it.
Dialogue: 0,0:25:55.26,0:25:57.11,中文,,0,0,0,,我们还没有太多讨论过它
Dialogue: 0,0:25:57.11,0:25:59.89,英文,,0,0,0,,It might have been in homework 0B or something.
Dialogue: 0,0:25:57.11,0:25:59.89,中文,,0,0,0,,可能是在作业0B或其他地方
Dialogue: 0,0:25:59.89,0:26:02.49,英文,,0,0,0,,But a set, it's an unordered collection of items.
Dialogue: 0,0:25:59.89,0:26:02.49,中文,,0,0,0,,但是一个集合 它是一个无序的项目集合
Dialogue: 0,0:26:02.49,0:26:03.97,英文,,0,0,0,,So it's a big pile of items.
Dialogue: 0,0:26:02.49,0:26:03.97,中文,,0,0,0,,它就是一个大杂烩
Dialogue: 0,0:26:03.97,0:26:05.25,英文,,0,0,0,,There's no order to them.
Dialogue: 0,0:26:03.97,0:26:05.25,中文,,0,0,0,,它们之间没有顺序
Dialogue: 0,0:26:05.25,0:26:06.51,英文,,0,0,0,,And there's no duplicates in them.
Dialogue: 0,0:26:05.25,0:26:06.51,中文,,0,0,0,,而且它们里面没有重复的
Dialogue: 0,0:26:06.51,0:26:13.84,英文,,0,0,0,,So if I create a set, and I say add potato, add potato, add potato, it will just have one copy of potato.
Dialogue: 0,0:26:06.51,0:26:13.84,中文,,0,0,0,,如果我创建一个集合 然后说加入土豆 再加入土豆 再加入土豆 它只会有一个土豆的副本
Dialogue: 0,0:26:13.84,0:26:14.68,英文,,0,0,0,,So that's a set.
Dialogue: 0,0:26:13.84,0:26:14.68,中文,,0,0,0,,那是一个集合
Dialogue: 0,0:26:14.68,0:26:16.38,英文,,0,0,0,,It's an unordered pile of items.
Dialogue: 0,0:26:14.68,0:26:16.38,中文,,0,0,0,,它是一堆无序的项目
Dialogue: 0,0:26:16.38,0:26:21.64,英文,,0,0,0,,So you could say that an SLList has a,
Dialogue: 0,0:26:16.38,0:26:21.64,中文,,0,0,0,,你可以说一个SLList有一个,
Dialogue: 0,0:26:21.64,0:26:23.08,英文,,0,0,0,,A set has an SLList.
Dialogue: 0,0:26:21.64,0:26:23.08,中文,,0,0,0,,一个集合有一个SLList
Dialogue: 0,0:26:23.08,0:26:23.92,英文,,0,0,0,,That's good.
Dialogue: 0,0:26:23.08,0:26:23.92,中文,,0,0,0,,那很好
Dialogue: 0,0:26:23.92,0:26:24.76,英文,,0,0,0,,We like that.
Dialogue: 0,0:26:23.92,0:26:24.76,中文,,0,0,0,,我们喜欢那个
Dialogue: 0,0:26:24.76,0:26:26.92,英文,,0,0,0,,Because you could say, how do I build a set?
Dialogue: 0,0:26:24.76,0:26:26.92,中文,,0,0,0,,因为你可以说 我怎么建立一个集合
Dialogue: 0,0:26:26.92,0:26:29.22,英文,,0,0,0,,Well, I could use a list to represent the set.
Dialogue: 0,0:26:26.92,0:26:29.22,中文,,0,0,0,,我可以用列表来表示集合
Dialogue: 0,0:26:29.22,0:26:31.84,英文,,0,0,0,,And when I add things, I'll check that there are no duplicates.
Dialogue: 0,0:26:29.22,0:26:31.84,中文,,0,0,0,,当我添加东西时 我会检查是否有重复的
Dialogue: 0,0:26:31.84,0:26:32.76,英文,,0,0,0,,That's good.
Dialogue: 0,0:26:31.84,0:26:32.76,中文,,0,0,0,,这很好
Dialogue: 0,0:26:32.76,0:26:35.64,英文,,0,0,0,,I can use a list to implement my set.
Dialogue: 0,0:26:32.76,0:26:35.64,中文,,0,0,0,,我可以用列表来实现我的集合
Dialogue: 0,0:26:35.64,0:26:41.97,英文,,0,0,0,,But if you say that a set is a list, you say set extends SLList, well, suddenly this is kind of bad.
Dialogue: 0,0:26:35.64,0:26:41.97,中文,,0,0,0,,但如果你说一个集合就是一个列表 你说集合扩展了SLList 突然这有点糟糕
Dialogue: 0,0:26:41.97,0:26:44.13,英文,,0,0,0,,Now you're saying a set is a list.
Dialogue: 0,0:26:41.97,0:26:44.13,中文,,0,0,0,,现在你在说集合就是列表
Dialogue: 0,0:26:44.13,0:26:50.11,英文,,0,0,0,,And because the set is a list, that means the set inherits all the methods of the list.
Dialogue: 0,0:26:44.13,0:26:50.11,中文,,0,0,0,,而且因为集合是列表 这意味着集合继承了列表的所有方法
Dialogue: 0,0:26:50.11,0:26:51.09,英文,,0,0,0,,So what does the list have?
Dialogue: 0,0:26:50.11,0:26:51.09,中文,,0,0,0,,列表里有什么
Dialogue: 0,0:26:51.09,0:26:53.81,英文,,0,0,0,,It has get i to get the ith item.
Dialogue: 0,0:26:51.09,0:26:53.81,中文,,0,0,0,,它有获取第i个项的方法
Dialogue: 0,0:26:53.81,0:26:59.03,英文,,0,0,0,,And if you say that a set is a list, suddenly now sets have a get method, which doesn't really make sense.
Dialogue: 0,0:26:53.81,0:26:59.03,中文,,0,0,0,,如果你说集合是一个列表 突然之间集合就有了一个获取方法 这其实没有什么意义
Dialogue: 0,0:26:59.03,0:27:00.81,英文,,0,0,0,,How can you get the fifth thing in a set?
Dialogue: 0,0:26:59.03,0:27:00.81,中文,,0,0,0,,你怎么能获取集合中的第五个元素
Dialogue: 0,0:27:00.81,0:27:01.23,英文,,0,0,0,,It's a set.
Dialogue: 0,0:27:00.81,0:27:01.23,中文,,0,0,0,,它是一个集合
Dialogue: 0,0:27:01.23,0:27:02.37,英文,,0,0,0,,There's no order.
Dialogue: 0,0:27:01.23,0:27:02.37,中文,,0,0,0,,没有顺序
Dialogue: 0,0:27:02.37,0:27:05.92,英文,,0,0,0,,So You know, to use strong words, this is an abomination.
Dialogue: 0,0:27:02.37,0:27:05.92,中文,,0,0,0,,那么你知道 使用强烈的词语来说 这真是一种憎恶
Dialogue: 0,0:27:05.92,0:27:08.22,英文,,0,0,0,,This is not how you want to use inheritance.
Dialogue: 0,0:27:05.92,0:27:08.22,中文,,0,0,0,,这不是你想要使用继承的方式
Dialogue: 0,0:27:08.22,0:27:14.82,英文,,0,0,0,,And it's going to cause your code to be really strange, because now the set object, which remember, it's an unordered pile of items.
Dialogue: 0,0:27:08.22,0:27:14.82,中文,,0,0,0,,而且这会导致你的代码变得很奇怪 因为现在这个集合对象 记住 它是一个无序的项目堆叠
Dialogue: 0,0:27:14.82,0:27:17.28,英文,,0,0,0,,Now it suddenly has like this get item method.
Dialogue: 0,0:27:14.82,0:27:17.28,中文,,0,0,0,,现在突然间有了这个获取项目的方法
Dialogue: 0,0:27:17.28,0:27:18.90,英文,,0,0,0,,That doesn't really make sense.
Dialogue: 0,0:27:17.28,0:27:18.90,中文,,0,0,0,,这其实没有太多意义
Dialogue: 0,0:27:18.90,0:27:24.22,英文,,0,0,0,,So it would be better to say that a set is implemented using an SLList.
Dialogue: 0,0:27:18.90,0:27:24.22,中文,,0,0,0,,更好的说法是使用SLList来实现集合
Dialogue: 0,0:27:24.22,0:27:26.52,英文,,0,0,0,,You can totally use an SLList to build a set.
Dialogue: 0,0:27:24.22,0:27:26.52,中文,,0,0,0,,你完全可以使用SLList来构建一个集合
Dialogue: 0,0:27:26.52,0:27:30.40,英文,,0,0,0,,But it doesn't really make sense to say that a set is an SLList.
Dialogue: 0,0:27:26.52,0:27:30.40,中文,,0,0,0,,但是说一个集合是一个SLList并没有太多意义
Dialogue: 0,0:27:30.40,0:27:33.12,英文,,0,0,0,,OK, here's another example.
Dialogue: 0,0:27:30.40,0:27:33.12,中文,,0,0,0,,这里有另一个例子
Dialogue: 0,0:27:33.12,0:27:35.05,英文,,0,0,0,,And this one actually appears in Java.
Dialogue: 0,0:27:33.12,0:27:35.05,中文,,0,0,0,,而且这个例子实际上出现在Java中
Dialogue: 0,0:27:35.05,0:27:36.95,英文,,0,0,0,,So I'll show you another data structure.
Dialogue: 0,0:27:35.05,0:27:36.95,中文,,0,0,0,,我会给你展示另一个数据结构
Dialogue: 0,0:27:36.95,0:27:38.01,英文,,0,0,0,,It's called a stack.
Dialogue: 0,0:27:36.95,0:27:38.01,中文,,0,0,0,,它叫做栈
Dialogue: 0,0:27:38.01,0:27:40.01,英文,,0,0,0,,A stack is supposed to be super simple.
Dialogue: 0,0:27:38.01,0:27:40.01,中文,,0,0,0,,栈应该是非常简单的
Dialogue: 0,0:27:40.01,0:27:41.81,英文,,0,0,0,,It's a beautiful data structure.
Dialogue: 0,0:27:40.01,0:27:41.81,中文,,0,0,0,,它是一个很美妙的数据结构
Dialogue: 0,0:27:41.81,0:27:45.98,英文,,0,0,0,,It plays into computer science theory in a lot of interesting ways that we won't talk about.
Dialogue: 0,0:27:41.81,0:27:45.98,中文,,0,0,0,,它以很多有趣的方式涉及到计算机科学理论 我们不会讨论这些
Dialogue: 0,0:27:45.98,0:27:50.34,英文,,0,0,0,,But basically, the idea behind a stack is that you can only do two things from the stack.
Dialogue: 0,0:27:45.98,0:27:50.34,中文,,0,0,0,,但基本上 栈的背后思想是 你只能从栈中做两件事情
Dialogue: 0,0:27:50.34,0:27:53.04,英文,,0,0,0,,You can push things onto the top of the stack.
Dialogue: 0,0:27:50.34,0:27:53.04,中文,,0,0,0,,你可以将东西推到栈的顶部
Dialogue: 0,0:27:53.04,0:27:57.13,英文,,0,0,0,,So for example, I push 6 on the stack, I push 2 on the stack.
Dialogue: 0,0:27:53.04,0:27:57.13,中文,,0,0,0,,例如 我将6推到栈上 我将2推到栈上
Dialogue: 0,0:27:57.13,0:27:59.39,英文,,0,0,0,,I can also pop things from the top of the stack.
Dialogue: 0,0:27:57.13,0:27:59.39,中文,,0,0,0,,我也可以从栈顶弹出东西
Dialogue: 0,0:27:59.39,0:28:01.29,英文,,0,0,0,,So I can pop 2, and it's gone.
Dialogue: 0,0:27:59.39,0:28:01.29,中文,,0,0,0,,我可以弹出2 它就消失了
Dialogue: 0,0:28:01.29,0:28:03.39,英文,,0,0,0,,I can pop 6, and it's gone.
Dialogue: 0,0:28:01.29,0:28:03.39,中文,,0,0,0,,我可以弹出6 它就消失了
Dialogue: 0,0:28:03.39,0:28:05.23,英文,,0,0,0,,The animation's amazing.
Dialogue: 0,0:28:03.39,0:28:05.23,中文,,0,0,0,,动画真是太棒了
Dialogue: 0,0:28:05.23,0:28:07.09,英文,,0,0,0,,OK, so that's the operations of a stack.
Dialogue: 0,0:28:05.23,0:28:07.09,中文,,0,0,0,,那就是栈的操作
Dialogue: 0,0:28:07.09,0:28:07.95,英文,,0,0,0,,It's super simple.
Dialogue: 0,0:28:07.09,0:28:07.95,中文,,0,0,0,,非常简单
Dialogue: 0,0:28:07.95,0:28:10.60,英文,,0,0,0,,You push things, you pop things, and that's it.
Dialogue: 0,0:28:07.95,0:28:10.60,中文,,0,0,0,,你压入东西 你弹出东西 就这样
Dialogue: 0,0:28:10.60,0:28:13.12,英文,,0,0,0,,The stack is not supposed to do anything else.
Dialogue: 0,0:28:10.60,0:28:13.12,中文,,0,0,0,,栈不应该做其他事情
Dialogue: 0,0:28:13.12,0:28:21.51,英文,,0,0,0,,But when the Java designers wrote the default stack implementation in the Java library, they made a big mistake, which is, well,
Dialogue: 0,0:28:13.12,0:28:21.51,中文,,0,0,0,,但当 Java 设计者在 Java 库中编写默认的栈实现时 他们犯了一个大错误 那就是
Dialogue: 0,0:28:21.51,0:28:28.44,英文,,0,0,0,,They said that a stack is a list, so they said stack extends something which implements list.
Dialogue: 0,0:28:21.51,0:28:28.44,中文,,0,0,0,,他们说栈是一个列表 他们说栈扩展了实现列表的东西
Dialogue: 0,0:28:28.44,0:28:31.20,英文,,0,0,0,,So what they're saying is that a stack is a list.
Dialogue: 0,0:28:28.44,0:28:31.20,中文,,0,0,0,,他们说的是 一个栈就是一个列表
Dialogue: 0,0:28:31.20,0:28:38.25,英文,,0,0,0,,And what that means is that all of the operations that a list has get at first remove first at last.
Dialogue: 0,0:28:31.20,0:28:38.25,中文,,0,0,0,,而这意味着列表具有的所有操作都首先获取第一个 最后获取最后一个
Dialogue: 0,0:28:38.25,0:28:40.05,英文,,0,0,0,,Insert at specific item.
Dialogue: 0,0:28:38.25,0:28:40.05,中文,,0,0,0,,在特定项目插入
Dialogue: 0,0:28:40.05,0:28:48.82,英文,,0,0,0,,All of those methods that a list has, they all get inherited into a stack, even though a stack was supposed to be a super simple data structure.
Dialogue: 0,0:28:40.05,0:28:48.82,中文,,0,0,0,,列表具有的所有这些方法都会被继承到栈中 尽管栈本应是一个非常简单的数据结构
Dialogue: 0,0:28:48.82,0:28:50.16,英文,,0,0,0,,You push, you pop.
Dialogue: 0,0:28:48.82,0:28:50.16,中文,,0,0,0,,你压入 你弹出
Dialogue: 0,0:28:50.16,0:28:56.52,英文,,0,0,0,,But because we said a stack is a list, suddenly we've inherited all these methods that we really didn't want.
Dialogue: 0,0:28:50.16,0:28:56.52,中文,,0,0,0,,但因为我们说过栈就是一个列表 突然间我们继承了所有这些我们实际上并不想要的方法
Dialogue: 0,0:28:56.52,0:29:02.23,英文,,0,0,0,,So this would be nice if you want to say the stack has a list that's beautiful.
Dialogue: 0,0:28:56.52,0:29:02.23,中文,,0,0,0,,如果你想说栈有一个列表 那就太美妙了
Dialogue: 0,0:29:02.23,0:29:03.57,英文,,0,0,0,,A stack has a list.
Dialogue: 0,0:29:02.23,0:29:03.57,中文,,0,0,0,,一个栈有一个列表
Dialogue: 0,0:29:03.57,0:29:04.75,英文,,0,0,0,,So here's my stack.
Dialogue: 0,0:29:03.57,0:29:04.75,中文,,0,0,0,,这是我的栈
Dialogue: 0,0:29:04.75,0:29:06.93,英文,,0,0,0,,I have a private instance variable called items.
Dialogue: 0,0:29:04.75,0:29:06.93,中文,,0,0,0,,我有一个称为items的私有实例变量
Dialogue: 0,0:29:06.93,0:29:12.11,英文,,0,0,0,,It's a list and I can use that list to store my items when I push and when I pop.
Dialogue: 0,0:29:06.93,0:29:12.11,中文,,0,0,0,,这是一个列表 当我推入和弹出时 我可以使用该列表来存储我的项目
Dialogue: 0,0:29:12.11,0:29:13.95,英文,,0,0,0,,This is beautiful, it's simple.
Dialogue: 0,0:29:12.11,0:29:13.95,中文,,0,0,0,,这很美好 很简单
Dialogue: 0,0:29:13.95,0:29:17.93,英文,,0,0,0,,When a user tries to interact with the stack, all that you can do is push and pop.
Dialogue: 0,0:29:13.95,0:29:17.93,中文,,0,0,0,,当用户尝试与栈交互时 你能做的就是推入和弹出
Dialogue: 0,0:29:17.93,0:29:20.14,英文,,0,0,0,,And inside, we're secretly using a list.
Dialogue: 0,0:29:17.93,0:29:20.14,中文,,0,0,0,,而在内部 我们暗中使用一个列表
Dialogue: 0,0:29:20.14,0:29:21.36,英文,,0,0,0,,That's totally fine.
Dialogue: 0,0:29:20.14,0:29:21.36,中文,,0,0,0,,这完全没问题
Dialogue: 0,0:29:21.36,0:29:26.14,英文,,0,0,0,,A stack has a linked list with the data, but a stack is not a linked list.
Dialogue: 0,0:29:21.36,0:29:26.14,中文,,0,0,0,,堆栈有一个带有数据的链表 但堆栈不是链表
Dialogue: 0,0:29:26.14,0:29:27.08,英文,,0,0,0,,This is great.
Dialogue: 0,0:29:26.14,0:29:27.08,中文,,0,0,0,,这太棒了
Dialogue: 0,0:29:27.08,0:29:27.94,英文,,0,0,0,,There's my stack.
Dialogue: 0,0:29:27.08,0:29:27.94,中文,,0,0,0,,这是我的堆栈
Dialogue: 0,0:29:27.94,0:29:30.56,英文,,0,0,0,,It's a nice little nail clipper with just a couple methods.
Dialogue: 0,0:29:27.94,0:29:30.56,中文,,0,0,0,,这是一个很好的小指甲剪 只有几个方法
Dialogue: 0,0:29:30.56,0:29:32.04,英文,,0,0,0,,But this is the danger.
Dialogue: 0,0:29:30.56,0:29:32.04,中文,,0,0,0,,但这就是危险所在
Dialogue: 0,0:29:32.04,0:29:37.95,英文,,0,0,0,,If you say stack is a linked list, you are inheriting all of the methods of a list.
Dialogue: 0,0:29:32.04,0:29:37.95,中文,,0,0,0,,如果你说堆栈是一个链表 你就继承了列表的所有方法
Dialogue: 0,0:29:37.95,0:29:41.61,英文,,0,0,0,,So instead of having this nice little nail clipper, you have this abomination.
Dialogue: 0,0:29:37.95,0:29:41.61,中文,,0,0,0,,本来你有一个很好的小指甲刀 现在却变成了一个怪物
Dialogue: 0,0:29:41.61,0:29:50.66,英文,,0,0,0,,And suddenly, the stack has push, pop, but it also has contains, intricate capacity, insert element at, and that's just not a useful data structure.
Dialogue: 0,0:29:41.61,0:29:50.66,中文,,0,0,0,,突然间 栈不仅有push和pop 还多了contains、intricate capacity、insert element at等功能 这根本就不是一个实用的数据结构
Dialogue: 0,0:29:50.66,0:29:55.40,英文,,0,0,0,,It's supposed to be so simple, but you've inherited all these methods that you do not want.
Dialogue: 0,0:29:50.66,0:29:55.40,中文,,0,0,0,,它本应该很简单 但你继承了所有这些你不需要的方法
Dialogue: 0,0:29:55.40,0:30:02.70,英文,,0,0,0,,And so now, if you're coding in IntelliJ, the IntelliJ autocomplete is going to start suggesting all kinds of things that you might not want.
Dialogue: 0,0:29:55.40,0:30:02.70,中文,,0,0,0,,现在 如果你在IntelliJ中编码 IntelliJ的自动完成会开始建议各种你可能不需要的东西
Dialogue: 0,0:30:02.70,0:30:04.04,英文,,0,0,0,,It's going to say, you have a stack.
Dialogue: 0,0:30:02.70,0:30:04.04,中文,,0,0,0,,它会说 你有一个栈
Dialogue: 0,0:30:04.04,0:30:05.92,英文,,0,0,0,,You're supposed to be able to push and pop.
Dialogue: 0,0:30:04.04,0:30:05.92,中文,,0,0,0,,你应该能够进行push和pop操作
Dialogue: 0,0:30:05.92,0:30:11.24,英文,,0,0,0,,But the IntelliJ autocomplete is going to suggest all sorts of things that stacks are not supposed to have.
Dialogue: 0,0:30:05.92,0:30:11.24,中文,,0,0,0,,但IntelliJ的自动完成会建议许多栈本不该有的功能
Dialogue: 0,0:30:11.24,0:30:13.90,英文,,0,0,0,,This is just no longer a very good data structure.
Dialogue: 0,0:30:11.24,0:30:13.90,中文,,0,0,0,,这只是不再是一个很好的数据结构
Dialogue: 0,0:30:13.90,0:30:17.26,英文,,0,0,0,,So I find this kind of distasteful.
Dialogue: 0,0:30:13.90,0:30:17.26,中文,,0,0,0,,我觉得这有点不合适
Dialogue: 0,0:30:17.26,0:30:25.27,英文,,0,0,0,,And so if you're using implementation inheritance, you gotta be really careful to use is-a relationships and not has-a relationships.
Dialogue: 0,0:30:17.26,0:30:25.27,中文,,0,0,0,,如果你在使用实现继承 你必须非常小心地使用is-a关系而不是has-a关系
Dialogue: 0,0:30:25.27,0:30:26.77,英文,,0,0,0,,Okay.
Dialogue: 0,0:30:26.77,0:30:30.15,英文,,0,0,0,,So that's one danger of implementation inheritance to watch out for.
Dialogue: 0,0:30:26.77,0:30:30.15,中文,,0,0,0,,这就是实现继承的一个危险 要注意
Dialogue: 0,0:30:30.15,0:30:33.82,英文,,0,0,0,,But here's another one, and this one's also really philosophical and high-level.
Dialogue: 0,0:30:30.15,0:30:33.82,中文,,0,0,0,,但这还有另一个 而且这也是非常哲学和高层次的
Dialogue: 0,0:30:33.82,0:30:42.52,英文,,0,0,0,,And so we'll talk about an idea called encapsulation, and then we'll think about how it interacts with implementation inheritance in ways that are kind of interesting.
Dialogue: 0,0:30:33.82,0:30:42.52,中文,,0,0,0,,我们将讨论一个叫做封装的概念 然后我们将思考它与实现继承的有趣交互方式
Dialogue: 0,0:30:42.52,0:30:45.23,英文,,0,0,0,,So what the heck is encapsulation?
Dialogue: 0,0:30:42.52,0:30:45.23,中文,,0,0,0,,那么封装到底是什么呢
Dialogue: 0,0:30:45.23,0:30:55.66,英文,,0,0,0,,So to talk about encapsulation, I have to start with this little rant, which is that in 61B or in life, when you're building large programs, the enemy is not the programming language, right?
Dialogue: 0,0:30:45.23,0:30:55.66,中文,,0,0,0,,说到封装 我得先来发表一下我的看法 就是在61B或者生活中 当你在构建大型程序时 敌人不是编程语言 对吧
Dialogue: 0,0:30:55.66,0:31:01.49,英文,,0,0,0,,It's not the semicolons in Java that makes the program difficult, but it's complexity.
Dialogue: 0,0:30:55.66,0:31:01.49,中文,,0,0,0,,不是Java中的分号使程序变得复杂 而是复杂性本身
Dialogue: 0,0:31:01.49,0:31:07.34,英文,,0,0,0,,In other words, the bigger programs that you build, if you have to keep all the things in your brain at once, you're going to have a sad time.
Dialogue: 0,0:31:01.49,0:31:07.34,中文,,0,0,0,,换句话说 构建更大的程序 如果你必须一次性记住所有的事情 那你会过得很痛苦
Dialogue: 0,0:31:07.34,0:31:09.66,英文,,0,0,0,,It's just too much for a human to keep track of.
Dialogue: 0,0:31:07.34,0:31:09.66,中文,,0,0,0,,这对于一个人来说太多了 难以掌握
Dialogue: 0,0:31:09.66,0:31:19.43,英文,,0,0,0,,So in order to build large programs effectively, in order to be a good programmer, the thing we really want you to take away from this class is managing complexity.
Dialogue: 0,0:31:09.66,0:31:19.43,中文,,0,0,0,,因此 为了有效地构建大型程序 为了成为一名优秀的程序员 我们真正希望你从这门课中学到的是如何管理复杂性
Dialogue: 0,0:31:19.43,0:31:20.55,英文,,0,0,0,,How do you do it?
Dialogue: 0,0:31:19.43,0:31:20.55,中文,,0,0,0,,你该如何做呢
Dialogue: 0,0:31:20.55,0:31:23.01,英文,,0,0,0,,We've already talked about a couple big ideas.
Dialogue: 0,0:31:20.55,0:31:23.01,中文,,0,0,0,,我们已经谈论过一些重要的概念
Dialogue: 0,0:31:23.01,0:31:27.09,英文,,0,0,0,,So one we talked about was layers of abstraction.
Dialogue: 0,0:31:23.01,0:31:27.09,中文,,0,0,0,,我们谈论的一个是抽象层次
Dialogue: 0,0:31:27.09,0:31:29.09,英文,,0,0,0,,I am the person operating the car.
Dialogue: 0,0:31:27.09,0:31:29.09,中文,,0,0,0,,我是驾驶汽车的人
Dialogue: 0,0:31:29.09,0:31:32.78,英文,,0,0,0,,I do not have to worry about how the fuel goes from the tank to the engine.
Dialogue: 0,0:31:29.09,0:31:32.78,中文,,0,0,0,,我不必担心燃料是如何从油箱到引擎的
Dialogue: 0,0:31:32.78,0:31:33.92,英文,,0,0,0,,I don't care.
Dialogue: 0,0:31:32.78,0:31:33.92,中文,,0,0,0,,我不在乎
Dialogue: 0,0:31:33.92,0:31:38.08,英文,,0,0,0,,All I care about is the public methods, the pedals, the steering wheel.
Dialogue: 0,0:31:33.92,0:31:38.08,中文,,0,0,0,,我只关心公共方法 踏板和方向盘
Dialogue: 0,0:31:38.08,0:31:40.04,英文,,0,0,0,,So we talked about layers of abstraction.
Dialogue: 0,0:31:38.08,0:31:40.04,中文,,0,0,0,,我们谈论了抽象层次
Dialogue: 0,0:31:40.04,0:31:42.22,英文,,0,0,0,,We enforced these abstraction barriers.
Dialogue: 0,0:31:40.04,0:31:42.22,中文,,0,0,0,,我们强制执行了这些抽象屏障
Dialogue: 0,0:31:42.22,0:31:47.67,英文,,0,0,0,,And we said, if you want to interact with an object, you interact with the object using the public methods.
Dialogue: 0,0:31:42.22,0:31:47.67,中文,,0,0,0,,我们说 如果你想与对象交互 就使用公共方法与对象交互
Dialogue: 0,0:31:47.67,0:31:52.87,英文,,0,0,0,,And you do not care about the private way in which the implementation actually is designed.
Dialogue: 0,0:31:47.67,0:31:52.87,中文,,0,0,0,,而不必关心实现的私有方式
Dialogue: 0,0:31:52.87,0:31:55.07,英文,,0,0,0,,So we're hiding information that people don't need.
Dialogue: 0,0:31:52.87,0:31:55.07,中文,,0,0,0,,我们隐藏了人们不需要知道的信息
Dialogue: 0,0:31:55.07,0:31:56.27,英文,,0,0,0,,And that's a good thing.
Dialogue: 0,0:31:55.07,0:31:56.27,中文,,0,0,0,,这是一件好事
Dialogue: 0,0:31:56.27,0:32:00.09,英文,,0,0,0,,Because by hiding information, it makes this object easier to use.
Dialogue: 0,0:31:56.27,0:32:00.09,中文,,0,0,0,,通过隐藏信息 使得使用这个对象变得更容易
Dialogue: 0,0:32:00.09,0:32:07.92,英文,,0,0,0,,And we can build this nice modular program where we can have all these super complicated objects, but all of them have these simple ways to interact with them.
Dialogue: 0,0:32:00.09,0:32:07.92,中文,,0,0,0,,我们可以构建一个很好的模块化程序 其中包含所有这些超级复杂的对象 但它们都有这些简单的与之交互的方式
Dialogue: 0,0:32:07.92,0:32:12.50,英文,,0,0,0,,So we can use them to build big, complicated systems that interact well together.
Dialogue: 0,0:32:07.92,0:32:12.50,中文,,0,0,0,,我们可以用它们来构建大型、复杂的系统 使它们很好地相互交互
Dialogue: 0,0:32:12.50,0:32:16.02,英文,,0,0,0,,So that's like the really big theme of 61B.
Dialogue: 0,0:32:12.50,0:32:16.02,中文,,0,0,0,,这就是 61B 的一个非常重要的主题
Dialogue: 0,0:32:16.02,0:32:19.89,英文,,0,0,0,,This is how you build large programs effectively.
Dialogue: 0,0:32:16.02,0:32:19.89,中文,,0,0,0,,这是如何有效地构建大型程序的方法
Dialogue: 0,0:32:19.89,0:32:23.17,英文,,0,0,0,,How does this tie into the idea of encapsulation?
Dialogue: 0,0:32:19.89,0:32:23.17,中文,,0,0,0,,这与封装的概念有什么关联呢
Dialogue: 0,0:32:23.17,0:32:29.13,英文,,0,0,0,,Well, encapsulation is this term that says, if you have an object and the implementation is completely hidden,
Dialogue: 0,0:32:23.17,0:32:29.13,中文,,0,0,0,,封装就是说 如果你有一个对象 而且实现是完全隐藏的
Dialogue: 0,0:32:29.13,0:32:35.13,英文,,0,0,0,,that is, the only way you can interact with this object is through an interface or this set of methods that are public,
Dialogue: 0,0:32:29.13,0:32:35.13,中文,,0,0,0,,也就是说 你只能通过接口或者一组公共的方法来与这个对象交互
Dialogue: 0,0:32:35.13,0:32:40.75,英文,,0,0,0,, then we say that this module or this object is encapsulated.
Dialogue: 0,0:32:35.13,0:32:40.75,中文,,0,0,0,,那么我们就说这个模块或者这个对象是被封装的
Dialogue: 0,0:32:40.75,0:32:43.59,英文,,0,0,0,,This array deck, I have no idea what's going on inside.
Dialogue: 0,0:32:40.75,0:32:43.59,中文,,0,0,0,,这个数组 deck 我完全不知道里面发生了什么
Dialogue: 0,0:32:43.59,0:32:49.64,英文,,0,0,0,,The only ways to know or to interact with the array deck are to call addLast, removeLast, and size.
Dialogue: 0,0:32:43.59,0:32:49.64,中文,,0,0,0,,了解或者与数组 deck 交互的唯一方式就是调用 addLast、removeLast 和 size
Dialogue: 0,0:32:49.64,0:32:50.60,英文,,0,0,0,,And that's it.
Dialogue: 0,0:32:49.64,0:32:50.60,中文,,0,0,0,,就是这样
Dialogue: 0,0:32:50.60,0:32:54.29,英文,,0,0,0,,I cannot interact with the array deck in any other way, shape, or form.
Dialogue: 0,0:32:50.60,0:32:54.29,中文,,0,0,0,,我不能以任何其他方式、形式与数组堆栈交互
Dialogue: 0,0:32:54.29,0:32:56.93,英文,,0,0,0,,So the array deck is encapsulated.
Dialogue: 0,0:32:54.29,0:32:56.93,中文,,0,0,0,,数组堆栈被封装起来
Dialogue: 0,0:32:56.93,0:32:57.61,英文,,0,0,0,,And that's a good thing.
Dialogue: 0,0:32:56.93,0:32:57.61,中文,,0,0,0,,而且这是一件好事
Dialogue: 0,0:32:57.61,0:32:58.63,英文,,0,0,0,,I like that.
Dialogue: 0,0:32:57.61,0:32:58.63,中文,,0,0,0,,我喜欢这样
Dialogue: 0,0:32:58.63,0:32:59.57,英文,,0,0,0,,So.
Dialogue: 0,0:32:59.57,0:33:04.73,英文,,0,0,0,,Uh, here's an example from- if you've done Project 1A, 1B, maybe this will sound familiar.
Dialogue: 0,0:32:59.57,0:33:04.73,中文,,0,0,0,,这里有一个例子-如果你完成了1A、1B项目 也许这会听起来很熟悉
Dialogue: 0,0:33:04.73,0:33:10.36,英文,,0,0,0,,Uh, I guess it's no longer extra credit, the assignments have changed a little bit, but here are some questions that students used to ask.
Dialogue: 0,0:33:04.73,0:33:10.36,中文,,0,0,0,,我猜额外学分已经没有了 作业有点变了 但是这里有些学生以前常问的问题
Dialogue: 0,0:33:10.36,0:33:14.28,英文,,0,0,0,,So remember in- in Project 1A, 1B, you have to test your deck.
Dialogue: 0,0:33:10.36,0:33:14.28,中文,,0,0,0,,记住 在1A、1B项目中 你必须测试你的牌组
Dialogue: 0,0:33:14.28,0:33:20.66,英文,,0,0,0,,So students would ask things like, I'm trying to find a bug in the resizing method, but I don't know how to see the length of the array deck.
Dialogue: 0,0:33:14.28,0:33:20.66,中文,,0,0,0,,学生会问一些问题 比如 我试图在调整大小的方法中找到一个错误 但我不知道如何查看牌组数组的长度
Dialogue: 0,0:33:20.66,0:33:23.86,英文,,0,0,0,,I try to like call the length of the array deck, but that doesn't work.
Dialogue: 0,0:33:20.66,0:33:23.86,中文,,0,0,0,,我试着调用牌组数组的长度 但不起作用
Dialogue: 0,0:33:23.86,0:33:27.14,英文,,0,0,0,,So how do I know how big the underlying array is?
Dialogue: 0,0:33:23.86,0:33:27.14,中文,,0,0,0,,那么我怎么知道底层数组有多大呢
Dialogue: 0,0:33:27.14,0:33:35.26,英文,,0,0,0,,Or I want to test whether resizing is working, and I want to call the length of the underlying items array, but the compiler yells at me and says it's private.
Dialogue: 0,0:33:27.14,0:33:35.26,中文,,0,0,0,,或者我想测试调整大小是否有效 我想调用底层项数组的长度 但编译器对我大喊大叫说它是私有的
Dialogue: 0,0:33:35.26,0:33:37.84,英文,,0,0,0,,Is there any way around this, or should we just not test it?
Dialogue: 0,0:33:35.26,0:33:37.84,中文,,0,0,0,,有没有办法绕过这个问题 或者我们就不应该测试它
Dialogue: 0,0:33:37.84,0:33:45.19,英文,,0,0,0,,Or can I assume that the next front in the array deck is 4, the next last is 5, and the starting array is size 8?
Dialogue: 0,0:33:37.84,0:33:45.19,中文,,0,0,0,,我可以假设数组甲板中的下一个前端是4 下一个末尾是5 而起始数组的大小是8吗
Dialogue: 0,0:33:45.19,0:33:50.47,英文,,0,0,0,,So the problem with all of these questions is that they're working at the wrong level of abstraction.
Dialogue: 0,0:33:45.19,0:33:50.47,中文,,0,0,0,,所有这些问题的问题在于它们都在错误的抽象级别上运作
Dialogue: 0,0:33:50.47,0:33:52.85,英文,,0,0,0,,Remember, the ArrayDeck is encapsulated.
Dialogue: 0,0:33:50.47,0:33:52.85,中文,,0,0,0,,记住 ArrayDeque是封装的
Dialogue: 0,0:33:52.85,0:33:55.61,英文,,0,0,0,,In other words, we don't care how the insights work.
Dialogue: 0,0:33:52.85,0:33:55.61,中文,,0,0,0,,换句话说 我们不关心洞见是如何工作的
Dialogue: 0,0:33:55.61,0:34:03.78,英文,,0,0,0,,All that we care about is that when we call the methods of ArrayDeck, add first, remove first, that they behave in a way that matches our model.
Dialogue: 0,0:33:55.61,0:34:03.78,中文,,0,0,0,,我们关心的是当我们调用ArrayDeque的方法时 比如add first、remove first 它们的行为是否与我们的模型相匹配
Dialogue: 0,0:34:03.78,0:34:10.84,英文,,0,0,0,,So When you're trying to test the private methods and look inside to see what's going on, you're kind of working at the wrong level of abstraction.
Dialogue: 0,0:34:03.78,0:34:10.84,中文,,0,0,0,, 当你试图测试私有方法并查看内部发生了什么时 你有点在错误的抽象级别上工作
Dialogue: 0,0:34:10.84,0:34:14.91,英文,,0,0,0,,So for example, when we write the autograder, we have no idea how you wrote your deck.
Dialogue: 0,0:34:10.84,0:34:14.91,中文,,0,0,0,,比如说 当我们写自动评分器时 我们完全不知道你是怎么写你的牌组的
Dialogue: 0,0:34:14.91,0:34:16.19,英文,,0,0,0,,You could have used one array.
Dialogue: 0,0:34:14.91,0:34:16.19,中文,,0,0,0,,你可能使用了一个数组
Dialogue: 0,0:34:16.19,0:34:18.35,英文,,0,0,0,,You could have used five arrays for some reason.
Dialogue: 0,0:34:16.19,0:34:18.35,中文,,0,0,0,,你可能出于某种原因使用了五个数组
Dialogue: 0,0:34:18.35,0:34:29.56,英文,,0,0,0,,But the important thing is that We just use the public methods to check whether your array deck is doing the things that it's supposed to and behaving in a way that matches what we expect.
Dialogue: 0,0:34:18.35,0:34:29.56,中文,,0,0,0,,但重要的是 我们只是使用公共方法来检查你的数组牌组是否按照预期执行 并且是否以我们期望的方式行为
Dialogue: 0,0:34:29.56,0:34:36.35,英文,,0,0,0,,So maybe to use a bit of an analogy, maybe if you go to the doctor and the doctor is trying to figure out if you're sick, well, what does the doctor do?
Dialogue: 0,0:34:29.56,0:34:36.35,中文,,0,0,0,,或许用一个类比的方式来说 如果你去看医生而医生试图弄清楚你是否生病 医生会做什么呢
Dialogue: 0,0:34:36.35,0:34:40.17,英文,,0,0,0,,The doctor tries to ask you questions like, how are you feeling?
Dialogue: 0,0:34:36.35,0:34:40.17,中文,,0,0,0,,医生会试图问你一些问题 比如 你感觉怎么样
Dialogue: 0,0:34:40.17,0:34:41.27,英文,,0,0,0,,Does anything feel weird?
Dialogue: 0,0:34:40.17,0:34:41.27,中文,,0,0,0,,有没有什么感觉奇怪的
Dialogue: 0,0:34:41.27,0:34:42.33,英文,,0,0,0,,Do you have a headache?
Dialogue: 0,0:34:41.27,0:34:42.33,中文,,0,0,0,,你头疼吗
Dialogue: 0,0:34:42.33,0:34:49.47,英文,,0,0,0,,But the doctor's not going to walk up to you and ask you, hey, can you tell me, is your heart pumping blood to your veins?
Dialogue: 0,0:34:42.33,0:34:49.47,中文,,0,0,0,,但医生不会走到你面前问你 嘿 你能告诉我 你的心脏是否在向静脉输送血液
Dialogue: 0,0:34:49.47,0:34:53.58,英文,,0,0,0,,That's working a little bit at a lower level of abstraction than you might expect.
Dialogue: 0,0:34:49.47,0:34:53.58,中文,,0,0,0,,它在一些比你预期的更低的抽象层次上运行一点点
Dialogue: 0,0:34:53.58,0:34:59.72,英文,,0,0,0,,Or the doctor can't go to you and say, well, let me just, I don't know,
Dialogue: 0,0:34:53.58,0:34:59.72,中文,,0,0,0,,或者医生不能对你说 好吧 让我看看 我不知道
Dialogue: 0,0:34:59.72,0:35:01.22,英文,,0,0,0,,Is the bone in your finger?
Dialogue: 0,0:34:59.72,0:35:01.22,中文,,0,0,0,,你手指骨头在哪里
Dialogue: 0,0:35:01.22,0:35:01.74,英文,,0,0,0,,I don't know.
Dialogue: 0,0:35:01.22,0:35:01.74,中文,,0,0,0,,我不知道
Dialogue: 0,0:35:01.74,0:35:02.72,英文,,0,0,0,,How many joints does it have?
Dialogue: 0,0:35:01.74,0:35:02.72,中文,,0,0,0,,它有多少个接口
Dialogue: 0,0:35:02.72,0:35:05.12,英文,,0,0,0,,It's working at a lower level of abstraction.
Dialogue: 0,0:35:02.72,0:35:05.12,中文,,0,0,0,,它在一个更低的抽象级别上工作
Dialogue: 0,0:35:05.12,0:35:10.41,英文,,0,0,0,,We don't really care about the insides of how the person is implemented.
Dialogue: 0,0:35:05.12,0:35:10.41,中文,,0,0,0,,我们不真的关心这个人是如何实现的
Dialogue: 0,0:35:10.41,0:35:16.05,英文,,0,0,0,,We just care about the public methods, the ways that we can interact with the person.
Dialogue: 0,0:35:10.41,0:35:16.05,中文,,0,0,0,,我们只关心公共方法 我们可以与这个人交互的方式
Dialogue: 0,0:35:16.05,0:35:18.53,英文,,0,0,0,,Sorry if that was kind of weird.
Dialogue: 0,0:35:16.05,0:35:18.53,中文,,0,0,0,,如果那有点奇怪 抱歉
Dialogue: 0,0:35:18.53,0:35:21.93,英文,,0,0,0,,Anyway, all this is to say encapsulation is a beautiful idea.
Dialogue: 0,0:35:18.53,0:35:21.93,中文,,0,0,0,,总之 所有这些都是为了说封装是一个很好的想法
Dialogue: 0,0:35:21.93,0:35:24.15,英文,,0,0,0,,I'm going to bring back this picture one more time.
Dialogue: 0,0:35:21.93,0:35:24.15,中文,,0,0,0,,我要再次拿出这张图片
Dialogue: 0,0:35:24.15,0:35:30.42,英文,,0,0,0,,And again, the idea is that if we're trying to test that your array deck works, all that we care about were the people in the cave.
Dialogue: 0,0:35:24.15,0:35:30.42,中文,,0,0,0,,而且 想法是 如果我们试图测试你的数组牌组是否有效 我们只关心洞穴里的人
Dialogue: 0,0:35:30.42,0:35:39.97,英文,,0,0,0,,All that we care about is that when we interact with these objects, like we shoot the bird or like we tickle the horse, all that we care about is that the puppet show matches what we expect.
Dialogue: 0,0:35:30.42,0:35:39.97,中文,,0,0,0,,我们关心的只是当我们与这些对象交互时 比如我们射击鸟或者我们挠马 我们关心的只是木偶戏是否符合我们的期望
Dialogue: 0,0:35:39.97,0:35:46.09,英文,,0,0,0,,And we could, we could like climb over the wall and start asking the monks questions, but that's breaking the abstraction barrier.
Dialogue: 0,0:35:39.97,0:35:46.09,中文,,0,0,0,,我们可以 我们可以像爬过墙开始问僧侣问题 但那就是突破了抽象屏障
Dialogue: 0,0:35:46.09,0:35:47.37,英文,,0,0,0,,We don't want to do that.
Dialogue: 0,0:35:46.09,0:35:47.37,中文,,0,0,0,,我们不想这样做
Dialogue: 0,0:35:47.37,0:35:49.91,英文,,0,0,0,,We want this class to be encapsulated.
Dialogue: 0,0:35:47.37,0:35:49.91,中文,,0,0,0,,我们希望这个类被封装起来
Dialogue: 0,0:35:49.91,0:35:51.05,英文,,0,0,0,,That's the idea.
Dialogue: 0,0:35:49.91,0:35:51.05,中文,,0,0,0,,这就是想法
Dialogue: 0,0:35:51.05,0:35:58.64,英文,,0,0,0,,And this is also why Java is such a great language for a class like 61B, because you can use encapsulation in a class or in a language like Python.
Dialogue: 0,0:35:51.05,0:35:58.64,中文,,0,0,0,,这也是为什么Java对于像61B这样的课程是一个很好的语言 因为你可以在类中或者像Python这样的语言中使用封装
Dialogue: 0,0:35:58.64,0:36:08.14,英文,,0,0,0,,But the great thing about Java is that Java just gives encapsulation more teeth, because if you use encapsulation in Java, well, Java has that private keyword, and the private keyword
Dialogue: 0,0:35:58.64,0:36:08.14,中文,,0,0,0,,但 Java 的一个很棒的地方在于它使封装更加严密 因为如果你在 Java 中使用封装 Java 有那个 private 关键字 而 private 关键字
Dialogue: 0,0:36:08.14,0:36:10.79,英文,,0,0,0,,enforces that this wall is absolute.
Dialogue: 0,0:36:08.14,0:36:10.79,中文,,0,0,0,,强制这个隔离是绝对的
Dialogue: 0,0:36:10.79,0:36:15.12,英文,,0,0,0,,If you declare a variable private, you cannot access it, and that's a beautiful thing.
Dialogue: 0,0:36:10.79,0:36:15.12,中文,,0,0,0,,如果你声明一个变量为 private 你就无法访问它 这是一件美好的事情
Dialogue: 0,0:36:15.12,0:36:19.82,英文,,0,0,0,,It means that when someone's trying to use your array deck, they only have to worry about these methods.
Dialogue: 0,0:36:15.12,0:36:19.82,中文,,0,0,0,,这意味着当有人试图使用你的数组时 他们只需要关心这些方法
Dialogue: 0,0:36:19.82,0:36:21.05,英文,,0,0,0,,It's great.
Dialogue: 0,0:36:19.82,0:36:21.05,中文,,0,0,0,,这很棒
Dialogue: 0,0:36:21.05,0:36:23.27,英文,,0,0,0,,OK, so why am I telling you this?
Dialogue: 0,0:36:21.05,0:36:23.27,中文,,0,0,0,,那么我为什么告诉你这个呢
Dialogue: 0,0:36:23.27,0:36:25.58,英文,,0,0,0,,Well, we talked about encapsulation.
Dialogue: 0,0:36:23.27,0:36:25.58,中文,,0,0,0,,我们谈论了封装
Dialogue: 0,0:36:25.58,0:36:26.42,英文,,0,0,0,,It's great.
Dialogue: 0,0:36:25.58,0:36:26.42,中文,,0,0,0,,这太棒了
Dialogue: 0,0:36:26.42,0:36:31.32,英文,,0,0,0,,The private keyword allows encapsulation to really be enforced by the compiler.
Dialogue: 0,0:36:26.42,0:36:31.32,中文,,0,0,0,,private关键字允许封装真正地被编译器强制执行
Dialogue: 0,0:36:31.32,0:36:34.22,英文,,0,0,0,,But how does this play with implementation inheritance?
Dialogue: 0,0:36:31.32,0:36:34.22,中文,,0,0,0,,但是这如何与实现继承配合
Dialogue: 0,0:36:34.22,0:36:35.92,英文,,0,0,0,,How do these two things interact?
Dialogue: 0,0:36:34.22,0:36:35.92,中文,,0,0,0,,这两件事情如何互相作用
Dialogue: 0,0:36:35.92,0:36:38.60,英文,,0,0,0,,So to demo this, I'll give you a little example.
Dialogue: 0,0:36:35.92,0:36:38.60,中文,,0,0,0,,为了演示这一点 我会给你一个小例子
Dialogue: 0,0:36:38.60,0:36:41.04,英文,,0,0,0,,For example, this is the dog class.
Dialogue: 0,0:36:38.60,0:36:41.04,中文,,0,0,0,,例如 这是狗类
Dialogue: 0,0:36:41.04,0:36:42.72,英文,,0,0,0,,So maybe someone has implemented this.
Dialogue: 0,0:36:41.04,0:36:42.72,中文,,0,0,0,,也许有人已经实现了这个
Dialogue: 0,0:36:42.72,0:36:43.88,英文,,0,0,0,,There's a bark method.
Dialogue: 0,0:36:42.72,0:36:43.88,中文,,0,0,0,,有一个 bark 方法
Dialogue: 0,0:36:43.88,0:36:45.56,英文,,0,0,0,,There's a bark many method.
Dialogue: 0,0:36:43.88,0:36:45.56,中文,,0,0,0,,有一个 bark 多方法
Dialogue: 0,0:36:45.56,0:36:48.15,英文,,0,0,0,,OK, so the bark method calls bark.
Dialogue: 0,0:36:45.56,0:36:48.15,中文,,0,0,0,, bark 方法调用 bark
Dialogue: 0,0:36:48.15,0:36:53.63,英文,,0,0,0,,And the bark many method, depending on the end that the user passes in, calls bark multiple times.
Dialogue: 0,0:36:48.15,0:36:53.63,中文,,0,0,0,,而 bark 多方法根据用户传入的参数 调用多次 bark
Dialogue: 0,0:36:53.63,0:36:54.59,英文,,0,0,0,,OK, great.
Dialogue: 0,0:36:53.63,0:36:54.59,中文,,0,0,0,,很棒
Dialogue: 0,0:36:54.59,0:36:58.90,英文,,0,0,0,,But what if the person implementing dog decided to switch these around?
Dialogue: 0,0:36:54.59,0:36:58.90,中文,,0,0,0,,但是如果实现 dog 的人决定交换它们怎么办
Dialogue: 0,0:36:58.90,0:37:01.88,英文,,0,0,0,,They said, actually, I like the idea that bark is over here.
Dialogue: 0,0:36:58.90,0:37:01.88,中文,,0,0,0,,他们说 实际上 我喜欢 bark 在这边的想法
Dialogue: 0,0:37:01.88,0:37:05.29,英文,,0,0,0,,And when you call bark, you should just call bark many one.
Dialogue: 0,0:37:01.88,0:37:05.29,中文,,0,0,0,,当你调用 bark 时 应该只调用 bark 很多次
Dialogue: 0,0:37:05.29,0:37:07.47,英文,,0,0,0,,This works exactly the same, right?
Dialogue: 0,0:37:05.29,0:37:07.47,中文,,0,0,0,,这完全一样 对吧
Dialogue: 0,0:37:07.47,0:37:08.65,英文,,0,0,0,,It's the same.
Dialogue: 0,0:37:07.47,0:37:08.65,中文,,0,0,0,,就是这样
Dialogue: 0,0:37:08.65,0:37:11.95,英文,,0,0,0,,Anytime you call Bark or BarkMany, you should get the same behavior.
Dialogue: 0,0:37:08.65,0:37:11.95,中文,,0,0,0,,每次你调用 bark 或 barkMany 时 应该得到相同的行为
Dialogue: 0,0:37:11.95,0:37:20.34,英文,,0,0,0,,Someone using your code should never, ever be able to look inside and look at your implementation, because this dog class should be encapsulated.
Dialogue: 0,0:37:11.95,0:37:20.34,中文,,0,0,0,,使用你的代码的人绝对不能看到里面的实现 因为这个 dog 类应该是封装的
Dialogue: 0,0:37:20.34,0:37:24.76,英文,,0,0,0,,They should just be able to call Bark and BarkMany, and things should work the same.
Dialogue: 0,0:37:20.34,0:37:24.76,中文,,0,0,0,,他们只需要调用 bark 和 barkMany 然后事情就应该一样
Dialogue: 0,0:37:24.76,0:37:27.37,英文,,0,0,0,,But here comes the puzzle.
Dialogue: 0,0:37:24.76,0:37:27.37,中文,,0,0,0,,但是这里有个难题
Dialogue: 0,0:37:27.37,0:37:31.86,英文,,0,0,0,,So suppose I have Another class called VerboseDog.
Dialogue: 0,0:37:27.37,0:37:31.86,中文,,0,0,0,,假设我有另一个名为 VerboseDog 的类
Dialogue: 0,0:37:31.86,0:37:34.48,英文,,0,0,0,,This is a subclass of the dog.
Dialogue: 0,0:37:31.86,0:37:34.48,中文,,0,0,0,,这是 Dog 类的一个子类
Dialogue: 0,0:37:34.48,0:37:36.80,英文,,0,0,0,,And in this subclass, I don't overwrite Bark.
Dialogue: 0,0:37:34.48,0:37:36.80,中文,,0,0,0,,在这个子类中 我不覆盖 bark 方法
Dialogue: 0,0:37:36.80,0:37:41.01,英文,,0,0,0,,So I keep the same implementation of Bark that is inherited from the parent.
Dialogue: 0,0:37:36.80,0:37:41.01,中文,,0,0,0,,因此 我保留从父类继承的相同 bark 方法的实现
Dialogue: 0,0:37:41.01,0:37:44.09,英文,,0,0,0,,However, I'm going to overwrite the BarkMany method.
Dialogue: 0,0:37:41.01,0:37:44.09,中文,,0,0,0,,然而 我将重写 barkMany 方法
Dialogue: 0,0:37:44.09,0:37:49.15,英文,,0,0,0,,And my VerboseDog will say, as a dog, I say, and then it'll call the Bark method.
Dialogue: 0,0:37:44.09,0:37:49.15,中文,,0,0,0,,我的 VerboseDog 会说 作为一只狗 我说 然后它会调用 bark 方法
Dialogue: 0,0:37:49.15,0:37:50.11,英文,,0,0,0,,OK.
Dialogue: 0,0:37:50.11,0:37:54.31,英文,,0,0,0,,So suppose I have a verbose dog and I call barkMany of 3.
Dialogue: 0,0:37:50.11,0:37:54.31,中文,,0,0,0,,假设我有一只多嘴的狗 然后我调用 barkMany 三次
Dialogue: 0,0:37:54.31,0:37:55.99,英文,,0,0,0,,What is this going to output?
Dialogue: 0,0:37:54.31,0:37:55.99,中文,,0,0,0,,这会输出什么
Dialogue: 0,0:37:55.99,0:37:59.14,英文,,0,0,0,,Well, to solve this, I'm going to have to turn to dynamic method selection.
Dialogue: 0,0:37:55.99,0:37:59.14,中文,,0,0,0,,要解决这个问题 我需要转向动态方法选择
Dialogue: 0,0:37:59.14,0:38:00.46,英文,,0,0,0,,Remember from last time?
Dialogue: 0,0:37:59.14,0:38:00.46,中文,,0,0,0,,还记得上次吗
Dialogue: 0,0:38:00.46,0:38:02.46,英文,,0,0,0,,I have to think, a verbose dog.
Dialogue: 0,0:38:00.46,0:38:02.46,中文,,0,0,0,,我得想想 一只多嘴的狗
Dialogue: 0,0:38:02.46,0:38:04.36,英文,,0,0,0,,Well, the dynamic type is verbose dog.
Dialogue: 0,0:38:02.46,0:38:04.36,中文,,0,0,0,,动态类型就是多嘴的狗
Dialogue: 0,0:38:04.36,0:38:06.36,英文,,0,0,0,,It's actually a verbose dog.
Dialogue: 0,0:38:04.36,0:38:06.36,中文,,0,0,0,,其实是一只啰嗦的狗
Dialogue: 0,0:38:06.36,0:38:13.62,英文,,0,0,0,,So I'm going to call the overridden method in the dynamic classes, the dynamic types class.
Dialogue: 0,0:38:06.36,0:38:13.62,中文,,0,0,0,,我要在动态类中调用重写的方法 动态类型类
Dialogue: 0,0:38:13.62,0:38:15.42,英文,,0,0,0,,So VD is a verbose dog.
Dialogue: 0,0:38:13.62,0:38:15.42,中文,,0,0,0,,VD是一只啰嗦的狗
Dialogue: 0,0:38:15.42,0:38:16.80,英文,,0,0,0,,That's its dynamic type.
Dialogue: 0,0:38:15.42,0:38:16.80,中文,,0,0,0,,这是它的动态类型
Dialogue: 0,0:38:16.80,0:38:20.32,英文,,0,0,0,,So I look in the dynamic types class verboseDog for a BarkMany.
Dialogue: 0,0:38:16.80,0:38:20.32,中文,,0,0,0,,我在动态类型类verboseDog中寻找barkMany
Dialogue: 0,0:38:20.32,0:38:21.04,英文,,0,0,0,,I find one.
Dialogue: 0,0:38:20.32,0:38:21.04,中文,,0,0,0,,我找到了一个
Dialogue: 0,0:38:21.04,0:38:22.10,英文,,0,0,0,,It's overridden.
Dialogue: 0,0:38:21.04,0:38:22.10,中文,,0,0,0,,它被重写了
Dialogue: 0,0:38:22.10,0:38:26.63,英文,,0,0,0,,So I'm going to say, as a dog, I say, then I'm going to call bark.
Dialogue: 0,0:38:22.10,0:38:26.63,中文,,0,0,0,,我要说 作为一只狗 我说 然后我要叫bark
Dialogue: 0,0:38:26.63,0:38:28.15,英文,,0,0,0,,So I'm a verboseDog object.
Dialogue: 0,0:38:26.63,0:38:28.15,中文,,0,0,0,,我是一个verboseDog对象
Dialogue: 0,0:38:28.15,0:38:29.23,英文,,0,0,0,,I call bark.
Dialogue: 0,0:38:28.15,0:38:29.23,中文,,0,0,0,,我调用bark
Dialogue: 0,0:38:29.23,0:38:30.91,英文,,0,0,0,,And I look in the verboseDog class.
Dialogue: 0,0:38:29.23,0:38:30.91,中文,,0,0,0,,然后我看看verboseDog类
Dialogue: 0,0:38:30.91,0:38:32.45,英文,,0,0,0,,Look, there's no bark.
Dialogue: 0,0:38:30.91,0:38:32.45,中文,,0,0,0,,看 这里没有bark
Dialogue: 0,0:38:32.45,0:38:34.63,英文,,0,0,0,,That means I'm going to use the inherited version from dog.
Dialogue: 0,0:38:32.45,0:38:34.63,中文,,0,0,0,,这意味着我要使用从dog继承的版本
Dialogue: 0,0:38:34.63,0:38:37.63,英文,,0,0,0,,So I'm going to go up here, and I'm going to call this bark.
Dialogue: 0,0:38:34.63,0:38:37.63,中文,,0,0,0,,我要上去 然后我要调用这个bark
Dialogue: 0,0:38:37.63,0:38:42.06,英文,,0,0,0,,So the output will be, as a dog, I say, bark, bark, bark.
Dialogue: 0,0:38:37.63,0:38:42.06,中文,,0,0,0,,输出会是 作为一只狗 我说 汪汪汪
Dialogue: 0,0:38:42.06,0:38:44.20,英文,,0,0,0,,OK, great.
Dialogue: 0,0:38:42.06,0:38:44.20,中文,,0,0,0,,太棒了
Dialogue: 0,0:38:44.20,0:38:45.36,英文,,0,0,0,,Now here comes the twist ending.
Dialogue: 0,0:38:44.20,0:38:45.36,中文,,0,0,0,,现在到了反转结局的时候
Dialogue: 0,0:38:45.36,0:38:46.30,英文,,0,0,0,,I hope you're ready.
Dialogue: 0,0:38:45.36,0:38:46.30,中文,,0,0,0,,希望你已经准备好了
Dialogue: 0,0:38:46.30,0:38:52.76,英文,,0,0,0,,So remember, we said that this code and this code should be functionally the same.
Dialogue: 0,0:38:46.30,0:38:52.76,中文,,0,0,0,,记住 我们说这段代码和这段代码在功能上应该是相同的
Dialogue: 0,0:38:52.76,0:38:57.49,英文,,0,0,0,,So whoever's maintaining Dog, the CEO of Dog, they could go inside, and they could say, you know what?
Dialogue: 0,0:38:52.76,0:38:57.49,中文,,0,0,0,,谁在维护狗 狗的CEO 他们可以进去 然后他们可以说 你知道吗
Dialogue: 0,0:38:57.49,0:38:59.07,英文,,0,0,0,,I like this version better.
Dialogue: 0,0:38:57.49,0:38:59.07,中文,,0,0,0,,我更喜欢这个版本
Dialogue: 0,0:38:59.07,0:39:08.06,英文,,0,0,0,,And remember, the idea behind encapsulation should be that nobody should ever, ever, ever be able to look inside the Dog class and care about its internal implementation.
Dialogue: 0,0:38:59.07,0:39:08.06,中文,,0,0,0,,记住 封装背后的理念应该是 任何人都不应该能够查看 Dog 类的内部实现并关心它的内部实现
Dialogue: 0,0:39:08.06,0:39:11.22,英文,,0,0,0,,They should just be able to interact using the interface.
Dialogue: 0,0:39:08.06,0:39:11.22,中文,,0,0,0,,他们只需要能够使用接口进行交互
Dialogue: 0,0:39:11.22,0:39:18.21,英文,,0,0,0,,So someone changing their private implementation of Dog should not affect outside users of the Dog class.
Dialogue: 0,0:39:11.22,0:39:18.21,中文,,0,0,0,,改变 Dog 的私有实现不应该影响 Dog 类的外部用户
Dialogue: 0,0:39:18.21,0:39:22.77,英文,,0,0,0,,But maybe, just maybe in this case, something weird happens.
Dialogue: 0,0:39:18.21,0:39:22.77,中文,,0,0,0,,但也许 在这种情况下 会发生一些奇怪的事情
Dialogue: 0,0:39:22.77,0:39:24.01,英文,,0,0,0,,So let's try it.
Dialogue: 0,0:39:22.77,0:39:24.01,中文,,0,0,0,,让我们试试吧
Dialogue: 0,0:39:24.01,0:39:25.97,英文,,0,0,0,,I call barkMany.
Dialogue: 0,0:39:24.01,0:39:25.97,中文,,0,0,0,,我调用 barkMany
Dialogue: 0,0:39:25.97,0:39:27.17,英文,,0,0,0,,on a verbose dog.
Dialogue: 0,0:39:25.97,0:39:27.17,中文,,0,0,0,,在一个冗长的狗上
Dialogue: 0,0:39:27.17,0:39:29.47,英文,,0,0,0,,The dynamic type is verbose dog.
Dialogue: 0,0:39:27.17,0:39:29.47,中文,,0,0,0,,动态类型是冗长的狗
Dialogue: 0,0:39:29.47,0:39:31.54,英文,,0,0,0,,So I go into the verbose dog class.
Dialogue: 0,0:39:29.47,0:39:31.54,中文,,0,0,0,,我进入了冗长的狗类
Dialogue: 0,0:39:31.54,0:39:33.10,英文,,0,0,0,,I look for the bark many method.
Dialogue: 0,0:39:31.54,0:39:33.10,中文,,0,0,0,,我寻找多种方法的吠声
Dialogue: 0,0:39:33.10,0:39:34.76,英文,,0,0,0,,I find an overridden method.
Dialogue: 0,0:39:33.10,0:39:34.76,中文,,0,0,0,,我找到了一个重写的方法
Dialogue: 0,0:39:34.76,0:39:39.06,英文,,0,0,0,,So I say, as a dog, I say, OK, now it's time to call bark.
Dialogue: 0,0:39:34.76,0:39:39.06,中文,,0,0,0,,我说 作为一只狗 我说 现在是叫吠声的时候了
Dialogue: 0,0:39:39.06,0:39:41.56,英文,,0,0,0,,So I go to the verbose dog method.
Dialogue: 0,0:39:39.06,0:39:41.56,中文,,0,0,0,,我去了冗长的狗方法
Dialogue: 0,0:39:41.56,0:39:45.69,英文,,0,0,0,,And I look inside the VerboseDog class, sorry, for a bark method.
Dialogue: 0,0:39:41.56,0:39:45.69,中文,,0,0,0,,然后我查看VerboseDog类内部 抱歉 寻找吠叫方法
Dialogue: 0,0:39:45.69,0:39:46.41,英文,,0,0,0,,And I don't find one.
Dialogue: 0,0:39:45.69,0:39:46.41,中文,,0,0,0,,然后我找不到一个
Dialogue: 0,0:39:46.41,0:39:47.95,英文,,0,0,0,,So I go to the parent class.
Dialogue: 0,0:39:46.41,0:39:47.95,中文,,0,0,0,,我去到父类
Dialogue: 0,0:39:47.95,0:39:49.45,英文,,0,0,0,,I look at its bark method.
Dialogue: 0,0:39:47.95,0:39:49.45,中文,,0,0,0,,我查看它的bark方法
Dialogue: 0,0:39:49.45,0:39:51.31,英文,,0,0,0,,And I find BarkMany of 1.
Dialogue: 0,0:39:49.45,0:39:51.31,中文,,0,0,0,,我发现barkMany的数量为1
Dialogue: 0,0:39:51.31,0:39:52.39,英文,,0,0,0,,So what do I do?
Dialogue: 0,0:39:51.31,0:39:52.39,中文,,0,0,0,,那我该怎么办呢
Dialogue: 0,0:39:52.39,0:39:54.12,英文,,0,0,0,,I go to the VerboseDog class.
Dialogue: 0,0:39:52.39,0:39:54.12,中文,,0,0,0,,我去VerboseDog类
Dialogue: 0,0:39:54.12,0:39:55.64,英文,,0,0,0,,I look for the BarkMany method.
Dialogue: 0,0:39:54.12,0:39:55.64,中文,,0,0,0,,我寻找barkMany方法
Dialogue: 0,0:39:55.64,0:39:56.76,英文,,0,0,0,,So I come down here.
Dialogue: 0,0:39:55.64,0:39:56.76,中文,,0,0,0,,我下来了
Dialogue: 0,0:39:56.76,0:39:58.06,英文,,0,0,0,,BarkMany of 1.
Dialogue: 0,0:39:56.76,0:39:58.06,中文,,0,0,0,,barkMany(1)
Dialogue: 0,0:39:58.06,0:39:59.54,英文,,0,0,0,,As a dog, I say.
Dialogue: 0,0:39:58.06,0:39:59.54,中文,,0,0,0,,作为一只狗 我说
Dialogue: 0,0:39:59.54,0:40:00.64,英文,,0,0,0,,OK, time to call Bark.
Dialogue: 0,0:39:59.54,0:40:00.64,中文,,0,0,0,,是时候叫 bark 了
Dialogue: 0,0:40:00.64,0:40:01.52,英文,,0,0,0,,What do I do?
Dialogue: 0,0:40:00.64,0:40:01.52,中文,,0,0,0,,我该怎么办
Dialogue: 0,0:40:01.52,0:40:03.42,英文,,0,0,0,,VerboseDog, there's no Bark.
Dialogue: 0,0:40:01.52,0:40:03.42,中文,,0,0,0,,VerboseDog 没有 bark
Dialogue: 0,0:40:03.42,0:40:05.79,英文,,0,0,0,,So I'll go to the parent class, BarkMany.
Dialogue: 0,0:40:03.42,0:40:05.79,中文,,0,0,0,,我会去父类 barkMany
Dialogue: 0,0:40:05.79,0:40:06.59,英文,,0,0,0,,OK, great.
Dialogue: 0,0:40:05.79,0:40:06.59,中文,,0,0,0,,太好了
Dialogue: 0,0:40:06.59,0:40:12.59,英文,,0,0,0,,VerboseDog, BarkMany, then I call Bark, which calls BarkMany, which calls Bark, which calls BarkMany.
Dialogue: 0,0:40:06.59,0:40:12.59,中文,,0,0,0,,详细狗 多吠几声 然后我调用吠声 它调用多吠几声 再调用吠声 吠声调用多吠几声
Dialogue: 0,0:40:12.59,0:40:15.75,英文,,0,0,0,,And suddenly, I get caught in an infinite loop.
Dialogue: 0,0:40:12.59,0:40:15.75,中文,,0,0,0,,突然间 我陷入了一个无限循环
Dialogue: 0,0:40:15.75,0:40:17.27,英文,,0,0,0,,So what just happened?
Dialogue: 0,0:40:15.75,0:40:17.27,中文,,0,0,0,,那刚刚发生了什么
Dialogue: 0,0:40:17.27,0:40:19.40,英文,,0,0,0,,Maybe this code didn't totally make sense.
Dialogue: 0,0:40:17.27,0:40:19.40,中文,,0,0,0,,也许这段代码并不完全有意义
Dialogue: 0,0:40:19.40,0:40:23.22,英文,,0,0,0,,But the takeaway, the moral of the story is,
Dialogue: 0,0:40:19.40,0:40:23.22,中文,,0,0,0,,但是故事的寓意是
Dialogue: 0,0:40:23.22,0:40:26.80,英文,,0,0,0,,Sorry, implementation inheritance broke encapsulation.
Dialogue: 0,0:40:23.22,0:40:26.80,中文,,0,0,0,,抱歉 实现继承破坏了封装
Dialogue: 0,0:40:26.80,0:40:29.63,英文,,0,0,0,,This dog class was supposed to be beautifully encapsulated.
Dialogue: 0,0:40:26.80,0:40:29.63,中文,,0,0,0,,这个狗类应该是被精美地封装起来的
Dialogue: 0,0:40:29.63,0:40:35.81,英文,,0,0,0,,Nobody could ever, ever, ever look inside and care about how the dog implementers wrote their code.
Dialogue: 0,0:40:29.63,0:40:35.81,中文,,0,0,0,,没人会看到里面 并在意狗实现者写的代码
Dialogue: 0,0:40:35.81,0:40:39.12,英文,,0,0,0,,But in this case, with implementation inheritance,
Dialogue: 0,0:40:35.81,0:40:39.12,中文,,0,0,0,,但在这种情况下 有了实现继承
Dialogue: 0,0:40:39.12,0:40:51.84,英文,,0,0,0,,Somebody inside the encapsulated dog method changed the way that they wrote their code, and it should not have affected anything, but suddenly, kapow, everything has gone broken, even though this dog class was supposed to be encapsulated.
Dialogue: 0,0:40:39.12,0:40:51.84,中文,,0,0,0,,封装的狗方法里的某人改变了他们写代码的方式 不应该影响任何东西 但突然间 嘭 一切都崩溃了 尽管这个狗类应该被封装起来
Dialogue: 0,0:40:51.84,0:40:59.00,英文,,0,0,0,,So, implementation inheritance broke encapsulation, nobody was supposed to look inside the dog class, but suddenly,
Dialogue: 0,0:40:51.84,0:40:59.00,中文,,0,0,0,,实现继承破坏了封装 本来没人应该看到狗类的内部 但突然间
Dialogue: 0,0:40:59.00,0:41:00.14,英文,,0,0,0,,looks like you can.
Dialogue: 0,0:40:59.00,0:41:00.14,中文,,0,0,0,,看起来你可以
Dialogue: 0,0:41:00.14,0:41:07.25,英文,,0,0,0,,So yeah, this example is a little bit weird, but the fact that it's even possible just makes implementation inheritance feel a little weird.
Dialogue: 0,0:41:00.14,0:41:07.25,中文,,0,0,0,,是的 这个例子有点奇怪 但事实上 它甚至可能性就让实现继承感觉有点奇怪
Dialogue: 0,0:41:07.25,0:41:09.29,英文,,0,0,0,,So how do you feel about it?
Dialogue: 0,0:41:07.25,0:41:09.29,中文,,0,0,0,,你对此有何感想
Dialogue: 0,0:41:09.29,0:41:16.31,英文,,0,0,0,,You'll have to go try it out yourself and let me know what you think, but those are some possible dangers of implementation inheritance.
Dialogue: 0,0:41:09.29,0:41:16.31,中文,,0,0,0,,你得亲自试试 然后告诉我你的想法 不过实现继承可能有一些风险
Dialogue: 0,0:41:16.31,0:41:19.89,英文,,0,0,0,,Okay, I have one more thing to show you and then we're out of here.
Dialogue: 0,0:41:16.31,0:41:19.89,中文,,0,0,0,,我还有一件事要展示 然后我们就可以离开了
Dialogue: 0,0:41:19.89,0:41:22.73,英文,,0,0,0,,To set the stage, I have a little puzzle for you.
Dialogue: 0,0:41:19.89,0:41:22.73,中文,,0,0,0,,为了开始 我有个小谜题给你
Dialogue: 0,0:41:22.73,0:41:25.09,英文,,0,0,0,,I'm not going to give you tons of time to solve it.
Dialogue: 0,0:41:22.73,0:41:25.09,中文,,0,0,0,,我不会给你太多时间来解决它
Dialogue: 0,0:41:25.09,0:41:28.06,英文,,0,0,0,,But basically, the idea is we're going to run through this code.
Dialogue: 0,0:41:25.09,0:41:28.06,中文,,0,0,0,,但基本上 我们的想法是要运行这段代码
Dialogue: 0,0:41:28.06,0:41:32.10,英文,,0,0,0,,And whenever we're running through code, it often helps to make two passes.
Dialogue: 0,0:41:28.06,0:41:32.10,中文,,0,0,0,,而且 当我们运行代码时 通常有助于进行两次检查
Dialogue: 0,0:41:32.10,0:41:33.32,英文,,0,0,0,,Why two?
Dialogue: 0,0:41:32.10,0:41:33.32,中文,,0,0,0,,为什么是两个
Dialogue: 0,0:41:33.32,0:41:36.34,英文,,0,0,0,,Because remember that every variable has a static type.
Dialogue: 0,0:41:33.32,0:41:36.34,中文,,0,0,0,,因为要记住每个变量都有一个静态类型
Dialogue: 0,0:41:36.34,0:41:38.10,英文,,0,0,0,,That's what the compiler is thinking.
Dialogue: 0,0:41:36.34,0:41:38.10,中文,,0,0,0,,这就是编译器在想什么
Dialogue: 0,0:41:38.10,0:41:39.24,英文,,0,0,0,,And a dynamic type.
Dialogue: 0,0:41:38.10,0:41:39.24,中文,,0,0,0,,还有一个动态类型
Dialogue: 0,0:41:39.24,0:41:42.18,英文,,0,0,0,,And that's what the runtime is thinking.
Dialogue: 0,0:41:39.24,0:41:42.18,中文,,0,0,0,,这就是运行时在想什么
Dialogue: 0,0:41:42.18,0:41:48.63,英文,,0,0,0,,So when I compile the program, when I'm checking all the types to make sure they match, I use the static type, the compile time type.
Dialogue: 0,0:41:42.18,0:41:48.63,中文,,0,0,0,,当我编译程序时 当我检查所有类型以确保它们匹配时 我使用静态类型 编译时类型
Dialogue: 0,0:41:48.63,0:41:51.09,英文,,0,0,0,,And that's the type of variable at declaration.
Dialogue: 0,0:41:48.63,0:41:51.09,中文,,0,0,0,,这就是声明时变量的类型
Dialogue: 0,0:41:51.09,0:41:55.45,英文,,0,0,0,,When I declare there is a variable, I use the static type to check.
Dialogue: 0,0:41:51.09,0:41:55.45,中文,,0,0,0,,当我声明有一个变量时 我使用静态类型来检查
Dialogue: 0,0:41:55.45,0:41:56.65,英文,,0,0,0,,That's the static type.
Dialogue: 0,0:41:55.45,0:41:56.65,中文,,0,0,0,,就是静态类型
Dialogue: 0,0:41:56.65,0:42:00.59,英文,,0,0,0,,The compiler uses the static type to check that all the types match up.
Dialogue: 0,0:41:56.65,0:42:00.59,中文,,0,0,0,,编译器使用静态类型来检查所有类型是否匹配
Dialogue: 0,0:42:00.59,0:42:02.53,英文,,0,0,0,,And if it does, I compile the program.
Dialogue: 0,0:42:00.59,0:42:02.53,中文,,0,0,0,,如果匹配 我就编译程序
Dialogue: 0,0:42:02.53,0:42:06.76,英文,,0,0,0,,Otherwise, the compiler errors and says, no, I refuse to compile your program.
Dialogue: 0,0:42:02.53,0:42:06.76,中文,,0,0,0,,否则 编译器会报错 说 不 我拒绝编译你的程序
Dialogue: 0,0:42:06.76,0:42:09.30,英文,,0,0,0,,And then after the program compiles,
Dialogue: 0,0:42:06.76,0:42:09.30,中文,,0,0,0,,然后程序编译完成后
Dialogue: 0,0:42:09.30,0:42:13.50,英文,,0,0,0,,Then we use the dynamic type to actually figure out which methods to call.
Dialogue: 0,0:42:09.30,0:42:13.50,中文,,0,0,0,,然后我们使用动态类型来实际确定调用哪些方法
Dialogue: 0,0:42:13.50,0:42:16.19,英文,,0,0,0,,So we use the static types to check that everything's good.
Dialogue: 0,0:42:13.50,0:42:16.19,中文,,0,0,0,,我们使用静态类型来检查一切是否正常
Dialogue: 0,0:42:16.19,0:42:21.33,英文,,0,0,0,,Then we use the dynamic type to actually run the program and figure out which methods to call.
Dialogue: 0,0:42:16.19,0:42:21.33,中文,,0,0,0,,然后我们使用动态类型来实际运行程序并找出要调用哪些方法
Dialogue: 0,0:42:21.33,0:42:26.68,英文,,0,0,0,,So let's put on our compiler hats and let's run through this whole thing with the compiler.
Dialogue: 0,0:42:21.33,0:42:26.68,中文,,0,0,0,,那么 让我们戴上编译器的帽子 通过编译器来运行整个过程
Dialogue: 0,0:42:26.68,0:42:27.74,英文,,0,0,0,,So here we go.
Dialogue: 0,0:42:26.68,0:42:27.74,中文,,0,0,0,,那么 我们开始吧
Dialogue: 0,0:42:27.74,0:42:28.86,英文,,0,0,0,,I'll start here.
Dialogue: 0,0:42:27.74,0:42:28.86,中文,,0,0,0,,我从这里开始
Dialogue: 0,0:42:28.86,0:42:32.26,英文,,0,0,0,,I will say S1 was a SL dot add last.
Dialogue: 0,0:42:28.86,0:42:32.26,中文,,0,0,0,,我会说sl是sl.addLast的最后一个
Dialogue: 0,0:42:32.26,0:42:34.69,英文,,0,0,0,,Okay, what variable type is SL?
Dialogue: 0,0:42:32.26,0:42:34.69,中文,,0,0,0,,sl的变量类型是什么
Dialogue: 0,0:42:34.69,0:42:35.75,英文,,0,0,0,,Remember, we're the compiler.
Dialogue: 0,0:42:34.69,0:42:35.75,中文,,0,0,0,,记住 我们是编译器
Dialogue: 0,0:42:35.75,0:42:37.81,英文,,0,0,0,,We're just thinking in terms of static type.
Dialogue: 0,0:42:35.75,0:42:37.81,中文,,0,0,0,,我们只是在考虑静态类型
Dialogue: 0,0:42:37.81,0:42:41.85,英文,,0,0,0,,So I look at SL SL was declared as an S list.
Dialogue: 0,0:42:37.81,0:42:41.85,中文,,0,0,0,,我看看sl sl被声明为SLList
Dialogue: 0,0:42:41.85,0:42:42.91,英文,,0,0,0,,I'm the compiler.
Dialogue: 0,0:42:41.85,0:42:42.91,中文,,0,0,0,,我是编译器
Dialogue: 0,0:42:42.91,0:42:45.51,英文,,0,0,0,,I don't actually care what type SL is.
Dialogue: 0,0:42:42.91,0:42:45.51,中文,,0,0,0,,我实际上不关心sl是什么类型
Dialogue: 0,0:42:45.51,0:42:47.46,英文,,0,0,0,,It's declared as an SLList.
Dialogue: 0,0:42:45.51,0:42:47.46,中文,,0,0,0,,它被声明为SLList
Dialogue: 0,0:42:47.46,0:42:49.42,英文,,0,0,0,,So I will say, SL, you're an SLList.
Dialogue: 0,0:42:47.46,0:42:49.42,中文,,0,0,0,,我会说 sl 你是一个SLList
Dialogue: 0,0:42:49.42,0:42:51.60,英文,,0,0,0,,Do SLLists have addLast methods?
Dialogue: 0,0:42:49.42,0:42:51.60,中文,,0,0,0,,SLList有addLast方法吗
Dialogue: 0,0:42:51.60,0:42:53.60,英文,,0,0,0,,Can an SLList addLast?
Dialogue: 0,0:42:51.60,0:42:53.60,中文,,0,0,0,,SLList能addLast吗
Dialogue: 0,0:42:53.60,0:42:54.36,英文,,0,0,0,,Yes.
Dialogue: 0,0:42:53.60,0:42:54.36,中文,,0,0,0,,可以的
Dialogue: 0,0:42:54.36,0:42:56.43,英文,,0,0,0,,So the compiler checks and says, this is fine.
Dialogue: 0,0:42:54.36,0:42:56.43,中文,,0,0,0,,编译器检查并说 这是可以的
Dialogue: 0,0:42:56.43,0:42:57.69,英文,,0,0,0,,I will let it through.
Dialogue: 0,0:42:56.43,0:42:57.69,中文,,0,0,0,,我会让它通过
Dialogue: 0,0:42:57.69,0:42:59.17,英文,,0,0,0,,Then I go to SL again.
Dialogue: 0,0:42:57.69,0:42:59.17,中文,,0,0,0,,然后我再次去sl
Dialogue: 0,0:42:59.17,0:43:01.35,英文,,0,0,0,,It has static type SLList.
Dialogue: 0,0:42:59.17,0:43:01.35,中文,,0,0,0,,它的静态类型是SLList
Dialogue: 0,0:43:01.35,0:43:02.51,英文,,0,0,0,,Can it removeLast?
Dialogue: 0,0:43:01.35,0:43:02.51,中文,,0,0,0,,它能removeLast吗?
Dialogue: 0,0:43:02.51,0:43:03.17,英文,,0,0,0,,Yes.
Dialogue: 0,0:43:02.51,0:43:03.17,中文,,0,0,0,,可以
Dialogue: 0,0:43:03.17,0:43:05.12,英文,,0,0,0,,So the compiler lets this through.
Dialogue: 0,0:43:03.17,0:43:05.12,中文,,0,0,0,,编译器允许这个通过
Dialogue: 0,0:43:05.12,0:43:06.72,英文,,0,0,0,,And here comes the twist ending.
Dialogue: 0,0:43:05.12,0:43:06.72,中文,,0,0,0,,然后这里就是反转结局了
Dialogue: 0,0:43:06.72,0:43:08.02,英文,,0,0,0,,SL, it is an SLList.
Dialogue: 0,0:43:06.72,0:43:08.02,中文,,0,0,0,,sl 它是一个SLList
Dialogue: 0,0:43:08.02,0:43:09.26,英文,,0,0,0,,That's the static type.
Dialogue: 0,0:43:08.02,0:43:09.26,中文,,0,0,0,,那是静态类型
Dialogue: 0,0:43:09.26,0:43:11.54,英文,,0,0,0,,Can an SLList print lost items?
Dialogue: 0,0:43:09.26,0:43:11.54,中文,,0,0,0,,SLList可以打印丢失的项目吗
Dialogue: 0,0:43:11.54,0:43:14.42,英文,,0,0,0,,Well, sometimes, but not always.
Dialogue: 0,0:43:11.54,0:43:14.42,中文,,0,0,0,,有时候 但并不总是
Dialogue: 0,0:43:14.42,0:43:17.36,英文,,0,0,0,,Some SLLists can print lost items, the vengeful ones.
Dialogue: 0,0:43:14.42,0:43:17.36,中文,,0,0,0,,一些 SLList 可以打印丢失的项目 那些怀恨的
Dialogue: 0,0:43:17.36,0:43:18.73,英文,,0,0,0,,Some SLLists, they're not vengeful.
Dialogue: 0,0:43:17.36,0:43:18.73,中文,,0,0,0,,有些 SLList 它们不是怀恨的
Dialogue: 0,0:43:18.73,0:43:20.81,英文,,0,0,0,,They're peaceful, and they don't print the lost items.
Dialogue: 0,0:43:18.73,0:43:20.81,中文,,0,0,0,,它们很和平 而且不打印丢失的项目
Dialogue: 0,0:43:20.81,0:43:23.59,英文,,0,0,0,,Some SLLists are like rotating, and they don't print lost items.
Dialogue: 0,0:43:20.81,0:43:23.59,中文,,0,0,0,,一些 SLList 就像是旋转的 并且不打印丢失的项目
Dialogue: 0,0:43:23.59,0:43:32.40,英文,,0,0,0,,So because not all SLLists can print lost items, the compiler will actually stop here and say, no, I'm not going to compile the program.
Dialogue: 0,0:43:23.59,0:43:32.40,中文,,0,0,0,,因为并非所有的 SLList 都可以打印丢失的项目 编译器实际上会在这里停止 并说 不 我不会编译这个程序
Dialogue: 0,0:43:32.40,0:43:37.26,英文,,0,0,0,,Not all SLLists have a print lost items method, so I don't feel comfortable with this line of code.
Dialogue: 0,0:43:32.40,0:43:37.26,中文,,0,0,0,,并非所有的 SLList 都有打印丢失项目的方法 我对这行代码不太放心
Dialogue: 0,0:43:37.26,0:43:41.11,英文,,0,0,0,,I'm going to play it safe and not allow this program to compile.
Dialogue: 0,0:43:37.26,0:43:41.11,中文,,0,0,0,,我会采取保守的做法 不允许这个程序编译
Dialogue: 0,0:43:41.11,0:43:43.61,英文,,0,0,0,,And same thing with this next line, which is,
Dialogue: 0,0:43:41.11,0:43:43.61,中文,,0,0,0,,还有下一行也是一样的 就是这个
Dialogue: 0,0:43:43.61,0:43:44.55,英文,,0,0,0,,What does this next line say?
Dialogue: 0,0:43:43.61,0:43:44.55,中文,,0,0,0,,这下一行说了什么
Dialogue: 0,0:43:44.55,0:43:46.45,英文,,0,0,0,,It says, what is SL?
Dialogue: 0,0:43:44.55,0:43:46.45,中文,,0,0,0,,它说 sl 是什么
Dialogue: 0,0:43:46.45,0:43:49.25,英文,,0,0,0,,According to the compiler, it is an SLList.
Dialogue: 0,0:43:46.45,0:43:49.25,中文,,0,0,0,,根据编译器 它是一个 SLList
Dialogue: 0,0:43:49.25,0:43:50.41,英文,,0,0,0,,OK, great.
Dialogue: 0,0:43:49.25,0:43:50.41,中文,,0,0,0,,很好
Dialogue: 0,0:43:50.41,0:43:55.43,英文,,0,0,0,,And what are we trying to assign the SLList to according to this equals operator?
Dialogue: 0,0:43:50.41,0:43:55.43,中文,,0,0,0,,根据这个等号运算符 我们试图将 SLList 分配给什么
Dialogue: 0,0:43:55.43,0:43:59.82,英文,,0,0,0,,I'm trying to assign an SLList to a memory box that holds vengeful SLLists.
Dialogue: 0,0:43:55.43,0:43:59.82,中文,,0,0,0,,我正在尝试将一个记忆盒分配给一个持有Vengeful性SLList的SLList
Dialogue: 0,0:43:59.82,0:44:03.10,英文,,0,0,0,,And I think, is a vengeful SLList an SLList?
Dialogue: 0,0:43:59.82,0:44:03.10,中文,,0,0,0,,我想 Vengeful性SLList是一个SLList吗
Dialogue: 0,0:44:03.10,0:44:05.42,英文,,0,0,0,,Well, sometimes, but not always.
Dialogue: 0,0:44:03.10,0:44:05.42,中文,,0,0,0,,有时候是 但不总是
Dialogue: 0,0:44:05.42,0:44:08.62,英文,,0,0,0,,Sorry, I think I got that backwards.
Dialogue: 0,0:44:05.42,0:44:08.62,中文,,0,0,0,,抱歉 我想我搞错了
Dialogue: 0,0:44:08.62,0:44:11.10,英文,,0,0,0,,So I have an SLList on the right-hand side.
Dialogue: 0,0:44:08.62,0:44:11.10,中文,,0,0,0,,我右手边有一个SLList
Dialogue: 0,0:44:11.10,0:44:13.49,英文,,0,0,0,,I'm trying to assign it to Vengeful SLList.
Dialogue: 0,0:44:11.10,0:44:13.49,中文,,0,0,0,,我试图将其分配给VengefulSLList
Dialogue: 0,0:44:13.49,0:44:17.11,英文,,0,0,0,,And the question is, is an SLList a Vengeful SLList?
Dialogue: 0,0:44:13.49,0:44:17.11,中文,,0,0,0,,问题是 SLList是VengefulSLList吗
Dialogue: 0,0:44:17.11,0:44:19.85,英文,,0,0,0,,Sometimes, but not always, it could be rotating.
Dialogue: 0,0:44:17.11,0:44:19.85,中文,,0,0,0,,有时候 但并不总是 它可能会旋转
Dialogue: 0,0:44:19.85,0:44:21.06,英文,,0,0,0,,It could be peaceful.
Dialogue: 0,0:44:19.85,0:44:21.06,中文,,0,0,0,,它可能会很平静
Dialogue: 0,0:44:21.06,0:44:25.20,英文,,0,0,0,,So for the same reason, that one's also going to fail to compile.
Dialogue: 0,0:44:21.06,0:44:25.20,中文,,0,0,0,,基本上 出于同样的原因 那个也会编译失败
Dialogue: 0,0:44:25.20,0:44:31.52,英文,,0,0,0,,OK, so again, the problem here, basically, is that the compiler is only checking based on the static type.
Dialogue: 0,0:44:25.20,0:44:31.52,中文,,0,0,0,,这里的问题 基本上 是编译器只是基于静态类型进行检查
Dialogue: 0,0:44:31.52,0:44:35.87,英文,,0,0,0,,And so the compiler, you can think of it as being super, super conservative and safe.
Dialogue: 0,0:44:31.52,0:44:35.87,中文,,0,0,0,,编译器非常保守和安全 你可以这样想
Dialogue: 0,0:44:35.87,0:44:37.23,英文,,0,0,0,,It's like a scaredy cat.
Dialogue: 0,0:44:35.87,0:44:37.23,中文,,0,0,0,,就像是一个胆小鬼
Dialogue: 0,0:44:37.23,0:44:41.65,英文,,0,0,0,,Whenever it sees something that could possibly go wrong, like this is an S list.
Dialogue: 0,0:44:37.23,0:44:41.65,中文,,0,0,0,,每当它看到可能出错的东西时 比如这是一个 SLList
Dialogue: 0,0:44:41.65,0:44:42.51,英文,,0,0,0,,What kind of SLList?
Dialogue: 0,0:44:41.65,0:44:42.51,中文,,0,0,0,,什么样的SLList
Dialogue: 0,0:44:42.51,0:44:43.41,英文,,0,0,0,,I don't know.
Dialogue: 0,0:44:42.51,0:44:43.41,中文,,0,0,0,,我不知道
Dialogue: 0,0:44:43.41,0:44:44.41,英文,,0,0,0,,I don't know if it's vengeful.
Dialogue: 0,0:44:43.41,0:44:44.41,中文,,0,0,0,,我不知道它是不是报复性的
Dialogue: 0,0:44:44.41,0:44:45.77,英文,,0,0,0,,I don't know if it's peaceful.
Dialogue: 0,0:44:44.41,0:44:45.77,中文,,0,0,0,,我不知道它是不是宁静的
Dialogue: 0,0:44:45.77,0:44:52.22,英文,,0,0,0,,So I cannot put it in this vengeful memory box because I don't know if SL is vengeful, peaceful, rotating.
Dialogue: 0,0:44:45.77,0:44:52.22,中文,,0,0,0,,我不能把它放在这个报复性的内存盒子里 因为我不知道SL是报复性的、宁静的还是旋转的
Dialogue: 0,0:44:52.22,0:44:56.10,英文,,0,0,0,,So I'm too scared to put it in this vengeful SLList memory box.
Dialogue: 0,0:44:52.22,0:44:56.10,中文,,0,0,0,,我太害怕把它放在这个报复性的SLList内存盒子里
Dialogue: 0,0:44:56.10,0:44:58.02,英文,,0,0,0,,The compiler is super conservative.
Dialogue: 0,0:44:56.10,0:44:58.02,中文,,0,0,0,,编译器非常保守
Dialogue: 0,0:44:58.02,0:45:03.80,英文,,0,0,0,,If something could possibly go wrong, it's going to panic and say, no, I don't want to compile this program.
Dialogue: 0,0:44:58.02,0:45:03.80,中文,,0,0,0,,如果有什么可能出错的 它会恐慌并说 不 我不想编译这个程序
Dialogue: 0,0:45:03.80,0:45:09.55,英文,,0,0,0,,OK, you can also think of it, if you want to, as expressions having compile-time types.
Dialogue: 0,0:45:03.80,0:45:09.55,中文,,0,0,0,,你也可以这样想 如果你愿意的话 就把它看作是表达式具有编译时类型
Dialogue: 0,0:45:09.55,0:45:14.91,英文,,0,0,0,,So not only do variables have compile-time types, like SL has compile-time type SLLIST.
Dialogue: 0,0:45:09.55,0:45:14.91,中文,,0,0,0,,不仅变量有编译时类型 像SL有编译时类型SLLIST一样
Dialogue: 0,0:45:14.91,0:45:20.55,英文,,0,0,0,,If you write something like new Vengeful SLLIST, this also has a compile-time type.
Dialogue: 0,0:45:14.91,0:45:20.55,中文,,0,0,0,,如果你写类似new VengefulSLList的东西 这也有一个编译时类型
Dialogue: 0,0:45:20.55,0:45:25.95,英文,,0,0,0,,The compiler can look at this right-hand side and say, ah, you're creating a new Vengeful SLLIST.
Dialogue: 0,0:45:20.55,0:45:25.95,中文,,0,0,0,,编译器可以查看右侧并说 啊 你正在创建一个新的VengefulSLList
Dialogue: 0,0:45:25.95,0:45:29.69,英文,,0,0,0,,This must have compile-time type Vengeful SLLIST.
Dialogue: 0,0:45:25.95,0:45:29.69,中文,,0,0,0,,这必须有编译时类型VengefulSLList
Dialogue: 0,0:45:29.69,0:45:33.40,英文,,0,0,0,,Can I put a vengeful SLList inside an SLList memory box?
Dialogue: 0,0:45:29.69,0:45:33.40,中文,,0,0,0,,我能把一个有Vengeful心的SLList放在SLList内存盒里吗
Dialogue: 0,0:45:33.40,0:45:37.46,英文,,0,0,0,,Yes, because a vengeful SLList is always an SLList.
Dialogue: 0,0:45:33.40,0:45:37.46,中文,,0,0,0,,是的 因为一个Vengeful心切的 SLList 总是一个 SLList
Dialogue: 0,0:45:37.46,0:45:38.80,英文,,0,0,0,,That's always true.
Dialogue: 0,0:45:37.46,0:45:38.80,中文,,0,0,0,,这总是正确的
Dialogue: 0,0:45:38.80,0:45:47.37,英文,,0,0,0,,By contrast, this line down here, this is not okay, because the compiler looks at the right-hand side and says, the right-hand side, the compile time type is SLList.
Dialogue: 0,0:45:38.80,0:45:47.37,中文,,0,0,0,,相比之下 这一行在这里 这是不行的 因为编译器看右边并说 右边 编译时类型是 SLList
Dialogue: 0,0:45:47.37,0:45:50.90,英文,,0,0,0,,Left hand side is declared as a vengeful SLList.
Dialogue: 0,0:45:47.37,0:45:50.90,中文,,0,0,0,,左边被声明为一个Vengeful的 SLList
Dialogue: 0,0:45:50.90,0:45:53.08,英文,,0,0,0,,Isn't SLList a vengeful SLList?
Dialogue: 0,0:45:50.90,0:45:53.08,中文,,0,0,0,,SLList 不是一个Vengeful的 SLList 吗
Dialogue: 0,0:45:53.08,0:45:55.18,英文,,0,0,0,,Sometimes, but not always.
Dialogue: 0,0:45:53.08,0:45:55.18,中文,,0,0,0,,有时候 但并不总是
Dialogue: 0,0:45:55.18,0:45:59.11,英文,,0,0,0,,So this will also compiler error the compiler super careful.
Dialogue: 0,0:45:55.18,0:45:59.11,中文,,0,0,0,,这也会编译错误 编译器非常小心
Dialogue: 0,0:45:59.11,0:46:01.23,英文,,0,0,0,,It says, Oh, but what if this is not vengeful?
Dialogue: 0,0:45:59.11,0:46:01.23,中文,,0,0,0,,它说 哦 但如果这不是Vengeful呢
Dialogue: 0,0:46:01.23,0:46:01.99,英文,,0,0,0,,What if it's peaceful?
Dialogue: 0,0:46:01.23,0:46:01.99,中文,,0,0,0,,如果它是和平的呢
Dialogue: 0,0:46:01.99,0:46:03.13,英文,,0,0,0,,What if it's rotating?
Dialogue: 0,0:46:01.99,0:46:03.13,中文,,0,0,0,,如果它在旋转呢
Dialogue: 0,0:46:03.13,0:46:07.42,英文,,0,0,0,,So it's not going to put it in the vengeful SLList memory box.
Dialogue: 0,0:46:03.13,0:46:07.42,中文,,0,0,0,,它不会把它放在VengefulSLList内存盒里
Dialogue: 0,0:46:07.42,0:46:10.00,英文,,0,0,0,,Okay, this even extends to things like expression.
Dialogue: 0,0:46:07.42,0:46:10.00,中文,,0,0,0,,这甚至延伸到像表达式这样的东西
Dialogue: 0,0:46:10.00,0:46:18.73,英文,,0,0,0,,So if you write like function calls, if you say you like add things together, any expression that you write in Java also has a compile time type.
Dialogue: 0,0:46:10.00,0:46:18.73,中文,,0,0,0,,如果你写函数调用 如果你说你想把东西加在一起 你在Java中写的任何表达式也都有一个编译时类型
Dialogue: 0,0:46:18.73,0:46:22.72,英文,,0,0,0,,So as an example, let's say I have two poodles, Frank and Frank Jr.
Dialogue: 0,0:46:18.73,0:46:22.72,中文,,0,0,0,,举个例子 假设我有两只贵宾犬 frank和frank Jr
Dialogue: 0,0:46:22.72,0:46:25.46,英文,,0,0,0,,And I call MaxDog on Frank and Frank Jr.
Dialogue: 0,0:46:22.72,0:46:25.46,中文,,0,0,0,,我给frank和frank Jr.打电话了
Dialogue: 0,0:46:25.46,0:46:26.40,英文,,0,0,0,,OK, great.
Dialogue: 0,0:46:25.46,0:46:26.40,中文,,0,0,0,,太棒了
Dialogue: 0,0:46:26.40,0:46:29.06,英文,,0,0,0,,So what does the compiler think about this?
Dialogue: 0,0:46:26.40,0:46:29.06,中文,,0,0,0,,那编译器对此怎么看
Dialogue: 0,0:46:29.06,0:46:33.35,英文,,0,0,0,,Remember, the compiler, it only thinks about declarations and static types.
Dialogue: 0,0:46:29.06,0:46:33.35,中文,,0,0,0,,记住 编译器只关心声明和静态类型
Dialogue: 0,0:46:33.35,0:46:37.83,英文,,0,0,0,,It does not actually run MaxDog to figure out what the dynamic type is.
Dialogue: 0,0:46:33.35,0:46:37.83,中文,,0,0,0,,它实际上不运行maxDog来确定动态类型是什么
Dialogue: 0,0:46:37.83,0:46:39.19,英文,,0,0,0,,It doesn't care about that.
Dialogue: 0,0:46:37.83,0:46:39.19,中文,,0,0,0,,它不在乎那些
Dialogue: 0,0:46:39.19,0:46:44.59,英文,,0,0,0,,All that the compiler does is it looks inside MaxDog and says, what does MaxDog return?
Dialogue: 0,0:46:39.19,0:46:44.59,中文,,0,0,0,,编译器所做的一切就是查看maxDog内部并询问 maxDog返回什么
Dialogue: 0,0:46:44.59,0:46:45.93,英文,,0,0,0,,Ah, it returns dog.
Dialogue: 0,0:46:44.59,0:46:45.93,中文,,0,0,0,,啊 它返回狗
Dialogue: 0,0:46:45.93,0:46:47.29,英文,,0,0,0,,What is it actually doing?
Dialogue: 0,0:46:45.93,0:46:47.29,中文,,0,0,0,,它实际上在做什么
Dialogue: 0,0:46:47.29,0:46:47.85,英文,,0,0,0,,I don't care.
Dialogue: 0,0:46:47.29,0:46:47.85,中文,,0,0,0,,我不在乎
Dialogue: 0,0:46:47.85,0:46:49.05,英文,,0,0,0,,I'm the compiler.
Dialogue: 0,0:46:47.85,0:46:49.05,中文,,0,0,0,,我是编译器
Dialogue: 0,0:46:49.05,0:46:50.79,英文,,0,0,0,,I am just here to check types.
Dialogue: 0,0:46:49.05,0:46:50.79,中文,,0,0,0,,我只是在这里检查类型
Dialogue: 0,0:46:50.79,0:46:52.25,英文,,0,0,0,,So I look at this MaxDog.
Dialogue: 0,0:46:50.79,0:46:52.25,中文,,0,0,0,,我看看这个 maxDog
Dialogue: 0,0:46:52.25,0:46:53.23,英文,,0,0,0,,I look inside.
Dialogue: 0,0:46:52.25,0:46:53.23,中文,,0,0,0,,我往里面看
Dialogue: 0,0:46:53.23,0:46:54.47,英文,,0,0,0,,I see, aha.
Dialogue: 0,0:46:53.23,0:46:54.47,中文,,0,0,0,,我明白了 啊哈
Dialogue: 0,0:46:54.47,0:46:55.63,英文,,0,0,0,,MaxDog returns a dog.
Dialogue: 0,0:46:54.47,0:46:55.63,中文,,0,0,0,,maxDog 返回一只狗
Dialogue: 0,0:46:55.63,0:46:59.26,英文,,0,0,0,,So the right-hand side has compile-time type dog.
Dialogue: 0,0:46:55.63,0:46:59.26,中文,,0,0,0,,因此右侧具有编译时类型为狗
Dialogue: 0,0:46:59.26,0:47:02.16,英文,,0,0,0,,The left-hand side, largerDog, is declared as a dog.
Dialogue: 0,0:46:59.26,0:47:02.16,中文,,0,0,0,,左侧的 largerDog 声明为一只狗
Dialogue: 0,0:47:02.16,0:47:04.84,英文,,0,0,0,,So the compiler thinks that largerDog is a dog.
Dialogue: 0,0:47:02.16,0:47:04.84,中文,,0,0,0,,因此编译器认为 largerDog 是一只狗
Dialogue: 0,0:47:04.84,0:47:08.51,英文,,0,0,0,,And the compiler asks the question, is a dog a dog?
Dialogue: 0,0:47:04.84,0:47:08.51,中文,,0,0,0,,编译器会问一个问题 狗是狗吗
Dialogue: 0,0:47:08.51,0:47:10.31,英文,,0,0,0,,Yes, dogs are dogs.
Dialogue: 0,0:47:08.51,0:47:10.31,中文,,0,0,0,,是的 狗就是狗
Dialogue: 0,0:47:10.31,0:47:11.07,英文,,0,0,0,,Great.
Dialogue: 0,0:47:11.07,0:47:14.32,英文,,0,0,0,,So it's okay to assign maxDog to this dog variable.
Dialogue: 0,0:47:11.07,0:47:14.32,中文,,0,0,0,,把maxDog赋值给这个dog变量是可以的
Dialogue: 0,0:47:14.32,0:47:16.72,英文,,0,0,0,,By contrast, look at this line down here.
Dialogue: 0,0:47:14.32,0:47:16.72,中文,,0,0,0,,相比之下 看看下面这行
Dialogue: 0,0:47:16.72,0:47:20.90,英文,,0,0,0,,I'm calling maxDog, the compile-time type of maxDog is dog.
Dialogue: 0,0:47:16.72,0:47:20.90,中文,,0,0,0,,我正在调用maxDog maxDog的编译时类型是dog
Dialogue: 0,0:47:20.90,0:47:22.28,英文,,0,0,0,,Is that the dynamic type?
Dialogue: 0,0:47:20.90,0:47:22.28,中文,,0,0,0,,那是动态类型吗
Dialogue: 0,0:47:22.28,0:47:23.10,英文,,0,0,0,,Who knows?
Dialogue: 0,0:47:22.28,0:47:23.10,中文,,0,0,0,,谁知道呢
Dialogue: 0,0:47:23.10,0:47:24.99,英文,,0,0,0,,Who knows what maxDog is going to return?
Dialogue: 0,0:47:23.10,0:47:24.99,中文,,0,0,0,,谁知道maxDog会返回什么
Dialogue: 0,0:47:24.99,0:47:32.97,英文,,0,0,0,,But the compile-time type of maxDog is dog, the left-hand side is poodle, and the compiler asks the question, is a maxDog a poodle?
Dialogue: 0,0:47:24.99,0:47:32.97,中文,,0,0,0,,但 maxDog 的编译时类型是 dog 左侧是 poodle 编译器会问一个问题 maxDog 是 poodle 吗
Dialogue: 0,0:47:32.97,0:47:34.25,英文,,0,0,0,,Or is a dog a poodle?
Dialogue: 0,0:47:32.97,0:47:34.25,中文,,0,0,0,,还是 dog 是 poodle 吗
Dialogue: 0,0:47:34.25,0:47:36.50,英文,,0,0,0,,Sometimes, but not always.
Dialogue: 0,0:47:34.25,0:47:36.50,中文,,0,0,0,,有时候是 但并非总是如此
Dialogue: 0,0:47:36.50,0:47:38.14,英文,,0,0,0,,So the compiler will refuse to run this.
Dialogue: 0,0:47:36.50,0:47:38.14,中文,,0,0,0,,因此 编译器会拒绝运行此代码
Dialogue: 0,0:47:38.14,0:47:41.66,英文,,0,0,0,,It'll say on the right-hand side, I'm trying to assign a dog to a poodle.
Dialogue: 0,0:47:38.14,0:47:41.66,中文,,0,0,0,,它会说在右侧 我试图将一个 dog 赋给一个 poodle
Dialogue: 0,0:47:41.66,0:47:44.87,英文,,0,0,0,,Not all dogs are poodles, so I'm too scared to do this.
Dialogue: 0,0:47:41.66,0:47:44.87,中文,,0,0,0,,并非所有的 dogs 都是 poodles 我太害怕这样做了
Dialogue: 0,0:47:44.87,0:47:47.78,英文,,0,0,0,,But let's look at this code a little bit more carefully.
Dialogue: 0,0:47:44.87,0:47:47.78,中文,,0,0,0,,但让我们仔细看看这段代码
Dialogue: 0,0:47:47.78,0:47:51.56,英文,,0,0,0,,Because if I read this code, it seems like Frank is a poodle.
Dialogue: 0,0:47:47.78,0:47:51.56,中文,,0,0,0,,因为如果我读这段代码 好像frank是一只贵宾犬
Dialogue: 0,0:47:51.56,0:47:53.06,英文,,0,0,0,,Frank Jr. is a poodle.
Dialogue: 0,0:47:51.56,0:47:53.06,中文,,0,0,0,,frank Jr. 是一只贵宾犬
Dialogue: 0,0:47:53.06,0:47:56.78,英文,,0,0,0,,So if I ask for the larger of Frank and Frank Jr., I'm going to get a poodle.
Dialogue: 0,0:47:53.06,0:47:56.78,中文,,0,0,0,,如果我要求frank和frank Jr.中较大的那个 我会得到一只贵宾犬
Dialogue: 0,0:47:56.78,0:48:01.95,英文,,0,0,0,,So you and I know, just by looking at the code, that Mag's dog's going to return a poodle.
Dialogue: 0,0:47:56.78,0:48:01.95,中文,,0,0,0,,你和我知道 单凭看代码 Mag的狗会返回一只贵宾犬
Dialogue: 0,0:48:01.95,0:48:03.47,英文,,0,0,0,,But the compiler, it doesn't know.
Dialogue: 0,0:48:01.95,0:48:03.47,中文,,0,0,0,,但是编译器并不知道
Dialogue: 0,0:48:03.47,0:48:04.69,英文,,0,0,0,,It's not writing the code.
Dialogue: 0,0:48:03.47,0:48:04.69,中文,,0,0,0,,它不写代码
Dialogue: 0,0:48:04.69,0:48:06.25,英文,,0,0,0,,It's just checking the types.
Dialogue: 0,0:48:04.69,0:48:06.25,中文,,0,0,0,,只是检查类型而已
Dialogue: 0,0:48:06.25,0:48:08.21,英文,,0,0,0,,So here's a case where the compiler is super scared.
Dialogue: 0,0:48:06.25,0:48:08.21,中文,,0,0,0,,这里有一个情况 编译器非常害怕
Dialogue: 0,0:48:08.21,0:48:09.88,英文,,0,0,0,,It's like, oh, but what if the dog's a malamute?
Dialogue: 0,0:48:08.21,0:48:09.88,中文,,0,0,0,,就像 哦 但如果狗是马拉穆特呢
Dialogue: 0,0:48:09.88,0:48:11.16,英文,,0,0,0,,What if it's a?
Dialogue: 0,0:48:09.88,0:48:11.16,中文,,0,0,0,,如果它是一个
Dialogue: 0,0:48:11.16,0:48:11.96,英文,,0,0,0,,Corgi.
Dialogue: 0,0:48:11.16,0:48:11.96,中文,,0,0,0,,柯基
Dialogue: 0,0:48:11.96,0:48:14.40,英文,,0,0,0,,But we all know that it's a poodle.
Dialogue: 0,0:48:11.96,0:48:14.40,中文,,0,0,0,,但我们都知道它是一只贵宾犬
Dialogue: 0,0:48:14.40,0:48:23.32,英文,,0,0,0,,So how do we solve this problem where we know that MaxDog's going to return a poodle, but the compiler is super scared and is not comfortable with this assignment?
Dialogue: 0,0:48:14.40,0:48:23.32,中文,,0,0,0,,那么我们如何解决这个问题 我们知道maxDog会返回一只贵宾犬 但编译器非常害怕 对这个赋值不感到舒服
Dialogue: 0,0:48:23.32,0:48:27.42,英文,,0,0,0,,To solve that, we're going to add an extra little piece of syntax called a cast.
Dialogue: 0,0:48:23.32,0:48:27.42,中文,,0,0,0,,为了解决这个问题 我们要添加一个额外的小语法片段 叫做转换
Dialogue: 0,0:48:27.42,0:48:28.80,英文,,0,0,0,,And what does the cast do?
Dialogue: 0,0:48:27.42,0:48:28.80,中文,,0,0,0,,那转换是做什么的
Dialogue: 0,0:48:28.80,0:48:32.85,英文,,0,0,0,,The cast, all that it does is it changes the compile time type.
Dialogue: 0,0:48:28.80,0:48:32.85,中文,,0,0,0,,这个转换 它的作用就是改变编译时的类型
Dialogue: 0,0:48:32.85,0:48:40.05,英文,,0,0,0,,So we are telling the compiler, hey, when you see this MaxDog expression, I know you thought it was a dog, but like,
Dialogue: 0,0:48:32.85,0:48:40.05,中文,,0,0,0,,我们在告诉编译器 嘿 当你看到这个maxDog表达式时 我知道你以为它是一条狗 但是
Dialogue: 0,0:48:40.05,0:48:40.83,英文,,0,0,0,,Don't worry about it.
Dialogue: 0,0:48:40.05,0:48:40.83,中文,,0,0,0,,别担心
Dialogue: 0,0:48:40.83,0:48:42.75,英文,,0,0,0,,Trust me, it's a poodle.
Dialogue: 0,0:48:40.83,0:48:42.75,中文,,0,0,0,,相信我 它是一只贵宾犬
Dialogue: 0,0:48:42.75,0:48:48.53,英文,,0,0,0,,So we are telling the compiler, we're giving it a hint that the MaxDog should be a compile-time-type poodle.
Dialogue: 0,0:48:42.75,0:48:48.53,中文,,0,0,0,,我们在告诉编译器 我们在给它一个提示 告诉它maxDog应该是一个编译时类型的贵宾犬
Dialogue: 0,0:48:48.53,0:48:55.40,英文,,0,0,0,,And by doing that, now the compiler says, well, the programmer told me that the MaxDog should have compiler-time-type poodle.
Dialogue: 0,0:48:48.53,0:48:55.40,中文,,0,0,0,,通过这样做 现在编译器说 程序员告诉我 maxDog应该在编译时具有泰迪狗的类型
Dialogue: 0,0:48:55.40,0:48:56.58,英文,,0,0,0,,Is a poodle a poodle?
Dialogue: 0,0:48:55.40,0:48:56.58,中文,,0,0,0,,贵宾狗是贵宾狗吗
Dialogue: 0,0:48:56.58,0:48:57.26,英文,,0,0,0,,Yes.
Dialogue: 0,0:48:56.58,0:48:57.26,中文,,0,0,0,,是的
Dialogue: 0,0:48:57.26,0:48:59.78,英文,,0,0,0,,So now this will compile.
Dialogue: 0,0:48:57.26,0:48:59.78,中文,,0,0,0,,现在这将编译
Dialogue: 0,0:48:59.78,0:49:03.16,英文,,0,0,0,,When you cast, you are not changing the way in which the code runs.
Dialogue: 0,0:48:59.78,0:49:03.16,中文,,0,0,0,,当你进行类型转换时 并不会改变代码运行的方式
Dialogue: 0,0:49:03.16,0:49:05.52,英文,,0,0,0,,The code runs the exact same way.
Dialogue: 0,0:49:03.16,0:49:05.52,中文,,0,0,0,,代码运行的方式完全相同
Dialogue: 0,0:49:05.52,0:49:09.63,英文,,0,0,0,,However, I'm just telling the compiler whose job it is to check types.
Dialogue: 0,0:49:05.52,0:49:09.63,中文,,0,0,0,,但是 我只是告诉编译器 检查类型是它的工作
Dialogue: 0,0:49:09.63,0:49:12.67,英文,,0,0,0,,When you see MaxDog, please treat it like a poodle.
Dialogue: 0,0:49:09.63,0:49:12.67,中文,,0,0,0,,当你看到maxDog时 请把它当作一只贵宾犬
Dialogue: 0,0:49:12.67,0:49:13.75,英文,,0,0,0,,So don't do your job.
Dialogue: 0,0:49:12.67,0:49:13.75,中文,,0,0,0,,不要做你的工作
Dialogue: 0,0:49:13.75,0:49:14.61,英文,,0,0,0,,Don't type check so hard.
Dialogue: 0,0:49:13.75,0:49:14.61,中文,,0,0,0,,不要检查类型太严格
Dialogue: 0,0:49:14.61,0:49:15.75,英文,,0,0,0,,Don't be such a wimp.
Dialogue: 0,0:49:14.61,0:49:15.75,中文,,0,0,0,,不要这么胆小
Dialogue: 0,0:49:15.75,0:49:16.61,英文,,0,0,0,,It's a poodle.
Dialogue: 0,0:49:15.75,0:49:16.61,中文,,0,0,0,,这是一只贵宾犬
Dialogue: 0,0:49:16.61,0:49:17.75,英文,,0,0,0,,Trust me.
Dialogue: 0,0:49:16.61,0:49:17.75,中文,,0,0,0,,相信我
Dialogue: 0,0:49:17.75,0:49:22.04,英文,,0,0,0,,OK, I have to show you one last thing, which is, what about this code right here?
Dialogue: 0,0:49:17.75,0:49:22.04,中文,,0,0,0,,我必须向你展示最后一件事情 那就是 这段代码怎么样
Dialogue: 0,0:49:22.04,0:49:24.92,英文,,0,0,0,,Because casting is powerful, but it can be dangerous.
Dialogue: 0,0:49:22.04,0:49:24.92,中文,,0,0,0,,因为转换很强大 但它可能很危险
Dialogue: 0,0:49:24.92,0:49:29.48,英文,,0,0,0,,What if I have Frank, a little poodle, and Frank Sr., the gigantic malamute from last time?
Dialogue: 0,0:49:24.92,0:49:29.48,中文,,0,0,0,,如果我有弗兰克 一只小贵宾犬 还有上次的巨大马拉穆特弗兰克老爷
Dialogue: 0,0:49:29.48,0:49:31.34,英文,,0,0,0,,Well, now we have a problem.
Dialogue: 0,0:49:29.48,0:49:31.34,中文,,0,0,0,,现在我们有一个问题
Dialogue: 0,0:49:31.34,0:49:37.73,英文,,0,0,0,,Because I try the same little cast trick, and I say, OK, MaxDog, the compiler, thinks it's a dog.
Dialogue: 0,0:49:31.34,0:49:37.73,中文,,0,0,0,,因为我尝试了同样的小型转换技巧 我说 好吧 maxDog 编译器 认为它是一只狗
Dialogue: 0,0:49:37.73,0:49:39.23,英文,,0,0,0,,But trust me, it's a poodle.
Dialogue: 0,0:49:37.73,0:49:39.23,中文,,0,0,0,,但相信我 它是一只贵宾犬
Dialogue: 0,0:49:39.23,0:49:40.35,英文,,0,0,0,,Don't worry about it.
Dialogue: 0,0:49:39.23,0:49:40.35,中文,,0,0,0,,不用担心
Dialogue: 0,0:49:40.35,0:49:41.79,英文,,0,0,0,,Everything is going to be OK.
Dialogue: 0,0:49:40.35,0:49:41.79,中文,,0,0,0,,一切都会好起来的
Dialogue: 0,0:49:41.79,0:49:43.69,英文,,0,0,0,,This has a compile-time type poodle.
Dialogue: 0,0:49:41.79,0:49:43.69,中文,,0,0,0,,这个有编译时类型的贵宾犬
Dialogue: 0,0:49:43.69,0:49:47.47,英文,,0,0,0,,So compiler, please treat this right-hand side like a poodle.
Dialogue: 0,0:49:43.69,0:49:47.47,中文,,0,0,0,,编译器 请把这个右边当作一只贵宾犬
Dialogue: 0,0:49:47.47,0:49:50.89,英文,,0,0,0,,However, if I look at this code, who's the larger dog?
Dialogue: 0,0:49:47.47,0:49:50.89,中文,,0,0,0,,但是 如果我看这段代码 谁是更大的狗呢
Dialogue: 0,0:49:50.89,0:49:52.21,英文,,0,0,0,,It's Frank Sr.
Dialogue: 0,0:49:50.89,0:49:52.21,中文,,0,0,0,,是 frank Sr
Dialogue: 0,0:49:52.21,0:49:53.63,英文,,0,0,0,,So now we have a problem.
Dialogue: 0,0:49:52.21,0:49:53.63,中文,,0,0,0,,现在我们有了问题
Dialogue: 0,0:49:53.63,0:49:55.21,英文,,0,0,0,,MaxDog returned Frank Sr.
Dialogue: 0,0:49:53.63,0:49:55.21,中文,,0,0,0,,maxDog 返回了 frank Sr
Dialogue: 0,0:49:55.21,0:49:56.27,英文,,0,0,0,,at runtime.
Dialogue: 0,0:49:55.21,0:49:56.27,中文,,0,0,0,,在运行时
Dialogue: 0,0:49:56.27,0:50:01.09,英文,,0,0,0,,I try to cast it and assign it to a poodle variable, and the code crashes at runtime.
Dialogue: 0,0:49:56.27,0:50:01.09,中文,,0,0,0,,我试图将其转换并赋值给一只贵宾犬变量 但代码在运行时崩溃了
Dialogue: 0,0:50:01.09,0:50:06.25,英文,,0,0,0,,It says, no, I cannot assign Frank Sr., the malamute, to a memory box for a poodle.
Dialogue: 0,0:50:01.09,0:50:06.25,中文,,0,0,0,,它说 不 我不能将frank Sr. 这只阿拉斯加犬 分配给一只贵宾犬的内存盒子
Dialogue: 0,0:50:06.25,0:50:09.22,英文,,0,0,0,,So with casting, you have to be really careful.
Dialogue: 0,0:50:06.25,0:50:09.22,中文,,0,0,0,,在进行转换时 你必须非常小心
Dialogue: 0,0:50:09.22,0:50:15.06,英文,,0,0,0,,It can be a powerful tool sometimes when you and I both know it's a poodle, but the compiler is too scared to be sure.
Dialogue: 0,0:50:09.22,0:50:15.06,中文,,0,0,0,,有时候它可以是一个强大的工具 当你我都知道它是一只贵宾犬时 但编译器却害怕确定
Dialogue: 0,0:50:15.06,0:50:19.84,英文,,0,0,0,,But you've got to be careful, because if you cast something that should not be cast, this is a malamute.
Dialogue: 0,0:50:15.06,0:50:19.84,中文,,0,0,0,,但你必须小心 因为如果你将不应该转换的东西转换了 那就是一只阿拉斯加犬
Dialogue: 0,0:50:19.84,0:50:23.90,英文,,0,0,0,,Casting it to a poodle, the compiler will crash and say no.
Dialogue: 0,0:50:19.84,0:50:23.90,中文,,0,0,0,,将其转换为贵宾犬 编译器将崩溃并说不
Dialogue: 0,0:50:23.90,0:50:25.91,英文,,0,0,0,,OK, it's 2 o'clock, so we can all go home.
Dialogue: 0,0:50:23.90,0:50:25.91,中文,,0,0,0,,现在两点了 我们都可以回家了
Dialogue: 0,0:50:25.91,0:50:27.99,英文,,0,0,0,,We'll talk about higher-order functions next time.
Dialogue: 0,0:50:25.91,0:50:27.99,中文,,0,0,0,,下次我们会谈论高阶函数的
Dialogue: 0,0:50:27.99,0:50:29.05,英文,,0,0,0,,Bye.
Dialogue: 0,0:50:27.99,0:50:29.05,中文,,0,0,0,,再见
