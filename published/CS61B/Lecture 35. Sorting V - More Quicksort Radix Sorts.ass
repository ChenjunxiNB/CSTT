[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 3
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Export Encoding: Unicode (UTF-8)
Audio File: D:/python_code/video_tool/video_tool/result/Lecture 02.1 - Number Representation Intro, Bits can be anything.mp4
Video File: D:/python_code/video_tool/video_tool/result/Lecture 02.1 - Number Representation Intro, Bits can be anything.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.375000
Scroll Position: 801
Active Line: 807
Video Position: 8466

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,14,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.33333,1.33333,2,6,6,8,1
Style: 英文,Arial,24,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1.33333,1.33333,2,2,2,6,1
Style: 中文,微软雅黑,38,&H0029EEF1,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1.33333,1.33333,2,2,2,20,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,
Dialogue: 0,0:00:03.45,0:00:10.50,英文,,0,0,0,,Hello, it's me, the evil twin version of myself, to finish telling you all about quicksort.
Dialogue: 0,0:00:03.45,0:00:10.50,中文,,0,0,0,,大家好  我是邪恶的双胞胎  我来继续给大家讲快速排序
Dialogue: 0,0:00:10.50,0:00:12.90,英文,,0,0,0,,Remember this stupid gimmick from a week ago?
Dialogue: 0,0:00:10.50,0:00:12.90,中文,,0,0,0,,还记得一周前的那个愚蠢的噱头吗？
Dialogue: 0,0:00:12.90,0:00:14.44,英文,,0,0,0,,We're gonna finish it.
Dialogue: 0,0:00:12.90,0:00:14.44,中文,,0,0,0,,我们要把它讲完
Dialogue: 0,0:00:14.44,0:00:18.66,英文,,0,0,0,,Alright, so last time I told you all about quicksort.
Dialogue: 0,0:00:14.44,0:00:18.66,中文,,0,0,0,,好的  上次我给大家讲了快速排序
Dialogue: 0,0:00:18.66,0:00:23.82,英文,,0,0,0,,The wonderful partition-based sorting algorithm that those other two clowns don't understand.
Dialogue: 0,0:00:18.66,0:00:23.82,中文,,0,0,0,,那两个小丑不明白的基于分区的排序算法
Dialogue: 0,0:00:23.82,0:00:28.55,英文,,0,0,0,,So remember the idea behind partitioning is you pick an item to be the pivot.
Dialogue: 0,0:00:23.82,0:00:28.55,中文,,0,0,0,,所以记住  分区背后的思想是选择一个元素作为基准
Dialogue: 0,0:00:28.55,0:00:35.15,英文,,0,0,0,,You put all the items less than or equal to the pivot on one side, all the items greater than or equal to the pivot on the other side.
Dialogue: 0,0:00:28.55,0:00:35.15,中文,,0,0,0,,将所有小于或等于基准的元素放在一边  将所有大于或等于基准的元素放在另一边
Dialogue: 0,0:00:35.15,0:00:39.33,英文,,0,0,0,,And by doing so, the pivot itself falls into the right place.
Dialogue: 0,0:00:35.15,0:00:39.33,中文,,0,0,0,,通过这样做  基准本身就落到了正确的位置
Dialogue: 0,0:00:39.33,0:00:48.56,英文,,0,0,0,,I don't know how this array is sorted, but I do know that whenever I'm done sorting it, that's where the 32, the pivot, will go from last time.
Dialogue: 0,0:00:39.33,0:00:48.56,中文,,0,0,0,,我不知道这个数组是如何排序的  但我确实知道  无论何时我完成排序  32  也就是上次的基准  都会放在那里
Dialogue: 0,0:00:48.56,0:00:54.56,英文,,0,0,0,,We also showed you that quicksort, in the best case, has n log n performance every time you cut the problem in half.
Dialogue: 0,0:00:48.56,0:00:54.56,中文,,0,0,0,,我们还向大家展示了  在最好的情况下  快速排序每次将问题分成两半  具有 N log N 的性能
Dialogue: 0,0:00:54.56,0:00:56.17,英文,,0,0,0,,It's the best case.
Dialogue: 0,0:00:54.56,0:00:56.17,中文,,0,0,0,,这是最好的情况
Dialogue: 0,0:00:56.17,0:01:02.45,英文,,0,0,0,,And we also saw that the worst case is theta of n squared every time the problem only reduces in size by one.
Dialogue: 0,0:00:56.17,0:01:02.45,中文,,0,0,0,,我们还看到了最坏的情况是 Θ(N²)  每次问题的大小只减少 1
Dialogue: 0,0:01:02.45,0:01:07.06,英文,,0,0,0,,And that happens if, for example, the array is sorted or almost sorted.
Dialogue: 0,0:01:02.45,0:01:07.06,中文,,0,0,0,,如果数组是已排序或几乎已排序的  就会发生这种情况
Dialogue: 0,0:01:07.06,0:01:11.24,英文,,0,0,0,,So the question we had for you was, how do you avoid the worst-case runtime?
Dialogue: 0,0:01:07.06,0:01:11.24,中文,,0,0,0,,所以我们给你的问题是  如何避免最坏情况下的运行时间？
Dialogue: 0,0:01:11.24,0:01:14.28,英文,,0,0,0,,And we came up with a couple of approaches.
Dialogue: 0,0:01:11.24,0:01:14.28,中文,,0,0,0,,我们想出了几种方法
Dialogue: 0,0:01:14.28,0:01:18.96,英文,,0,0,0,,One of them was to embrace chaos and to shuffle the array before you sort.
Dialogue: 0,0:01:14.28,0:01:18.96,中文,,0,0,0,,其中一种是拥抱混乱  在排序之前打乱数组
Dialogue: 0,0:01:18.96,0:01:24.81,英文,,0,0,0,,That way, with extremely high probability, the sort will be n log n time.
Dialogue: 0,0:01:18.96,0:01:24.81,中文,,0,0,0,,这样一来  排序时间极有可能为 N log N
Dialogue: 0,0:01:24.81,0:01:28.49,英文,,0,0,0,,Second approach was, well, what if we picked a better pivot?
Dialogue: 0,0:01:24.81,0:01:28.49,中文,,0,0,0,,第二种方法是  如果我们选择一个更好的基准呢？
Dialogue: 0,0:01:28.49,0:01:35.12,英文,,0,0,0,,So instead of always picking the leftmost item to be the pivot, which could be a bad choice, what if we did something a little bit smarter?
Dialogue: 0,0:01:28.49,0:01:35.12,中文,,0,0,0,,与其总是选择最左边的元素作为基准  这可能是一个糟糕的选择  不如做一些更聪明的事情？
Dialogue: 0,0:01:35.12,0:01:42.69,英文,,0,0,0,,And one idea I left you with was, what if I said, let's look at the first three items, seven, two, and three?
Dialogue: 0,0:01:35.12,0:01:42.69,中文,,0,0,0,,我给你留下了一个想法  如果我说  让我们看看前三个元素  7、2 和 3？
Dialogue: 0,0:01:42.69,0:01:45.47,英文,,0,0,0,,Between those three, which pivot did you like best?
Dialogue: 0,0:01:42.69,0:01:45.47,中文,,0,0,0,,在这三个主元中  你最喜欢哪个？
Dialogue: 0,0:01:45.47,0:01:49.60,英文,,0,0,0,,You liked three because it was the middle item of the first three.
Dialogue: 0,0:01:45.47,0:01:49.60,中文,,0,0,0,,你喜欢第三个  因为它是前三个元素的中间项
Dialogue: 0,0:01:49.60,0:01:58.36,英文,,0,0,0,,So maybe you could take a small sample like that and pick something that's a little bit better and hopefully not the worst case, although you do have to be a little bit careful.
Dialogue: 0,0:01:49.60,0:01:58.36,中文,,0,0,0,,也许你可以取一个这样的小样本  选择一个稍微好一点的元素  希望不是最坏的情况  尽管你确实需要小心一点
Dialogue: 0,0:01:58.36,0:02:06.89,英文,,0,0,0,,Because there is an interesting paper that showed that if you do a pivot selection algorithm that is deterministic, that is, you don't do any randomness,
Dialogue: 0,0:01:58.36,0:02:06.89,中文,,0,0,0,,因为有一篇有趣的论文表明  如果你使用确定性的主元选择算法  也就是说  你不进行任何随机化
Dialogue: 0,0:02:06.89,0:02:15.89,英文,,0,0,0,,no shuffling, and constant time, that is, you look at a constant number of elements like we were, say, three elements, it turns out an adversary,
Dialogue: 0,0:02:06.89,0:02:15.89,中文,,0,0,0,,不进行洗牌并且时间是常数的  你查看像我们之前那样数量恒定的元素  比如三个元素  结果发现一个对手
Dialogue: 0,0:02:15.89,0:02:22.43,英文,,0,0,0,,like an attacker, they could actually design an input that's dangerous and will cause your quicksort to go n squared.
Dialogue: 0,0:02:15.89,0:02:22.43,中文,,0,0,0,,比如攻击者  他们实际上可以设计一个危险的输入  这将导致你的快速排序变成 N² 的时间复杂度
Dialogue: 0,0:02:22.43,0:02:27.75,英文,,0,0,0,,It's kind of interesting that if you're smarter with your pivot selection and you take a small sample,
Dialogue: 0,0:02:22.43,0:02:27.75,中文,,0,0,0,,有趣的是  如果你在选择主元时更聪明一些  并取一个小样本
Dialogue: 0,0:02:27.75,0:02:33.64,英文,,0,0,0,,If it's deterministic and it's constant time, somebody could come along and break your quicksort.
Dialogue: 0,0:02:27.75,0:02:33.64,中文,,0,0,0,,如果它是确定性的并且时间是常数的  那么就会有人能够破解你的快速排序
Dialogue: 0,0:02:33.64,0:02:36.32,英文,,0,0,0,,So you have to be careful.
Dialogue: 0,0:02:33.64,0:02:36.32,中文,,0,0,0,,所以你必须小心
Dialogue: 0,0:02:36.32,0:02:42.27,英文,,0,0,0,,A better approach, maybe, and we'll talk about this one too, is what if, instead of taking a small sample and saying,
Dialogue: 0,0:02:36.32,0:02:42.27,中文,,0,0,0,,也许一个更好的方法  我们也会讨论这个方法  是如果  不是取一个小样本然后说
Dialogue: 0,0:02:42.27,0:02:46.71,英文,,0,0,0,, oh, look at the first three elements and pick the middle one, what if you just picked the exact median?
Dialogue: 0,0:02:42.27,0:02:46.71,中文,,0,0,0,,看看前三个元素并选择中间那个  而是直接选择精确的中位数呢？
Dialogue: 0,0:02:46.71,0:02:51.53,英文,,0,0,0,,So I went through the array, and I picked the exact middle item to be the pivot.
Dialogue: 0,0:02:46.71,0:02:51.53,中文,,0,0,0,,所以我遍历了数组  并选择了精确的中间项作为主元
Dialogue: 0,0:02:51.53,0:02:53.81,英文,,0,0,0,,Well, in that case, that's going to be safe.
Dialogue: 0,0:02:51.53,0:02:53.81,中文,,0,0,0,,好吧  在这种情况下  这将是安全的
Dialogue: 0,0:02:53.81,0:02:56.13,英文,,0,0,0,,You're always going to get n log n runtime.
Dialogue: 0,0:02:53.81,0:02:56.13,中文,,0,0,0,,你总是会得到 N log N 的运行时间
Dialogue: 0,0:02:56.13,0:02:57.08,英文,,0,0,0,,Why is that?
Dialogue: 0,0:02:56.13,0:02:57.08,中文,,0,0,0,,为什么呢？
Dialogue: 0,0:02:57.08,0:03:04.42,英文,,0,0,0,,Because if you always pick the median, the middle item, to be the pivot, you are always splitting the array into two smaller halves.
Dialogue: 0,0:02:57.08,0:03:04.42,中文,,0,0,0,,因为如果你总是选择中位数  也就是中间项  作为主元  你总是将数组分成两个较小的部分
Dialogue: 0,0:03:04.42,0:03:07.20,英文,,0,0,0,,And you'll always end up in the n log n runtime.
Dialogue: 0,0:03:04.42,0:03:07.20,中文,,0,0,0,,并且你最终总是会得到 N log N 的运行时间
Dialogue: 0,0:03:07.20,0:03:08.40,英文,,0,0,0,,So you could do that.
Dialogue: 0,0:03:07.20,0:03:08.40,中文,,0,0,0,,所以你可以这样做
Dialogue: 0,0:03:08.40,0:03:11.87,英文,,0,0,0,,It turns out, and we'll see this when we run some experiments, it's kind of slow.
Dialogue: 0,0:03:08.40,0:03:11.87,中文,,0,0,0,,事实证明  我们会在进行一些实验时看到这一点  它有点慢
Dialogue: 0,0:03:11.87,0:03:14.41,英文,,0,0,0,,But technically, it would work.
Dialogue: 0,0:03:11.87,0:03:14.41,中文,,0,0,0,,但从技术上讲  它是可行的
Dialogue: 0,0:03:14.41,0:03:19.72,英文,,0,0,0,,You can be smarter with your pivot selection, pick the exact middle, and things will be OK.
Dialogue: 0,0:03:14.41,0:03:19.72,中文,,0,0,0,,你可以更聪明地选择主元  选择精确的中间项  一切都会好起来的
Dialogue: 0,0:03:19.72,0:03:21.26,英文,,0,0,0,,How do you actually compute the median?
Dialogue: 0,0:03:19.72,0:03:21.26,中文,,0,0,0,,你如何实际计算中位数呢？
Dialogue: 0,0:03:21.26,0:03:23.06,英文,,0,0,0,,Well, we'll talk about that soon.
Dialogue: 0,0:03:21.26,0:03:23.06,中文,,0,0,0,,好吧  我们很快就会讨论这个问题
Dialogue: 0,0:03:23.06,0:03:25.98,英文,,0,0,0,,But those are the first two approaches.
Dialogue: 0,0:03:23.06,0:03:25.98,中文,,0,0,0,,但这些只是前两种方法
Dialogue: 0,0:03:25.98,0:03:30.80,英文,,0,0,0,,Then there are two more approaches that we don't really use in real life, but I'll briefly mention them.
Dialogue: 0,0:03:25.98,0:03:30.80,中文,,0,0,0,,还有两种方法在现实生活中不太常用  但我还是简单提一下
Dialogue: 0,0:03:30.80,0:03:38.11,英文,,0,0,0,,One of them, I think you all mentioned, was you just watch the quicksort run,
Dialogue: 0,0:03:30.80,0:03:34.61,中文,,0,0,0,,其中一种  我想你们都提到了  就是观察快速排序的运行
Dialogue: 0,0:03:34.61,0:03:38.87,中文,,0,0,0,,如果它运行时间过长  就放弃  说  嘿  也许有人给了我一个N²的输入
Dialogue: 0,0:03:38.11,0:03:38.87,英文,,0,0,0,, and if it's taking forever, just give up and say, hey, maybe someone gave me an n-squared input.
Dialogue: 0,0:03:38.87,0:03:41.39,英文,,0,0,0,,I'll switch to something safe, like merge sort.
Dialogue: 0,0:03:38.87,0:03:41.39,中文,,0,0,0,,我会换成更安全的方法  比如归并排序
Dialogue: 0,0:03:41.39,0:03:45.09,英文,,0,0,0,,No one really does it, but technically, it's reasonable.
Dialogue: 0,0:03:41.39,0:03:45.09,中文,,0,0,0,,没有人真的这样做  但从技术上讲  这是合理的
Dialogue: 0,0:03:45.09,0:03:53.46,英文,,0,0,0,,And another approach that I think you all came up with is, well, what if I just check the array ahead of time and see if it's sorted or almost sorted and switch the merge sort?
Dialogue: 0,0:03:45.09,0:03:53.46,中文,,0,0,0,,我想你们都想到的另一种方法是  如果我提前检查数组  看看它是否已排序或几乎已排序  然后切换到归并排序呢？
Dialogue: 0,0:03:53.46,0:04:01.87,英文,,0,0,0,,Again, seems reasonable to me, although it turns out that in real life, philosophies one and two are more common.
Dialogue: 0,0:03:53.46,0:04:01.87,中文,,0,0,0,,同样  对我来说这似乎是合理的  尽管事实证明  在现实生活中  第一种和第二种方法更常见
Dialogue: 0,0:04:01.87,0:04:03.32,英文,,0,0,0,,Good so far?
Dialogue: 0,0:04:01.87,0:04:03.32,中文,,0,0,0,,到目前为止还不错吧？
Dialogue: 0,0:04:03.32,0:04:06.98,英文,,0,0,0,,All right, there's your summary of the sorts so far.
Dialogue: 0,0:04:03.32,0:04:06.98,中文,,0,0,0,,好的  这就是目前为止排序方法的总结
Dialogue: 0,0:04:06.98,0:04:11.23,英文,,0,0,0,,So the last thing I have to show you for Quicksort before I am gone forever is
Dialogue: 0,0:04:06.98,0:04:11.23,中文,,0,0,0,,所以在快速排序部分结束之前  我要向你们展示的最后一件事是
Dialogue: 0,0:04:11.23,0:04:17.04,英文,,0,0,0,,we'll run some experiments to see what versions of Quicksort perform better than others.
Dialogue: 0,0:04:11.23,0:04:17.04,中文,,0,0,0,,我们将进行一些实验  看看哪些版本的快速排序比其他版本表现更好
Dialogue: 0,0:04:17.04,0:04:19.70,英文,,0,0,0,,So there's actually lots of different choice points.
Dialogue: 0,0:04:17.04,0:04:19.70,中文,,0,0,0,,所以实际上有很多不同的选择点
Dialogue: 0,0:04:19.70,0:04:26.46,英文,,0,0,0,,Like if I wanted to write QuickSort as a piece of code, there are quite a few things I can choose as I'm implementing.
Dialogue: 0,0:04:19.70,0:04:26.46,中文,,0,0,0,,比如  如果我想把快速排序写成一段代码  在实现过程中我可以选择很多东西
Dialogue: 0,0:04:26.46,0:04:27.88,英文,,0,0,0,,So here are some examples.
Dialogue: 0,0:04:26.46,0:04:27.88,中文,,0,0,0,,以下是一些例子
Dialogue: 0,0:04:27.88,0:04:30.32,英文,,0,0,0,,One thing I can choose is, how do I choose the pivot?
Dialogue: 0,0:04:27.88,0:04:30.32,中文,,0,0,0,,我可以选择的一件事是  如何选择基准值？
Dialogue: 0,0:04:30.32,0:04:31.88,英文,,0,0,0,,Do I choose the leftmost item?
Dialogue: 0,0:04:30.32,0:04:31.88,中文,,0,0,0,,我选择最左边的元素吗？
Dialogue: 0,0:04:31.88,0:04:33.50,英文,,0,0,0,,Do I choose the rightmost item?
Dialogue: 0,0:04:31.88,0:04:33.50,中文,,0,0,0,,我选择最右边的元素吗？
Dialogue: 0,0:04:33.50,0:04:35.30,英文,,0,0,0,,Do I choose the exact median?
Dialogue: 0,0:04:33.50,0:04:35.30,中文,,0,0,0,,我选择精确的中位数吗？
Dialogue: 0,0:04:35.30,0:04:38.16,英文,,0,0,0,,Do I choose, you know, take a sample and choose a pivot?
Dialogue: 0,0:04:35.30,0:04:38.16,中文,,0,0,0,,我是否选择一个样本并从中选择一个基准值呢？
Dialogue: 0,0:04:38.16,0:04:39.54,英文,,0,0,0,,Do I choose a random pivot?
Dialogue: 0,0:04:38.16,0:04:39.54,中文,,0,0,0,,我选择一个随机的基准值吗？
Dialogue: 0,0:04:39.54,0:04:42.81,英文,,0,0,0,,There are lots of different choices for how you choose your pivot.
Dialogue: 0,0:04:39.54,0:04:42.81,中文,,0,0,0,,在选择基准值方面  有很多不同的选择
Dialogue: 0,0:04:42.81,0:04:49.14,英文,,0,0,0,,And it turns out that your decision of how to choose the pivot can affect the runtime of QuickSort.
Dialogue: 0,0:04:42.81,0:04:49.14,中文,,0,0,0,,事实证明  选择枢轴的方式会影响快速排序的运行时间
Dialogue: 0,0:04:49.14,0:04:55.94,英文,,0,0,0,,Another thing you can play with as you're implementing quicksort and change is what partition algorithm do you use?
Dialogue: 0,0:04:49.14,0:04:55.94,中文,,0,0,0,,在实现快速排序时  你可以尝试的另一件事是使用哪种分区算法
Dialogue: 0,0:04:55.94,0:05:00.04,英文,,0,0,0,,Do you use the silly three scan one that that other guy would have come up with?
Dialogue: 0,0:04:55.94,0:05:00.04,中文,,0,0,0,,你会使用那个傻瓜式的三扫描算法吗？
Dialogue: 0,0:05:00.04,0:05:06.11,英文,,0,0,0,,Do we come up with something smarter to partition on an array that will also affect the runtime of our algorithm?
Dialogue: 0,0:05:00.04,0:05:06.11,中文,,0,0,0,,我们能否想出一个更聪明的数组分区方法  同样会影响算法的运行时间？
Dialogue: 0,0:05:06.11,0:05:08.81,英文,,0,0,0,,Turns out there are so many different partition algorithms.
Dialogue: 0,0:05:06.11,0:05:08.81,中文,,0,0,0,,事实证明  存在许多不同的分区算法
Dialogue: 0,0:05:08.81,0:05:11.36,英文,,0,0,0,,We'll do some experiments with some of them.
Dialogue: 0,0:05:08.81,0:05:11.36,中文,,0,0,0,,我们将对其中一些算法进行实验
Dialogue: 0,0:05:11.36,0:05:15.23,英文,,0,0,0,,And finally, we saw four different choices for how to avoid the worst case.
Dialogue: 0,0:05:11.36,0:05:15.23,中文,,0,0,0,,最后  我们看到了四种不同的方法来避免最坏情况
Dialogue: 0,0:05:15.23,0:05:16.59,英文,,0,0,0,,So do you shuffle?
Dialogue: 0,0:05:15.23,0:05:16.59,中文,,0,0,0,,那么  你要洗牌吗？
Dialogue: 0,0:05:16.59,0:05:18.13,英文,,0,0,0,,Do you pick a better pivot?
Dialogue: 0,0:05:16.59,0:05:18.13,中文,,0,0,0,,你会选择一个更好的枢轴吗？
Dialogue: 0,0:05:18.13,0:05:22.83,英文,,0,0,0,,Do you do introspection and give up if it's taking a long time?
Dialogue: 0,0:05:18.13,0:05:22.83,中文,,0,0,0,,你会进行反省  如果花费时间太长就放弃吗？
Dialogue: 0,0:05:22.83,0:05:31.32,英文,,0,0,0,,So we'll run some speed tests where we'll choose different implementations and see if they do better or worse compared to merge sort.
Dialogue: 0,0:05:22.83,0:05:31.32,中文,,0,0,0,,因此  我们将运行一些速度测试  选择不同的实现方式  看看它们与归并排序相比是更好还是更差
Dialogue: 0,0:05:31.32,0:05:32.78,英文,,0,0,0,,So merge sort is our standard.
Dialogue: 0,0:05:31.32,0:05:32.78,中文,,0,0,0,,归并排序是我们的标准
Dialogue: 0,0:05:32.78,0:05:36.82,英文,,0,0,0,,Let's see if we can beat merge sort by making good choices.
Dialogue: 0,0:05:32.78,0:05:36.82,中文,,0,0,0,,让我们看看能否通过做出好的选择来击败归并排序
Dialogue: 0,0:05:36.82,0:05:38.58,英文,,0,0,0,,So here's my first attempt.
Dialogue: 0,0:05:36.82,0:05:38.58,中文,,0,0,0,,这是我的第一次尝试
Dialogue: 0,0:05:38.58,0:05:39.60,英文,,0,0,0,,What pivot will I choose?
Dialogue: 0,0:05:38.58,0:05:39.60,中文,,0,0,0,,我会选择哪个枢轴？
Dialogue: 0,0:05:39.60,0:05:42.20,英文,,0,0,0,,I will always choose the leftmost item.
Dialogue: 0,0:05:39.60,0:05:42.20,中文,,0,0,0,,我将始终选择最左侧的项
Dialogue: 0,0:05:42.20,0:05:43.68,英文,,0,0,0,,That's what I'm choosing.
Dialogue: 0,0:05:42.20,0:05:43.68,中文,,0,0,0,,那就是我的选择
Dialogue: 0,0:05:43.68,0:05:45.44,英文,,0,0,0,,What partition algorithm will I use?
Dialogue: 0,0:05:43.68,0:05:45.44,中文,,0,0,0,,我将使用哪种分区算法？
Dialogue: 0,0:05:45.44,0:05:53.83,英文,,0,0,0,,I'll use the three scan approach from last time that that other guy came up with, where you scan for all the items that are less than the pivot and you copy them over.
Dialogue: 0,0:05:45.44,0:05:53.83,中文,,0,0,0,,我将使用上次那个家伙想出的三扫描方法  扫描所有小于枢轴的项并将它们复制过来
Dialogue: 0,0:05:53.83,0:05:56.63,英文,,0,0,0,,Then you scan again for all the items that are equal.
Dialogue: 0,0:05:53.83,0:05:56.63,中文,,0,0,0,,然后再次扫描所有相等的项
Dialogue: 0,0:05:56.63,0:05:59.11,英文,,0,0,0,,You scan again for all the items that are greater than.
Dialogue: 0,0:05:56.63,0:05:59.11,中文,,0,0,0,,你再次扫描所有大于的项目
Dialogue: 0,0:05:59.11,0:06:00.81,英文,,0,0,0,,And how do I avoid the worst case?
Dialogue: 0,0:05:59.11,0:06:00.81,中文,,0,0,0,,如何避免最坏情况？
Dialogue: 0,0:06:00.81,0:06:02.94,英文,,0,0,0,,I will choose the shuffle.
Dialogue: 0,0:06:00.81,0:06:02.94,中文,,0,0,0,,我将选择随机排序
Dialogue: 0,0:06:02.94,0:06:05.34,英文,,0,0,0,,If you don't like this, you choose something else.
Dialogue: 0,0:06:02.94,0:06:05.34,中文,,0,0,0,,如果你不喜欢这个  可以选择其他方法
Dialogue: 0,0:06:05.34,0:06:07.33,英文,,0,0,0,,But that's what I'll choose for now.
Dialogue: 0,0:06:05.34,0:06:07.33,中文,,0,0,0,,但现在我选择这个
Dialogue: 0,0:06:07.33,0:06:16.76,英文,,0,0,0,,So if I choose this and I run the experiment, I sort a bunch of numbers and I time how long it takes, Merge Sort takes 1.3 seconds to sort all of my numbers.
Dialogue: 0,0:06:07.33,0:06:16.76,中文,,0,0,0,,如果我选择这个并运行实验  我对一堆数字进行排序并计时  归并排序需要1.3秒来排序所有数字
Dialogue: 0,0:06:16.76,0:06:19.74,英文,,0,0,0,,Quick Sort takes 3.2 seconds.
Dialogue: 0,0:06:16.76,0:06:19.74,中文,,0,0,0,,快速排序需要3.2秒
Dialogue: 0,0:06:19.74,0:06:22.76,英文,,0,0,0,,Wait a minute, you told me Quick Sort is faster.
Dialogue: 0,0:06:19.74,0:06:22.76,中文,,0,0,0,,等等  你告诉我快速排序更快
Dialogue: 0,0:06:22.76,0:06:25.92,英文,,0,0,0,,You liar. So why is quicksort so much slower?
Dialogue: 0,0:06:22.76,0:06:25.92,中文,,0,0,0,,你这个骗子   为什么快速排序这么慢？
Dialogue: 0,0:06:25.92,0:06:33.35,英文,,0,0,0,,Well, that's because maybe we didn't choose the best or optimal ways to partition or select the pivot or avoid the worst case.
Dialogue: 0,0:06:25.92,0:06:33.35,中文,,0,0,0,,嗯  那是因为我们可能没有选择最佳或最优的方式来分区或选择枢轴或避免最坏情况
Dialogue: 0,0:06:33.35,0:06:39.39,英文,,0,0,0,,So maybe by changing some of these choices as we implement the algorithm, we can get this number down.
Dialogue: 0,0:06:33.35,0:06:39.39,中文,,0,0,0,,也许通过在我们实现算法时改变其中一些选择  我们可以降低这个数字
Dialogue: 0,0:06:39.39,0:06:43.09,英文,,0,0,0,,But are we at least convinced that this is one possible way to do quicksort?
Dialogue: 0,0:06:39.39,0:06:43.09,中文,,0,0,0,,但我们至少确信这是快速排序的一种可能方式吗？
Dialogue: 0,0:06:43.09,0:06:45.67,英文,,0,0,0,,Maybe we can do better?
Dialogue: 0,0:06:43.09,0:06:45.67,中文,,0,0,0,,也许我们可以做得更好？
Dialogue: 0,0:06:45.67,0:06:47.26,英文,,0,0,0,,Okay, so it's still quicksort.
Dialogue: 0,0:06:45.67,0:06:47.26,中文,,0,0,0,,好的  所以它仍然是快速排序
Dialogue: 0,0:06:47.26,0:06:47.76,英文,,0,0,0,,It works.
Dialogue: 0,0:06:47.26,0:06:47.76,中文,,0,0,0,,它起作用了
Dialogue: 0,0:06:47.76,0:06:50.10,英文,,0,0,0,,It's n log n with very high probability.
Dialogue: 0,0:06:47.76,0:06:50.10,中文,,0,0,0,,它以非常高的概率是 N log N
Dialogue: 0,0:06:50.10,0:06:54.04,英文,,0,0,0,,It just turns out in real life to be a little slower than mergesort.
Dialogue: 0,0:06:50.10,0:06:54.04,中文,,0,0,0,,结果证明在现实生活中它比归并排序要慢一些
Dialogue: 0,0:06:54.04,0:07:01.80,英文,,0,0,0,,So one thing I don't like about this particular choice of implementation, I don't like this 3-scan.
Dialogue: 0,0:06:54.04,0:07:01.80,中文,,0,0,0,,所以我不喜欢这种特定实现选择的一件事是  我不喜欢这个 3 次扫描
Dialogue: 0,0:07:01.80,0:07:04.20,英文,,0,0,0,,That other guy, he came up with the 3-scan approach.
Dialogue: 0,0:07:01.80,0:07:04.20,中文,,0,0,0,,那个家伙  他想出了 3 次扫描的方法
Dialogue: 0,0:07:04.20,0:07:10.08,英文,,0,0,0,,I don't like it, because you have to check the array once, twice, three times to copy everything.
Dialogue: 0,0:07:04.20,0:07:10.08,中文,,0,0,0,,我不喜欢它  因为你必须检查数组一次、两次、三次才能复制所有内容
Dialogue: 0,0:07:10.08,0:07:15.34,英文,,0,0,0,,And well, that's probably slower, and maybe there's a better partition algorithm out there.
Dialogue: 0,0:07:10.08,0:07:15.34,中文,,0,0,0,,嗯  那可能比较慢  也许还有更好的分区算法
Dialogue: 0,0:07:15.34,0:07:21.64,英文,,0,0,0,,So now I'm going to show you the partition algorithm that the other guy could not have come up with, which is an in-place
Dialogue: 0,0:07:15.34,0:07:21.64,中文,,0,0,0,,所以现在我要展示那个家伙想不出来的分区算法  这是一个就地算法
Dialogue: 0,0:07:21.64,0:07:33.59,英文,,0,0,0,,This turns out to also be the thing that Tony Hoare came up with.
Dialogue: 0,0:07:21.64,0:07:33.59,中文,,0,0,0,,结果证明这也是 Tony Hoare 想出来的算法
Dialogue: 0,0:07:33.59,0:07:38.98,英文,,0,0,0,,So Tony Hoare, this rookie programmer, somehow not only came up with QuickSort on his first try,
Dialogue: 0,0:07:33.59,0:07:38.98,中文,,0,0,0,,所以 Tony Hoare  这位菜鸟程序员  不仅第一次尝试就提出了快速排序算法
Dialogue: 0,0:07:38.98,0:07:44.72,英文,,0,0,0,,but also came up with this very strange partitioning scheme that works, because Tony and I, we think alike.
Dialogue: 0,0:07:38.98,0:07:44.72,中文,,0,0,0,,而且还提出了这种非常奇怪的分区方案  因为 Tony 和我  我们想法一样
Dialogue: 0,0:07:44.72,0:07:50.32,英文,,0,0,0,,We see the vision, and we're going to show you a very cool in-place partitioning scheme.
Dialogue: 0,0:07:44.72,0:07:50.32,中文,,0,0,0,,我们看到了愿景  我们将向你展示一个非常酷的就地分区方案
Dialogue: 0,0:07:50.32,0:07:51.78,英文,,0,0,0,,So that's the plan.
Dialogue: 0,0:07:50.32,0:07:51.78,中文,,0,0,0,,这就是计划
Dialogue: 0,0:07:51.78,0:08:00.33,英文,,0,0,0,,Okay, so the big idea is we're gonna have two pointers, and here I'll just represent the pointers as numbers that point at certain indices in the array.
Dialogue: 0,0:07:51.78,0:08:00.33,中文,,0,0,0,,好的  所以我们的主要想法是我们将有两个指针  在这里我将指针表示为指向数组中特定索引的数字
Dialogue: 0,0:08:00.33,0:08:02.10,英文,,0,0,0,,It'll make more sense with the picture.
Dialogue: 0,0:08:00.33,0:08:02.10,中文,,0,0,0,,有了图片会更容易理解
Dialogue: 0,0:08:02.10,0:08:06.14,英文,,0,0,0,,And the idea is the pointers will walk toward each other, swapping items they don't like.
Dialogue: 0,0:08:02.10,0:08:06.14,中文,,0,0,0,,我们的想法是让指针相互靠近  交换它们不喜欢的项
Dialogue: 0,0:08:06.14,0:08:09.06,英文,,0,0,0,,I think this makes more sense once you see the story.
Dialogue: 0,0:08:06.14,0:08:09.06,中文,,0,0,0,,我认为一旦你看到故事  就会更容易理解
Dialogue: 0,0:08:09.06,0:08:10.96,英文,,0,0,0,,So I will have two pointers.
Dialogue: 0,0:08:09.06,0:08:10.96,中文,,0,0,0,,所以我将有两个指针
Dialogue: 0,0:08:10.96,0:08:13.27,英文,,0,0,0,,I guess to start, I will choose a pivot.
Dialogue: 0,0:08:10.96,0:08:13.27,中文,,0,0,0,,我想首先  我会选择一个基准
Dialogue: 0,0:08:13.27,0:08:15.91,英文,,0,0,0,,Here I'm choosing the leftmost item, which is 17.
Dialogue: 0,0:08:13.27,0:08:15.91,中文,,0,0,0,,在这里我选择最左边的项  也就是 17
Dialogue: 0,0:08:15.91,0:08:17.37,英文,,0,0,0,,You could have chosen something else.
Dialogue: 0,0:08:15.91,0:08:17.37,中文,,0,0,0,,你也可以选择其他的
Dialogue: 0,0:08:17.37,0:08:19.95,英文,,0,0,0,,But I chose 17 to be the pivot.
Dialogue: 0,0:08:17.37,0:08:19.95,中文,,0,0,0,,但我选择 17 作为基准
Dialogue: 0,0:08:19.95,0:08:26.80,英文,,0,0,0,,Just for our human eyes, I'll color everything greater than the pivot to be red, everything less than the pivot to be blue.
Dialogue: 0,0:08:19.95,0:08:26.80,中文,,0,0,0,,为了方便我们观察  我将把所有大于基准的元素涂成红色  所有小于基准的元素涂成蓝色
Dialogue: 0,0:08:26.80,0:08:29.30,英文,,0,0,0,,But there's nothing special about those colors.
Dialogue: 0,0:08:26.80,0:08:29.30,中文,,0,0,0,,但是这些颜色没有什么特别的意义
Dialogue: 0,0:08:29.30,0:08:33.38,英文,,0,0,0,,I just want to remind myself what's less than the pivot, what's greater than the pivot.
Dialogue: 0,0:08:29.30,0:08:33.38,中文,,0,0,0,,我只是想提醒自己哪些元素小于基准  哪些元素大于基准
Dialogue: 0,0:08:33.38,0:08:35.32,英文,,0,0,0,,So I will create two pointers.
Dialogue: 0,0:08:33.38,0:08:35.32,中文,,0,0,0,,所以我将创建两个指针
Dialogue: 0,0:08:35.32,0:08:39.52,英文,,0,0,0,,One pointer is named L, and it starts on the left side of the array.
Dialogue: 0,0:08:35.32,0:08:39.52,中文,,0,0,0,,有一个指针叫做L  它从数组的左侧开始
Dialogue: 0,0:08:39.52,0:08:44.38,英文,,0,0,0,,L is a friend to small items, and it dislikes items that are large or equal.
Dialogue: 0,0:08:39.52,0:08:44.38,中文,,0,0,0,, L 喜欢较小的元素  不喜欢较大或相等的元素
Dialogue: 0,0:08:44.38,0:08:47.63,英文,,0,0,0,,Then I'll create another pointer called G, starts at the right side.
Dialogue: 0,0:08:44.38,0:08:47.63,中文,,0,0,0,,然后我创建另一个指针叫做 G   它从右侧开始
Dialogue: 0,0:08:47.63,0:08:52.41,英文,,0,0,0,,G is a friend to large items, and it hates items that are small or equal.
Dialogue: 0,0:08:47.63,0:08:52.41,中文,,0,0,0,, G 喜欢较大的元素  讨厌较小或相等的元素
Dialogue: 0,0:08:52.41,0:08:54.83,英文,,0,0,0,,And these pointers will walk toward each other.
Dialogue: 0,0:08:52.41,0:08:54.83,中文,,0,0,0,,这些指针会向彼此移动
Dialogue: 0,0:08:54.83,0:08:58.91,英文,,0,0,0,,Anytime they see an item they don't like, they will stop and stop moving.
Dialogue: 0,0:08:54.83,0:08:58.91,中文,,0,0,0,,每当它们看到不喜欢的元素时  它们就会停下来
Dialogue: 0,0:08:58.91,0:09:01.87,英文,,0,0,0,,As soon as both pointers stop moving, they will swap.
Dialogue: 0,0:08:58.91,0:09:01.87,中文,,0,0,0,,一旦两个指针都停止移动  它们就会交换位置
Dialogue: 0,0:09:01.87,0:09:05.03,英文,,0,0,0,,This will make more sense once I show you the story.
Dialogue: 0,0:09:01.87,0:09:05.03,中文,,0,0,0,,当我向你展示这个过程时  你会更明白
Dialogue: 0,0:09:05.03,0:09:07.07,英文,,0,0,0,,So let's start with L. It starts here.
Dialogue: 0,0:09:05.03,0:09:07.07,中文,,0,0,0,,让我们从 L 开始  它从这里开始
Dialogue: 0,0:09:07.07,0:09:09.57,英文,,0,0,0,,And remember, L is a friend to small items.
Dialogue: 0,0:09:07.07,0:09:09.57,中文,,0,0,0,,记住   L 喜欢较小的元素
Dialogue: 0,0:09:09.57,0:09:16.02,英文,,0,0,0,,So if it sees an item that's less than 17, and here by small, I mean small compared to the pivot, then L is happy.
Dialogue: 0,0:09:09.57,0:09:16.02,中文,,0,0,0,,所以如果它看到一个小于17的元素  这里的小是指与基准值相比小  那么 L 会很开心
Dialogue: 0,0:09:16.02,0:09:20.88,英文,,0,0,0,,And if it sees an item that's equal to 17 or larger than 17, then it gets cranky.
Dialogue: 0,0:09:16.02,0:09:20.88,中文,,0,0,0,,如果它看到一个等于或大于17的元素  它就会生气
Dialogue: 0,0:09:20.88,0:09:22.24,英文,,0,0,0,,So here we go.
Dialogue: 0,0:09:20.88,0:09:22.24,中文,,0,0,0,,好的  我们开始吧
Dialogue: 0,0:09:22.24,0:09:23.38,英文,,0,0,0,,L sees 15.
Dialogue: 0,0:09:22.24,0:09:23.38,中文,,0,0,0,, L 看到15
Dialogue: 0,0:09:23.38,0:09:24.06,英文,,0,0,0,,What does L think of 15?
Dialogue: 0,0:09:23.38,0:09:24.06,中文,,0,0,0,, L 对15怎么看？
Dialogue: 0,0:09:24.06,0:09:26.22,英文,,0,0,0,,Is it a friend to 15?
Dialogue: 0,0:09:24.06,0:09:26.22,中文,,0,0,0,,它是15的朋友吗？
Dialogue: 0,0:09:26.22,0:09:28.12,英文,,0,0,0,,Is it like an enemy of 15?
Dialogue: 0,0:09:26.22,0:09:28.12,中文,,0,0,0,,它是15的敌人吗？
Dialogue: 0,0:09:28.12,0:09:30.04,英文,,0,0,0,,I think L is a friend of 15.
Dialogue: 0,0:09:28.12,0:09:30.04,中文,,0,0,0,,我认为 L 是15的朋友
Dialogue: 0,0:09:30.04,0:09:31.58,英文,,0,0,0,,So it says, hello, lovely 15.
Dialogue: 0,0:09:30.04,0:09:31.58,中文,,0,0,0,,所以它说  你好  可爱的15
Dialogue: 0,0:09:31.58,0:09:33.96,英文,,0,0,0,,It's a friend to 15.
Dialogue: 0,0:09:31.58,0:09:33.96,中文,,0,0,0,,它是15的朋友
Dialogue: 0,0:09:33.96,0:09:34.87,英文,,0,0,0,,And so we keep stepping.
Dialogue: 0,0:09:33.96,0:09:34.87,中文,,0,0,0,,所以我们继续前进
Dialogue: 0,0:09:34.87,0:09:36.13,英文,,0,0,0,,We keep going forward.
Dialogue: 0,0:09:34.87,0:09:36.13,中文,,0,0,0,,我们继续往前走
Dialogue: 0,0:09:36.13,0:09:38.63,英文,,0,0,0,,And it goes to the next item, which will be 19.
Dialogue: 0,0:09:36.13,0:09:38.63,中文,,0,0,0,,然后它指向下一个元素  也就是 19
Dialogue: 0,0:09:38.63,0:09:41.29,英文,,0,0,0,,Is L a friend of 19?
Dialogue: 0,0:09:38.63,0:09:41.29,中文,,0,0,0,, L  喜欢 19 吗？
Dialogue: 0,0:09:41.29,0:09:42.15,英文,,0,0,0,,No.
Dialogue: 0,0:09:41.29,0:09:42.15,中文,,0,0,0,,不喜欢
Dialogue: 0,0:09:42.15,0:09:43.47,英文,,0,0,0,,And so it looks like, grr, 19.
Dialogue: 0,0:09:42.15,0:09:43.47,中文,,0,0,0,,所以它看起来像  呃  19
Dialogue: 0,0:09:43.47,0:09:45.05,英文,,0,0,0,,It's like me when I see the other guy.
Dialogue: 0,0:09:43.47,0:09:45.05,中文,,0,0,0,,就像我看到另一个家伙一样
Dialogue: 0,0:09:45.05,0:09:46.29,英文,,0,0,0,,Grr, I don't like him.
Dialogue: 0,0:09:45.05,0:09:46.29,中文,,0,0,0,,呃  我不喜欢他
Dialogue: 0,0:09:46.29,0:09:48.01,英文,,0,0,0,,And so I see this 19.
Dialogue: 0,0:09:46.29,0:09:48.01,中文,,0,0,0,,所以我看到这个 19
Dialogue: 0,0:09:48.01,0:09:49.53,英文,,0,0,0,,I don't like it.
Dialogue: 0,0:09:48.01,0:09:49.53,中文,,0,0,0,,我不喜欢它
Dialogue: 0,0:09:49.53,0:09:50.75,英文,,0,0,0,,So I stop.
Dialogue: 0,0:09:49.53,0:09:50.75,中文,,0,0,0,,所以我停下来
Dialogue: 0,0:09:50.75,0:09:51.38,英文,,0,0,0,,And I stop here.
Dialogue: 0,0:09:50.75,0:09:51.38,中文,,0,0,0,,我在这里停下来
Dialogue: 0,0:09:51.38,0:09:55.63,英文,,0,0,0,,And I wait, because I've stopped on an item that I don't like.
Dialogue: 0,0:09:51.38,0:09:55.63,中文,,0,0,0,,然后我等待  因为我停在一个我不喜欢的元素上
Dialogue: 0,0:09:55.63,0:09:58.73,英文,,0,0,0,,Now I go to G. So now it's time for G to start walking.
Dialogue: 0,0:09:55.63,0:09:58.73,中文,,0,0,0,,现在轮到 G 了  现在 G 开始走了
Dialogue: 0,0:09:58.73,0:10:03.56,英文,,0,0,0,,And G immediately spots trouble, because it says, do I like 17?
Dialogue: 0,0:09:58.73,0:10:03.56,中文,,0,0,0,,G 马上就发现了麻烦  因为它说  我喜欢 17 吗？
Dialogue: 0,0:10:03.56,0:10:07.96,英文,,0,0,0,,I don't, because I do not like items that are smaller than or equal to 17.
Dialogue: 0,0:10:03.56,0:10:07.96,中文,,0,0,0,,我不喜欢  因为我不喜欢小于或等于 17 的元素
Dialogue: 0,0:10:07.96,0:10:10.30,英文,,0,0,0,,So L walked until it stopped.
Dialogue: 0,0:10:07.96,0:10:10.30,中文,,0,0,0,,所以 L 一直走到停下来
Dialogue: 0,0:10:10.30,0:10:12.16,英文,,0,0,0,,The G walked until it stopped.
Dialogue: 0,0:10:10.30,0:10:12.16,中文,,0,0,0,,G 也一直走到停下来
Dialogue: 0,0:10:12.16,0:10:14.68,英文,,0,0,0,,In this case, it didn't walk at all before stopping.
Dialogue: 0,0:10:12.16,0:10:14.68,中文,,0,0,0,,在这种情况下  它还没开始走就停下来了
Dialogue: 0,0:10:14.68,0:10:20.73,英文,,0,0,0,,So now L and G, they both have problems, which is they're both staring at an item they dislike.
Dialogue: 0,0:10:14.68,0:10:20.73,中文,,0,0,0,,所以现在 L 和 G  他们都遇到了问题  也就是他们都盯着一个他们不喜欢的元素
Dialogue: 0,0:10:20.73,0:10:23.15,英文,,0,0,0,,So how do they solve this problem?
Dialogue: 0,0:10:20.73,0:10:23.15,中文,,0,0,0,,他们如何解决这个问题呢？
Dialogue: 0,0:10:23.15,0:10:26.57,英文,,0,0,0,,Well, all they have to do is swap their items.
Dialogue: 0,0:10:23.15,0:10:26.57,中文,,0,0,0,,嗯  他们只需要交换物品
Dialogue: 0,0:10:26.57,0:10:28.85,英文,,0,0,0,,So L says, this 19 sucks.
Dialogue: 0,0:10:26.57,0:10:28.85,中文,,0,0,0,,所以 L 说  这个19太烂了
Dialogue: 0,0:10:28.85,0:10:29.63,英文,,0,0,0,,Get it out of here.
Dialogue: 0,0:10:28.85,0:10:29.63,中文,,0,0,0,,把它拿走
Dialogue: 0,0:10:29.63,0:10:34.32,英文,,0,0,0,,And it throws the 19 all the way to the other side of the array, where G is sitting.
Dialogue: 0,0:10:29.63,0:10:34.32,中文,,0,0,0,,然后它把19扔到数组的另一边   G 所在的位置
Dialogue: 0,0:10:34.32,0:10:37.94,英文,,0,0,0,,And G looks at the 17 and says, I don't like you. Get out of here.
Dialogue: 0,0:10:34.32,0:10:37.94,中文,,0,0,0,, G 看着17说  我不喜欢你   滚开
Dialogue: 0,0:10:37.94,0:10:42.22,英文,,0,0,0,,And the 17 gets tossed all the way over to where the L is.
Dialogue: 0,0:10:37.94,0:10:42.22,中文,,0,0,0,,然后17被扔到 L 所在的位置
Dialogue: 0,0:10:42.22,0:10:48.82,英文,,0,0,0,,So if you watch what happens next, the 19 that the L is on and the 17 that the G is on, they swap.
Dialogue: 0,0:10:42.22,0:10:48.82,中文,,0,0,0,,所以如果你观察接下来发生的事情   L 所在的19和 G 所在的17  它们交换了
Dialogue: 0,0:10:48.82,0:10:52.61,英文,,0,0,0,,So they both do not like 19 and 17, so they swap.
Dialogue: 0,0:10:48.82,0:10:52.61,中文,,0,0,0,,他们都不喜欢19和17  所以他们交换了
Dialogue: 0,0:10:52.61,0:10:55.59,英文,,0,0,0,,So the 17 and the 19 swapped.
Dialogue: 0,0:10:52.61,0:10:55.59,中文,,0,0,0,,所以17和19交换了
Dialogue: 0,0:10:55.59,0:11:02.97,英文,,0,0,0,,And as they swap, they will also take a step forward because now the 17 and 19 are items that they like.
Dialogue: 0,0:10:55.59,0:11:02.97,中文,,0,0,0,,当他们交换时  他们也会向前迈进一步  因为现在17和19是他们喜欢的物品
Dialogue: 0,0:11:02.97,0:11:03.95,英文,,0,0,0,,So that's kind of the idea.
Dialogue: 0,0:11:02.97,0:11:03.95,中文,,0,0,0,,所以这就是大概的想法
Dialogue: 0,0:11:03.95,0:11:05.18,英文,,0,0,0,,They walk toward each other.
Dialogue: 0,0:11:03.95,0:11:05.18,中文,,0,0,0,,他们互相走向对方
Dialogue: 0,0:11:05.18,0:11:08.39,英文,,0,0,0,,Anytime they see an item they don't like, they swap.
Dialogue: 0,0:11:05.18,0:11:08.39,中文,,0,0,0,,每当他们看到不喜欢的东西  就交换
Dialogue: 0,0:11:08.39,0:11:09.73,英文,,0,0,0,,So let's keep going.
Dialogue: 0,0:11:08.39,0:11:09.73,中文,,0,0,0,,所以让我们继续吧
Dialogue: 0,0:11:09.73,0:11:10.75,英文,,0,0,0,,They've now swapped.
Dialogue: 0,0:11:09.73,0:11:10.75,中文,,0,0,0,,他们现在已经交换了
Dialogue: 0,0:11:10.75,0:11:12.59,英文,,0,0,0,,Are we good with the first swap?
Dialogue: 0,0:11:10.75,0:11:12.59,中文,,0,0,0,,第一次交换可以吗？
Dialogue: 0,0:11:12.59,0:11:13.91,英文,,0,0,0,,Have I messed anything up yet?
Dialogue: 0,0:11:12.59,0:11:13.91,中文,,0,0,0,,我搞砸什么了吗？
Dialogue: 0,0:11:13.91,0:11:15.79,英文,,0,0,0,,Okay, so now let's keep walking.
Dialogue: 0,0:11:13.91,0:11:15.79,中文,,0,0,0,,好的  现在让我们继续走
Dialogue: 0,0:11:15.79,0:11:23.15,英文,,0,0,0,,So we start at the L, and remember, L is a friend to small items, so L sees the 32, and what does the L think?
Dialogue: 0,0:11:15.79,0:11:23.15,中文,,0,0,0,,我们从 L 开始  记住   L 喜欢小东西  所以 L 看到32  它会怎么想？
Dialogue: 0,0:11:23.15,0:11:24.11,英文,,0,0,0,,Doesn't like it.
Dialogue: 0,0:11:23.15,0:11:24.11,中文,,0,0,0,,不喜欢
Dialogue: 0,0:11:24.11,0:11:25.43,英文,,0,0,0,,Media trouble.
Dialogue: 0,0:11:24.11,0:11:25.43,中文,,0,0,0,,遇到麻烦了
Dialogue: 0,0:11:25.43,0:11:26.73,英文,,0,0,0,,Don't like the 32.
Dialogue: 0,0:11:25.43,0:11:26.73,中文,,0,0,0,,不喜欢32
Dialogue: 0,0:11:26.73,0:11:27.99,英文,,0,0,0,,What about the G?
Dialogue: 0,0:11:26.73,0:11:27.99,中文,,0,0,0,,那 G 呢？
Dialogue: 0,0:11:27.99,0:11:29.53,英文,,0,0,0,,Remember, G starts walking.
Dialogue: 0,0:11:27.99,0:11:29.53,中文,,0,0,0,,记住   G 开始移动
Dialogue: 0,0:11:29.53,0:11:31.65,英文,,0,0,0,,It doesn't like small items or equal items.
Dialogue: 0,0:11:29.53,0:11:31.65,中文,,0,0,0,,它不喜欢小东西或相等的东西
Dialogue: 0,0:11:31.65,0:11:34.19,英文,,0,0,0,,And so it looks here, and it says, nope.
Dialogue: 0,0:11:31.65,0:11:34.19,中文,,0,0,0,,所以它看这里  然后说  不行
Dialogue: 0,0:11:34.19,0:11:35.15,英文,,0,0,0,,Also trouble here.
Dialogue: 0,0:11:34.19,0:11:35.15,中文,,0,0,0,,这里也有麻烦
Dialogue: 0,0:11:35.15,0:11:35.63,英文,,0,0,0,,I don't like the 17.
Dialogue: 0,0:11:35.15,0:11:35.63,中文,,0,0,0,,我不喜欢17
Dialogue: 0,0:11:35.63,0:11:41.13,英文,,0,0,0,,So because both of them have stopped on items they don't like, it's time for them to swap.
Dialogue: 0,0:11:35.63,0:11:41.13,中文,,0,0,0,,因为它们都停在不喜欢的东西上  所以是时候交换了
Dialogue: 0,0:11:41.13,0:11:47.05,英文,,0,0,0,,So the 17 and the 32 will swap, and the L and the G will move toward each other.
Dialogue: 0,0:11:41.13,0:11:47.05,中文,,0,0,0,,所以17和32会交换   L 和 G 会互相靠近
Dialogue: 0,0:11:47.05,0:11:48.90,英文,,0,0,0,,And we keep going.
Dialogue: 0,0:11:47.05,0:11:48.90,中文,,0,0,0,,然后我们继续
Dialogue: 0,0:11:48.90,0:11:51.40,英文,,0,0,0,,So now this L looks, and it sees the 2.
Dialogue: 0,0:11:48.90,0:11:51.40,中文,,0,0,0,,现在这个 L 看到了2
Dialogue: 0,0:11:51.40,0:11:52.97,英文,,0,0,0,,What does it think about 2?
Dialogue: 0,0:11:51.40,0:11:52.97,中文,,0,0,0,,它觉得2怎么样？
Dialogue: 0,0:11:52.97,0:11:54.31,英文,,0,0,0,,It likes it. It's a lovely 2.
Dialogue: 0,0:11:52.97,0:11:54.31,中文,,0,0,0,,它喜欢   这是一个可爱的2
Dialogue: 0,0:11:54.31,0:11:55.11,英文,,0,0,0,,It's cool.
Dialogue: 0,0:11:54.31,0:11:55.11,中文,,0,0,0,,很酷
Dialogue: 0,0:11:55.11,0:11:55.89,英文,,0,0,0,,OK, good.
Dialogue: 0,0:11:55.11,0:11:55.89,中文,,0,0,0,,好的  很好
Dialogue: 0,0:11:55.89,0:11:57.69,英文,,0,0,0,,And then what about the G?
Dialogue: 0,0:11:55.89,0:11:57.69,中文,,0,0,0,,那 G 呢？
Dialogue: 0,0:11:57.69,0:11:59.97,英文,,0,0,0,,OK, I guess we will step the L further.
Dialogue: 0,0:11:57.69,0:11:59.97,中文,,0,0,0,,好  我们再把 L 往前挪
Dialogue: 0,0:11:59.97,0:12:04.90,英文,,0,0,0,,So L steps, then it sees the 26 and says, disgusting, it's large.
Dialogue: 0,0:11:59.97,0:12:04.90,中文,,0,0,0,, L 向前移动  看到了26  说：真恶心  太大了
Dialogue: 0,0:12:04.90,0:12:06.72,英文,,0,0,0,,So I'll stop there.
Dialogue: 0,0:12:04.90,0:12:06.72,中文,,0,0,0,,所以它就停在那儿
Dialogue: 0,0:12:06.72,0:12:08.44,英文,,0,0,0,,And then what about the G?
Dialogue: 0,0:12:06.72,0:12:08.44,中文,,0,0,0,,那 G 呢？
Dialogue: 0,0:12:08.44,0:12:11.40,英文,,0,0,0,,Well, it says the 41 is OK.
Dialogue: 0,0:12:08.44,0:12:11.40,中文,,0,0,0,, G 觉得41还可以
Dialogue: 0,0:12:11.40,0:12:17.20,英文,,0,0,0,,So the L has moved until it stopped. The G has moved until it stopped.
Dialogue: 0,0:12:11.40,0:12:17.20,中文,,0,0,0,,所以 L 移动到停下   G 也移动到停下
Dialogue: 0,0:12:17.20,0:12:19.00,英文,,0,0,0,,Or sorry, let me try that one more time.
Dialogue: 0,0:12:17.20,0:12:19.00,中文,,0,0,0,,抱歉  我再说一遍
Dialogue: 0,0:12:19.00,0:12:20.62,英文,,0,0,0,,OK, so they swapped.
Dialogue: 0,0:12:19.00,0:12:20.62,中文,,0,0,0,,它们交换了位置
Dialogue: 0,0:12:20.62,0:12:23.12,英文,,0,0,0,,Good. So the L is going to start walking.
Dialogue: 0,0:12:20.62,0:12:23.12,中文,,0,0,0,,很好   所以 L 要开始走了
Dialogue: 0,0:12:23.12,0:12:25.34,英文,,0,0,0,,And remember, L is a friend to small items.
Dialogue: 0,0:12:23.12,0:12:25.34,中文,,0,0,0,,记住   L 喜欢小数字
Dialogue: 0,0:12:25.34,0:12:26.10,英文,,0,0,0,,So it sees the 2.
Dialogue: 0,0:12:25.34,0:12:26.10,中文,,0,0,0,,它看到了2
Dialogue: 0,0:12:26.10,0:12:27.34,英文,,0,0,0,,It says, that's great.
Dialogue: 0,0:12:26.10,0:12:27.34,中文,,0,0,0,,说：太棒了
Dialogue: 0,0:12:27.34,0:12:28.18,英文,,0,0,0,,I walk.
Dialogue: 0,0:12:27.34,0:12:28.18,中文,,0,0,0,,我走
Dialogue: 0,0:12:28.18,0:12:28.90,英文,,0,0,0,,It sees the 26.
Dialogue: 0,0:12:28.18,0:12:28.90,中文,,0,0,0,,它看到了26
Dialogue: 0,0:12:28.90,0:12:30.78,英文,,0,0,0,,It says, don't like you.
Dialogue: 0,0:12:28.90,0:12:30.78,中文,,0,0,0,,说：不喜欢你
Dialogue: 0,0:12:30.78,0:12:32.16,英文,,0,0,0,,So it stops.
Dialogue: 0,0:12:30.78,0:12:32.16,中文,,0,0,0,,它就停下了
Dialogue: 0,0:12:32.16,0:12:34.24,英文,,0,0,0,,Then we look at the G.
Dialogue: 0,0:12:32.16,0:12:34.24,中文,,0,0,0,,然后我们看 G
Dialogue: 0,0:12:34.24,0:12:37.69,英文,,0,0,0,,And the G is going to start walking to the left until it sees an item it doesn't like.
Dialogue: 0,0:12:34.24,0:12:37.69,中文,,0,0,0,, G 要开始向左走  直到看到它不喜欢的数字
Dialogue: 0,0:12:37.69,0:12:39.61,英文,,0,0,0,,So it says, 41, you're cool.
Dialogue: 0,0:12:37.69,0:12:39.61,中文,,0,0,0,,它说  41  你很棒
Dialogue: 0,0:12:39.61,0:12:40.33,英文,,0,0,0,,I like you.
Dialogue: 0,0:12:39.61,0:12:40.33,中文,,0,0,0,,我喜欢你
Dialogue: 0,0:12:40.33,0:12:42.11,英文,,0,0,0,,You're greater than 17.
Dialogue: 0,0:12:40.33,0:12:42.11,中文,,0,0,0,,你比 17 大
Dialogue: 0,0:12:42.11,0:12:43.47,英文,,0,0,0,,26, I like you too.
Dialogue: 0,0:12:42.11,0:12:43.47,中文,,0,0,0,,26  我也喜欢你
Dialogue: 0,0:12:43.47,0:12:44.59,英文,,0,0,0,,You're greater than 17.
Dialogue: 0,0:12:43.47,0:12:44.59,中文,,0,0,0,,你比 17 大
Dialogue: 0,0:12:44.59,0:12:47.53,英文,,0,0,0,,2, I don't like you, but hold on.
Dialogue: 0,0:12:44.59,0:12:47.53,中文,,0,0,0,,2  我不喜欢你  但等等
Dialogue: 0,0:12:47.53,0:12:48.81,英文,,0,0,0,,We just crossed each other.
Dialogue: 0,0:12:47.53,0:12:48.81,中文,,0,0,0,,我们刚刚互相交叉了
Dialogue: 0,0:12:48.81,0:12:55.95,英文,,0,0,0,,Hello, L. So as soon as the pointers cross, that tells me that I have visited all the items, and I'm done.
Dialogue: 0,0:12:48.81,0:12:55.95,中文,,0,0,0,,你好  L  所以一旦指针交叉  就说明我已经访问了所有项目  并且完成了
Dialogue: 0,0:12:55.95,0:13:03.29,英文,,0,0,0,,So as soon as the L and the G swap places or they meet each other in the middle, that's when I know that everything's done.
Dialogue: 0,0:12:55.95,0:13:03.29,中文,,0,0,0,,所以一旦 L 和 G 交换位置或者他们在中间相遇  我就知道一切都完成了
Dialogue: 0,0:13:03.29,0:13:05.27,英文,,0,0,0,,OK, so they both walk toward each other.
Dialogue: 0,0:13:03.29,0:13:05.27,中文,,0,0,0,,好的  所以他们都朝对方走去
Dialogue: 0,0:13:05.27,0:13:08.19,英文,,0,0,0,,When they see an item they don't like, they swap.
Dialogue: 0,0:13:05.27,0:13:08.19,中文,,0,0,0,,当他们看到不喜欢的东西时  他们就会交换
Dialogue: 0,0:13:08.19,0:13:13.45,英文,,0,0,0,,And so at this point, is my array partitioned on 17?
Dialogue: 0,0:13:08.19,0:13:13.45,中文,,0,0,0,,那么在这一点上  我的数组是否以 17 为界进行分区？
Dialogue: 0,0:13:13.45,0:13:17.93,英文,,0,0,0,,Did I create an array where the 17 is in the right place, everything to the left is less than
Dialogue: 0,0:13:13.45,0:13:17.93,中文,,0,0,0,,我是否创建了一个数组  其中 17 在正确的位置
Dialogue: 0,0:13:17.93,0:13:23.41,英文,,0,0,0,,or equal to 17, everything to the right is greater than or equal to 17?
Dialogue: 0,0:13:17.93,0:13:23.41,中文,,0,0,0,,左侧的所有内容都小于或等于 17  右侧的所有内容都大于或等于 17？
Dialogue: 0,0:13:23.41,0:13:27.07,英文,,0,0,0,,Well, not really, because the 17 is still stuck in the front.
Dialogue: 0,0:13:23.41,0:13:27.07,中文,,0,0,0,,嗯  不完全是  因为 17 仍然卡在前面
Dialogue: 0,0:13:27.07,0:13:31.78,英文,,0,0,0,,Remember, for the partition to be valid, the 17 has to be in its correct place.
Dialogue: 0,0:13:27.07,0:13:31.78,中文,,0,0,0,,请记住  要使分区有效  17 必须在其正确的位置
Dialogue: 0,0:13:31.78,0:13:34.64,英文,,0,0,0,,And then everyone to the left has to be less than 17.
Dialogue: 0,0:13:31.78,0:13:34.64,中文,,0,0,0,,然后左边的人都必须小于 17
Dialogue: 0,0:13:34.64,0:13:36.12,英文,,0,0,0,,Everyone to the right has to be greater than 17.
Dialogue: 0,0:13:34.64,0:13:36.12,中文,,0,0,0,,右边的人都必须大于 17
Dialogue: 0,0:13:36.12,0:13:39.14,英文,,0,0,0,,So this 17 is still in the wrong place.
Dialogue: 0,0:13:36.12,0:13:39.14,中文,,0,0,0,,所以这个 17 仍然在错误的地方
Dialogue: 0,0:13:39.14,0:13:42.51,英文,,0,0,0,,So how do I get the 17 into the right place?
Dialogue: 0,0:13:39.14,0:13:42.51,中文,,0,0,0,,那么如何才能让 17 到达正确的位置呢？
Dialogue: 0,0:13:42.51,0:13:45.95,英文,,0,0,0,,Well, there's two possible traces of where I can put the 17.
Dialogue: 0,0:13:42.51,0:13:45.95,中文,,0,0,0,,嗯  我有两个可能的位置可以放置 17
Dialogue: 0,0:13:45.95,0:13:51.25,英文,,0,0,0,,I could maybe swap the 17 with G and put it right there, and then swap the 2 to the front.
Dialogue: 0,0:13:45.95,0:13:51.25,中文,,0,0,0,,也许我可以把 17 和 G 交换位置  把它放在那里  然后把 2 换到前面
Dialogue: 0,0:13:51.25,0:13:55.36,英文,,0,0,0,,Or I could swap the 17 with the L and then put the 26 at the front.
Dialogue: 0,0:13:51.25,0:13:55.36,中文,,0,0,0,,或者我可以把 17 和 L 交换位置  然后把 26 放在前面
Dialogue: 0,0:13:55.36,0:14:02.07,英文,,0,0,0,,So which do you like better if my goal is to put 17 in the right place and create a valid partition?
Dialogue: 0,0:13:55.36,0:14:02.07,中文,,0,0,0,,那么  如果我的目标是将 17 放在正确的位置并创建一个有效的分区  你更喜欢哪一种呢？
Dialogue: 0,0:14:02.07,0:14:05.06,英文,,0,0,0,,It is literally spoiled on the slide.
Dialogue: 0,0:14:02.07,0:14:05.06,中文,,0,0,0,,答案就在幻灯片上
Dialogue: 0,0:14:05.06,0:14:07.18,英文,,0,0,0,,You're like G, genius.
Dialogue: 0,0:14:05.06,0:14:07.18,中文,,0,0,0,,你是对的  天才
Dialogue: 0,0:14:07.18,0:14:08.38,英文,,0,0,0,,So I like G as well.
Dialogue: 0,0:14:07.18,0:14:08.38,中文,,0,0,0,,我也喜欢 G
Dialogue: 0,0:14:08.38,0:14:15.40,英文,,0,0,0,,If you take the 17 and you swap it with the 2, 17 and the 2 swap, well, then now the 17 is the pivot.
Dialogue: 0,0:14:08.38,0:14:15.40,中文,,0,0,0,,如果你把 17 和 2 交换位置  那么现在 17 就是支点
Dialogue: 0,0:14:15.40,0:14:16.74,英文,,0,0,0,,It's in the right place.
Dialogue: 0,0:14:15.40,0:14:16.74,中文,,0,0,0,,它在正确的位置
Dialogue: 0,0:14:16.74,0:14:18.82,英文,,0,0,0,,Everything to the left is less than or equal to 17.
Dialogue: 0,0:14:16.74,0:14:18.82,中文,,0,0,0,,左边的一切都小于或等于 17
Dialogue: 0,0:14:18.82,0:14:22.61,英文,,0,0,0,,Everything to the right is greater than or equal to 17.
Dialogue: 0,0:14:18.82,0:14:22.61,中文,,0,0,0,,右边的一切都大于或等于 17
Dialogue: 0,0:14:22.61,0:14:29.75,英文,,0,0,0,,And the reason why it shows G instead of L is because if I had chosen L, well, then the 17 would be in the wrong place.
Dialogue: 0,0:14:22.61,0:14:29.75,中文,,0,0,0,,它显示 G 而不是 L 的原因是  如果我选择了 L  那么 17 就放错了地方
Dialogue: 0,0:14:29.75,0:14:34.54,英文,,0,0,0,,So it just so happens, based on the invariance, that G was the right person to swap with
Dialogue: 0,0:14:29.75,0:14:34.54,中文,,0,0,0,,根据不变性  碰巧 G 是正确的交换对象
Dialogue: 0,0:14:34.54,0:14:39.56,英文,,0,0,0,,At the very end, that's word partitioning.
Dialogue: 0,0:14:34.54,0:14:39.56,中文,,0,0,0,,最后  这就是单词分区
Dialogue: 0,0:14:39.56,0:14:41.28,英文,,0,0,0,,How did he come up with this in the first try?
Dialogue: 0,0:14:39.56,0:14:41.28,中文,,0,0,0,,他是如何在第一次尝试中就想出这个方法的？
Dialogue: 0,0:14:41.28,0:14:42.82,英文,,0,0,0,,I don't know.
Dialogue: 0,0:14:41.28,0:14:42.82,中文,,0,0,0,,我不知道
Dialogue: 0,0:14:42.82,0:14:47.73,英文,,0,0,0,,So the invariant that I think makes the whole thing work, I think if you follow the story, you'll be all set.
Dialogue: 0,0:14:42.82,0:14:47.73,中文,,0,0,0,,所以我认为使整个过程有效的不变性是  如果你遵循这个故事  你就会明白
Dialogue: 0,0:14:47.73,0:14:51.27,英文,,0,0,0,,The invariant that really makes it work, if you just watch it,
Dialogue: 0,0:14:47.73,0:14:51.27,中文,,0,0,0,,真正起作用的不变性是  如果你只是看着它
Dialogue: 0,0:14:51.27,0:14:59.12,英文,,0,0,0,,Kind of in fast forward, is as L walks, so if you start L right here, as it's walking, one of two things can happen.
Dialogue: 0,0:14:51.27,0:14:59.12,中文,,0,0,0,,有点像快进  就像 L 走路一样  如果你让 L 从这里开始  当它走的时候  会发生两种情况之一
Dialogue: 0,0:14:59.12,0:15:06.47,英文,,0,0,0,,Either it sees a friend, so like here we saw the friend, 15, and we keep going, or we see someone we don't like.
Dialogue: 0,0:14:59.12,0:15:06.47,中文,,0,0,0,,要么它看到了一个朋友  就像我们在这里看到了朋友 15  然后继续前进  要么我们看到了一个我们不喜欢的人
Dialogue: 0,0:15:06.47,0:15:09.15,英文,,0,0,0,,In which case, we stop and wait for a swap.
Dialogue: 0,0:15:06.47,0:15:09.15,中文,,0,0,0,,在这种情况下  我们会停下来等待交换
Dialogue: 0,0:15:09.15,0:15:17.12,英文,,0,0,0,,So as L is scanning through potentially hundreds or thousands of items, it's leaving in its wake a path of destruction.
Dialogue: 0,0:15:09.15,0:15:17.12,中文,,0,0,0,,所以当 L 扫描成百上千个元素时  它所经之处留下了一片狼藉
Dialogue: 0,0:15:17.12,0:15:23.98,英文,,0,0,0,,And everything in L's wake behind it is only items that are smaller, because that was a friend to L, and it walked forward.
Dialogue: 0,0:15:17.12,0:15:23.98,中文,,0,0,0,,L 身后留下的所有元素都比它小  因为那些元素是 L 的朋友  它向前移动了
Dialogue: 0,0:15:23.98,0:15:29.80,英文,,0,0,0,,Or it was an item that was larger, but L stopped there and swapped it, so now it's an item that's smaller.
Dialogue: 0,0:15:23.98,0:15:29.80,中文,,0,0,0,,或者它是一个更大的元素  但是 L 在那里停下来交换了它  所以现在它是一个更小的元素
Dialogue: 0,0:15:29.80,0:15:33.43,英文,,0,0,0,,So I don't know if that was the greatest way to explain it.
Dialogue: 0,0:15:29.80,0:15:33.43,中文,,0,0,0,,我不确定这是否是解释它的最佳方式
Dialogue: 0,0:15:33.43,0:15:35.95,英文,,0,0,0,,But basically, as L walks,
Dialogue: 0,0:15:33.43,0:15:35.95,中文,,0,0,0,,但基本上  当 L 移动时
Dialogue: 0,0:15:35.95,0:15:40.41,英文,,0,0,0,,Either it sees friends that it leaves behind, or it sees items that it doesn't like.
Dialogue: 0,0:15:35.95,0:15:40.41,中文,,0,0,0,,它要么看到它留下的朋友  要么看到它不喜欢的元素
Dialogue: 0,0:15:40.41,0:15:43.15,英文,,0,0,0,,And whenever that happens, there will be a swap that happens.
Dialogue: 0,0:15:40.41,0:15:43.15,中文,,0,0,0,,每当这种情况发生时  就会发生交换
Dialogue: 0,0:15:43.15,0:15:46.67,英文,,0,0,0,,So L is always leaving items that it likes behind it.
Dialogue: 0,0:15:43.15,0:15:46.67,中文,,0,0,0,,所以 L 总是把它喜欢的元素留在身后
Dialogue: 0,0:15:46.67,0:15:51.96,英文,,0,0,0,,And likewise with G, as it walks over, it is always leaving items that it likes behind it.
Dialogue: 0,0:15:46.67,0:15:51.96,中文,,0,0,0,,同样地  当 G 移动时  它也总是把它喜欢的元素留在身后
Dialogue: 0,0:15:51.96,0:16:00.02,英文,,0,0,0,,So when L and G meet in the middle and they swap, behind them are only items that are less than or greater than the pivot.
Dialogue: 0,0:15:51.96,0:16:00.02,中文,,0,0,0,,所以当 L 和 G 在中间相遇并交换时  它们身后只有小于或大于基准值的元素
Dialogue: 0,0:16:00.02,0:16:01.90,英文,,0,0,0,,That's how I know the scheme works.
Dialogue: 0,0:16:00.02,0:16:01.90,中文,,0,0,0,,这就是我知道这个方案有效的原因
Dialogue: 0,0:16:01.90,0:16:04.99,英文,,0,0,0,,That's the invariant that makes it work.
Dialogue: 0,0:16:01.90,0:16:04.99,中文,,0,0,0,,这就是使其生效的不变量
Dialogue: 0,0:16:04.99,0:16:21.97,英文,,0,0,0,,Yeah, question.
Dialogue: 0,0:16:04.99,0:16:21.97,中文,,0,0,0,,是的  提问
Dialogue: 0,0:16:21.97,0:16:28.12,英文,,0,0,0,,That's a good question, which is, and I think I should bring it up, which is, do the 17s all have to be in the middle?
Dialogue: 0,0:16:21.97,0:16:28.12,中文,,0,0,0,,这是一个很好的问题  我想我应该提出来  那就是  所有的 17 都必须在中间吗？
Dialogue: 0,0:16:28.12,0:16:28.74,英文,,0,0,0,,Not quite.
Dialogue: 0,0:16:28.12,0:16:28.74,中文,,0,0,0,,不完全是
Dialogue: 0,0:16:28.74,0:16:35.14,英文,,0,0,0,,If you remember the first partitioning slide that I ever showed you, it doesn't actually matter that all the 17s are bunched together.
Dialogue: 0,0:16:28.74,0:16:35.14,中文,,0,0,0,,如果你还记得我第一次给你展示的分区幻灯片  实际上所有 17 都聚集在一起并不重要
Dialogue: 0,0:16:35.14,0:16:38.95,英文,,0,0,0,,All that matters is that the 17 that I chose is in the right place.
Dialogue: 0,0:16:35.14,0:16:38.95,中文,,0,0,0,,重要的是我选择的 17 在正确的位置
Dialogue: 0,0:16:38.95,0:16:40.93,英文,,0,0,0,,Everything to the left is less than or equal to.
Dialogue: 0,0:16:38.95,0:16:40.93,中文,,0,0,0,,左边的一切都小于或等于它
Dialogue: 0,0:16:40.93,0:16:42.95,英文,,0,0,0,,Everything to the right is greater than or equal to.
Dialogue: 0,0:16:40.93,0:16:42.95,中文,,0,0,0,,右边的一切都大于或等于它
Dialogue: 0,0:16:42.95,0:16:45.09,英文,,0,0,0,,These 17s could have been like over here.
Dialogue: 0,0:16:42.95,0:16:45.09,中文,,0,0,0,,这些 17 可以像在这里一样
Dialogue: 0,0:16:45.09,0:16:46.29,英文,,0,0,0,,That's fine.
Dialogue: 0,0:16:45.09,0:16:46.29,中文,,0,0,0,,没问题
Dialogue: 0,0:16:46.29,0:16:48.51,英文,,0,0,0,,It's a great question, though.
Dialogue: 0,0:16:46.29,0:16:48.51,中文,,0,0,0,,不过这是个好问题
Dialogue: 0,0:16:48.51,0:16:49.57,英文,,0,0,0,,Anything else?
Dialogue: 0,0:16:48.51,0:16:49.57,中文,,0,0,0,,还有什么问题吗？
Dialogue: 0,0:16:49.57,0:16:52.74,英文,,0,0,0,,So it's not required that the 17s be bunched up.
Dialogue: 0,0:16:49.57,0:16:52.74,中文,,0,0,0,,所以17不需要扎堆在一起
Dialogue: 0,0:16:52.74,0:16:57.58,英文,,0,0,0,,All that I care about is the one pivot, the 17 has to be in the right place.
Dialogue: 0,0:16:52.74,0:16:57.58,中文,,0,0,0,,我关心的只有一个基准点  17必须在正确的位置
Dialogue: 0,0:16:57.58,0:16:59.04,英文,,0,0,0,,Anything else?
Dialogue: 0,0:16:57.58,0:16:59.04,中文,,0,0,0,,还有什么问题吗？
Dialogue: 0,0:16:59.04,0:17:00.51,英文,,0,0,0,,Okay.
Dialogue: 0,0:16:59.04,0:17:00.51,中文,,0,0,0,,好的
Dialogue: 0,0:17:00.51,0:17:07.47,英文,,0,0,0,,So it turns out if I take my old implementation where I use that other guy's 3-scan approach and I delete it
Dialogue: 0,0:17:00.51,0:17:07.47,中文,,0,0,0,,结果证明  如果我采用我之前的实现  使用那个家伙的三扫描方法  然后删除它
Dialogue: 0,0:17:07.47,0:17:12.47,英文,,0,0,0,,and I replace it with the smarter Tony Hoare partitioning scheme and I run the exact same experiment,
Dialogue: 0,0:17:07.47,0:17:12.47,中文,,0,0,0,,并用更智能的Tony Hoare分区方案替换它  然后运行完全相同的实验
Dialogue: 0,0:17:12.47,0:17:17.53,英文,,0,0,0,,I go from losing to merge sort by a couple of seconds to now beating merge sort.
Dialogue: 0,0:17:12.47,0:17:17.53,中文,,0,0,0,,我从输给归并排序几秒钟变成了现在击败归并排序
Dialogue: 0,0:17:17.53,0:17:23.58,英文,,0,0,0,,It now takes 0.9 seconds to sort and run my experiment, where merge sort took 1.3 seconds.
Dialogue: 0,0:17:17.53,0:17:23.58,中文,,0,0,0,,现在排序和运行我的实验需要0.9秒  而归并排序需要1.3秒
Dialogue: 0,0:17:23.58,0:17:24.46,英文,,0,0,0,,So we did it.
Dialogue: 0,0:17:23.58,0:17:24.46,中文,,0,0,0,,所以我们做到了
Dialogue: 0,0:17:24.46,0:17:28.33,英文,,0,0,0,,We made quicksort faster by using a better partitioning scheme.
Dialogue: 0,0:17:24.46,0:17:28.33,中文,,0,0,0,,我们通过使用更好的分区方案使快速排序更快
Dialogue: 0,0:17:28.33,0:17:29.53,英文,,0,0,0,,It's kind of cool.
Dialogue: 0,0:17:28.33,0:17:29.53,中文,,0,0,0,,这很酷
Dialogue: 0,0:17:29.53,0:17:32.24,英文,,0,0,0,,Turns out there are all sorts of different partitioning schemes out there.
Dialogue: 0,0:17:29.53,0:17:32.24,中文,,0,0,0,,事实证明  有各种不同的分区方案
Dialogue: 0,0:17:32.24,0:17:36.16,英文,,0,0,0,,There are people on like Java developer forums coming up with new ones all sorts of times.
Dialogue: 0,0:17:32.24,0:17:36.16,中文,,0,0,0,,在像Java开发者论坛上  人们会不断想出新的方案
Dialogue: 0,0:17:36.16,0:17:41.41,英文,,0,0,0,,So you can go and have fun and develop new partitioning schemes.
Dialogue: 0,0:17:36.16,0:17:41.41,中文,,0,0,0,,所以你可以去玩玩  开发新的分区方案
Dialogue: 0,0:17:41.41,0:17:44.25,英文,,0,0,0,,But those are the two that I will leave you with.
Dialogue: 0,0:17:41.41,0:17:44.25,中文,,0,0,0,,但这是我要留给你的两个
Dialogue: 0,0:17:44.25,0:17:45.29,英文,,0,0,0,,Any other things you want to know?
Dialogue: 0,0:17:44.25,0:17:45.29,中文,,0,0,0,,你还有什么想知道的吗？
Dialogue: 0,0:17:45.29,0:17:46.49,英文,,0,0,0,,One more.
Comment: 0,0:17:45.29,0:17:46.49,中文,,0,0,0,,还有一个
Dialogue: 0,0:17:56.77,0:17:57.91,英文,,0,0,0,,Yes, that's a great point.
Dialogue: 0,0:17:56.77,0:17:57.91,中文,,0,0,0,,是的  这是个好观点
Dialogue: 0,0:17:57.91,0:18:01.71,英文,,0,0,0,,So I'll repeat it, which is we didn't change the algorithmic complexity.
Dialogue: 0,0:17:57.91,0:18:01.71,中文,,0,0,0,,所以我要重复一遍  我们没有改变算法的复杂度
Dialogue: 0,0:18:01.71,0:18:05.14,英文,,0,0,0,,Both of these are n log n with very high probability.
Dialogue: 0,0:18:01.71,0:18:05.14,中文,,0,0,0,,这两种情况下的时间复杂度  以极高的概率都是 N  log N
Dialogue: 0,0:18:05.14,0:18:08.22,英文,,0,0,0,,The only thing we changed was some of the underlying constants.
Dialogue: 0,0:18:05.14,0:18:08.22,中文,,0,0,0,,我们只是改变了一些底层常数
Dialogue: 0,0:18:08.22,0:18:15.27,英文,,0,0,0,,And we don't look at those when we're doing analysis, like n log n. But in real life, is it faster to scan once instead of three times?
Dialogue: 0,0:18:08.22,0:18:15.27,中文,,0,0,0,,当我们做分析的时候  我们不考虑这些常数  比如 N  log N  但在实际生活中  扫描一次比扫描三次快吗？
Dialogue: 0,0:18:15.27,0:18:18.67,英文,,0,0,0,,It is. And that's where this three times speed up comes from.
Dialogue: 0,0:18:15.27,0:18:18.67,中文,,0,0,0,,是的   这就是这个三倍加速的来源
Dialogue: 0,0:18:18.67,0:18:23.88,英文,,0,0,0,,That's a great point. But if n grows really large, it's still n log n runtime.
Dialogue: 0,0:18:18.67,0:18:23.88,中文,,0,0,0,,说得好   但是如果 N 变得非常大  它仍然是 N  log N 的运行时间
Dialogue: 0,0:18:23.88,0:18:25.44,英文,,0,0,0,,We just knocked off a constant.
Dialogue: 0,0:18:23.88,0:18:25.44,中文,,0,0,0,,我们只是减少了一个常数
Dialogue: 0,0:18:25.44,0:18:26.80,英文,,0,0,0,,It's kind of cool.
Dialogue: 0,0:18:25.44,0:18:26.80,中文,,0,0,0,,这有点酷
Dialogue: 0,0:18:26.80,0:18:31.09,英文,,0,0,0,,Okay, we talked more about, so we talked about randomness.
Dialogue: 0,0:18:26.80,0:18:31.09,中文,,0,0,0,,好吧  我们更多地讨论了  所以我们讨论了随机性
Dialogue: 0,0:18:31.09,0:18:33.61,英文,,0,0,0,,Let's try some other strategies if you are ready.
Dialogue: 0,0:18:31.09,0:18:33.61,中文,,0,0,0,,如果你准备好了  我们来试试其他策略
Dialogue: 0,0:18:33.61,0:18:36.31,英文,,0,0,0,,Okay, so I'm gonna go to strategy number two.
Dialogue: 0,0:18:33.61,0:18:36.31,中文,,0,0,0,,好的  我要去策略二了
Dialogue: 0,0:18:36.31,0:18:40.31,英文,,0,0,0,,So I'm gonna keep experimenting with swapping some of these approaches in and out.
Dialogue: 0,0:18:36.31,0:18:40.31,中文,,0,0,0,,所以我会继续尝试交换其中一些方法
Dialogue: 0,0:18:40.31,0:18:43.03,英文,,0,0,0,,So this time, I'm gonna leave
Dialogue: 0,0:18:40.31,0:18:43.03,中文,,0,0,0,,所以这次  我要离开
Dialogue: 0,0:18:43.03,0:18:47.40,英文,,0,0,0,,The leftmost pivot, or I'm actually gonna change the leftmost pivot selection.
Dialogue: 0,0:18:43.03,0:18:47.40,中文,,0,0,0,,最左边的基准  或者我实际上要改变最左边的基准选择
Dialogue: 0,0:18:47.40,0:18:54.07,英文,,0,0,0,,Instead of choosing the leftmost item every single time, I am going to be smarter with my pivot selection.
Dialogue: 0,0:18:47.40,0:18:54.07,中文,,0,0,0,,与其每次都选择最左边的项  我将更明智地选择基准
Dialogue: 0,0:18:54.07,0:19:00.80,英文,,0,0,0,,So the thing I will do is let's pick the exact median and use that as the pivot.
Dialogue: 0,0:18:54.07,0:19:00.80,中文,,0,0,0,,所以我要做的是  让我们选择确切的中位数  并将其用作基准
Dialogue: 0,0:19:00.80,0:19:08.11,英文,,0,0,0,,So now that brings up another question, which is, well, first, if I use the exact median, I know that I will have n log n runtime guaranteed.
Dialogue: 0,0:19:00.80,0:19:08.11,中文,,0,0,0,,那么现在就带来了另一个问题  那就是  首先  如果我使用确切的中位数  我知道我的运行时间保证是 N  log N
Dialogue: 0,0:19:08.11,0:19:12.53,英文,,0,0,0,,I will always split the problem into two equally sized subproblems.
Dialogue: 0,0:19:08.11,0:19:12.53,中文,,0,0,0,,我总是会把问题分成两个大小相等的子问题
Dialogue: 0,0:19:12.53,0:19:16.27,英文,,0,0,0,,But the question is, how do you choose the median of an array?
Dialogue: 0,0:19:12.53,0:19:16.27,中文,,0,0,0,,但问题是  你如何选择数组的中位数？
Dialogue: 0,0:19:16.27,0:19:20.08,英文,,0,0,0,,How do you scan an array and figure out what the middle item is?
Dialogue: 0,0:19:16.27,0:19:20.08,中文,,0,0,0,,如何扫描数组并找出中间项？
Dialogue: 0,0:19:20.08,0:19:22.22,英文,,0,0,0,,It's kind of an interesting question.
Dialogue: 0,0:19:20.08,0:19:22.22,中文,,0,0,0,,这是个有趣的问题
Dialogue: 0,0:19:22.22,0:19:30.17,英文,,0,0,0,,Does anyone have like, think like that other guy, does anyone have a really stupid algorithm that will definitely work for finding the median of an array?
Dialogue: 0,0:19:22.22,0:19:30.17,中文,,0,0,0,,有没有人像刚才那个人一样  想出一个很蠢的算法  但肯定能找到数组的中位数？
Dialogue: 0,0:19:30.17,0:19:32.63,英文,,0,0,0,,It doesn't even have to take linear time.
Dialogue: 0,0:19:30.17,0:19:32.63,中文,,0,0,0,,它甚至不需要线性时间
Dialogue: 0,0:19:32.63,0:19:45.76,英文,,0,0,0,,Yeah. It's one word. You're good.
Dialogue: 0,0:19:32.63,0:19:45.76,中文,,0,0,0,,是的   就一个词   你很棒
Dialogue: 0,0:19:45.76,0:19:47.98,英文,,0,0,0,,Gotcha, so put it in a hash map, see what occurs the most.
Dialogue: 0,0:19:45.76,0:19:47.98,中文,,0,0,0,,明白了  把它放到哈希映射中  看看出现次数最多的
Dialogue: 0,0:19:47.98,0:19:51.52,英文,,0,0,0,,That would be great if you were finding the mode, which is the item that appears the most.
Dialogue: 0,0:19:47.98,0:19:51.52,中文,,0,0,0,,如果你要找众数  也就是出现次数最多的项  那倒是不错
Dialogue: 0,0:19:51.52,0:19:53.75,英文,,0,0,0,,What about the median, the middle item?
Dialogue: 0,0:19:51.52,0:19:53.75,中文,,0,0,0,,那中位数呢  中间项？
Dialogue: 0,0:19:53.75,0:19:57.27,英文,,0,0,0,,Who has the really silly one-word answer?
Dialogue: 0,0:19:53.75,0:19:57.27,中文,,0,0,0,,谁有那个很傻的一个词的答案？
Dialogue: 0,0:19:57.27,0:20:01.76,英文,,0,0,0,,Yeah? Sorted, and then find the item in the middle.
Dialogue: 0,0:19:57.27,0:20:01.76,中文,,0,0,0,,是的排序  然后找到中间的项
Dialogue: 0,0:20:01.76,0:20:05.31,英文,,0,0,0,,Is that a good approach for running quicksort and finding the pivot?
Dialogue: 0,0:20:01.76,0:20:05.31,中文,,0,0,0,,这对于运行快速排序并找到枢轴来说是个好方法吗？
Dialogue: 0,0:20:05.31,0:20:11.52,英文,,0,0,0,,Probably not, because you have to sort the array to find a median, but it's a silly one-word answer that would work.
Dialogue: 0,0:20:05.31,0:20:11.52,中文,,0,0,0,,可能不是  因为你必须对数组进行排序才能找到中位数  但这是一个很傻的一个词的答案  而且有效
Dialogue: 0,0:20:11.52,0:20:14.32,英文,,0,0,0,,So I'll give you something that's a little bit better.
Dialogue: 0,0:20:11.52,0:20:14.32,中文,,0,0,0,,所以我会给你一个更好的方法
Dialogue: 0,0:20:14.32,0:20:16.26,英文,,0,0,0,,If that didn't make sense, it's okay.
Dialogue: 0,0:20:14.32,0:20:16.26,中文,,0,0,0,,如果没听懂也没关系
Dialogue: 0,0:20:16.26,0:20:20.38,英文,,0,0,0,,I just wanted to raise the issue that technically, one way to find the median is to just sort it.
Dialogue: 0,0:20:16.26,0:20:20.38,中文,,0,0,0,,我只是想提出一个问题  从技术上讲  找到中位数的一种方法就是对其进行排序
Dialogue: 0,0:20:20.38,0:20:24.64,英文,,0,0,0,,But of course, that defeats the whole point, because we're trying to find better ways to sort.
Dialogue: 0,0:20:20.38,0:20:24.64,中文,,0,0,0,,但当然  这就失去了意义  因为我们试图找到更好的排序方法
Dialogue: 0,0:20:24.64,0:20:26.95,英文,,0,0,0,,So it turns out there are different.
Dialogue: 0,0:20:24.64,0:20:26.95,中文,,0,0,0,,所以事实证明有不同的方法
Dialogue: 0,0:20:26.95,0:20:28.03,英文,,0,0,0,,OK, so sorting it works.
Dialogue: 0,0:20:26.95,0:20:28.03,中文,,0,0,0,,好的  排序算法有效
Dialogue: 0,0:20:28.03,0:20:29.51,英文,,0,0,0,,It's kind of silly.
Dialogue: 0,0:20:28.03,0:20:29.51,中文,,0,0,0,,虽然有点傻
Dialogue: 0,0:20:29.51,0:20:32.35,英文,,0,0,0,,But it turns out there are actually faster ways to find the median.
Dialogue: 0,0:20:29.51,0:20:32.35,中文,,0,0,0,,但实际上  存在更快的寻找中位数的方法
Dialogue: 0,0:20:32.35,0:20:36.53,英文,,0,0,0,,So one of the ways to find it is called the PIC algorithm.
Dialogue: 0,0:20:32.35,0:20:36.53,中文,,0,0,0,,其中一种方法叫做PIC算法
Dialogue: 0,0:20:36.53,0:20:37.97,英文,,0,0,0,,And this paper is nuts.
Dialogue: 0,0:20:36.53,0:20:37.97,中文,,0,0,0,,这篇论文太牛了
Dialogue: 0,0:20:37.97,0:20:39.55,英文,,0,0,0,,Look at these people.
Dialogue: 0,0:20:37.97,0:20:39.55,中文,,0,0,0,,看看这些作者
Dialogue: 0,0:20:39.55,0:20:43.55,英文,,0,0,0,,There are four of these people who want Turing awards, which is like the Nobel Prize in computing.
Dialogue: 0,0:20:39.55,0:20:43.55,中文,,0,0,0,,他们中有四位获得了图灵奖  相当于计算机领域的诺贝尔奖
Dialogue: 0,0:20:43.55,0:20:45.77,英文,,0,0,0,,So four of them want it.
Dialogue: 0,0:20:43.55,0:20:45.77,中文,,0,0,0,,他们四个都获得了图灵奖
Dialogue: 0,0:20:45.77,0:20:51.72,英文,,0,0,0,,Geniuses upon geniuses coming up with this paper, like the Avengers of computer scientists coming together.
Dialogue: 0,0:20:45.77,0:20:51.72,中文,,0,0,0,,天才中的天才们写出了这篇论文  就像计算机科学家中的复仇者联盟
Dialogue: 0,0:20:51.72,0:20:55.60,英文,,0,0,0,,They found a theta of n time algorithm to find the median.
Dialogue: 0,0:20:51.72,0:20:55.60,中文,,0,0,0,,他们找到了一个时间复杂度为Θ(N)的寻找中位数的算法
Dialogue: 0,0:20:55.60,0:20:58.28,英文,,0,0,0,,Don't tell them, but I actually came up with this and I gave it to them.
Dialogue: 0,0:20:55.60,0:20:58.28,中文,,0,0,0,,别告诉他们  其实这个算法是我想出来的  我把它给了他们
Dialogue: 0,0:20:58.28,0:21:01.20,英文,,0,0,0,,But that's the algorithm.
Dialogue: 0,0:20:58.28,0:21:01.20,中文,,0,0,0,,这就是那个算法
Dialogue: 0,0:21:01.20,0:21:08.93,英文,,0,0,0,,And so question for you then is if we take this genius four Turing Award winner paper to find the median
Dialogue: 0,0:21:01.20,0:21:08.93,中文,,0,0,0,,问题来了  如果我们用这篇由四位图灵奖得主撰写的论文中找到的中位数算法  它只需要线性时间
Dialogue: 0,0:21:08.93,0:21:14.47,英文,,0,0,0,,and theta of n time, just takes a linear time in the size of the array and not say n log n.
Dialogue: 0,0:21:08.93,0:21:14.47,中文,,0,0,0,,也就是Θ(N)的时间复杂度  而不是N log N的时间复杂度  会怎么样呢？
Dialogue: 0,0:21:14.47,0:21:17.09,英文,,0,0,0,,How will that do if I use this on quicksort?
Dialogue: 0,0:21:14.47,0:21:17.09,中文,,0,0,0,,如果我将它用于快速排序  会有什么效果？
Dialogue: 0,0:21:17.09,0:21:24.19,英文,,0,0,0,,So now instead of choosing the leftmost item, I will use their genius paper to find the exact median,
Dialogue: 0,0:21:17.09,0:21:24.19,中文,,0,0,0,,也就是说  现在我不再选择最左边的元素  而是使用他们的天才论文来找到确切的中位数
Dialogue: 0,0:21:24.19,0:21:30.85,英文,,0,0,0,,always split the problem into two equally sized subproblems, and then that way I always have n log n runtime.
Dialogue: 0,0:21:24.19,0:21:30.85,中文,,0,0,0,,始终将问题分成两个大小相等的子问题  这样我就能始终保持N log N的运行时间
Dialogue: 0,0:21:30.85,0:21:31.35,英文,,0,0,0,,You ready?
Dialogue: 0,0:21:30.85,0:21:31.35,中文,,0,0,0,,准备好了吗？
Dialogue: 0,0:21:31.35,0:21:32.83,英文,,0,0,0,,I hope you're ready for the suspense.
Dialogue: 0,0:21:31.35,0:21:32.83,中文,,0,0,0,,我希望你已经准备好迎接悬念了
Dialogue: 0,0:21:32.83,0:21:33.89,英文,,0,0,0,,So I try it.
Dialogue: 0,0:21:32.83,0:21:33.89,中文,,0,0,0,,所以我尝试了它
Dialogue: 0,0:21:33.89,0:21:37.17,英文,,0,0,0,,And remember, the thing I was trying to beat is 1.3 seconds.
Dialogue: 0,0:21:33.89,0:21:37.17,中文,,0,0,0,,记住  我想要打破的记录是1.3秒
Dialogue: 0,0:21:37.17,0:21:40.70,英文,,0,0,0,,And I try exact median using this brilliant pick algorithm.
Dialogue: 0,0:21:37.17,0:21:40.70,中文,,0,0,0,,我尝试使用这个牛逼的PIC算法找到精确的中位数
Dialogue: 0,0:21:40.70,0:21:43.90,英文,,0,0,0,,And I get 4.9 seconds.
Dialogue: 0,0:21:40.70,0:21:43.90,中文,,0,0,0,,我算出来是 4.9 秒
Dialogue: 0,0:21:43.90,0:21:44.88,英文,,0,0,0,,What?
Dialogue: 0,0:21:43.90,0:21:44.88,中文,,0,0,0,,什么？
Dialogue: 0,0:21:44.88,0:21:47.82,英文,,0,0,0,,OK, so maybe these guys weren't so smart after all.
Dialogue: 0,0:21:44.88,0:21:47.82,中文,,0,0,0,,好吧  看来这些人也没那么聪明
Dialogue: 0,0:21:47.82,0:21:49.18,英文,,0,0,0,,I don't know.
Dialogue: 0,0:21:47.82,0:21:49.18,中文,,0,0,0,,我不知道
Dialogue: 0,0:21:49.18,0:21:51.44,英文,,0,0,0,,But it turns out 4.9 is not so good.
Dialogue: 0,0:21:49.18,0:21:51.44,中文,,0,0,0,,但结果 4.9 秒并不理想
Dialogue: 0,0:21:51.44,0:21:54.37,英文,,0,0,0,,It's actually slower than the other ones we've tried.
Dialogue: 0,0:21:51.44,0:21:54.37,中文,,0,0,0,,它实际上比我们尝试过的其他方法都要慢
Dialogue: 0,0:21:54.37,0:21:59.31,英文,,0,0,0,,And the rough intuition here is you're spending too much time being perfect.
Dialogue: 0,0:21:54.37,0:21:59.31,中文,,0,0,0,,大概的直觉是  你花了太多时间追求完美
Dialogue: 0,0:21:59.31,0:22:02.27,英文,,0,0,0,,You don't have to be perfect and find the exact median.
Dialogue: 0,0:21:59.31,0:22:02.27,中文,,0,0,0,,你不需要完美地找到确切的中位数
Dialogue: 0,0:22:02.27,0:22:07.36,英文,,0,0,0,,And it turns out that by trying to be perfect and find the exact median, you're wasting too much time,
Dialogue: 0,0:22:02.27,0:22:07.36,中文,,0,0,0,,事实证明  试图追求完美并找到确切的中位数  你会浪费太多时间
Dialogue: 0,0:22:07.36,0:22:11.54,英文,,0,0,0,,as opposed to these other true approaches, where I just did some shuffling and I said, you know what?
Dialogue: 0,0:22:07.36,0:22:11.54,中文,,0,0,0,,而与之相反的是其他真正有效的方法  我只是做了一些洗牌  然后说  你知道吗？
Dialogue: 0,0:22:11.54,0:22:12.60,英文,,0,0,0,,Good enough.
Dialogue: 0,0:22:11.54,0:22:12.60,中文,,0,0,0,,足够好了
Dialogue: 0,0:22:12.60,0:22:15.38,英文,,0,0,0,,I'll get something that works with very high probability.
Dialogue: 0,0:22:12.60,0:22:15.38,中文,,0,0,0,,我会找到一个很有可能奏效的方法
Dialogue: 0,0:22:15.38,0:22:21.60,英文,,0,0,0,,So it turns out, while it is technically valid to find the exact median,
Dialogue: 0,0:22:15.38,0:22:21.60,中文,,0,0,0,,所以事实证明  虽然从技术上讲找到确切的中位数是有效的
Dialogue: 0,0:22:21.60,0:22:27.52,英文,,0,0,0,,it's a little bit too much extra overhead, because coming up with something that's good enough is also faster.
Dialogue: 0,0:22:21.60,0:22:27.52,中文,,0,0,0,,但这有点过头的额外开销  因为想出一个足够好的方法也会更快
Dialogue: 0,0:22:27.52,0:22:32.28,英文,,0,0,0,,And that's one of those things that you might not be able to see with analysis, but with some experiments,
Dialogue: 0,0:22:27.52,0:22:32.28,中文,,0,0,0,,这是你可能无法通过分析看到的事情之一  但通过一些实验
Dialogue: 0,0:22:32.28,0:22:36.76,英文,,0,0,0,, we can clearly see just by these numbers that using the exact median is too slow.
Dialogue: 0,0:22:32.28,0:22:36.76,中文,,0,0,0,,我们可以从这些数字中清楚地看到  使用确切的中位数太慢了
Dialogue: 0,0:22:36.76,0:22:43.50,英文,,0,0,0,,You're wasting too much time being perfect when you could have just been almost perfect and avoided the worst case scenario.
Dialogue: 0,0:22:36.76,0:22:43.50,中文,,0,0,0,,你浪费了太多时间追求完美  而你本可以做到几乎完美并避免最坏的情况
Dialogue: 0,0:22:43.50,0:22:51.28,英文,,0,0,0,,So it's kind of interesting that QuickSort has this dangerous flavor to it, where if you really want to make it fast in real life, you cannot be perfect.
Dialogue: 0,0:22:43.50,0:22:51.28,中文,,0,0,0,,有趣的是  快速排序具有这种危险的味道  如果你真的想在现实生活中让它变得更快  你就不能追求完美
Dialogue: 0,0:22:51.28,0:22:54.94,英文,,0,0,0,,You have to live with the tiny possibility of an n-squared input.
Dialogue: 0,0:22:51.28,0:22:54.94,中文,,0,0,0,,你必须忍受 N² 输入的微小可能性
Dialogue: 0,0:22:54.94,0:22:56.87,英文,,0,0,0,,But by tiny, I mean really tiny.
Dialogue: 0,0:22:54.94,0:22:56.87,中文,,0,0,0,,但我说微小  是指真的很小
Dialogue: 0,0:22:56.87,0:22:59.15,英文,,0,0,0,,Remember the graph from last time.
Dialogue: 0,0:22:56.87,0:22:59.15,中文,,0,0,0,,还记得上次的图表吗？
Dialogue: 0,0:22:59.15,0:22:59.83,英文,,0,0,0,,It's kind of cool.
Dialogue: 0,0:22:59.15,0:22:59.83,中文,,0,0,0,,这有点酷
Dialogue: 0,0:22:59.83,0:23:01.39,英文,,0,0,0,,It's kind of wild.
Dialogue: 0,0:22:59.83,0:23:01.39,中文,,0,0,0,,这有点疯狂
Dialogue: 0,0:23:01.39,0:23:07.02,英文,,0,0,0,,OK. So that's it for the different quicksort variants.
Dialogue: 0,0:23:01.39,0:23:07.02,中文,,0,0,0,,好的   那么快速排序的各种变体就讲到这里
Dialogue: 0,0:23:07.02,0:23:08.40,英文,,0,0,0,,Is there anything else you want to know about it?
Dialogue: 0,0:23:07.02,0:23:08.40,中文,,0,0,0,,关于快速排序  你还有什么想知道的吗？
Dialogue: 0,0:23:08.40,0:23:13.58,英文,,0,0,0,,We could spend all day coming up with different algorithms, but I'll leave you with just three.
Dialogue: 0,0:23:08.40,0:23:13.58,中文,,0,0,0,,我们可以花一整天的时间来研究不同的算法  但我只给你介绍三种
Dialogue: 0,0:23:13.58,0:23:18.70,英文,,0,0,0,,OK, I have one more final topic to show you before I disappear off into the sunset.
Dialogue: 0,0:23:13.58,0:23:18.70,中文,,0,0,0,,好的  在我消失之前  我还有一个最后的主题要展示给你
Dialogue: 0,0:23:18.70,0:23:27.13,英文,,0,0,0,,And that's a little dessert for this whole quicksort journey that we've taken together, which is we've already seen
Dialogue: 0,0:23:18.70,0:23:27.13,中文,,0,0,0,,这是我们一起进行的快速排序之旅的一个小甜点  我们已经看到有一个天才的版本可以找到中位数
Dialogue: 0,0:23:27.13,0:23:32.93,英文,,0,0,0,,that there's a genius version of finding the median, which was to use that pick algorithm, which I did not describe.
Dialogue: 0,0:23:27.13,0:23:32.93,中文,,0,0,0,,那就是使用选择算法  但我没有描述它
Dialogue: 0,0:23:32.93,0:23:42.26,英文,,0,0,0,,But it turns out there's actually another way to find the median that I can show you, which is what if we used partitioning to find the median?
Dialogue: 0,0:23:32.93,0:23:42.26,中文,,0,0,0,,但事实证明  还有另一种方法可以找到中位数  我可以告诉你  如果我们使用分区来找到中位数会怎样？
Dialogue: 0,0:23:42.26,0:23:48.59,英文,,0,0,0,,It's kind of like a mind-bending moment because we just talked about using partitioning to sort an array,
Dialogue: 0,0:23:42.26,0:23:48.59,中文,,0,0,0,,这有点像一个令人费解的时刻  因为我们刚刚讨论了使用分区来排序数组
Dialogue: 0,0:23:48.59,0:23:53.17,英文,,0,0,0,,and it turns out you can also use partitioning to find the exact median.
Dialogue: 0,0:23:48.59,0:23:53.17,中文,,0,0,0,,结果发现你也可以使用分区来找到精确的中位数
Dialogue: 0,0:23:53.17,0:23:55.53,英文,,0,0,0,,And this is the part where, if it doesn't make sense, it's OK.
Dialogue: 0,0:23:53.17,0:23:55.53,中文,,0,0,0,,如果你不明白这一部分  没关系
Dialogue: 0,0:23:55.53,0:23:58.67,英文,,0,0,0,,I will try to say it out loud, although it might sound silly.
Dialogue: 0,0:23:55.53,0:23:58.67,中文,,0,0,0,,我会试着大声说出来  尽管这听起来可能很傻
Dialogue: 0,0:23:58.67,0:24:05.09,英文,,0,0,0,,You can use partitioning to find the median, which then gives you the best thing to partition on for sorting.
Dialogue: 0,0:23:58.67,0:24:05.09,中文,,0,0,0,,你可以使用分区来找到中位数  然后它会为你提供最好的分区对象来进行排序
Dialogue: 0,0:24:05.09,0:24:06.27,英文,,0,0,0,,It's weird.
Dialogue: 0,0:24:05.09,0:24:06.27,中文,,0,0,0,,这很奇怪
Dialogue: 0,0:24:06.27,0:24:14.13,英文,,0,0,0,,But the thing I want to show you in this case, even if that made no sense, is that you can actually use partitioning to quickly find the best median.
Dialogue: 0,0:24:06.27,0:24:14.13,中文,,0,0,0,,我想在这种情况下向你展示的是  即使这没有任何意义  你实际上可以使用分区来快速找到最佳中位数
Dialogue: 0,0:24:14.13,0:24:15.92,英文,,0,0,0,,So let's do it.
Dialogue: 0,0:24:14.13,0:24:15.92,中文,,0,0,0,,那么  让我们开始吧
Dialogue: 0,0:24:15.92,0:24:18.26,英文,,0,0,0,,So here's my array.
Dialogue: 0,0:24:15.92,0:24:18.26,中文,,0,0,0,,这是我的数组
Dialogue: 0,0:24:18.26,0:24:23.84,英文,,0,0,0,,And I want to find the middle item, the item that has half the items less than it, half the items greater than it.
Dialogue: 0,0:24:18.26,0:24:23.84,中文,,0,0,0,,我想找到中间的项  也就是一半的项小于它  一半的项大于它的项
Dialogue: 0,0:24:23.84,0:24:25.21,英文,,0,0,0,,I want to find the median.
Dialogue: 0,0:24:23.84,0:24:25.21,中文,,0,0,0,,我想找到中位数
Dialogue: 0,0:24:25.21,0:24:26.75,英文,,0,0,0,,And I want to do so in linear time.
Dialogue: 0,0:24:25.21,0:24:26.75,中文,,0,0,0,,我想在线性时间内做到这一点
Dialogue: 0,0:24:26.75,0:24:27.47,英文,,0,0,0,,So no cheating.
Dialogue: 0,0:24:26.75,0:24:27.47,中文,,0,0,0,,所以不要作弊
Dialogue: 0,0:24:27.47,0:24:28.83,英文,,0,0,0,,You can just sort the array.
Dialogue: 0,0:24:27.47,0:24:28.83,中文,,0,0,0,,你可以直接对数组进行排序
Dialogue: 0,0:24:28.83,0:24:30.63,英文,,0,0,0,,It would take n log n time.
Dialogue: 0,0:24:28.83,0:24:30.63,中文,,0,0,0,,那需要 N log N 的时间
Dialogue: 0,0:24:30.63,0:24:34.17,英文,,0,0,0,,So I will try to use partitions to help me find the median.
Dialogue: 0,0:24:30.63,0:24:34.17,中文,,0,0,0,,所以我将尝试使用分区来帮助我找到中位数
Dialogue: 0,0:24:34.17,0:24:36.26,英文,,0,0,0,,So I'll just pick any old item like I always do.
Dialogue: 0,0:24:34.17,0:24:36.26,中文,,0,0,0,,所以我像往常一样随便挑一个数
Dialogue: 0,0:24:36.26,0:24:38.02,英文,,0,0,0,,Here, I'll choose 9 to be the pivot.
Dialogue: 0,0:24:36.26,0:24:38.02,中文,,0,0,0,,在这里  我将选择 9 作为支点
Dialogue: 0,0:24:38.02,0:24:40.50,英文,,0,0,0,,And I will partition the array on 9.
Dialogue: 0,0:24:38.02,0:24:40.50,中文,,0,0,0,,我将根据 9 对数组进行分区
Dialogue: 0,0:24:40.50,0:24:44.92,英文,,0,0,0,,Done. Everything less than 9 on the left, everything greater than 9 on the right.
Dialogue: 0,0:24:40.50,0:24:44.92,中文,,0,0,0,,完成   所有小于 9 的数都在左边  所有大于 9 的数都在右边
Dialogue: 0,0:24:44.92,0:24:46.39,英文,,0,0,0,,Is 9 the median?
Dialogue: 0,0:24:44.92,0:24:46.39,中文,,0,0,0,,9 是中位数吗？
Dialogue: 0,0:24:46.39,0:24:49.54,英文,,0,0,0,,Did it land in the exact middle of the array?
Dialogue: 0,0:24:46.39,0:24:49.54,中文,,0,0,0,,它是否正好落在数组的正中间？
Dialogue: 0,0:24:49.54,0:24:50.22,英文,,0,0,0,,No.
Dialogue: 0,0:24:49.54,0:24:50.22,中文,,0,0,0,,不是
Dialogue: 0,0:24:50.22,0:24:51.82,英文,,0,0,0,,So 9 is not the median.
Dialogue: 0,0:24:50.22,0:24:51.82,中文,,0,0,0,,所以 9 不是中位数
Dialogue: 0,0:24:51.82,0:24:53.00,英文,,0,0,0,,You're not the winner.
Dialogue: 0,0:24:51.82,0:24:53.00,中文,,0,0,0,,你不是赢家
Dialogue: 0,0:24:53.00,0:24:56.27,英文,,0,0,0,,So what do we do next?
Dialogue: 0,0:24:53.00,0:24:56.27,中文,,0,0,0,,那我们下一步该怎么办？
Dialogue: 0,0:24:56.27,0:24:56.93,英文,,0,0,0,,Where's the median?
Dialogue: 0,0:24:56.27,0:24:56.93,中文,,0,0,0,,中位数在哪里？
Dialogue: 0,0:24:56.93,0:24:57.89,英文,,0,0,0,,We don't know.
Dialogue: 0,0:24:56.93,0:24:57.89,中文,,0,0,0,,我们不知道
Dialogue: 0,0:24:57.89,0:25:00.01,英文,,0,0,0,,We tried 9, and it wasn't the median.
Dialogue: 0,0:24:57.89,0:25:00.01,中文,,0,0,0,,我们试了 9  它不是中位数
Dialogue: 0,0:25:00.01,0:25:01.61,英文,,0,0,0,,Do we just have to start over?
Dialogue: 0,0:25:00.01,0:25:01.61,中文,,0,0,0,,我们必须重新开始吗？
Dialogue: 0,0:25:01.61,0:25:08.97,英文,,0,0,0,,Well, not really, because by partitioning, we've already figured something out, which is, could the median possibly be to the left of 9?
Dialogue: 0,0:25:01.61,0:25:08.97,中文,,0,0,0,,嗯  不完全是  因为通过分区  我们已经发现了一些东西  那就是  中位数有可能在 9 的左边吗？
Dialogue: 0,0:25:08.97,0:25:10.95,英文,,0,0,0,,Could it be 5 or 6?
Dialogue: 0,0:25:08.97,0:25:10.95,中文,,0,0,0,,可能是 5 或者 6 吗？
Dialogue: 0,0:25:10.95,0:25:13.45,英文,,0,0,0,,Nope. So where does the median have to be?
Dialogue: 0,0:25:10.95,0:25:13.45,中文,,0,0,0,,不可能   那么中位数应该在哪儿呢？
Dialogue: 0,0:25:13.45,0:25:18.07,英文,,0,0,0,,It has to be to the right of 9, because there's more items on this side.
Dialogue: 0,0:25:13.45,0:25:18.07,中文,,0,0,0,,它必须在 9 的右边  因为这边有更多项
Dialogue: 0,0:25:18.07,0:25:27.44,英文,,0,0,0,,So because I know that the partition or the median cannot be to the left of 9, I only have to run partitioning on the right subproblem.
Dialogue: 0,0:25:18.07,0:25:27.44,中文,,0,0,0,,所以因为我知道分区或中位数不可能在 9 的左边  所以我只需要对右边的子问题运行分区
Dialogue: 0,0:25:27.44,0:25:29.60,英文,,0,0,0,,So these three items are losers.
Dialogue: 0,0:25:27.44,0:25:29.60,中文,,0,0,0,,所以这三项都是失败者
Dialogue: 0,0:25:29.60,0:25:31.06,英文,,0,0,0,,They are not the median.
Dialogue: 0,0:25:29.60,0:25:31.06,中文,,0,0,0,,它们不是中位数
Dialogue: 0,0:25:31.06,0:25:33.96,英文,,0,0,0,,We only have to look on this smaller subarray.
Dialogue: 0,0:25:31.06,0:25:33.96,中文,,0,0,0,,我们只需要查看这个较小的子数组
Dialogue: 0,0:25:33.96,0:25:35.00,英文,,0,0,0,,So I'll choose another item.
Dialogue: 0,0:25:33.96,0:25:35.00,中文,,0,0,0,,所以我将选择另一个项目
Dialogue: 0,0:25:35.00,0:25:35.58,英文,,0,0,0,,I choose 550.
Dialogue: 0,0:25:35.00,0:25:35.58,中文,,0,0,0,,我选择 550
Dialogue: 0,0:25:35.58,0:25:37.36,英文,,0,0,0,,I partition.
Dialogue: 0,0:25:35.58,0:25:37.36,中文,,0,0,0,,我分区
Dialogue: 0,0:25:37.36,0:25:39.76,英文,,0,0,0,,Everything to the left of 550 is less than it.
Dialogue: 0,0:25:37.36,0:25:39.76,中文,,0,0,0,,550 左边的所有东西都小于它
Dialogue: 0,0:25:39.76,0:25:42.12,英文,,0,0,0,,Everything to the right of 550 is greater than.
Dialogue: 0,0:25:39.76,0:25:42.12,中文,,0,0,0,,550 右边的所有东西都大于它
Dialogue: 0,0:25:42.12,0:25:47.23,英文,,0,0,0,,Did 550 land in the middle of the original large array, like right there?
Dialogue: 0,0:25:42.12,0:25:47.23,中文,,0,0,0,,550 是落在原始大数组的中间了吗  就像在那里？
Dialogue: 0,0:25:47.23,0:25:50.35,英文,,0,0,0,,No. So 550 is also not the winner.
Dialogue: 0,0:25:47.23,0:25:50.35,中文,,0,0,0,,没有   所以 550 也不是赢家
Dialogue: 0,0:25:50.35,0:25:56.27,英文,,0,0,0,,But again, we can look at the 550 and say, could the median be to the right of 550?
Dialogue: 0,0:25:50.35,0:25:56.27,中文,,0,0,0,,但是  我们可以再次查看 550 并说  中位数可能在 550 的右边吗？
Dialogue: 0,0:25:56.27,0:25:57.95,英文,,0,0,0,,Could it be one of these two?
Dialogue: 0,0:25:56.27,0:25:57.95,中文,,0,0,0,,它可能是这两个中的一个吗？
Dialogue: 0,0:25:57.95,0:26:00.10,英文,,0,0,0,,No. It's got to be on this side.
Dialogue: 0,0:25:57.95,0:26:00.10,中文,,0,0,0,,没有   它必须在这边
Dialogue: 0,0:26:00.10,0:26:03.46,英文,,0,0,0,,So again, I only have to look at this part of the array.
Dialogue: 0,0:26:00.10,0:26:03.46,中文,,0,0,0,,我只需要查看数组的这一部分
Dialogue: 0,0:26:03.46,0:26:05.50,英文,,0,0,0,,And so I pick another item to partition on.
Dialogue: 0,0:26:03.46,0:26:05.50,中文,,0,0,0,,所以我选择另一个项目进行分区
Dialogue: 0,0:26:05.50,0:26:06.86,英文,,0,0,0,,Here I choose 14.
Dialogue: 0,0:26:05.50,0:26:06.86,中文,,0,0,0,,我这里选 14
Dialogue: 0,0:26:06.86,0:26:08.04,英文,,0,0,0,,I partition on 14.
Dialogue: 0,0:26:06.86,0:26:08.04,中文,,0,0,0,,以 14 为基准分区
Dialogue: 0,0:26:08.04,0:26:09.38,英文,,0,0,0,,It finds its rightful place.
Dialogue: 0,0:26:08.04,0:26:09.38,中文,,0,0,0,,它找到了合适的位置
Dialogue: 0,0:26:09.38,0:26:12.31,英文,,0,0,0,,And look, it landed exactly in the middle.
Dialogue: 0,0:26:09.38,0:26:12.31,中文,,0,0,0,,看  它正好落在中间
Dialogue: 0,0:26:12.31,0:26:15.73,英文,,0,0,0,,So now we know that we are in the middle of the array.
Dialogue: 0,0:26:12.31,0:26:15.73,中文,,0,0,0,,所以现在我们知道我们位于数组的中间
Dialogue: 0,0:26:15.73,0:26:18.73,英文,,0,0,0,,This item is the correct median.
Dialogue: 0,0:26:15.73,0:26:18.73,中文,,0,0,0,,这个元素就是正确的中位数
Dialogue: 0,0:26:18.73,0:26:20.21,英文,,0,0,0,,Sometimes we call this quick select.
Dialogue: 0,0:26:18.73,0:26:20.21,中文,,0,0,0,,有时我们称之为快速选择
Dialogue: 0,0:26:20.21,0:26:24.63,英文,,0,0,0,,And the idea is you use partitioning to find the median of the array.
Dialogue: 0,0:26:20.21,0:26:24.63,中文,,0,0,0,,其思想是使用分区来查找数组的中位数
Dialogue: 0,0:26:24.63,0:26:31.58,英文,,0,0,0,,Every time you partition, and the trick that really makes this work and fast is every time you partition, you can throw away some of the array.
Dialogue: 0,0:26:24.63,0:26:31.58,中文,,0,0,0,,每次你分区  真正让它工作并快速的关键是  每次分区后  你都可以丢弃一部分数组
Dialogue: 0,0:26:31.58,0:26:34.58,英文,,0,0,0,,Like when I partition here, I knew none of this could be the median.
Dialogue: 0,0:26:31.58,0:26:34.58,中文,,0,0,0,,比如我在这里分区  我知道这些元素都不可能是中位数
Dialogue: 0,0:26:34.58,0:26:38.06,英文,,0,0,0,,When I did this partition, I figured out that none of this stuff could be the median.
Dialogue: 0,0:26:34.58,0:26:38.06,中文,,0,0,0,,当我进行这次分区时  我发现这些元素都不可能是中位数
Dialogue: 0,0:26:38.06,0:26:41.94,英文,,0,0,0,,So every time I partition, some of the array falls away.
Dialogue: 0,0:26:38.06,0:26:41.94,中文,,0,0,0,,所以每次我分区  都会有一部分数组被丢弃
Dialogue: 0,0:26:41.94,0:26:44.18,英文,,0,0,0,,Guaranteed to never be the partition.
Dialogue: 0,0:26:41.94,0:26:44.18,中文,,0,0,0,,保证永远不会成为分区的一部分
Dialogue: 0,0:26:44.18,0:26:46.82,英文,,0,0,0,,And I have less work to do every time.
Dialogue: 0,0:26:44.18,0:26:46.82,中文,,0,0,0,,每次我都要做的工作都减少了
Dialogue: 0,0:26:46.82,0:26:50.02,英文,,0,0,0,,So now to do some runtime analysis.
Dialogue: 0,0:26:46.82,0:26:50.02,中文,,0,0,0,,现在来进行一些运行时分析
Dialogue: 0,0:26:50.02,0:26:52.95,英文,,0,0,0,,What is the worst case performance for quick select?
Dialogue: 0,0:26:50.02,0:26:52.95,中文,,0,0,0,,快速选择的 最坏情况性能 是怎样的？
Dialogue: 0,0:26:52.95,0:26:54.53,英文,,0,0,0,,I'll just spoil this for time.
Dialogue: 0,0:26:52.95,0:26:54.53,中文,,0,0,0,,为了节省时间  我直接剧透吧
Dialogue: 0,0:26:54.53,0:27:02.13,英文,,0,0,0,,Turns out, if you pass in the same sorted array that gave quick sort really bad runtime, you will also break quick select.
Dialogue: 0,0:26:54.53,0:27:02.13,中文,,0,0,0,,事实证明  如果你传入导致快速排序运行时间很差的相同排序数组  你也会破坏快速选择
Dialogue: 0,0:27:02.13,0:27:03.39,英文,,0,0,0,,Because what will you do?
Dialogue: 0,0:27:02.13,0:27:03.39,中文,,0,0,0,,因为你会怎么做？
Dialogue: 0,0:27:03.39,0:27:09.80,英文,,0,0,0,,You'll have this array, one, two, three, four, all sorted all the way up to n. So you have n items in the array.
Dialogue: 0,0:27:03.39,0:27:09.80,中文,,0,0,0,,你会有这个数组  1、2、3、4  一直排序到 n  所以数组中有 n 个元素
Dialogue: 0,0:27:09.80,0:27:11.78,英文,,0,0,0,,And let's say you partition on one.
Dialogue: 0,0:27:09.80,0:27:11.78,中文,,0,0,0,,假设你以 1 为基准进行分区
Dialogue: 0,0:27:11.78,0:27:13.74,英文,,0,0,0,,Everything falls to the right of 1.
Dialogue: 0,0:27:11.78,0:27:13.74,中文,,0,0,0,,所有元素都落在了 1 的右边
Dialogue: 0,0:27:13.74,0:27:15.34,英文,,0,0,0,,Nothing is to the left of 1.
Dialogue: 0,0:27:13.74,0:27:15.34,中文,,0,0,0,,1 的左边没有元素
Dialogue: 0,0:27:15.34,0:27:16.20,英文,,0,0,0,,Where's the partition?
Dialogue: 0,0:27:15.34,0:27:16.20,中文,,0,0,0,,那么分区在哪里呢？
Dialogue: 0,0:27:16.20,0:27:18.46,英文,,0,0,0,,It's not 1. It's to the right of 1.
Dialogue: 0,0:27:16.20,0:27:18.46,中文,,0,0,0,,它不在 1 的位置   它在 1 的右边
Dialogue: 0,0:27:18.46,0:27:20.70,英文,,0,0,0,,So what's your subproblem size?
Dialogue: 0,0:27:18.46,0:27:20.70,中文,,0,0,0,,那么你的子问题的规模是多少呢？
Dialogue: 0,0:27:20.70,0:27:22.64,英文,,0,0,0,,n minus 1.
Dialogue: 0,0:27:20.70,0:27:22.64,中文,,0,0,0,,N - 1
Dialogue: 0,0:27:22.64,0:27:26.66,英文,,0,0,0,,Now you have to solve the partition problem on n minus 1 items.
Dialogue: 0,0:27:22.64,0:27:26.66,中文,,0,0,0,,现在你需要解决 N - 1 个元素的分区问题
Dialogue: 0,0:27:26.66,0:27:28.12,英文,,0,0,0,,So you partition on 2.
Dialogue: 0,0:27:26.66,0:27:28.12,中文,,0,0,0,,所以你以 2 为基准进行分区
Dialogue: 0,0:27:28.12,0:27:30.34,英文,,0,0,0,,Everything greater than 2 lands on one side.
Dialogue: 0,0:27:28.12,0:27:30.34,中文,,0,0,0,,所有大于 2 的元素都落在一边
Dialogue: 0,0:27:30.34,0:27:32.15,英文,,0,0,0,,Nothing lands on the other side.
Dialogue: 0,0:27:30.34,0:27:32.15,中文,,0,0,0,,另一边没有元素
Dialogue: 0,0:27:32.15,0:27:34.09,英文,,0,0,0,,So which side do I look on?
Dialogue: 0,0:27:32.15,0:27:34.09,中文,,0,0,0,,那么我应该在哪边查找呢？
Dialogue: 0,0:27:34.09,0:27:36.77,英文,,0,0,0,,The side with nothing or the side with everything?
Dialogue: 0,0:27:34.09,0:27:36.77,中文,,0,0,0,,没有元素的一边还是有元素的一边？
Dialogue: 0,0:27:36.77,0:27:39.01,英文,,0,0,0,,You've got to look on the side with everything.
Dialogue: 0,0:27:36.77,0:27:39.01,中文,,0,0,0,,你必须在有元素的一边查找
Dialogue: 0,0:27:39.01,0:27:41.43,英文,,0,0,0,,You create a subproblem of size n minus 2.
Dialogue: 0,0:27:39.01,0:27:41.43,中文,,0,0,0,,你创建了一个规模为 N - 2 的子问题
Dialogue: 0,0:27:41.43,0:27:42.49,英文,,0,0,0,,You solve that.
Dialogue: 0,0:27:41.43,0:27:42.49,中文,,0,0,0,,你解决了这个问题
Dialogue: 0,0:27:42.49,0:27:44.75,英文,,0,0,0,,You create a subproblem of size n minus 3.
Dialogue: 0,0:27:42.49,0:27:44.75,中文,,0,0,0,,你创建了一个规模为 N - 3 的子问题
Dialogue: 0,0:27:44.75,0:27:55.17,英文,,0,0,0,,So it turns out if you pass in an array that is totally sorted and use the leftmost item as the pivot, the median finding algorithm is still n squared time.
Dialogue: 0,0:27:44.75,0:27:55.17,中文,,0,0,0,,所以事实证明  如果你传入一个完全排序的数组  并使用最左边的元素作为基准  那么中位数查找算法仍然是 N² 时间复杂度
Dialogue: 0,0:27:55.17,0:28:01.87,英文,,0,0,0,,Every time you run the algorithm, the problem decreases in size by 1.
Dialogue: 0,0:27:55.17,0:28:01.87,中文,,0,0,0,,每次你运行算法时  问题的规模都会减少 1
Dialogue: 0,0:28:01.87,0:28:04.81,英文,,0,0,0,,That's not so good. But what about on average?
Dialogue: 0,0:28:01.87,0:28:04.81,中文,,0,0,0,,这不太妙   但平均情况如何呢？
Dialogue: 0,0:28:04.81,0:28:10.07,英文,,0,0,0,,So we saw that in the worst case, the median finding algorithm is n squared, just like in quicksort.
Dialogue: 0,0:28:04.81,0:28:10.07,中文,,0,0,0,,我们看到  在最坏的情况下  中位数查找算法的时间复杂度是N²  就像快速排序一样
Dialogue: 0,0:28:10.07,0:28:18.68,英文,,0,0,0,,But in the best case, turns out quicksort is not n log n. It's theta of n. That's kind of weird.
Dialogue: 0,0:28:10.07,0:28:18.68,中文,,0,0,0,,但在最好的情况下  快速排序的时间复杂度不是N log N  而是Θ(N)  这有点奇怪
Dialogue: 0,0:28:18.68,0:28:23.95,英文,,0,0,0,,So why is it theta of n when quicksort was theta of n log n?
Dialogue: 0,0:28:18.68,0:28:23.95,中文,,0,0,0,,那么  为什么快速排序是Θ(N log N)  而中位数查找算法却是Θ(N)呢？
Dialogue: 0,0:28:23.95,0:28:30.23,英文,,0,0,0,,There's one key that makes it n instead of n log n. So here's the picture that you saw from last time when we did quicksort.
Dialogue: 0,0:28:23.95,0:28:30.23,中文,,0,0,0,,有一个关键因素使得它是N而不是N log N  这是我们上次进行快速排序时看到的图片
Dialogue: 0,0:28:30.23,0:28:31.17,英文,,0,0,0,,You pick an item.
Dialogue: 0,0:28:30.23,0:28:31.17,中文,,0,0,0,,你选择一个元素
Dialogue: 0,0:28:31.17,0:28:32.31,英文,,0,0,0,,You partition it.
Dialogue: 0,0:28:31.17,0:28:32.31,中文,,0,0,0,,你把它分成两部分
Dialogue: 0,0:28:32.31,0:28:35.63,英文,,0,0,0,,Some of the items land to the left of the partition or the pivot.
Dialogue: 0,0:28:32.31,0:28:35.63,中文,,0,0,0,,一些元素落在分区或枢轴的左侧
Dialogue: 0,0:28:35.63,0:28:37.81,英文,,0,0,0,,Some of the items land to the right.
Dialogue: 0,0:28:35.63,0:28:37.81,中文,,0,0,0,,一些元素落在右侧
Dialogue: 0,0:28:37.81,0:28:40.14,英文,,0,0,0,,In quicksort, what did you do at this step?
Dialogue: 0,0:28:37.81,0:28:40.14,中文,,0,0,0,,在快速排序中  你在这一步做了什么？
Dialogue: 0,0:28:40.14,0:28:43.78,英文,,0,0,0,,Pause right here. If you get this, you're all set for quick select.
Dialogue: 0,0:28:40.14,0:28:43.78,中文,,0,0,0,,暂停一下   如果你理解了这一点  你就可以进行快速选择了
Dialogue: 0,0:28:43.78,0:28:45.26,英文,,0,0,0,,What did we do in quicksort?
Dialogue: 0,0:28:43.78,0:28:45.26,中文,,0,0,0,,我们在快速排序中做了什么？
Dialogue: 0,0:28:45.26,0:28:48.72,英文,,0,0,0,,You had to solve the left problem, and then you had to solve the right problem.
Dialogue: 0,0:28:45.26,0:28:48.72,中文,,0,0,0,,你必须解决左侧问题  然后你必须解决右侧问题
Dialogue: 0,0:28:48.72,0:28:52.56,英文,,0,0,0,,You had to solve both because you were trying to sort the whole array.
Dialogue: 0,0:28:48.72,0:28:52.56,中文,,0,0,0,,你必须解决这两个问题  因为你试图对整个数组进行排序
Dialogue: 0,0:28:52.56,0:28:54.66,英文,,0,0,0,,What do you do in Quick Select, though?
Dialogue: 0,0:28:52.56,0:28:54.66,中文,,0,0,0,,那么  在快速选择中你做什么呢？
Dialogue: 0,0:28:54.66,0:28:56.68,英文,,0,0,0,,Do you have to solve both sides?
Dialogue: 0,0:28:54.66,0:28:56.68,中文,,0,0,0,,你必须解决两边的问题吗？
Dialogue: 0,0:28:56.68,0:28:57.76,英文,,0,0,0,,Well, not really.
Dialogue: 0,0:28:56.68,0:28:57.76,中文,,0,0,0,,嗯  不是真的
Dialogue: 0,0:28:57.76,0:29:03.62,英文,,0,0,0,,Because if the pivot lands here, I know that the median has to be on the right side.
Dialogue: 0,0:28:57.76,0:29:03.62,中文,,0,0,0,,因为如果枢轴落在這裡  我知道中位数必须在右侧
Dialogue: 0,0:29:03.62,0:29:05.84,英文,,0,0,0,,So I can completely discard everything here.
Dialogue: 0,0:29:03.62,0:29:05.84,中文,,0,0,0,,所以我这边可以完全舍弃
Dialogue: 0,0:29:05.84,0:29:07.69,英文,,0,0,0,,There's no more work to do on that side.
Dialogue: 0,0:29:05.84,0:29:07.69,中文,,0,0,0,,这边不再需要做任何工作
Dialogue: 0,0:29:07.69,0:29:11.41,英文,,0,0,0,,And I only have to solve one of the subproblems.
Dialogue: 0,0:29:07.69,0:29:11.41,中文,,0,0,0,,我只需要解决一个子问题
Dialogue: 0,0:29:11.41,0:29:13.99,英文,,0,0,0,,That's what makes Quick Select different from Quick Sort.
Dialogue: 0,0:29:11.41,0:29:13.99,中文,,0,0,0,,这就是快速选择与快速排序的不同之处
Dialogue: 0,0:29:13.99,0:29:17.81,英文,,0,0,0,,In Quick Sort, right here, I have to solve both subproblems.
Dialogue: 0,0:29:13.99,0:29:17.81,中文,,0,0,0,,在快速排序中  我必须解决这两个子问题
Dialogue: 0,0:29:17.81,0:29:20.97,英文,,0,0,0,,In Quick Select, I only have to solve one of them.
Dialogue: 0,0:29:17.81,0:29:20.97,中文,,0,0,0,,在快速选择中  我只需要解决其中一个
Dialogue: 0,0:29:20.97,0:29:22.93,英文,,0,0,0,,Because I don't care about sorting the whole array.
Dialogue: 0,0:29:20.97,0:29:22.93,中文,,0,0,0,,因为我不关心整个数组的排序
Dialogue: 0,0:29:22.93,0:29:24.83,英文,,0,0,0,,I just need the middle item.
Dialogue: 0,0:29:22.93,0:29:24.83,中文,,0,0,0,,我只需要中间的元素
Dialogue: 0,0:29:24.83,0:29:27.92,英文,,0,0,0,,So again, I do another partition.
Dialogue: 0,0:29:24.83,0:29:27.92,中文,,0,0,0,,所以我再次进行分区
Dialogue: 0,0:29:27.92,0:29:28.94,英文,,0,0,0,,The pivot lands here.
Dialogue: 0,0:29:27.92,0:29:28.94,中文,,0,0,0,,主元落在这里
Dialogue: 0,0:29:28.94,0:29:31.62,英文,,0,0,0,,Some items less than the pivot, some items greater than.
Dialogue: 0,0:29:28.94,0:29:31.62,中文,,0,0,0,,一些元素小于主元  一些元素大于主元
Dialogue: 0,0:29:31.62,0:29:36.07,英文,,0,0,0,,And in QuickSort, you'd have to solve both problems in QuickSelect. You don't.
Dialogue: 0,0:29:31.62,0:29:36.07,中文,,0,0,0,,在快速排序中  你必须解决这两个问题  但在快速选择中则不需要
Dialogue: 0,0:29:36.07,0:29:39.57,英文,,0,0,0,,You can throw away some of the array and just solve the smaller problem.
Dialogue: 0,0:29:36.07,0:29:39.57,中文,,0,0,0,,你可以舍弃数组的一部分  只解决较小的问题
Dialogue: 0,0:29:39.57,0:29:44.32,英文,,0,0,0,,And again, when you partition on this one, you can throw away one of the smaller problems.
Dialogue: 0,0:29:39.57,0:29:44.32,中文,,0,0,0,,同样  当你对这个分区进行分区时  你可以舍弃其中一个较小的问题
Dialogue: 0,0:29:44.32,0:29:49.70,英文,,0,0,0,,So every time you go to a smaller problem, you can throw away some of the array.
Dialogue: 0,0:29:44.32,0:29:49.70,中文,,0,0,0,,所以每次你转到一个较小的问题时  你都可以舍弃数组的一部分
Dialogue: 0,0:29:49.70,0:29:53.42,英文,,0,0,0,,That's what gives QuickSelect the theta of n runtime.
Dialogue: 0,0:29:49.70,0:29:53.42,中文,,0,0,0,,这就是快速选择具有 Θ(N) 运行时间的原因
Dialogue: 0,0:29:53.42,0:29:59.53,英文,,0,0,0,,So very roughly speaking, at the first step, you have to partition this array of size n.
Dialogue: 0,0:29:53.42,0:29:59.53,中文,,0,0,0,,粗略地说  在第一步  你必须对这个大小为 n 的数组进行分区
Dialogue: 0,0:29:59.53,0:30:06.00,英文,,0,0,0,,And again, using the same kind of rough logic as quicksort, at the next level, I have approximately n over 2 items to look at,
Dialogue: 0,0:29:59.53,0:30:06.00,中文,,0,0,0,,再次使用与快速排序相同的粗略逻辑  在下一层  我大约有 N/2 个元素需要查看
Dialogue: 0,0:30:06.00,0:30:11.74,英文,,0,0,0,,and then n over 4 items, and then n over 8 items, all the way down to 1.
Dialogue: 0,0:30:06.00,0:30:11.74,中文,,0,0,0,,然后是 N/4 个元素  然后是 N/8 个元素  一直到 1
Dialogue: 0,0:30:11.74,0:30:21.46,英文,,0,0,0,,And we know that the sum of n plus n over 2 plus n over 4 all the way down to 1 is theta of n geometric series.
Dialogue: 0,0:30:11.74,0:30:21.46,中文,,0,0,0,,我们知道  从 N 加到 N/2 再加到 N/4  一直加到 1  这是一个 Θ(N) 的几何级数
Dialogue: 0,0:30:21.46,0:30:25.28,英文,,0,0,0,,So that's what makes quick select theta of n linear time.
Dialogue: 0,0:30:21.46,0:30:25.28,中文,,0,0,0,,这就是为什么快速选择算法的时间复杂度是Θ(N) 线性时间
Dialogue: 0,0:30:25.28,0:30:29.30,英文,,0,0,0,,And the difference between this and quicksort is that in quicksort, you have to look at both subproblems.
Dialogue: 0,0:30:25.28,0:30:29.30,中文,,0,0,0,,它和快速排序的区别在于  快速排序需要查看两个子问题
Dialogue: 0,0:30:29.30,0:30:31.38,英文,,0,0,0,,That's what gave it the n log n character.
Dialogue: 0,0:30:29.30,0:30:31.38,中文,,0,0,0,,这导致了 N log N 的时间复杂度特性
Dialogue: 0,0:30:31.38,0:30:35.30,英文,,0,0,0,,In this case, the size of the subproblem gets cut in half every single time.
Dialogue: 0,0:30:31.38,0:30:35.30,中文,,0,0,0,,在这种情况下  子问题的大小每次都会减少一半
Dialogue: 0,0:30:35.30,0:30:39.77,英文,,0,0,0,,So you're down to a theta of n runtime.
Dialogue: 0,0:30:35.30,0:30:39.77,中文,,0,0,0,,所以你的运行时间降到了Θ(N)
Dialogue: 0,0:30:39.77,0:30:44.89,英文,,0,0,0,,Technically, I'm cheating a little bit here because you're not cutting the problem exactly in half.
Dialogue: 0,0:30:39.77,0:30:44.89,中文,,0,0,0,,严格来说  我在这里有点作弊  因为你并没有把问题完全分成两半
Dialogue: 0,0:30:44.89,0:30:52.40,英文,,0,0,0,,And in fact, if you actually cut the problem exactly in half, you would be done right here, because you would have found the median on the first try.
Dialogue: 0,0:30:44.89,0:30:52.40,中文,,0,0,0,,事实上  如果你真的把问题完全分成两半  你在这里就完成了  因为你第一次尝试就找到了中位数
Dialogue: 0,0:30:52.40,0:30:56.24,英文,,0,0,0,,But we're going to say, on average, it takes theta of n time.
Dialogue: 0,0:30:52.40,0:30:56.24,中文,,0,0,0,,但我们要说  平均而言  它需要Θ(N) 时间
Dialogue: 0,0:30:56.24,0:30:59.56,英文,,0,0,0,,So it's not a proof, but it's a rough sketch.
Dialogue: 0,0:30:56.24,0:30:59.56,中文,,0,0,0,,所以这不是一个证明  而是一个粗略的草图
Dialogue: 0,0:30:59.56,0:31:03.19,英文,,0,0,0,,The problem gets approximately half as hard each time.
Dialogue: 0,0:30:59.56,0:31:03.19,中文,,0,0,0,,每次问题都会变得大约一半难
Dialogue: 0,0:31:03.19,0:31:05.55,英文,,0,0,0,,OK.
Dialogue: 0,0:31:03.19,0:31:05.55,中文,,0,0,0,,
Dialogue: 0,0:31:05.55,0:31:15.51,英文,,0,0,0,,is a very strange thing to do, but what if you used partitioning to find the median, and then you use that to partition the array for quicksort?
Dialogue: 0,0:31:05.55,0:31:15.51,中文,,0,0,0,,这是一件很奇怪的事情  但是如果你用分区来找到中位数  然后你用它来为快速排序分区数组呢？
Dialogue: 0,0:31:15.51,0:31:18.63,英文,,0,0,0,,So you're using partitioning to figure out how to partition.
Dialogue: 0,0:31:15.51,0:31:18.63,中文,,0,0,0,,所以你正在使用分区来确定如何分区
Dialogue: 0,0:31:18.63,0:31:26.35,英文,,0,0,0,,It's very weird, and you could do it, but turns out the runtime is still not great for the same reasons that the pick algorithm wasn't great,
Dialogue: 0,0:31:18.63,0:31:26.35,中文,,0,0,0,,这很奇怪  你可以这样做  但结果证明  运行时间仍然不是很好  原因与选择算法不好相同
Dialogue: 0,0:31:26.35,0:31:32.61,英文,,0,0,0,,because you're spending too much time being perfect when being approximate and shuffling is good enough.
Dialogue: 0,0:31:26.35,0:31:32.61,中文,,0,0,0,,因为当你近似的时候  你花了太多时间来追求完美  而随机排序就足够好了
Dialogue: 0,0:31:32.61,0:31:33.93,英文,,0,0,0,,OK.
Dialogue: 0,0:31:32.61,0:31:33.93,中文,,0,0,0,,
Dialogue: 0,0:31:33.93,0:31:37.49,英文,,0,0,0,,Do you have final thoughts on quicksort before I leave you forever?
Dialogue: 0,0:31:33.93,0:31:37.49,中文,,0,0,0,,在我永远离开你之前  你对快速排序有什么最后的看法吗？
Dialogue: 0,0:31:37.49,0:31:38.75,英文,,0,0,0,,It's the fastest known sort.
Dialogue: 0,0:31:37.49,0:31:38.75,中文,,0,0,0,,它是目前已知最快的排序算法
Dialogue: 0,0:31:38.75,0:31:41.26,英文,,0,0,0,,There are all these different fun little variations.
Dialogue: 0,0:31:38.75,0:31:41.26,中文,,0,0,0,,它有各种各样有趣的小变化
Dialogue: 0,0:31:41.26,0:31:47.36,英文,,0,0,0,,And as a dessert, I showed you the quick select algorithm where I adapted it for median finding.
Dialogue: 0,0:31:41.26,0:31:47.36,中文,,0,0,0,,作为甜点  我向你展示了快速选择算法  我把它用于中位数查找
Dialogue: 0,0:31:47.36,0:31:48.58,英文,,0,0,0,,You have no more thoughts?
Dialogue: 0,0:31:47.36,0:31:48.58,中文,,0,0,0,,你没有更多的想法了吗？
Dialogue: 0,0:31:48.58,0:31:51.68,英文,,0,0,0,,OK, so that means I get to ride off into the sunset.
Dialogue: 0,0:31:48.58,0:31:51.68,中文,,0,0,0,,好的  那意味着我可以功成身退了
Dialogue: 0,0:31:51.68,0:31:55.89,英文,,0,0,0,,Do not tell the other two guys that I showed you quicksort, otherwise they'll get mad at me.
Dialogue: 0,0:31:51.68,0:31:55.89,中文,,0,0,0,,别告诉另外两个人我演示了快速排序  不然他们会生我气的
Dialogue: 0,0:31:55.89,0:31:58.41,英文,,0,0,0,,OK, I will be back when you need me in post.
Dialogue: 0,0:31:55.89,0:31:58.41,中文,,0,0,0,,好的  后期制作需要我的时候我会回来的
Dialogue: 0,0:31:58.41,0:32:00.27,英文,,0,0,0,,OK, costume change.
Dialogue: 0,0:31:58.41,0:32:00.27,中文,,0,0,0,,好的  换装
Dialogue: 0,0:32:00.27,0:32:01.47,英文,,0,0,0,,Hold on.
Dialogue: 0,0:32:00.27,0:32:01.47,中文,,0,0,0,,等一下
Dialogue: 0,0:32:01.47,0:32:03.10,英文,,0,0,0,,OK.
Dialogue: 0,0:32:01.47,0:32:03.10,中文,,0,0,0,,
Dialogue: 0,0:32:03.10,0:32:04.98,英文,,0,0,0,,OK, I don't know what I missed.
Dialogue: 0,0:32:03.10,0:32:04.98,中文,,0,0,0,,好的  我不知道我错过了什么
Dialogue: 0,0:32:04.98,0:32:06.34,英文,,0,0,0,,So I'm back.
Dialogue: 0,0:32:04.98,0:32:06.34,中文,,0,0,0,,我回来了
Dialogue: 0,0:32:06.34,0:32:09.78,英文,,0,0,0,,OK, I'm here to show you all about radix sorts.
Dialogue: 0,0:32:06.34,0:32:09.78,中文,,0,0,0,,好的  我来这里向大家介绍基数排序
Dialogue: 0,0:32:09.78,0:32:12.09,英文,,0,0,0,,Did the other guy mess anything up?
Dialogue: 0,0:32:09.78,0:32:12.09,中文,,0,0,0,,那个人搞砸了什么吗？
Dialogue: 0,0:32:12.09,0:32:13.05,英文,,0,0,0,,Did you show?
Dialogue: 0,0:32:12.09,0:32:13.05,中文,,0,0,0,,你演示了吗？
Dialogue: 0,0:32:13.05,0:32:14.63,英文,,0,0,0,,You all have to fix it.
Dialogue: 0,0:32:13.05,0:32:14.63,中文,,0,0,0,,你们都得解决这个问题
Dialogue: 0,0:32:14.63,0:32:15.53,英文,,0,0,0,,Oh, he messed some stuff up?
Dialogue: 0,0:32:14.63,0:32:15.53,中文,,0,0,0,,哦  他搞砸了一些东西？
Dialogue: 0,0:32:15.53,0:32:17.81,英文,,0,0,0,,Where did he show the audience?
Dialogue: 0,0:32:15.53,0:32:17.81,中文,,0,0,0,,他给观众演示到哪里了？
Dialogue: 0,0:32:17.81,0:32:19.33,英文,,0,0,0,,What topics?
Dialogue: 0,0:32:17.81,0:32:19.33,中文,,0,0,0,,什么主题？
Dialogue: 0,0:32:19.33,0:32:21.09,英文,,0,0,0,,Don't worry about it.
Dialogue: 0,0:32:19.33,0:32:21.09,中文,,0,0,0,,别担心
Dialogue: 0,0:32:21.09,0:32:24.55,英文,,0,0,0,,Are you telling anything about sorts that we shouldn't have showed them?
Dialogue: 0,0:32:21.09,0:32:24.55,中文,,0,0,0,,你有没有讲一些我们不应该展示的排序算法？
Dialogue: 0,0:32:24.55,0:32:25.93,英文,,0,0,0,,I don't know.
Dialogue: 0,0:32:24.55,0:32:25.93,中文,,0,0,0,,我不知道
Dialogue: 0,0:32:25.93,0:32:27.21,英文,,0,0,0,,I was kind of blacked out the entire time.
Dialogue: 0,0:32:25.93,0:32:27.21,中文,,0,0,0,,我当时全程都断片了
Dialogue: 0,0:32:27.21,0:32:28.57,英文,,0,0,0,,Oh, you were blacked out too?
Dialogue: 0,0:32:27.21,0:32:28.57,中文,,0,0,0,,哦  你也断片了吗？
Dialogue: 0,0:32:28.57,0:32:31.55,英文,,0,0,0,,Did they show you anything that we shouldn't have seen?
Dialogue: 0,0:32:28.57,0:32:31.55,中文,,0,0,0,,他们有没有给你们看什么不该看的东西？
Dialogue: 0,0:32:31.55,0:32:34.73,英文,,0,0,0,,Any sorts?
Dialogue: 0,0:32:31.55,0:32:34.73,中文,,0,0,0,,任何排序算法吗？
Dialogue: 0,0:32:34.73,0:32:36.29,英文,,0,0,0,,Are you sure?
Dialogue: 0,0:32:34.73,0:32:36.29,中文,,0,0,0,,你确定吗？
Dialogue: 0,0:32:36.29,0:32:43.68,英文,,0,0,0,,Because I'm looking on the slide, and it really looks like the other guy showed you quicksort when he wasn't supposed to.
Dialogue: 0,0:32:36.29,0:32:43.68,中文,,0,0,0,,因为我正在看幻灯片  看起来另一个家伙给你们展示了快速排序  而他不应该这么做
Dialogue: 0,0:32:43.68,0:32:47.33,英文,,0,0,0,,Because if the other guy showed you quicksort, well, now I'm very mad.
Dialogue: 0,0:32:43.68,0:32:47.33,中文,,0,0,0,,因为如果另一个家伙给你们展示了快速排序  好吧  我现在很生气
Dialogue: 0,0:32:47.33,0:32:51.83,英文,,0,0,0,,Because I wanted to show you a fast sort, and he showed you the fastest known sort.
Dialogue: 0,0:32:47.33,0:32:51.83,中文,,0,0,0,,因为我想给你们展示一个快速排序  而他给你们展示了已知最快的排序
Dialogue: 0,0:32:51.83,0:32:53.43,英文,,0,0,0,,So what am I supposed to do now?
Dialogue: 0,0:32:51.83,0:32:53.43,中文,,0,0,0,,那我该怎么办？
Dialogue: 0,0:32:53.43,0:32:55.56,英文,,0,0,0,,OK.
Dialogue: 0,0:32:53.43,0:32:55.56,中文,,0,0,0,,
Dialogue: 0,0:32:55.56,0:32:59.95,英文,,0,0,0,,If the other guy showed you quicksort, which I sure hope he didn't,
Dialogue: 0,0:32:55.56,0:32:59.95,中文,,0,0,0,,如果另一个家伙给你们展示了快速排序  我当然希望他没有
Dialogue: 0,0:32:59.95,0:33:04.27,英文,,0,0,0,,then now I look stupid because I was supposed to show you the fastest sort.
Dialogue: 0,0:32:59.95,0:33:04.27,中文,,0,0,0,,那我现在看起来很傻  因为我本来应该给你们展示最快的排序
Dialogue: 0,0:33:04.27,0:33:05.47,英文,,0,0,0,,So you know what I'm going to do?
Dialogue: 0,0:33:04.27,0:33:05.47,中文,,0,0,0,,所以你知道我要做什么吗？
Dialogue: 0,0:33:05.47,0:33:08.21,英文,,0,0,0,,That other guy, he thought he had you with quicksort.
Dialogue: 0,0:33:05.47,0:33:08.21,中文,,0,0,0,,那个家伙  他以为用快速排序就能搞定你们
Dialogue: 0,0:33:08.21,0:33:09.61,英文,,0,0,0,,I'm going to beat him.
Dialogue: 0,0:33:08.21,0:33:09.61,中文,,0,0,0,,我要打败他
Dialogue: 0,0:33:09.61,0:33:10.67,英文,,0,0,0,,So forget quicksort.
Dialogue: 0,0:33:09.61,0:33:10.67,中文,,0,0,0,,所以忘记快速排序吧
Dialogue: 0,0:33:10.67,0:33:14.87,英文,,0,0,0,,I'm going to show you something even faster.
Dialogue: 0,0:33:10.67,0:33:14.87,中文,,0,0,0,,我要给你们展示一些更快的
Dialogue: 0,0:33:14.87,0:33:19.38,英文,,0,0,0,,Before I do that, here's a warm-up topic, which is sorting stability.
Dialogue: 0,0:33:14.87,0:33:19.38,中文,,0,0,0,,在开始之前  这里有一个热身话题  那就是排序稳定性
Dialogue: 0,0:33:19.38,0:33:21.16,英文,,0,0,0,,And we'll need you for this next topic.
Dialogue: 0,0:33:19.38,0:33:21.16,中文,,0,0,0,,下一个话题我们需要你参与
Dialogue: 0,0:33:21.16,0:33:23.62,英文,,0,0,0,,So, so far, you've seen a bunch of different sorts.
Dialogue: 0,0:33:21.16,0:33:23.62,中文,,0,0,0,,到目前为止  你们已经看到了很多不同的排序
Dialogue: 0,0:33:23.62,0:33:31.12,英文,,0,0,0,,And remember, the thing I showed you before I left, like a week ago, is that each sort has a key operation that makes it work.
Dialogue: 0,0:33:23.62,0:33:31.12,中文,,0,0,0,,记住  我一周前离开之前给你们展示的东西  每个排序都有一个关键操作  让它起作用
Dialogue: 0,0:33:31.12,0:33:34.53,英文,,0,0,0,,So heap sort, the operation was put things in a heap and remove it.
Dialogue: 0,0:33:31.12,0:33:34.53,中文,,0,0,0,,所以堆排序的操作是把东西放进堆里  然后移除
Dialogue: 0,0:33:34.53,0:33:37.63,英文,,0,0,0,,There was insertion sort, where the operation was traveling.
Dialogue: 0,0:33:34.53,0:33:37.63,中文,,0,0,0,,还有插入排序  操作是移动
Dialogue: 0,0:33:37.63,0:33:41.77,英文,,0,0,0,,There was merge sort, where the operation was merging two smaller arrays into one.
Dialogue: 0,0:33:37.63,0:33:41.77,中文,,0,0,0,,有一种叫做合并排序的排序算法  它的操作是将两个较小的数组合并成一个
Dialogue: 0,0:33:41.77,0:33:47.57,英文,,0,0,0,,And then the top secret thing that you didn't see, which is quicksort, where you partition an array
Dialogue: 0,0:33:41.77,0:33:47.57,中文,,0,0,0,,还有一种你没看到的“最高机密”排序算法  叫做快速排序  它将数组进行分区
Dialogue: 0,0:33:47.57,0:33:52.01,英文,,0,0,0,,and put all the items that are less than to one side, all the items that are greater than to the other side.
Dialogue: 0,0:33:47.57,0:33:52.01,中文,,0,0,0,,把所有小于基准值的元素放在一边  所有大于基准值的元素放在另一边
Dialogue: 0,0:33:52.01,0:33:59.35,英文,,0,0,0,,And we saw that in all of these cases, the best we could do is n log n.
Dialogue: 0,0:33:52.01,0:33:59.35,中文,,0,0,0,,我们看到  在所有这些情况下  我们能做的最好的结果是 N log N 的时间复杂度
Dialogue: 0,0:33:59.35,0:34:06.04,英文,,0,0,0,,So one property that we haven't really talked about yet, but I'll tell you about really quickly, is stability.
Dialogue: 0,0:33:59.35,0:34:06.04,中文,,0,0,0,,有一个我们还没有真正讨论过的属性  但我很快就会告诉你的  那就是稳定性
Dialogue: 0,0:34:06.04,0:34:13.24,英文,,0,0,0,,So do you remember all the way back in sorting one, I told you that sometimes you can sort on different things.
Dialogue: 0,0:34:06.04,0:34:13.24,中文,,0,0,0,,还记得我们在第一节排序中提到的吗  我告诉过你  有时候你可以根据不同的标准进行排序
Dialogue: 0,0:34:13.24,0:34:15.13,英文,,0,0,0,,So they give you an object.
Dialogue: 0,0:34:13.24,0:34:15.13,中文,,0,0,0,,比如给你一个对象
Dialogue: 0,0:34:15.13,0:34:17.95,英文,,0,0,0,,or a bunch of objects, there can be different ways to sort them.
Dialogue: 0,0:34:15.13,0:34:17.95,中文,,0,0,0,,或者一堆对象  可以有不同的方法对它们进行排序
Dialogue: 0,0:34:17.95,0:34:26.13,英文,,0,0,0,,So for example, I gave you the strings, and we said, you can sort them by alphabetical order, but you could also sort them by, for example, length of the strings.
Dialogue: 0,0:34:17.95,0:34:26.13,中文,,0,0,0,,例如我给了你一些字符串  我们说你可以按字母顺序对它们进行排序  但你也可以按字符串的长度进行排序
Dialogue: 0,0:34:26.13,0:34:29.53,英文,,0,0,0,,Put the shorter strings in front, put the longer strings in the back.
Dialogue: 0,0:34:26.13,0:34:29.53,中文,,0,0,0,,把较短的字符串放在前面  把较长的字符串放在后面
Dialogue: 0,0:34:29.53,0:34:31.47,英文,,0,0,0,,So that's something we can do here.
Dialogue: 0,0:34:29.53,0:34:31.47,中文,,0,0,0,,所以这是我们可以在这里做的事情
Dialogue: 0,0:34:31.47,0:34:36.99,英文,,0,0,0,,Let's say I have this class where every item is a student, and the student has two things.
Dialogue: 0,0:34:31.47,0:34:36.99,中文,,0,0,0,,假设我有一个类  每个项目都是一个学生  学生有两个属性
Dialogue: 0,0:34:36.99,0:34:39.31,英文,,0,0,0,,They have a name, and they have a section number.
Dialogue: 0,0:34:36.99,0:34:39.31,中文,,0,0,0,,他们有姓名和编号
Dialogue: 0,0:34:39.31,0:34:43.66,英文,,0,0,0,,So this object is,
Dialogue: 0,0:34:39.31,0:34:43.66,中文,,0,0,0,,所以这个对象是...
Dialogue: 0,0:34:43.66,0:34:51.28,英文,,0,0,0,,So in this case, there are actually two things I could sort by.
Dialogue: 0,0:34:43.66,0:34:51.28,中文,,0,0,0,,在这种情况下  实际上有两个属性我可以用来排序
Dialogue: 0,0:34:51.28,0:34:58.00,英文,,0,0,0,,I could sort by their name and put them in alphabetical order, or I could sort them by their section number
Dialogue: 0,0:34:51.28,0:34:58.00,中文,,0,0,0,,我可以按他们的姓名排序  并按字母顺序排列  或者我可以按他们的编号排序
Dialogue: 0,0:34:58.00,0:35:03.92,英文,,0,0,0,,so that people in section 1 come first, and then section 2, and then section 3, and then section 4.
Dialogue: 0,0:34:58.00,0:35:03.92,中文,,0,0,0,,这样1号的学生排在前面  然后是2号  然后是3号  然后是4号
Dialogue: 0,0:35:03.92,0:35:05.96,英文,,0,0,0,,So I actually have different choices for what to sort by.
Dialogue: 0,0:35:03.92,0:35:05.96,中文,,0,0,0,,所以实际上我有多种选择来决定排序依据
Dialogue: 0,0:35:05.96,0:35:08.27,英文,,0,0,0,,There are different orderings I can feed in.
Dialogue: 0,0:35:05.96,0:35:08.27,中文,,0,0,0,,我可以输入不同的排序方式
Dialogue: 0,0:35:08.27,0:35:13.67,英文,,0,0,0,,So the question is, well, what if I wanted to sort by both orders?
Dialogue: 0,0:35:08.27,0:35:13.67,中文,,0,0,0,,所以问题是  如果我想按两种顺序排序怎么办？
Dialogue: 0,0:35:13.67,0:35:17.91,英文,,0,0,0,,That is, I want to sort by name, but I also want to sort by section number.
Dialogue: 0,0:35:13.67,0:35:17.91,中文,,0,0,0,,也就是说  我想按姓名排序  但我也想按编号排序
Dialogue: 0,0:35:17.91,0:35:23.11,英文,,0,0,0,,So for example, maybe what I want to do is I want to sort them by section number, but when there is a tie,
Dialogue: 0,0:35:17.91,0:35:23.11,中文,,0,0,0,,例如  也许我想做的是按编号排序  但当出现平局时
Dialogue: 0,0:35:23.11,0:35:31.29,英文,,0,0,0,,like there are multiple people in the same section, I want the people within that same section to be alphabetically sorted.
Dialogue: 0,0:35:23.11,0:35:31.29,中文,,0,0,0,,比如有多个学生在同一个编号  我希望同一编号内的学生按字母顺序排列
Dialogue: 0,0:35:31.29,0:35:36.07,英文,,0,0,0,,So then one thing I could do is I could first start by alphabetically sorting everybody.
Dialogue: 0,0:35:31.29,0:35:36.07,中文,,0,0,0,,我可以先按字母顺序对所有人进行排序
Dialogue: 0,0:35:36.07,0:35:40.96,英文,,0,0,0,,So if you look at this one, b, f, j. This is totally alphabetically sorted.
Dialogue: 0,0:35:36.07,0:35:40.96,中文,,0,0,0,,看这里  b、f、j  完全是按字母顺序排列的
Dialogue: 0,0:35:40.96,0:35:45.98,英文,,0,0,0,,So I sorted by a name, completely ignoring the section number, and now,
Dialogue: 0,0:35:40.96,0:35:45.98,中文,,0,0,0,,我按姓名排序  完全忽略了编号  现在
Dialogue: 0,0:35:45.98,0:35:48.83,英文,,0,0,0,,What if I then sorted by section number?
Dialogue: 0,0:35:45.98,0:35:48.83,中文,,0,0,0,,如果再按编号排序呢？
Dialogue: 0,0:35:48.83,0:35:50.77,英文,,0,0,0,,So they're already sorted by name.
Dialogue: 0,0:35:48.83,0:35:50.77,中文,,0,0,0,,他们已经按姓名排序了
Dialogue: 0,0:35:50.77,0:35:53.09,英文,,0,0,0,,Now I want to sort by section number.
Dialogue: 0,0:35:50.77,0:35:53.09,中文,,0,0,0,,现在我想按编号排序
Dialogue: 0,0:35:53.09,0:36:02.52,英文,,0,0,0,,Well, one thing I don't want to happen if I want the array to be sorted by both name and section number is I don't want the alphabetical order to get messed up.
Dialogue: 0,0:35:53.09,0:36:02.52,中文,,0,0,0,,如果我希望数组同时按姓名和编号排序  我不希望字母顺序被打乱
Dialogue: 0,0:36:02.52,0:36:06.47,英文,,0,0,0,,I just went through all this trouble getting all the names in alphabetical order.
Dialogue: 0,0:36:02.52,0:36:06.47,中文,,0,0,0,,我费了很大劲才把所有名字按字母顺序排列好
Dialogue: 0,0:36:06.47,0:36:11.91,英文,,0,0,0,,So now when I sort by section number, I do not want the alphabetical order to be messed up.
Dialogue: 0,0:36:06.47,0:36:11.91,中文,,0,0,0,,所以现在当我按编号排序时  我不希望字母顺序被打乱
Dialogue: 0,0:36:11.91,0:36:25.10,英文,,0,0,0,,Specifically, what's going to happen is when I sort by section number, a bunch of people with section number three are all going to get bunched together, specifically Bass, Jayna, Joni, and Rosella.
Dialogue: 0,0:36:11.91,0:36:25.10,中文,,0,0,0,,具体来说  当我按编号排序时  一堆编号为 3 的人都会被放在一起  特别是 Bass、Jayna、Joni 和 Rosella
Dialogue: 0,0:36:25.10,0:36:33.36,英文,,0,0,0,,And what I want to happen is when these people get bunched up together in section 3, I want their relative alphabetical order to be preserved.
Dialogue: 0,0:36:25.10,0:36:33.36,中文,,0,0,0,,我希望发生的是  当这些人被集中到第 3 组时  我希望他们原来的字母顺序得以保留
Dialogue: 0,0:36:33.36,0:36:40.92,英文,,0,0,0,,So if that is the case, then I say that this sort of stable, because these items are in their relative order.
Dialogue: 0,0:36:33.36,0:36:40.92,中文,,0,0,0,,如果是这样的话  那么我认为这种排序是稳定的  因为这些项目的相对顺序没有改变
Dialogue: 0,0:36:40.92,0:36:51.39,英文,,0,0,0,,Even though all of them have the same section number of 3, and I'm sorting on the section number of 3, their relative order, which in this case just happens to be alphabetical, stays the same.
Dialogue: 0,0:36:40.92,0:36:51.39,中文,,0,0,0,,即使他们都有相同的编号 3  而且我是按编号 3 排序的  但他们的相对顺序  在这种情况下恰好是字母顺序  保持不变
Dialogue: 0,0:36:51.39,0:36:53.67,英文,,0,0,0,,Here's an example where they're not stable.
Dialogue: 0,0:36:51.39,0:36:53.67,中文,,0,0,0,,这里有一个例子  它们不是稳定的
Dialogue: 0,0:36:53.67,0:36:57.85,英文,,0,0,0,,Here's a case where all of them have the same section number of three.
Dialogue: 0,0:36:53.67,0:36:57.85,中文,,0,0,0,,这里有一个例子  所有人的编号都是 3
Dialogue: 0,0:36:57.85,0:37:00.79,英文,,0,0,0,,And when I sort by section, this is a valid sort.
Dialogue: 0,0:36:57.85,0:37:00.79,中文,,0,0,0,,当我按编号排序时  这是一个有效的排序
Dialogue: 0,0:37:00.79,0:37:03.87,英文,,0,0,0,,I'm still putting all the threes before the fours.
Dialogue: 0,0:37:00.79,0:37:03.87,中文,,0,0,0,,我仍然把所有的 3 放在 4 之前
Dialogue: 0,0:37:03.87,0:37:07.93,英文,,0,0,0,,But this is no longer stable because the items are crossing over.
Dialogue: 0,0:37:03.87,0:37:07.93,中文,,0,0,0,,但这不再是稳定的  因为项目之间交叉了
Dialogue: 0,0:37:07.93,0:37:20.14,英文,,0,0,0,,And one reason why non-stable sorts can be bad is because by crossing over, I am losing the relative order of, say, alphabetical that I had set up earlier.
Dialogue: 0,0:37:07.93,0:37:20.14,中文,,0,0,0,,非稳定排序不好的一个原因是  通过交叉  我失去了之前设置的字母顺序等相对顺序
Dialogue: 0,0:37:20.14,0:37:24.65,英文,,0,0,0,,That's sorting stability versus instability.
Dialogue: 0,0:37:20.14,0:37:24.65,中文,,0,0,0,,这就是排序的稳定性与不稳定性
Dialogue: 0,0:37:24.65,0:37:26.75,英文,,0,0,0,,Thoughts, opinions?
Dialogue: 0,0:37:24.65,0:37:26.75,中文,,0,0,0,,想法？意见？
Dialogue: 0,0:37:26.75,0:37:32.94,英文,,0,0,0,,Okay, so it's one of those things, to be honest, a little hard to explain, but I think if you look at the pictures, you'll see that
Dialogue: 0,0:37:26.75,0:37:32.94,中文,,0,0,0,,说实话  这个概念有点难解释  但是我想如果你看图片  你就会明白
Dialogue: 0,0:37:32.94,0:37:41.88,英文,,0,0,0,,stability means items that are the same keep their same relative order, whereas instability means items that are the same could possibly cross over each other.
Dialogue: 0,0:37:32.94,0:37:41.88,中文,,0,0,0,,稳定性意味着相同的元素保持它们原来的相对顺序  而*不稳定*意味着相同的元素可能会互相交叉
Dialogue: 0,0:37:41.88,0:37:43.61,英文,,0,0,0,,So some questions for you.
Dialogue: 0,0:37:41.88,0:37:43.61,中文,,0,0,0,,所以这里有些问题要问你
Dialogue: 0,0:37:43.61,0:37:45.19,英文,,0,0,0,,Is insertion sort stable?
Dialogue: 0,0:37:43.61,0:37:45.19,中文,,0,0,0,,插入排序是稳定的吗？
Dialogue: 0,0:37:45.19,0:37:47.09,英文,,0,0,0,,Is quick sort stable?
Dialogue: 0,0:37:45.19,0:37:47.09,中文,,0,0,0,,快速排序是稳定的吗？
Dialogue: 0,0:37:47.09,0:37:48.81,英文,,0,0,0,,I'll just quickly spoil them, I guess.
Dialogue: 0,0:37:47.09,0:37:48.81,中文,,0,0,0,,我想我会直接剧透答案
Dialogue: 0,0:37:48.81,0:37:50.27,英文,,0,0,0,,So insertion sort, what does it do?
Dialogue: 0,0:37:48.81,0:37:50.27,中文,,0,0,0,,那么插入排序  它是如何工作的呢？
Dialogue: 0,0:37:50.27,0:37:55.32,英文,,0,0,0,,It takes an item and it travels the item backwards until it finds its rightful place.
Dialogue: 0,0:37:50.27,0:37:55.32,中文,,0,0,0,,它会取一个元素  并将其向后移动  直到找到它正确的位置
Dialogue: 0,0:37:55.32,0:38:04.23,英文,,0,0,0,,And if you implement insertion sort such that when it sees an item, the traveling item, it travels, if it sees an item that's equivalent and it stops,
Dialogue: 0,0:37:55.32,0:38:04.23,中文,,0,0,0,,如果你这样实现插入排序  当它看到一个元素  也就是移动的元素  它会移动  如果它看到一个等效的元素  它就会停止
Dialogue: 0,0:38:04.23,0:38:05.61,英文,,0,0,0,,Then the sword is stable.
Dialogue: 0,0:38:04.23,0:38:05.61,中文,,0,0,0,,那么这个排序就是稳定的
Dialogue: 0,0:38:05.61,0:38:07.13,英文,,0,0,0,,I'll see if I can find an example in here.
Dialogue: 0,0:38:05.61,0:38:07.13,中文,,0,0,0,,我看看能不能在这里找到一个例子
Dialogue: 0,0:38:07.13,0:38:13.90,英文,,0,0,0,,OK, so let's say this E at the very end, it travels all the way over, and it stops here, and it looks to its left and says, oh, there's another E.
Dialogue: 0,0:38:07.13,0:38:13.90,中文,,0,0,0,,好的  假设最后这个E  它一路移动过来  停在这里  它向左看  说  哦  这里还有另一个E
Dialogue: 0,0:38:13.90,0:38:21.38,英文,,0,0,0,, If it stops right there, then insertion sword is stable, because these two E's, they don't cross over.
Dialogue: 0,0:38:13.90,0:38:21.38,中文,,0,0,0,,如果它就停在那里  那么插入排序就是稳定的  因为这两个E  它们没有交叉
Dialogue: 0,0:38:21.38,0:38:22.58,英文,,0,0,0,,Is QuickSort stable?
Dialogue: 0,0:38:21.38,0:38:22.58,中文,,0,0,0,,快速排序稳定吗？
Dialogue: 0,0:38:22.58,0:38:28.58,英文,,0,0,0,,It depends on whether you use these different partitioning strategies, which you have never seen before.
Dialogue: 0,0:38:22.58,0:38:28.58,中文,,0,0,0,,这取决于你是否使用这些不同的分区策略  你之前从未见过
Dialogue: 0,0:38:28.58,0:38:32.59,英文,,0,0,0,,If you use three scan partitioning, then QuickSort is stable.
Dialogue: 0,0:38:28.58,0:38:32.59,中文,,0,0,0,,如果你使用三扫描分区  那么快速排序是稳定的
Dialogue: 0,0:38:32.59,0:38:35.71,英文,,0,0,0,,Because when you scan, you say three, one, two, three.
Dialogue: 0,0:38:32.59,0:38:35.71,中文,,0,0,0,,因为当你扫描时  你说3  1  2  3
Dialogue: 0,0:38:35.71,0:38:37.01,英文,,0,0,0,,They go on the left side.
Dialogue: 0,0:38:35.71,0:38:37.01,中文,,0,0,0,,它们在左侧
Dialogue: 0,0:38:37.01,0:38:39.33,英文,,0,0,0,,And then seven, eight, they go on the right side.
Dialogue: 0,0:38:37.01,0:38:39.33,中文,,0,0,0,,然后7  8  它们在右侧
Dialogue: 0,0:38:39.33,0:38:43.55,英文,,0,0,0,,So the relative ordering of the threes, for example, they stay the same.
Dialogue: 0,0:38:39.33,0:38:43.55,中文,,0,0,0,,例如  三个的相对顺序保持不变
Dialogue: 0,0:38:43.55,0:38:47.89,英文,,0,0,0,,Because as you scan, you see the first three and then the second three.
Dialogue: 0,0:38:43.55,0:38:47.89,中文,,0,0,0,,因为当你扫描时  你首先看到第一个3  然后是第二个3
Dialogue: 0,0:38:47.89,0:38:49.57,英文,,0,0,0,,So they stay in the same relative order.
Dialogue: 0,0:38:47.89,0:38:49.57,中文,,0,0,0,,这样它们就能保持相对顺序
Dialogue: 0,0:38:49.57,0:38:54.93,英文,,0,0,0,,By contrast, if you use something weirder like Hoare partitioning, the items swap back and forth.
Dialogue: 0,0:38:49.57,0:38:54.93,中文,,0,0,0,,相反  如果你使用一些更奇怪的东西  比如 Hoare 分区  这些项目会来回交换
Dialogue: 0,0:38:54.93,0:38:58.42,英文,,0,0,0,,And in that case, it's possible that the 3s end up crossing over.
Dialogue: 0,0:38:54.93,0:38:58.42,中文,,0,0,0,,在这种情况下  3 有可能最终交叉
Dialogue: 0,0:38:58.42,0:39:06.02,英文,,0,0,0,,And if you're not convinced you can run the partitioning algorithm, you'll see that these two 3s actually swap places, which we don't want.
Dialogue: 0,0:38:58.42,0:39:06.02,中文,,0,0,0,,如果你不相信你可以运行分区算法  你会看到这两个 3 实际上交换了位置  这不是我们想要的
Dialogue: 0,0:39:06.02,0:39:07.62,英文,,0,0,0,,So that's stability.
Dialogue: 0,0:39:06.02,0:39:07.62,中文,,0,0,0,,这就是稳定性
Dialogue: 0,0:39:07.62,0:39:13.84,英文,,0,0,0,,It can be useful in applications like, as you saw earlier, if I want to sort on two different orders at the same time.
Dialogue: 0,0:39:07.62,0:39:13.84,中文,,0,0,0,,它可以在应用程序中很有用  就像你之前看到的  如果我想同时对两个不同的顺序进行排序
Dialogue: 0,0:39:13.84,0:39:17.63,英文,,0,0,0,,We'll also see another application today.
Dialogue: 0,0:39:13.84,0:39:17.63,中文,,0,0,0,,今天我们还将看到另一个应用
Dialogue: 0,0:39:17.63,0:39:18.58,英文,,0,0,0,,So that's stability.
Dialogue: 0,0:39:17.63,0:39:18.58,中文,,0,0,0,,这就是稳定性
Dialogue: 0,0:39:18.58,0:39:22.34,英文,,0,0,0,,Turns out some sorts are stable, some sorts are not.
Dialogue: 0,0:39:18.58,0:39:22.34,中文,,0,0,0,,事实证明  有些排序是稳定的  有些排序则不是
Dialogue: 0,0:39:22.34,0:39:24.44,英文,,0,0,0,,OK.
Dialogue: 0,0:39:22.34,0:39:24.44,中文,,0,0,0,,好的
Dialogue: 0,0:39:24.44,0:39:31.71,英文,,0,0,0,,By the way, like a puzzle for you later, turns out in Java, and the answer has to do with stability,
Dialogue: 0,0:39:24.44,0:39:31.71,中文,,0,0,0,,顺便说一下  就像一个留给你们以后解决的谜题  事实证明在 Java 中  答案与稳定性有关
Dialogue: 0,0:39:31.71,0:39:37.71,英文,,0,0,0,,so you can try and think of that, merge sort actually uses, or sorry, the sort method for arrays,
Dialogue: 0,0:39:31.71,0:39:37.71,中文,,0,0,0,,所以你可以试着想想  归并排序实际上使用  或者抱歉  数组的排序方法
Dialogue: 0,0:39:37.71,0:39:42.13,英文,,0,0,0,, if you pass in a bunch of objects, the arrays.sort in Java uses merge sort.
Dialogue: 0,0:39:37.71,0:39:42.13,中文,,0,0,0,,如果你传入一堆对象  Java 中的 arrays.sort 使用归并排序
Dialogue: 0,0:39:42.13,0:39:46.37,英文,,0,0,0,,And if you pass in primitives like integers, arrays.sort uses quicksort.
Dialogue: 0,0:39:42.13,0:39:46.37,中文,,0,0,0,,如果你传入像整数这样的基本类型  arrays.sort 使用快速排序
Dialogue: 0,0:39:46.37,0:39:49.75,英文,,0,0,0,,And this has to do with the fact that we want sorts to be stable.
Dialogue: 0,0:39:46.37,0:39:49.75,中文,,0,0,0,,这与我们希望排序是稳定的这一事实有关
Dialogue: 0,0:39:49.75,0:39:52.46,英文,,0,0,0,,And in merge sort, objects might cross over.
Dialogue: 0,0:39:49.75,0:39:52.46,中文,,0,0,0,,在归并排序中  对象可能会交叉
Dialogue: 0,0:39:52.46,0:39:57.26,英文,,0,0,0,,But in quicksort, if things are primitives, then crossing over is less of an issue.
Dialogue: 0,0:39:52.46,0:39:57.26,中文,,0,0,0,,但在快速排序中  如果事情是基本类型  那么交叉就不是什么大问题了
Dialogue: 0,0:39:57.26,0:40:02.62,英文,,0,0,0,,Not something I'll talk about in detail here, but kind of a fun puzzle if you have time at home.
Dialogue: 0,0:39:57.26,0:40:02.62,中文,,0,0,0,,我不会在这里详细讨论  但如果你在家里有时间  这是一个有趣的谜题
Dialogue: 0,0:40:02.62,0:40:05.12,英文,,0,0,0,,There's the answer if you want.
Dialogue: 0,0:40:02.62,0:40:05.12,中文,,0,0,0,,如果你愿意  答案就在这里
Dialogue: 0,0:40:05.12,0:40:09.88,英文,,0,0,0,,OK. Anything else you want to know before I keep going?
Dialogue: 0,0:40:05.12,0:40:09.88,中文,,0,0,0,,好的   在我继续之前  还有什么你想知道的？
Dialogue: 0,0:40:09.88,0:40:12.10,英文,,0,0,0,,OK.
Dialogue: 0,0:40:09.88,0:40:12.10,中文,,0,0,0,,
Dialogue: 0,0:40:12.10,0:40:14.78,英文,,0,0,0,,Because I have a couple more slides before I show you the last sort.
Dialogue: 0,0:40:12.10,0:40:14.78,中文,,0,0,0,,因为在展示最后一个排序算法之前  我还想再讲几张幻灯片
Dialogue: 0,0:40:14.78,0:40:19.27,英文,,0,0,0,,So there are a couple more tricks you can do to make sorts really fast.
Dialogue: 0,0:40:14.78,0:40:19.27,中文,,0,0,0,,还有一些技巧可以让排序变得非常快
Dialogue: 0,0:40:19.27,0:40:27.61,英文,,0,0,0,,One thing that you saw from a long time ago is that when problems get really small, insertion sort is actually the fastest sort.
Dialogue: 0,0:40:19.27,0:40:27.61,中文,,0,0,0,,很久以前你就知道  当问题规模非常小时  插入排序实际上是最快的排序算法
Dialogue: 0,0:40:27.61,0:40:35.51,英文,,0,0,0,,So even though it's n squared asymptotically, if you have an array that's approximately size 15 or smaller, insertion sort is faster than, say, merge sort,
Dialogue: 0,0:40:27.61,0:40:35.51,中文,,0,0,0,,即使它在渐进时间复杂度上是N²  如果你的数组大小约为15或更小  插入排序比归并排序更快
Dialogue: 0,0:40:35.51,0:40:41.89,英文,,0,0,0,, because merge sort spends all the time dividing the problem and saying, you do this half, you do this half.
Dialogue: 0,0:40:35.51,0:40:41.89,中文,,0,0,0,,因为归并排序会花费所有时间来分割问题  并说  你处理这一半  你处理那一半
Dialogue: 0,0:40:41.89,0:40:44.71,英文,,0,0,0,,Meanwhile, insertion sort just gets the job done.
Dialogue: 0,0:40:41.89,0:40:44.71,中文,,0,0,0,,而插入排序则可以快速完成任务
Dialogue: 0,0:40:44.71,0:40:49.84,英文,,0,0,0,,So for example, if you had merge sort, when the array splits into subarrays of size 15 or so,
Dialogue: 0,0:40:44.71,0:40:49.84,中文,,0,0,0,,例如  如果你使用归并排序  当数组分成大小约为15的子数组时
Dialogue: 0,0:40:49.84,0:40:55.38,英文,,0,0,0,,you can just give up and use insertion sort instead of using merge sort all the way to the end.
Dialogue: 0,0:40:49.84,0:40:55.38,中文,,0,0,0,,你可以放弃并使用插入排序  而不是一直使用归并排序到最后
Dialogue: 0,0:40:55.38,0:40:59.08,英文,,0,0,0,,That's one way to make sorts faster in real life.
Dialogue: 0,0:40:55.38,0:40:59.08,中文,,0,0,0,,这是一种在实际生活中使排序更快的方法
Dialogue: 0,0:40:59.08,0:41:01.68,英文,,0,0,0,,You can also do things like make sorts adaptive.
Dialogue: 0,0:40:59.08,0:41:01.68,中文,,0,0,0,,你还可以做一些事情  比如使排序自适应
Dialogue: 0,0:41:01.68,0:41:02.56,英文,,0,0,0,,I won't talk about it.
Dialogue: 0,0:41:01.68,0:41:02.56,中文,,0,0,0,,我不会谈论它
Dialogue: 0,0:41:02.56,0:41:07.00,英文,,0,0,0,,But you can analyze the array and use different sorts to make it faster.
Dialogue: 0,0:41:02.56,0:41:07.00,中文,,0,0,0,,但是你可以分析数组并使用不同的排序来使其更快
Dialogue: 0,0:41:07.00,0:41:10.48,英文,,0,0,0,,There's a sort in Python, and I guess Java as well, called TimSort.
Dialogue: 0,0:41:07.00,0:41:10.48,中文,,0,0,0,,Python中有一种排序  我猜Java也有  叫做TimSort
Dialogue: 0,0:41:10.48,0:41:12.12,英文,,0,0,0,,And it's named for Tim.
Dialogue: 0,0:41:10.48,0:41:12.12,中文,,0,0,0,,它以Tim的名字命名
Dialogue: 0,0:41:12.12,0:41:13.48,英文,,0,0,0,,There he is. Hello, Tim.
Dialogue: 0,0:41:12.12,0:41:13.48,中文,,0,0,0,,他来了   你好  Tim
Dialogue: 0,0:41:13.48,0:41:16.18,英文,,0,0,0,,So there are different things you can do.
Dialogue: 0,0:41:13.48,0:41:16.18,中文,,0,0,0,,所以你可以做不同的事情
Dialogue: 0,0:41:16.18,0:41:17.54,英文,,0,0,0,,I won't talk about all of them.
Dialogue: 0,0:41:16.18,0:41:17.54,中文,,0,0,0,,我不会谈论所有这些
Dialogue: 0,0:41:17.54,0:41:20.44,英文,,0,0,0,,But if you're interested, it's a really deep topic.
Dialogue: 0,0:41:17.54,0:41:20.44,中文,,0,0,0,,但是如果你感兴趣  这是一个非常深入的主题
Dialogue: 0,0:41:20.44,0:41:25.46,英文,,0,0,0,,There's all sorts of ways to try and make sort faster because it's something we use every day.
Dialogue: 0,0:41:20.44,0:41:25.46,中文,,0,0,0,,有很多方法可以尝试使排序更快  因为这是我们每天都在使用的东西
Dialogue: 0,0:41:25.46,0:41:27.37,英文,,0,0,0,,Pretty cool.
Dialogue: 0,0:41:25.46,0:41:27.37,中文,,0,0,0,,非常酷
Dialogue: 0,0:41:27.37,0:41:30.71,英文,,0,0,0,,Okay, that's it for sorting philosophy.
Dialogue: 0,0:41:27.37,0:41:30.71,中文,,0,0,0,,好的  排序原理就讲到这里
Dialogue: 0,0:41:30.71,0:41:37.45,英文,,0,0,0,,So now you're ready for the two big ideas of the day, whatever's left of today.
Dialogue: 0,0:41:30.71,0:41:37.45,中文,,0,0,0,,好了  现在你准备好迎接今天剩下的两个重要的概念了
Dialogue: 0,0:41:37.45,0:41:40.29,英文,,0,0,0,,Last time, you weren't supposed to learn quicksort, but you did.
Dialogue: 0,0:41:37.45,0:41:40.29,中文,,0,0,0,,上次课  你不应该学快速排序  但你学了
Dialogue: 0,0:41:40.29,0:41:44.19,英文,,0,0,0,,So now I'm jealous, so I have to show you an even faster sort.
Dialogue: 0,0:41:40.29,0:41:44.19,中文,,0,0,0,,所以现在我嫉妒了  我要向你展示一个更快的排序算法
Dialogue: 0,0:41:44.19,0:41:46.20,英文,,0,0,0,,And to do so, I'll show you two big ideas.
Dialogue: 0,0:41:44.19,0:41:46.20,中文,,0,0,0,,为此  我将向你展示两个重要的概念
Dialogue: 0,0:41:46.20,0:41:51.46,英文,,0,0,0,,And when we merge them together, you will get the fastest sort, even faster than quicksort.
Dialogue: 0,0:41:46.20,0:41:51.46,中文,,0,0,0,,当我们将它们结合在一起时  你将得到最快的排序算法  甚至比快速排序还要快
Dialogue: 0,0:41:51.46,0:42:00.12,英文,,0,0,0,,All right, so the first thing I'll do is something that's a little bit silly, and it's kind of a warm-up, which is I will do something called digit-by-digit sorting.
Dialogue: 0,0:41:51.46,0:42:00.12,中文,,0,0,0,,好的  我要做的第一件事有点傻  有点像热身  就是做一种叫做按位排序的操作
Dialogue: 0,0:42:00.12,0:42:02.18,英文,,0,0,0,,So let's say I have a bunch of integers.
Dialogue: 0,0:42:00.12,0:42:02.18,中文,,0,0,0,,假设我有一堆整数
Dialogue: 0,0:42:02.18,0:42:03.08,英文,,0,0,0,,Here they are.
Dialogue: 0,0:42:02.18,0:42:03.08,中文,,0,0,0,,就是这些
Dialogue: 0,0:42:03.08,0:42:04.40,英文,,0,0,0,,And I want to sort them.
Dialogue: 0,0:42:03.08,0:42:04.40,中文,,0,0,0,,我想对它们进行排序
Dialogue: 0,0:42:04.40,0:42:08.56,英文,,0,0,0,,Just by regular old, smaller numbers first, and then larger numbers later.
Dialogue: 0,0:42:04.40,0:42:08.56,中文,,0,0,0,,就像普通的旧排序一样  先排较小的数字  然后再排较大的数字
Dialogue: 0,0:42:08.56,0:42:10.70,英文,,0,0,0,,So what I could do is I could just compare the numbers.
Dialogue: 0,0:42:08.56,0:42:10.70,中文,,0,0,0,,所以我可以做的就是比较这些数字
Dialogue: 0,0:42:10.70,0:42:13.12,英文,,0,0,0,,Like 22 is less than 34.
Dialogue: 0,0:42:10.70,0:42:13.12,中文,,0,0,0,,比如 22 小于 34
Dialogue: 0,0:42:13.12,0:42:16.23,英文,,0,0,0,,And I can compare them all and put them in order.
Dialogue: 0,0:42:13.12,0:42:16.23,中文,,0,0,0,,我可以把它们都比较一下  然后按顺序排列
Dialogue: 0,0:42:16.23,0:42:29.06,英文,,0,0,0,,But what if? I was a little bit weird, and I said, let's not compare the numbers as actual numbers where I say, I don't know, 23 is less than 41.
Dialogue: 0,0:42:16.23,0:42:29.06,中文,,0,0,0,,我有点奇怪  我说  让我们不要把这些数字当作实际的数字来比较  比如  我不知道  23 小于 41
Dialogue: 0,0:42:29.06,0:42:32.52,英文,,0,0,0,,What if I compared them using only the rightmost digit?
Dialogue: 0,0:42:29.06,0:42:32.52,中文,,0,0,0,,如果我只用最右边的数字来比较它们呢？
Dialogue: 0,0:42:32.52,0:42:41.80,英文,,0,0,0,,So I totally ignored the tens digit, and I said, just put all the numbers in order based on their ones digit.
Dialogue: 0,0:42:32.52,0:42:41.80,中文,,0,0,0,,所以我完全忽略了十位数字  我说  只要把所有数字按个位数字的顺序排列
Dialogue: 0,0:42:41.80,0:42:50.19,英文,,0,0,0,,So I get something where all the numbers ending in one show up first, and then all the numbers ending in two show up next, and then all the numbers ending in three, and so forth.
Dialogue: 0,0:42:41.80,0:42:50.19,中文,,0,0,0,,所以我得到的结果是  所有以 1 结尾的数字都排在最前面  然后是以 2 结尾的数字  然后是以 3 结尾的数字  以此类推
Dialogue: 0,0:42:50.19,0:42:53.28,英文,,0,0,0,,It's kind of a weird thing to do, but I could do it, yeah?
Dialogue: 0,0:42:50.19,0:42:53.28,中文,,0,0,0,,这样做有点奇怪  但我可以这样做  对吧？
Dialogue: 0,0:42:53.28,0:42:58.88,英文,,0,0,0,,I could use merge sort or quicksort or whatever I wanted, and I can put this array in order.
Dialogue: 0,0:42:53.28,0:42:58.88,中文,,0,0,0,,我可以使用归并排序、快速排序或任何我想要的排序算法来整理这个数组
Dialogue: 0,0:42:58.88,0:43:06.45,英文,,0,0,0,,And maybe I feed in a different comparator or something, and I put all the items that end in one, then all the items that end in two, and so forth.
Dialogue: 0,0:42:58.88,0:43:06.45,中文,,0,0,0,,也许我会传入一个不同的比较器之类的  然后我把所有以 1 结尾的项目放在一起  然后是所有以 2 结尾的项目  以此类推
Dialogue: 0,0:43:06.45,0:43:09.01,英文,,0,0,0,,It's kind of weird, but I could do it.
Dialogue: 0,0:43:06.45,0:43:09.01,中文,,0,0,0,,这有点奇怪  但我可以做到
Dialogue: 0,0:43:09.01,0:43:12.31,英文,,0,0,0,,Is this array sorted on the overall number?
Dialogue: 0,0:43:09.01,0:43:12.31,中文,,0,0,0,,这个数组是按整体数字排序的吗？
Dialogue: 0,0:43:12.31,0:43:15.11,英文,,0,0,0,,No, because I sorted only on the ones digit.
Dialogue: 0,0:43:12.31,0:43:15.11,中文,,0,0,0,,不是  因为我只按个位数排序
Dialogue: 0,0:43:15.11,0:43:20.93,英文,,0,0,0,,But what if after, okay, I guess, puzzle for you first to make sure it makes sense.
Dialogue: 0,0:43:15.11,0:43:20.93,中文,,0,0,0,,但是如果在那之后  好吧  我想  先给你一个谜题  以确保它有意义
Dialogue: 0,0:43:20.93,0:43:24.91,英文,,0,0,0,,What are the integers at the end of the array if I do digit by digit sorting?
Dialogue: 0,0:43:20.93,0:43:24.91,中文,,0,0,0,,如果我按位数进行排序  那么数组末尾的整数是什么？
Dialogue: 0,0:43:24.91,0:43:28.26,英文,,0,0,0,,So I ignore the tens digit, and I just look at the ones digit.
Dialogue: 0,0:43:24.91,0:43:28.26,中文,,0,0,0,,所以我忽略十位数  只看个位数
Dialogue: 0,0:43:28.26,0:43:34.42,英文,,0,0,0,,I've already successfully found the rightful places of all the items in gray, and I just have these items left.
Dialogue: 0,0:43:28.26,0:43:34.42,中文,,0,0,0,,我已经成功地找到了灰色中所有项目的正确位置  现在只剩下这些项目了
Dialogue: 0,0:43:34.42,0:43:36.96,英文,,0,0,0,,So what order will they show up here?
Dialogue: 0,0:43:34.42,0:43:36.96,中文,,0,0,0,,那么它们会以什么顺序出现在这里呢？
Dialogue: 0,0:43:36.96,0:43:39.37,英文,,0,0,0,,You get like 10 seconds to think about it.
Dialogue: 0,0:43:36.96,0:43:39.37,中文,,0,0,0,,你有 10 秒钟的时间思考这个问题
Dialogue: 0,0:43:39.37,0:43:41.97,英文,,0,0,0,,Remember, I'm only sorting on the ones digit.
Dialogue: 0,0:43:39.37,0:43:41.97,中文,,0,0,0,,记住  我只按个位数排序
Dialogue: 0,0:43:41.97,0:43:45.77,英文,,0,0,0,,I don't care what happens in the tens digit for now.
Dialogue: 0,0:43:41.97,0:43:45.77,中文,,0,0,0,,我现在不关心十位数会发生什么
Dialogue: 0,0:43:45.77,0:43:51.73,英文,,0,0,0,,So if I only care about the ones digit, I'll get the things that end in three and then the things that end in four.
Dialogue: 0,0:43:45.77,0:43:51.73,中文,,0,0,0,,所以如果我只关心个位数  我会得到以 3 结尾的数字  然后是以 4 结尾的数字
Dialogue: 0,0:43:51.73,0:43:54.67,英文,,0,0,0,,Will it always end up such that 53 comes before the 23?
Dialogue: 0,0:43:51.73,0:43:54.67,中文,,0,0,0,,它最终总是会使 53 在 23 之前吗？
Dialogue: 0,0:43:54.67,0:43:57.39,英文,,0,0,0,,That depends on stability.
Dialogue: 0,0:43:54.67,0:43:57.39,中文,,0,0,0,,这取决于稳定性
Dialogue: 0,0:43:57.39,0:44:01.58,英文,,0,0,0,,For example, in this case, if the sort was stable, then 53 comes before the 23.
Dialogue: 0,0:43:57.39,0:44:01.58,中文,,0,0,0,,例如  在这种情况下  如果排序是稳定的  那么 53 就在 23 之前
Dialogue: 0,0:44:01.58,0:44:06.84,英文,,0,0,0,,They're considered equal in my new sort, and they keep the same relative order.
Dialogue: 0,0:44:01.58,0:44:06.84,中文,,0,0,0,,在我的新排序中  它们被认为是相等的  并且它们保持相同的相对顺序
Dialogue: 0,0:44:06.84,0:44:09.86,英文,,0,0,0,,If the sort was unstable, maybe I'd get 23 before the 53.
Dialogue: 0,0:44:06.84,0:44:09.86,中文,,0,0,0,,如果排序不稳定  我可能会得到 23 在 53 之前
Dialogue: 0,0:44:09.86,0:44:15.11,英文,,0,0,0,,It would be weird, but it would be a valid sort.
Dialogue: 0,0:44:09.86,0:44:15.11,中文,,0,0,0,,这会很奇怪  但它将是一个有效的排序
Dialogue: 0,0:44:15.11,0:44:16.81,英文,,0,0,0,,So I sorted by the rightmost digit.
Dialogue: 0,0:44:15.11,0:44:16.81,中文,,0,0,0,,所以我按最右边一位数字排序了
Dialogue: 0,0:44:16.81,0:44:20.73,英文,,0,0,0,,It's kind of weird, but it worked.
Dialogue: 0,0:44:16.81,0:44:20.73,中文,,0,0,0,,有点奇怪  但奏效了
Dialogue: 0,0:44:20.73,0:44:22.77,英文,,0,0,0,,I'm done with the ones digit.
Dialogue: 0,0:44:20.73,0:44:22.77,中文,,0,0,0,,个位数排序完成了
Dialogue: 0,0:44:22.77,0:44:27.07,英文,,0,0,0,,What if I now turn my attention to the tens digit, the digit on the left?
Dialogue: 0,0:44:22.77,0:44:27.07,中文,,0,0,0,,如果我现在把注意力转向左边那一位  也就是十位数  会怎么样？
Dialogue: 0,0:44:27.07,0:44:29.28,英文,,0,0,0,,So I said, the ones digit is totally done.
Dialogue: 0,0:44:27.07,0:44:29.28,中文,,0,0,0,,所以我说  个位数已经完全排好序了
Dialogue: 0,0:44:29.28,0:44:33.08,英文,,0,0,0,,All the ones come before the twos, before the threes, before the fours.
Dialogue: 0,0:44:29.28,0:44:33.08,中文,,0,0,0,,所有个位数是 1 的排在前面  然后是 2  3  4
Dialogue: 0,0:44:33.08,0:44:36.14,英文,,0,0,0,,What if I now turn my attention to the tens digit, the one on the left?
Dialogue: 0,0:44:33.08,0:44:36.14,中文,,0,0,0,,如果我现在把注意力转向左边那一位  也就是十位数  会怎么样？
Dialogue: 0,0:44:36.14,0:44:38.40,英文,,0,0,0,,And I said, let's put these in order.
Dialogue: 0,0:44:36.14,0:44:38.40,中文,,0,0,0,,我说  让我们把这些排好序
Dialogue: 0,0:44:38.40,0:44:39.70,英文,,0,0,0,,And again, I can use merge sort.
Dialogue: 0,0:44:38.40,0:44:39.70,中文,,0,0,0,,我可以用归并排序
Dialogue: 0,0:44:39.70,0:44:41.80,英文,,0,0,0,,I can use quicksort, whatever I want.
Dialogue: 0,0:44:39.70,0:44:41.80,中文,,0,0,0,,我也可以用快速排序  随便用哪个都行
Dialogue: 0,0:44:41.80,0:44:44.64,英文,,0,0,0,,And all I have to do is put these items in order.
Dialogue: 0,0:44:41.80,0:44:44.64,中文,,0,0,0,,我要做的就是把这些项目排好序
Dialogue: 0,0:44:44.64,0:44:54.93,英文,,0,0,0,,Such that everything that begins with the 1 comes before everything that begins with the 2, comes before everything that begins with the 3, so on.
Dialogue: 0,0:44:44.64,0:44:54.93,中文,,0,0,0,,这样  所有以 1 开头的都排在以 2 开头的前面  以 2 开头的排在以 3 开头的前面  以此类推
Dialogue: 0,0:44:54.93,0:45:04.07,英文,,0,0,0,,So as you can see here, everything that starts with the 1 comes first, and then everything that starts with the 2, and then everything that starts with the 3, and then everything that starts with the 4.
Dialogue: 0,0:44:54.93,0:45:04.07,中文,,0,0,0,,正如你在这里看到的  所有以 1 开头的都排在最前面  然后是以 2 开头的  然后是以 3 开头的  最后是以 4 开头的
Dialogue: 0,0:45:04.07,0:45:08.52,英文,,0,0,0,,So assuming my sword is stable, that's an assumption we actually have to make this time.
Dialogue: 0,0:45:04.07,0:45:08.52,中文,,0,0,0,,假设我的排序是稳定的  这是我们这次必须做的一个假设
Dialogue: 0,0:45:08.52,0:45:18.42,英文,,0,0,0,,Assuming the sword is stable, these four items, 31, 32, 34, 34, they are all considered equal because I'm only looking at the top digit.
Dialogue: 0,0:45:08.52,0:45:18.42,中文,,0,0,0,,假设排序是稳定的  这四个项目  31  32  34  34  它们都被认为是相等的  因为我只看最高位数字
Dialogue: 0,0:45:18.42,0:45:26.46,英文,,0,0,0,,So if these four items are all considered equal by the top digit and my sword is stable, what order will they appear in?
Dialogue: 0,0:45:18.42,0:45:26.46,中文,,0,0,0,,所以如果这四个项目在最高位数字上都被认为是相等的  并且我的排序是稳定的  它们会以什么顺序出现？
Dialogue: 0,0:45:26.46,0:45:31.99,英文,,0,0,0,,Hopefully, in an order where none of them cross over because my sword is stable.
Dialogue: 0,0:45:26.46,0:45:31.99,中文,,0,0,0,,希望它们不会交叉  因为我的排序是稳定的
Dialogue: 0,0:45:31.99,0:45:36.53,英文,,0,0,0,,By contrast, if my sort was not stable, some of these items might have crossed over.
Dialogue: 0,0:45:31.99,0:45:36.53,中文,,0,0,0,,相反  如果我的排序不稳定  其中一些项目可能会交叉
Dialogue: 0,0:45:36.53,0:45:37.99,英文,,0,0,0,,So that's an example.
Dialogue: 0,0:45:36.53,0:45:37.99,中文,,0,0,0,,这就是一个例子
Dialogue: 0,0:45:37.99,0:45:42.51,英文,,0,0,0,,If the sort is unstable, the items might cross over, and this strategy won't work.
Dialogue: 0,0:45:37.99,0:45:42.51,中文,,0,0,0,,如果排序不稳定  项目可能会交叉  这种策略就行不通了
Dialogue: 0,0:45:42.51,0:45:51.45,英文,,0,0,0,,So it turns out you can do something a little bit silly called digit-by-digit sorting, where you take your array of numbers, you sort by the leftmost digit.
Dialogue: 0,0:45:42.51,0:45:51.45,中文,,0,0,0,,所以其实可以做一件有点蠢的事情  叫做逐位排序  就是把你的数字数组  按最左边的数字排序
Dialogue: 0,0:45:51.45,0:45:55.11,英文,,0,0,0,,So if you look at the leftmost digit, everybody's in the right order.
Dialogue: 0,0:45:51.45,0:45:55.11,中文,,0,0,0,,所以如果你看最左边的数字  每个人都在正确的顺序
Dialogue: 0,0:45:55.11,0:45:57.01,英文,,0,0,0,,Then you sort by the middle digit.
Dialogue: 0,0:45:55.11,0:45:57.01,中文,,0,0,0,,然后你按中间的数字排序
Dialogue: 0,0:45:57.01,0:45:59.19,英文,,0,0,0,,Now everyone here is in the right order.
Dialogue: 0,0:45:57.01,0:45:59.19,中文,,0,0,0,,现在这里每个人都在正确的顺序
Dialogue: 0,0:45:59.19,0:46:02.00,英文,,0,0,0,,And the key idea here is that my sort is stable.
Dialogue: 0,0:45:59.19,0:46:02.00,中文,,0,0,0,,这里的关键思想是我的排序是稳定的
Dialogue: 0,0:46:02.00,0:46:03.52,英文,,0,0,0,,Then I sort by the rightmost digit.
Dialogue: 0,0:46:02.00,0:46:03.52,中文,,0,0,0,,然后我按最右边的数字排序
Dialogue: 0,0:46:03.52,0:46:07.58,英文,,0,0,0,,And if I do that, my final array will actually be sorted.
Dialogue: 0,0:46:03.52,0:46:07.58,中文,,0,0,0,,如果我这样做  我的最终数组实际上会被排序
Dialogue: 0,0:46:07.58,0:46:10.74,英文,,0,0,0,,It takes a little bit of scaring out, I think, to really get the hang of it.
Dialogue: 0,0:46:07.58,0:46:10.74,中文,,0,0,0,,我认为  要真正掌握它  需要一点时间去理解
Dialogue: 0,0:46:10.74,0:46:14.36,英文,,0,0,0,,But the key ideas here are I go left to right.
Dialogue: 0,0:46:10.74,0:46:14.36,中文,,0,0,0,,但这里的关键思想是我从左到右
Dialogue: 0,0:46:14.36,0:46:19.16,英文,,0,0,0,,And because I go left to right and my sort is stable, none of the items cross over.
Dialogue: 0,0:46:14.36,0:46:19.16,中文,,0,0,0,,而且因为我是从左到右  而且我的排序是稳定的  所以没有一个项目会交叉
Dialogue: 0,0:46:19.16,0:46:25.06,英文,,0,0,0,,So as soon as I get everything ending in 1, coming before everything ending in 2, and 3, and 4,
Dialogue: 0,0:46:19.16,0:46:25.06,中文,,0,0,0,,所以一旦我让所有以1结尾的  排在所有以2、3和4结尾的前面
Dialogue: 0,0:46:25.06,0:46:26.77,英文,,0,0,0,,None of this stuff will cross over.
Dialogue: 0,0:46:25.06,0:46:26.77,中文,,0,0,0,,这些东西都不会交叉
Dialogue: 0,0:46:26.77,0:46:37.55,英文,,0,0,0,,So I know that later, even as the items shuffle around further to account for higher digits, everything ending in a 1 will come before everything ending in a 2, and so forth.
Dialogue: 0,0:46:26.77,0:46:37.55,中文,,0,0,0,,所以我知道  即使这些项目为了考虑更高的数字而进一步打乱  所有以1结尾的都会排在所有以2结尾的前面  以此类推
Dialogue: 0,0:46:37.55,0:46:44.16,英文,,0,0,0,,And likewise here, once I get the middle digit all sorted out, I know that when I sort by the top digit, nothing will cross over.
Dialogue: 0,0:46:37.55,0:46:44.16,中文,,0,0,0,,同样地  一旦我把中间的数字都排好了  我就知道当我按最上面的数字排序时  不会有任何交叉
Dialogue: 0,0:46:44.16,0:46:50.58,英文,,0,0,0,,So for example, when I sort by the top digit, 322 and 331 both have the same top digit.
Dialogue: 0,0:46:44.16,0:46:50.58,中文,,0,0,0,,例如  当我按最上面的数字排序时  322和331都有相同的最高数字
Dialogue: 0,0:46:50.58,0:46:51.90,英文,,0,0,0,,But that's OK.
Dialogue: 0,0:46:50.58,0:46:51.90,中文,,0,0,0,,但这没关系
Dialogue: 0,0:46:51.90,0:46:55.33,英文,,0,0,0,,I know that these two will not cross over.
Dialogue: 0,0:46:51.90,0:46:55.33,中文,,0,0,0,,我知道这两个不会交叉
Dialogue: 0,0:46:55.33,0:46:57.43,英文,,0,0,0,,That's digit by digit sorting.
Dialogue: 0,0:46:55.33,0:46:57.43,中文,,0,0,0,,这就是逐位排序
Dialogue: 0,0:46:57.43,0:47:01.71,英文,,0,0,0,,It is kind of a strange thing to do, because why not just sort by the entire number?
Dialogue: 0,0:46:57.43,0:47:01.71,中文,,0,0,0,,这是一种奇怪的做法  因为为什么不直接按整个数字排序呢？
Dialogue: 0,0:47:01.71,0:47:03.94,英文,,0,0,0,,Why go digit by digit?
Dialogue: 0,0:47:01.71,0:47:03.94,中文,,0,0,0,,为什么逐位排序？
Dialogue: 0,0:47:03.94,0:47:08.34,英文,,0,0,0,,But when we combine this with the other idea, magical things will happen.
Dialogue: 0,0:47:03.94,0:47:08.34,中文,,0,0,0,,但当我们把它和另一个想法结合起来  就会发生神奇的事情
Dialogue: 0,0:47:08.34,0:47:09.86,英文,,0,0,0,,So that's the idea.
Dialogue: 0,0:47:08.34,0:47:09.86,中文,,0,0,0,,所以这就是我的想法
Dialogue: 0,0:47:09.86,0:47:12.44,英文,,0,0,0,,Is everyone ready to kind of stash it away for later?
Dialogue: 0,0:47:09.86,0:47:12.44,中文,,0,0,0,,大家都准备好了吗  先把它放一边？
Dialogue: 0,0:47:12.44,0:47:21.09,英文,,0,0,0,,And now I'll show you the thing that's fast question.
Dialogue: 0,0:47:12.44,0:47:21.09,中文,,0,0,0,,现在我将向你展示快速排序的东西
Dialogue: 0,0:47:21.09,0:47:22.05,英文,,0,0,0,,Yeah, that's a great question.
Dialogue: 0,0:47:21.09,0:47:22.05,中文,,0,0,0,,是的  这是个好问题
Dialogue: 0,0:47:22.05,0:47:23.85,英文,,0,0,0,,So what's the runtime of this thing?
Dialogue: 0,0:47:22.05,0:47:23.85,中文,,0,0,0,,那么这个东西的运行时间是多少？
Dialogue: 0,0:47:23.85,0:47:25.59,英文,,0,0,0,,I'll show you a runtime next time as well.
Dialogue: 0,0:47:23.85,0:47:25.59,中文,,0,0,0,,下次我也会向你展示运行时间
Dialogue: 0,0:47:25.59,0:47:30.45,英文,,0,0,0,,But if you were using, say, merge sort, I think it would be n log n. But you have to do it once per digit.
Dialogue: 0,0:47:25.59,0:47:30.45,中文,,0,0,0,,但如果你使用的是  比如归并排序  我认为应该是 N log N  但你必须对每个数字进行一次排序
Dialogue: 0,0:47:30.45,0:47:36.06,英文,,0,0,0,,So in this case, it'd be like three times n log n, because I had to do merge sort three times.
Dialogue: 0,0:47:30.45,0:47:36.06,中文,,0,0,0,,所以在这种情况下  它就像 3 次 N log N  因为我必须进行 3 次归并排序
Dialogue: 0,0:47:36.06,0:47:38.10,英文,,0,0,0,,That's a good question, though.
Dialogue: 0,0:47:36.06,0:47:38.10,中文,,0,0,0,,不过  这是个好问题
Dialogue: 0,0:47:38.10,0:47:43.20,英文,,0,0,0,,Other question?
Dialogue: 0,0:47:38.10,0:47:43.20,中文,,0,0,0,,其他问题？
Dialogue: 0,0:47:43.20,0:47:44.69,英文,,0,0,0,,Can I have radix sort on other bases?
Dialogue: 0,0:47:43.20,0:47:44.69,中文,,0,0,0,,我可以在其他进制上进行基数排序吗？
Dialogue: 0,0:47:44.69,0:47:46.78,英文,,0,0,0,,Yes. Come back next time.
Dialogue: 0,0:47:44.69,0:47:46.78,中文,,0,0,0,,是的   下次再来吧
Dialogue: 0,0:47:46.78,0:47:47.82,英文,,0,0,0,,But you're ahead of me.
Dialogue: 0,0:47:46.78,0:47:47.82,中文,,0,0,0,,但你比我快一步
Dialogue: 0,0:47:47.82,0:47:48.94,英文,,0,0,0,,It's a good question, though.
Dialogue: 0,0:47:47.82,0:47:48.94,中文,,0,0,0,,不过  这是个好问题
Dialogue: 0,0:47:48.94,0:47:51.92,英文,,0,0,0,,OK, that was the warm-up, digit-by-digit sorting.
Dialogue: 0,0:47:48.94,0:47:51.92,中文,,0,0,0,,好的  这就是热身  逐位排序
Dialogue: 0,0:47:51.92,0:47:53.98,英文,,0,0,0,,It works, although it's kind of strange.
Dialogue: 0,0:47:51.92,0:47:53.98,中文,,0,0,0,,它确实有效  虽然有点奇怪
Dialogue: 0,0:47:53.98,0:47:55.20,英文,,0,0,0,,So here's the second idea.
Dialogue: 0,0:47:53.98,0:47:55.20,中文,,0,0,0,,所以这是第二个想法
Dialogue: 0,0:47:55.20,0:47:58.51,英文,,0,0,0,,And when we put these together, you'll get something really pretty.
Dialogue: 0,0:47:55.20,0:47:58.51,中文,,0,0,0,,当我们将这些想法结合起来时  你将得到一些非常漂亮的东西
Dialogue: 0,0:47:58.51,0:48:03.69,英文,,0,0,0,,So I guess I'll just have to give you a little preview, and then you'll have to come back next time for the finish.
Dialogue: 0,0:47:58.51,0:48:03.69,中文,,0,0,0,,那我想我只能先简单介绍一下  剩下的部分下次再讲
Dialogue: 0,0:48:03.69,0:48:09.21,英文,,0,0,0,,But you remember from last time, we said quick sorting is the fastest known sort.
Dialogue: 0,0:48:03.69,0:48:09.21,中文,,0,0,0,,还记得上次我们说过  快速排序是已知最快的排序算法吗？
Dialogue: 0,0:48:09.21,0:48:11.64,英文,,0,0,0,,It was n log n.
Dialogue: 0,0:48:09.21,0:48:11.64,中文,,0,0,0,,它的时间复杂度是 N log N
Dialogue: 0,0:48:11.64,0:48:20.34,英文,,0,0,0,,We proved to you that there is an actual bound that says that comparison sorts cannot do any better than n log n. That was something we proved.
Dialogue: 0,0:48:11.64,0:48:20.34,中文,,0,0,0,,我们向你证明了  确实存在一个界限  它表明基于比较的排序算法不可能比 N log N 更快  这是我们已经证明过的事情
Dialogue: 0,0:48:20.34,0:48:28.60,英文,,0,0,0,,We actually pulled out all of the math, and we did all the proofs, and we showed you that no matter what you do,
Dialogue: 0,0:48:20.34,0:48:28.60,中文,,0,0,0,,我们实际上进行了所有的数学推导  做了所有的证明  并向你展示了无论你做什么
Dialogue: 0,0:48:28.60,0:48:36.78,英文,,0,0,0,, even if you go out and invent a brand new sort, you will never do asymptotically better than n log n. That's what the omega bound says.
Dialogue: 0,0:48:28.60,0:48:36.78,中文,,0,0,0,,即使你发明了一种全新的排序算法  你也不可能在渐进时间复杂度上超越 N log N  这就是 Ω 符号的含义
Dialogue: 0,0:48:36.78,0:48:39.54,英文,,0,0,0,,So I guess someone asked this last time, so I'll answer it real quick.
Dialogue: 0,0:48:36.78,0:48:39.54,中文,,0,0,0,,我想上次有人问了这个问题  所以我快速回答一下
Dialogue: 0,0:48:39.54,0:48:50.41,英文,,0,0,0,,The omega bound says this is the family of all the functions that are larger than n log n. So what this says is that you pick any sorting algorithm in the world that's based on comparisons.
Dialogue: 0,0:48:39.54,0:48:50.41,中文,,0,0,0,,Ω 符号表示所有大于 N log N 函数的集合  所以这意味着你选择的任何基于比较的排序算法
Dialogue: 0,0:48:50.41,0:48:57.33,英文,,0,0,0,,You pick merge sort, you pick insertion sort, you invent your own sort, and you name it after yourself like that guy, Tim.
Dialogue: 0,0:48:50.41,0:48:57.33,中文,,0,0,0,,无论是归并排序、插入排序  还是你自己发明的排序算法  并像那个人 Tim 一样以自己的名字命名
Dialogue: 0,0:48:57.33,0:48:58.95,英文,,0,0,0,,Whatever you do,
Dialogue: 0,0:48:57.33,0:48:58.95,中文,,0,0,0,,无论你做什么
Dialogue: 0,0:48:58.95,0:49:06.13,英文,,0,0,0,,Any sort that you come up with, if you find the asymptotic big theta runtime, I promise you it will be in this family,
Dialogue: 0,0:48:58.95,0:49:06.13,中文,,0,0,0,,你提出的任何排序算法  如果你找到它的渐进 Θ 时间复杂度  我保证它会在这个集合中
Dialogue: 0,0:49:06.13,0:49:12.31,英文,,0,0,0,,which is the family of functions that are greater than n log n. That's what the omega bound says.
Dialogue: 0,0:49:06.13,0:49:12.31,中文,,0,0,0,,这个集合包含所有大于 N log N 的函数  这就是 Ω 符号的含义
Dialogue: 0,0:49:12.31,0:49:19.94,英文,,0,0,0,,So in other words, the ultimate comparison-based sort, whatever it is, maybe it's quicksort, maybe it's something that has not been invented yet,
Dialogue: 0,0:49:12.31,0:49:19.94,中文,,0,0,0,,换句话说  最终的基于比较的排序算法  无论它是什么  也许是快速排序  也许是尚未发明的东西
Dialogue: 0,0:49:19.94,0:49:26.85,英文,,0,0,0,,the asymptotic runtime will never be better than n log n, no matter how clever you are.
Dialogue: 0,0:49:19.94,0:49:26.85,中文,,0,0,0,,无论你多么聪明  它的渐进时间复杂度永远不会比 N log N 更快
Dialogue: 0,0:49:26.85,0:49:31.29,英文,,0,0,0,,But here's the trick. That was assuming that you were using comparison-based sorting.
Dialogue: 0,0:49:26.85,0:49:31.29,中文,,0,0,0,,但诀窍在于   那是假设你使用的是基于比较的排序算法
Dialogue: 0,0:49:31.29,0:49:40.70,英文,,0,0,0,,That is, all the things you were doing had to do with taking two items and asking, who's bigger, this one or this one, and asking that question over and over again.
Dialogue: 0,0:49:31.29,0:49:40.70,中文,,0,0,0,,也就是说  你所做的一切都与取两个元素并询问谁更大  这个还是那个  并一遍又一遍地问这个问题有关
Dialogue: 0,0:49:40.70,0:49:48.64,英文,,0,0,0,,If your sorts are based on the idea of asking who is greater over and over again, you are constrained by the n log n bound.
Dialogue: 0,0:49:40.70,0:49:48.64,中文,,0,0,0,,如果你的排序算法是基于一遍又一遍地询问谁更大的想法  那么你就会受到 N log N 界限的限制
Dialogue: 0,0:49:48.64,0:49:55.00,英文,,0,0,0,,And so here's the idea that we're going to use to beat that other guy, which is, what if we don't do comparisons at all?
Dialogue: 0,0:49:48.64,0:49:55.00,中文,,0,0,0,,所以我们要用来击败那个家伙的想法是  如果我们根本不做比较呢？
Dialogue: 0,0:49:55.00,0:49:58.92,英文,,0,0,0,,We don't actually take two items and ask, are you greater or are you greater?
Dialogue: 0,0:49:55.00,0:49:58.92,中文,,0,0,0,,我们实际上不取两个元素并询问  你更大还是你更大？
Dialogue: 0,0:49:58.92,0:50:03.17,英文,,0,0,0,,What if we completely switched philosophies and did something different?
Dialogue: 0,0:49:58.92,0:50:03.17,中文,,0,0,0,,如果我们完全改变思路  做一些不同的事情呢？
Dialogue: 0,0:50:03.17,0:50:06.15,英文,,0,0,0,,That's going to give us our final sort called radix sort.
Dialogue: 0,0:50:03.17,0:50:06.15,中文,,0,0,0,,这将引出我们最终的排序算法  叫做基数排序
Dialogue: 0,0:50:06.15,0:50:13.87,英文,,0,0,0,,But since I'm out of time, because that other guy wasted so much time talking about quicksort, you'll have to come back next time for the final sorting lecture.
Dialogue: 0,0:50:06.15,0:50:13.87,中文,,0,0,0,,但由于我没有时间了  因为那个家伙浪费了太多时间谈论快速排序  你只能下次再来参加最后的排序算法讲座
Dialogue: 0,0:50:13.87,0:50:15.31,英文,,0,0,0,,OK, I will see you then.
Dialogue: 0,0:50:13.87,0:50:15.31,中文,,0,0,0,,好的  回头见
