[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 3
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Export Encoding: Unicode (UTF-8)
Audio File: D:/python_code/video_tool/result/cs61b/[61B SP24] Lecture 38 - Compression.mp4
Video File: D:/python_code/video_tool/result/cs61b/[61B SP24] Lecture 38 - Compression.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.750000
Scroll Position: 524
Active Line: 540
Video Position: 10857

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,14,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.33333,1.33333,2,5,5,8,1
Style: 英文,Arial,24,&H00FFFFFF,&H000102FC,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,1,2,2,2,6,1
Style: 中文,微软雅黑,38,&H0000FFFF,&H0000FFFF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,1,2,2,2,20,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,
Dialogue: 0,0:00:00.42,0:00:02.08,英文,,0,0,0,,All right.
Dialogue: 0,0:00:00.42,0:00:02.08,中文,,0,0,0,,好的
Dialogue: 0,0:00:02.08,0:00:08.19,英文,,0,0,0,,So just as a recap, everything that we covered this week is not going to be considered in scope for the exams.
Dialogue: 0,0:00:02.08,0:00:08.19,中文,,0,0,0,,简单回顾一下  这周我们讲的所有内容都不会纳入考试范围
Dialogue: 0,0:00:08.19,0:00:14.57,英文,,0,0,0,,We're just going to be covering a few fun side topics that aren't in the core 61b series,
Dialogue: 0,0:00:08.19,0:00:14.57,中文,,0,0,0,,我们将讨论一些核心 61b 课程系列之外的有趣课题
Dialogue: 0,0:00:14.57,0:00:20.57,英文,,0,0,0,,but are just kind of fun to talk about, like potential applications of what we learned in this class.
Dialogue: 0,0:00:14.57,0:00:20.57,中文,,0,0,0,,这些课题很有趣  比如我们在这门课上学到的知识的潜在应用
Dialogue: 0,0:00:20.57,0:00:26.45,英文,,0,0,0,,So for today, we'll be discussing compression.
Dialogue: 0,0:00:20.57,0:00:26.45,中文,,0,0,0,,所以今天  我们将讨论压缩
Dialogue: 0,0:00:26.45,0:00:28.77,英文,,0,0,0,,Oh, it's reversed.
Dialogue: 0,0:00:26.45,0:00:28.77,中文,,0,0,0,,哦  反了
Dialogue: 0,0:00:28.77,0:00:29.51,英文,,0,0,0,,This is going up.
Dialogue: 0,0:00:28.77,0:00:29.51,中文,,0,0,0,,这个在上升
Dialogue: 0,0:00:29.51,0:00:30.25,英文,,0,0,0,,OK.
Dialogue: 0,0:00:29.51,0:00:30.25,中文,,0,0,0,,好的
Dialogue: 0,0:00:30.25,0:00:30.91,英文,,0,0,0,,I'm going to have to take.
Dialogue: 0,0:00:30.25,0:00:30.91,中文,,0,0,0,,我得拿一下
Dialogue: 0,0:00:30.91,0:00:32.01,英文,,0,0,0,,All right.
Dialogue: 0,0:00:30.91,0:00:32.01,中文,,0,0,0,,
Dialogue: 0,0:00:32.01,0:00:35.60,英文,,0,0,0,,So here's an example of how you might compress something.
Dialogue: 0,0:00:32.01,0:00:35.60,中文,,0,0,0,,这里有一个例子  说明你可能如何压缩一些东西
Dialogue: 0,0:00:35.60,0:00:43.34,英文,,0,0,0,,So Moby Dick is this really nice classic piece of literature.
Dialogue: 0,0:00:35.60,0:00:43.34,中文,,0,0,0,,所以《白鲸记》是一部非常好的经典文学作品
Dialogue: 0,0:00:43.34,0:00:57.24,英文,,0,0,0,,And if you look at the actual raw file, you notice that it's about 643 kilobytes of data, 643,000 characters or so.
Dialogue: 0,0:00:43.34,0:00:57.24,中文,,0,0,0,,如果你查看实际的原始文件  你会发现它大约有 643 KB 的数据  大约 643,000 个字符
Dialogue: 0,0:00:57.24,0:01:05.12,英文,,0,0,0,,But if you look at how we want to send it out, we don't want to send out the entire 643,000 bytes worth of data.
Dialogue: 0,0:00:57.24,0:01:05.12,中文,,0,0,0,,但是如果你看看我们想要如何发送它  我们不想发送整个 643,000 字节的数据
Dialogue: 0,0:01:05.12,0:01:08.73,英文,,0,0,0,,That's too much. What we can do is we can do something called zip.
Dialogue: 0,0:01:05.12,0:01:08.73,中文,,0,0,0,,太多了   我们可以做的是使用 zip
Dialogue: 0,0:01:08.73,0:01:16.29,英文,,0,0,0,,And zip is this program that takes in an input file and converts it into a shorter version of the same file.
Dialogue: 0,0:01:08.73,0:01:16.29,中文,,0,0,0,,zip 是一个程序  它接收一个输入文件并将其转换为同一个文件的较短版本
Dialogue: 0,0:01:16.29,0:01:22.00,英文,,0,0,0,,So as we can see here, if we zip together Moby Dick, then it turns into this MobyDick.zip file,
Dialogue: 0,0:01:16.29,0:01:22.00,中文,,0,0,0,,所以正如我们在这里看到的  如果我们将《白鲸记》压缩在一起
Dialogue: 0,0:01:22.00,0:01:29.00,英文,,0,0,0,,which is 261,000 bytes, so about at least a factor of two smaller.
Dialogue: 0,0:01:22.00,0:01:29.00,中文,,0,0,0,,那么它就会变成这个 mobydick.zip 文件  它有 261,000 字节  所以至少小了两倍
Dialogue: 0,0:01:29.00,0:01:34.33,英文,,0,0,0,,And the idea is, as long as we're able to unzip this, so undo this operation,
Dialogue: 0,0:01:29.00,0:01:34.33,中文,,0,0,0,,我们的想法是  只要我们能够解压缩它  也就是撤销这个操作
Dialogue: 0,0:01:34.33,0:01:41.33,英文,,0,0,0,,we take the MobyDick.zip file, we undo that operation, we can get back our original data.
Dialogue: 0,0:01:34.33,0:01:41.33,中文,,0,0,0,,我们就可以拿回 mobydick.zip 文件  撤销这个操作  就可以得到我们原来的数据
Dialogue: 0,0:01:41.33,0:01:46.29,英文,,0,0,0,,Our goal is going to be to find ways to do this.
Dialogue: 0,0:01:41.33,0:01:46.29,中文,,0,0,0,,我们的目标将是找到方法来做到这一点
Dialogue: 0,0:01:46.29,0:01:53.96,英文,,0,0,0,,Formally, what we'll be calling this is a lossless compression algorithm, where we take in a bit string b,
Dialogue: 0,0:01:46.29,0:01:53.96,中文,,0,0,0,,正式地说  我们将称之为无损压缩算法  我们接收一个比特字符串 B
Dialogue: 0,0:01:53.96,0:02:01.96,英文,,0,0,0,,we perform some function on it to get a smaller bit string, and we can later use that smaller bit string to revert back to the original bit string.
Dialogue: 0,0:01:53.96,0:02:01.96,中文,,0,0,0,,对其执行一些函数以得到一个更小的比特字符串  然后我们可以使用这个更小的比特字符串恢复到原来的比特字符串
Dialogue: 0,0:02:01.96,0:02:04.34,英文,,0,0,0,,This is known as a lossless compression algorithm.
Dialogue: 0,0:02:01.96,0:02:04.34,中文,,0,0,0,,这称为无损压缩算法
Dialogue: 0,0:02:04.34,0:02:08.88,英文,,0,0,0,,Formally, we just need to ensure that this compression algorithm c is injective.
Dialogue: 0,0:02:04.34,0:02:08.88,中文,,0,0,0,,形式上  我们只需要确保这个压缩算法 C 是单射的
Dialogue: 0,0:02:08.88,0:02:15.40,英文,,0,0,0,,So no two identical bit strings end up yielding the exact same compressed file.
Dialogue: 0,0:02:08.88,0:02:15.40,中文,,0,0,0,,这样就不会有两个相同的位串最终产生完全相同的压缩文件
Dialogue: 0,0:02:15.40,0:02:25.05,英文,,0,0,0,,And generally speaking, most text files, you can compress them by about 70% or more.
Dialogue: 0,0:02:15.40,0:02:25.05,中文,,0,0,0,,一般来说  大多数文本文件可以压缩 70% 或更多
Dialogue: 0,0:02:25.05,0:02:31.01,英文,,0,0,0,,So in order to look at this, we should talk a bit more about how information is actually conveyed.
Dialogue: 0,0:02:25.05,0:02:31.01,中文,,0,0,0,,为了研究这一点  我们应该多谈谈信息是如何实际传递的
Dialogue: 0,0:02:31.01,0:02:37.55,英文,,0,0,0,,So in a general sense, like when we compress our bit string, we're not going to be losing any information from it.
Dialogue: 0,0:02:31.01,0:02:37.55,中文,,0,0,0,,所以从一般意义上讲  就像我们压缩位串时一样  我们不会丢失任何信息
Dialogue: 0,0:02:37.55,0:02:41.43,英文,,0,0,0,,The information that we're trying to convey should remain the exact same.
Dialogue: 0,0:02:37.55,0:02:41.43,中文,,0,0,0,,我们试图传达的信息应该保持完全相同
Dialogue: 0,0:02:41.43,0:02:45.95,英文,,0,0,0,,We're just expressing it with a smaller amount of bits.
Dialogue: 0,0:02:41.43,0:02:45.95,中文,,0,0,0,,我们只是用更少的位来表达它
Dialogue: 0,0:02:45.95,0:02:53.79,英文,,0,0,0,,Now, that generally means that different types of characters, different types of strings, are going to have different amounts of information.
Dialogue: 0,0:02:45.95,0:02:53.79,中文,,0,0,0,,现在  这通常意味着不同类型的字符、不同类型的字符串将具有不同的信息量
Dialogue: 0,0:02:53.79,0:02:59.44,英文,,0,0,0,,So it's going to be useful to see what actually constitutes information, because it's not the same as how long the string is.
Dialogue: 0,0:02:53.79,0:02:59.44,中文,,0,0,0,,因此  看看实际构成信息的内容将很有用  因为它与字符串的长度不同
Dialogue: 0,0:02:59.44,0:03:06.38,英文,,0,0,0,,A general useful metric for this is how easy it is for something to be memorized.
Dialogue: 0,0:02:59.44,0:03:06.38,中文,,0,0,0,,一个通用的有用指标是某事物易于记忆的程度
Dialogue: 0,0:03:06.38,0:03:12.60,英文,,0,0,0,,If something is easy to memorize, then generally it contains less actual information than something that's harder to memorize.
Dialogue: 0,0:03:06.38,0:03:12.60,中文,,0,0,0,,如果某事物易于记忆  那么通常它包含的实际信息少于难以记忆的事物
Dialogue: 0,0:03:12.60,0:03:16.07,英文,,0,0,0,,So let's play a game.
Dialogue: 0,0:03:12.60,0:03:16.07,中文,,0,0,0,,我们来玩个游戏吧
Dialogue: 0,0:03:16.07,0:03:19.27,英文,,0,0,0,,Memorize this string.
Dialogue: 0,0:03:16.07,0:03:19.27,中文,,0,0,0,,记住这个字符串
Dialogue: 0,0:03:19.27,0:03:30.78,英文,,0,0,0,,You have 10 seconds.
Dialogue: 0,0:03:19.27,0:03:30.78,中文,,0,0,0,,你有 10 秒钟
Dialogue: 0,0:03:30.78,0:03:31.78,英文,,0,0,0,,All right.
Dialogue: 0,0:03:30.78,0:03:31.78,中文,,0,0,0,,好的
Dialogue: 0,0:03:31.78,0:03:38.65,英文,,0,0,0,,What's the string?
Dialogue: 0,0:03:31.78,0:03:38.65,中文,,0,0,0,,字符串是什么？
Dialogue: 0,0:03:38.65,0:03:46.48,英文,,0,0,0,,Yeah, BXXONHPWTP.
Dialogue: 0,0:03:38.65,0:03:46.48,中文,,0,0,0,,是的  BXX ONHP WTP
Dialogue: 0,0:03:46.48,0:03:47.68,英文,,0,0,0,,Yeah.
Dialogue: 0,0:03:46.48,0:03:47.68,中文,,0,0,0,,是的
Dialogue: 0,0:03:47.68,0:03:52.24,英文,,0,0,0,,How hard was that on a scale of 1 to 10?
Dialogue: 0,0:03:47.68,0:03:52.24,中文,,0,0,0,,在 1 到 10 的范围内  这有多难？
Dialogue: 0,0:03:52.24,0:03:53.24,英文,,0,0,0,,3?
Dialogue: 0,0:03:52.24,0:03:53.24,中文,,0,0,0,,3？
Dialogue: 0,0:03:53.24,0:03:54.78,英文,,0,0,0,,Somewhere around a 2 or 3?
Dialogue: 0,0:03:53.24,0:03:54.78,中文,,0,0,0,,大概是2或3？
Dialogue: 0,0:03:54.78,0:03:55.54,英文,,0,0,0,,All right.
Dialogue: 0,0:03:54.78,0:03:55.54,中文,,0,0,0,,好的
Dialogue: 0,0:03:55.54,0:03:57.59,英文,,0,0,0,,Do you want to go larger?
Dialogue: 0,0:03:55.54,0:03:57.59,中文,,0,0,0,,想要更大的吗？
Dialogue: 0,0:03:57.59,0:04:08.85,英文,,0,0,0,,Let's do a 47 character string.
Dialogue: 0,0:03:57.59,0:04:08.85,中文,,0,0,0,,我们来个47个字符的字符串
Dialogue: 0,0:04:08.85,0:04:13.52,英文,,0,0,0,,5, 6, 7, 8, 9, 10.
Dialogue: 0,0:04:08.85,0:04:13.52,中文,,0,0,0,,5、6、7、8、9、10
Dialogue: 0,0:04:13.52,0:04:15.30,英文,,0,0,0,,All right.
Dialogue: 0,0:04:13.52,0:04:15.30,中文,,0,0,0,,
Dialogue: 0,0:04:15.30,0:04:23.00,英文,,0,0,0,,What's the string?
Dialogue: 0,0:04:15.30,0:04:23.00,中文,,0,0,0,,字符串是什么？
Dialogue: 0,0:04:23.00,0:04:30.69,英文,,0,0,0,,One, a poem, a raven, midnight so dreary, tired and weary, I believe.
Dialogue: 0,0:04:23.00,0:04:30.69,中文,,0,0,0,,1、一首诗  一只乌鸦  午夜如此沉闷  疲惫不堪  我相信
Dialogue: 0,0:04:30.69,0:04:34.43,英文,,0,0,0,,All right, how was that?
Dialogue: 0,0:04:30.69,0:04:34.43,中文,,0,0,0,,好的  怎么样？
Dialogue: 0,0:04:34.43,0:04:35.35,英文,,0,0,0,,Easier?
Dialogue: 0,0:04:34.43,0:04:35.35,中文,,0,0,0,,更容易了吗？
Dialogue: 0,0:04:35.35,0:04:38.09,英文,,0,0,0,,How many people thought this was easier?
Dialogue: 0,0:04:35.35,0:04:38.09,中文,,0,0,0,,有多少人觉得这更容易了？
Dialogue: 0,0:04:38.09,0:04:40.47,英文,,0,0,0,,How many people thought this was harder?
Dialogue: 0,0:04:38.09,0:04:40.47,中文,,0,0,0,,有多少人觉得这更难了？
Dialogue: 0,0:04:40.47,0:04:43.11,英文,,0,0,0,,This is about a 50-50 split.
Dialogue: 0,0:04:40.47,0:04:43.11,中文,,0,0,0,,这大约是五五开
Dialogue: 0,0:04:43.11,0:04:46.72,英文,,0,0,0,,All right, you want to go bigger?
Dialogue: 0,0:04:43.11,0:04:46.72,中文,,0,0,0,,好的  想要更大的吗？
Dialogue: 0,0:04:46.72,0:04:53.18,英文,,0,0,0,,All right, let's do 10,000.
Dialogue: 0,0:04:46.72,0:04:53.18,中文,,0,0,0,,好的  让我们来10,000
Dialogue: 0,0:04:53.18,0:04:56.13,英文,,0,0,0,,Five, four, three, two, one.
Dialogue: 0,0:04:53.18,0:04:56.13,中文,,0,0,0,,五、四、三、二、一
Dialogue: 0,0:04:56.13,0:04:56.83,英文,,0,0,0,,All right, what's a string?
Dialogue: 0,0:04:56.13,0:04:56.83,中文,,0,0,0,,好的  字符串是什么？
Dialogue: 0,0:04:56.83,0:05:06.88,英文,,0,0,0,,A. Ah, yes.
Dialogue: 0,0:04:56.83,0:05:06.88,中文,,0,0,0,,A  是的
Dialogue: 0,0:05:06.88,0:05:11.88,英文,,0,0,0,,So why was this easier to remember than this one?
Dialogue: 0,0:05:06.88,0:05:11.88,中文,,0,0,0,,那么  为什么这个比这个更容易记住呢？
Dialogue: 0,0:05:11.88,0:05:15.75,英文,,0,0,0,,And why was this one about the same difficulty to remember as this one?
Dialogue: 0,0:05:11.88,0:05:15.75,中文,,0,0,0,,为什么这串字母和这串字母的记忆难度差不多呢？
Dialogue: 0,0:05:15.75,0:05:30.56,英文,,0,0,0,,Yeah.
Dialogue: 0,0:05:15.75,0:05:30.56,中文,,0,0,0,,
Dialogue: 0,0:05:30.56,0:05:35.46,英文,,0,0,0,,Yeah, so the main thing is this was just an entirely random string of letters.
Dialogue: 0,0:05:30.56,0:05:35.46,中文,,0,0,0,,是的  关键在于这只是一串完全随机的字母
Dialogue: 0,0:05:35.46,0:05:40.04,英文,,0,0,0,,In fact, I created it with a Python random.
Dialogue: 0,0:05:35.46,0:05:40.04,中文,,0,0,0,,实际上  我用Python的random函数创建了它
Dialogue: 0,0:05:40.04,0:05:45.49,英文,,0,0,0,,Meanwhile, this one here, it's actually a sequence of words that we read.
Dialogue: 0,0:05:40.04,0:05:45.49,中文,,0,0,0,,而这一串  它实际上是我们读过的一系列单词
Dialogue: 0,0:05:45.49,0:05:50.13,英文,,0,0,0,,In fact, this is the first few words of the Cadaic cadenza.
Dialogue: 0,0:05:45.49,0:05:50.13,中文,,0,0,0,,实际上  这是卡迪克华彩乐段的前几个词
Dialogue: 0,0:05:50.13,0:05:57.13,英文,,0,0,0,,So if you read the number of letters in here, then it spells out pi, 314159.
Dialogue: 0,0:05:50.13,0:05:57.13,中文,,0,0,0,,所以  如果你数一下这里的字母数量  就会拼出圆周率  314159
Dialogue: 0,0:05:57.13,0:06:01.87,英文,,0,0,0,,Meanwhile, this one, it's very clear that it's just the same thing.
Dialogue: 0,0:05:57.13,0:06:01.87,中文,,0,0,0,,而这串  很明显它是一样的
Dialogue: 0,0:06:01.87,0:06:09.23,英文,,0,0,0,,The main idea is the amount of data that you found in one character here is significantly less than the amount of data that you have in one character here.
Dialogue: 0,0:06:01.87,0:06:09.23,中文,,0,0,0,,主要思想是  你在这里一个字符中发现的数据量远远少于你在这里一个字符中拥有的数据量
Dialogue: 0,0:06:09.23,0:06:20.92,英文,,0,0,0,,And because we can associate this with an actual phrase or words, this actually contains less data per character than this here, which is entirely random.
Dialogue: 0,0:06:09.23,0:06:20.92,中文,,0,0,0,,而且因为我们可以将它与实际的短语或单词联系起来  所以它实际上每个字符包含的数据比这里完全随机的要少
Dialogue: 0,0:06:20.92,0:06:24.58,英文,,0,0,0,,In CS, we define a bit to be a single binary digit.
Dialogue: 0,0:06:20.92,0:06:24.58,中文,,0,0,0,,在计算机科学中  我们将一个比特定义为一个二进制数字
Dialogue: 0,0:06:24.58,0:06:26.74,英文,,0,0,0,,Most computers use this to store information.
Dialogue: 0,0:06:24.58,0:06:26.74,中文,,0,0,0,,大多数计算机用它来存储信息
Dialogue: 0,0:06:26.74,0:06:30.46,英文,,0,0,0,,By default, we generally store English text using a string of bits.
Dialogue: 0,0:06:26.74,0:06:30.46,中文,,0,0,0,,默认情况下  我们通常使用一串比特来存储英文文本
Dialogue: 0,0:06:30.46,0:06:33.90,英文,,0,0,0,,So every single eight bits corresponds to a single letter.
Dialogue: 0,0:06:30.46,0:06:33.90,中文,,0,0,0,,所以每八个比特对应一个字母
Dialogue: 0,0:06:33.90,0:06:39.14,英文,,0,0,0,,But the amount of information that we store is generally much less than the raw number of bits we use.
Dialogue: 0,0:06:33.90,0:06:39.14,中文,,0,0,0,,但我们存储的信息量通常远小于我们使用的原始比特数
Dialogue: 0,0:06:39.14,0:06:49.69,英文,,0,0,0,,And generally speaking, the more predictable the data set is, the more likely it is for a human to be able to memorize it, and the fewer bits of data it actually needs to use.
Dialogue: 0,0:06:39.14,0:06:49.69,中文,,0,0,0,,一般来说  数据集越可预测  人类就越有可能记住它  它实际需要使用的比特数据就越少
Dialogue: 0,0:06:49.69,0:06:53.55,英文,,0,0,0,,We actually defined this formally as something called the Shannon entropy.
Dialogue: 0,0:06:49.69,0:06:53.55,中文,,0,0,0,,我们实际上把它正式定义为香农熵
Dialogue: 0,0:06:53.55,0:06:57.55,英文,,0,0,0,,It's kind of a measure of how predictable a data set is.
Dialogue: 0,0:06:53.55,0:06:57.55,中文,,0,0,0,,它是衡量数据集可预测性的一个指标
Dialogue: 0,0:06:57.55,0:07:04.64,英文,,0,0,0,,The formal definition is that expected value of the negative log of p of x, where p of x is the probability.
Dialogue: 0,0:06:57.55,0:07:04.64,中文,,0,0,0,,其正式定义是p(x)的负对数的期望值  其中p(x)是概率
Dialogue: 0,0:07:04.64,0:07:11.24,英文,,0,0,0,,It's fairly complicated, but informally it's a measure of how many possible strings exist with that particular characteristic.
Dialogue: 0,0:07:04.64,0:07:11.24,中文,,0,0,0,,它相当复杂  但通俗地说  它是衡量具有特定特征的可能字符串数量的指标
Dialogue: 0,0:07:11.24,0:07:17.38,英文,,0,0,0,,So for example, the set of all possible strings of 10 random bits.
Dialogue: 0,0:07:11.24,0:07:17.38,中文,,0,0,0,,例如  所有可能的 10 个随机比特组成的字符串的集合
Dialogue: 0,0:07:17.38,0:07:24.94,英文,,0,0,0,,There's 2 to the 10 different possible strings, because there's two choices for the first bit, two choices for the second, and so on.
Dialogue: 0,0:07:17.38,0:07:24.94,中文,,0,0,0,,总共有 2¹⁰ 种不同的可能字符串  因为第一个比特有两种选择  第二个比特有两种选择  以此类推
Dialogue: 0,0:07:24.94,0:07:33.19,英文,,0,0,0,,If we have 10 characters of random English letters, then there's 26 to the 10 possible strings.
Dialogue: 0,0:07:24.94,0:07:33.19,中文,,0,0,0,,如果我们有 10 个随机英文字母组成的字符  那么就有 26¹⁰ 种可能的字符串
Dialogue: 0,0:07:33.19,0:07:39.51,英文,,0,0,0,,And if you do the math, log base 2 of 26 times 10, that's about 47 bits of entropy.
Dialogue: 0,0:07:33.19,0:07:39.51,中文,,0,0,0,,如果你计算一下  以 2 为底 26 的对数乘以 10  大约是 47 比特的熵
Dialogue: 0,0:07:39.51,0:07:47.93,英文,,0,0,0,,So in theory, it would be possible to compress that string of 10 characters to 47 bits of randomized data.
Dialogue: 0,0:07:39.51,0:07:47.93,中文,,0,0,0,,所以理论上  可以将 10 个字符的字符串压缩成 47 比特的随机数据
Dialogue: 0,0:07:47.93,0:07:56.52,英文,,0,0,0,,On the other extreme, if you have a 10,000 character string containing only the exact same letter, there's only 26 possible strings that could possibly exist of that format.
Dialogue: 0,0:07:47.93,0:07:56.52,中文,,0,0,0,,另一个极端  如果你有一个 10,000 个字符的字符串  其中只包含完全相同的字母  那么这种格式的字符串只有 26 种可能性
Dialogue: 0,0:07:56.52,0:08:01.07,英文,,0,0,0,,So we really only have 4.7 bits of entropy there.
Dialogue: 0,0:07:56.52,0:08:01.07,中文,,0,0,0,,所以我们实际上只有 4.7 比特的熵
Dialogue: 0,0:08:01.07,0:08:08.31,英文,,0,0,0,,So that's kind of an explanation for why the M10,000 character string was way easier to memorize than that 10 character string.
Dialogue: 0,0:08:01.07,0:08:08.31,中文,,0,0,0,,这就是为什么 10,000 个字符的字符串比 10 个字符的字符串更容易记忆的原因
Dialogue: 0,0:08:08.31,0:08:10.33,英文,,0,0,0,,English text is somewhere in the middle of these two.
Dialogue: 0,0:08:08.31,0:08:10.33,中文,,0,0,0,,英文文本介于这两者之间
Dialogue: 0,0:08:10.33,0:08:11.95,英文,,0,0,0,,It's not completely predictable.
Dialogue: 0,0:08:10.33,0:08:11.95,中文,,0,0,0,,它不是完全可预测的
Dialogue: 0,0:08:11.95,0:08:13.77,英文,,0,0,0,,It's not completely random.
Dialogue: 0,0:08:11.95,0:08:13.77,中文,,0,0,0,,它也不是完全随机的
Dialogue: 0,0:08:13.77,0:08:20.74,英文,,0,0,0,,And in fact, if you do the math for this, you can actually show exactly how predictable it is.
Dialogue: 0,0:08:13.77,0:08:20.74,中文,,0,0,0,,事实上  如果你计算一下  你就能确切地知道它有多可预测
Dialogue: 0,0:08:20.74,0:08:24.36,英文,,0,0,0,,As an example here, let's say that I have this string.
Dialogue: 0,0:08:20.74,0:08:24.36,中文,,0,0,0,,作为一个例子  假设我有这个字符串
Dialogue: 0,0:08:24.36,0:08:29.31,英文,,0,0,0,,And I'm saying that this string is a valid English sentence.
Dialogue: 0,0:08:24.36,0:08:29.31,中文,,0,0,0,,我说这个字符串是一个有效的英文句子
Dialogue: 0,0:08:29.31,0:08:31.34,英文,,0,0,0,,So let's try to guess.
Dialogue: 0,0:08:29.31,0:08:31.34,中文,,0,0,0,,所以让我们来猜一猜
Dialogue: 0,0:08:31.34,0:08:41.96,英文,,0,0,0,,What does this string say?
Dialogue: 0,0:08:31.34,0:08:41.96,中文,,0,0,0,,这个字符串是什么意思？
Dialogue: 0,0:08:41.96,0:08:57.80,英文,,0,0,0,,When writing English text.
Dialogue: 0,0:08:41.96,0:08:57.80,中文,,0,0,0,,在写英文文本时
Dialogue: 0,0:08:57.80,0:09:04.83,英文,,0,0,0,,Most characters can be omitted without losing meaning.
Dialogue: 0,0:08:57.80,0:09:04.83,中文,,0,0,0,,大多数字符可以省略而不丢失含义
Dialogue: 0,0:09:04.83,0:09:08.17,英文,,0,0,0,,So a decent number of these characters are actually entirely unneeded.
Dialogue: 0,0:09:04.83,0:09:08.17,中文,,0,0,0,,所以其中相当多的字符实际上是完全不需要的
Dialogue: 0,0:09:08.17,0:09:16.16,英文,,0,0,0,,I just didn't include them, and you were able to largely read what's being said.
Dialogue: 0,0:09:08.17,0:09:16.16,中文,,0,0,0,,我只是没有包含它们  而你基本上能够读懂我说的内容
Dialogue: 0,0:09:16.16,0:09:31.21,英文,,0,0,0,,So we've actually had a bunch of these experiments of this type where you kind of showcase parts of a sentence of English, and you get people to tell about how much they're able to read.
Dialogue: 0,0:09:16.16,0:09:31.21,中文,,0,0,0,,我们做过很多这种类型的实验  展示英语句子的一部分  然后让人们说出他们能读懂多少
Dialogue: 0,0:09:31.21,0:09:44.02,英文,,0,0,0,,And using these types of experiments, it was shown that standard English, yeah?
Dialogue: 0,0:09:31.21,0:09:44.02,中文,,0,0,0,,通过这些实验  结果显示标准英语是这样的  对吧？
Dialogue: 0,0:09:44.02,0:09:59.18,英文,,0,0,0,,like it's like there's not there's lit like aligning with the rules of grammar and like words like is there any other option for that or is that just so yeah?
Dialogue: 0,0:09:44.02,0:09:59.18,中文,,0,0,0,,这意味着是否有其他选择？还是标准英语是唯一的选择？是这样的吗？
Dialogue: 0,0:09:59.18,0:10:02.24,英文,,0,0,0,,Yeah, this is specifically one possible way you could read this.
Dialogue: 0,0:09:59.18,0:10:02.24,中文,,0,0,0,,这只是其中一种可能的解读方式
Dialogue: 0,0:10:02.24,0:10:07.28,英文,,0,0,0,,There are definitely other particular sequences of words that you can find, right?
Dialogue: 0,0:10:02.24,0:10:07.28,中文,,0,0,0,,肯定还有其他特定的词序  对吧？
Dialogue: 0,0:10:07.28,0:10:14.25,英文,,0,0,0,,So for example, blank blank st, that could be just, and just has the exact same grammatical form as most,
Dialogue: 0,0:10:07.28,0:10:14.25,中文,,0,0,0,,例如  空格空格st  它可以是“just”  而“just”与“most”具有完全相同的语法形式
Dialogue: 0,0:10:14.25,0:10:19.25,英文,,0,0,0,, but you can tell whether it's most or just because of the context within the sentence.
Dialogue: 0,0:10:14.25,0:10:19.25,中文,,0,0,0,,但你能分辨出它是“most”还是“just”是因为句子中的上下文
Dialogue: 0,0:10:19.25,0:10:23.84,英文,,0,0,0,,So the sentence itself isn't just a sequence of words with parts of speech.
Dialogue: 0,0:10:19.25,0:10:23.84,中文,,0,0,0,,所以句子本身不仅仅是一串带有词性的词
Dialogue: 0,0:10:23.84,0:10:30.20,英文,,0,0,0,,It also has meaning to it, and we're able to intuit what the meaning is because we have familiarity with the language and with real life.
Dialogue: 0,0:10:23.84,0:10:30.20,中文,,0,0,0,,它也有意义  我们能够凭直觉理解它的意思  因为我们熟悉语言和现实生活
Dialogue: 0,0:10:30.20,0:10:31.96,英文,,0,0,0,,And is that captured in Shannon entropy?
Dialogue: 0,0:10:30.20,0:10:31.96,中文,,0,0,0,,香农熵包含了这些吗？
Dialogue: 0,0:10:31.96,0:10:34.38,英文,,0,0,0,,Yeah, that's in effect captured in Shannon entropy.
Dialogue: 0,0:10:31.96,0:10:34.38,中文,,0,0,0,,是的  这实际上包含在香农熵中
Dialogue: 0,0:10:34.38,0:10:44.57,英文,,0,0,0,,The set of all possible phrases that are human readable and make coherent sense, that's the set of things that we're looking at.
Dialogue: 0,0:10:34.38,0:10:44.57,中文,,0,0,0,,所有人类可读且语义连贯的短语的集合  就是我们正在研究的集合
Dialogue: 0,0:10:44.57,0:10:50.67,英文,,0,0,0,,And if you look at the Shannon entropy of standard English, you get that it's about one bit of entropy per character.
Dialogue: 0,0:10:44.57,0:10:50.67,中文,,0,0,0,,如果你看一下标准英语的香农熵  你会发现它每个字符大约有一个比特的熵
Dialogue: 0,0:10:50.67,0:10:55.23,英文,,0,0,0,,So 47 character string, that has around 47 bits of entropy.
Dialogue: 0,0:10:50.67,0:10:55.23,中文,,0,0,0,,所以47个字符的字符串  大约有47比特的熵
Dialogue: 0,0:10:55.23,0:11:02.32,英文,,0,0,0,,So in theory, we could compress that 47 character string to, on average, 47 bits of data.
Dialogue: 0,0:10:55.23,0:11:02.32,中文,,0,0,0,,所以理论上  我们可以将这个47个字符的字符串平均压缩成47比特的数据
Dialogue: 0,0:11:02.32,0:11:11.35,英文,,0,0,0,,So when we did that experiment, 47-character string versus 10-character string, the 47-character string was about as hard to memorize as a 10-character string.
Dialogue: 0,0:11:02.32,0:11:11.35,中文,,0,0,0,,所以当我们做那个实验时  47个字符的字符串和10个字符的字符串一样难记
Dialogue: 0,0:11:11.35,0:11:13.13,英文,,0,0,0,,About half the people said it was easier.
Dialogue: 0,0:11:11.35,0:11:13.13,中文,,0,0,0,,大约一半的人说它更容易
Dialogue: 0,0:11:13.13,0:11:14.79,英文,,0,0,0,,About half the people said it was harder.
Dialogue: 0,0:11:13.13,0:11:14.79,中文,,0,0,0,,大约一半的人说它更难
Dialogue: 0,0:11:14.79,0:11:17.40,英文,,0,0,0,,So that's kind of the reason why that's the case.
Dialogue: 0,0:11:14.79,0:11:17.40,中文,,0,0,0,,这就是原因
Dialogue: 0,0:11:17.40,0:11:19.78,英文,,0,0,0,,Now, in practice, it's hard to get to that theoretical limit.
Dialogue: 0,0:11:17.40,0:11:19.78,中文,,0,0,0,,实际上  很难达到这个理论极限
Dialogue: 0,0:11:19.78,0:11:24.70,英文,,0,0,0,,Like, this is just the theoretical, absolute best that's even possible.
Dialogue: 0,0:11:19.78,0:11:24.70,中文,,0,0,0,,这只是理论上  绝对最好的可能性
Dialogue: 0,0:11:24.70,0:11:27.80,英文,,0,0,0,,You can't really do that in most circumstances, but you can get fairly close.
Dialogue: 0,0:11:24.70,0:11:27.80,中文,,0,0,0,,在大多数情况下  这并不完全可行  但可以做到相当接近
Dialogue: 0,0:11:27.80,0:11:30.72,英文,,0,0,0,,If you just look at the relative frequencies of English characters, right?
Dialogue: 0,0:11:27.80,0:11:30.72,中文,,0,0,0,,如果只看英语字符的相对频率  对吧？
Dialogue: 0,0:11:30.72,0:11:33.36,英文,,0,0,0,,So E is the most common letter in the English language.
Dialogue: 0,0:11:30.72,0:11:33.36,中文,,0,0,0,,所以 E 是英语中最常见的字母
Dialogue: 0,0:11:33.36,0:11:35.39,英文,,0,0,0,,S is the most common first letter.
Dialogue: 0,0:11:33.36,0:11:35.39,中文,,0,0,0,,S 是最常见的首字母
Dialogue: 0,0:11:35.39,0:11:40.47,英文,,0,0,0,,If you keep going, it's E-T-A-O-I-N.
Dialogue: 0,0:11:35.39,0:11:40.47,中文,,0,0,0,,如果继续下去  那就是 E-T-A-O-I-N
Dialogue: 0,0:11:40.47,0:11:44.25,英文,,0,0,0,,ETAU in short lieu is like the particular set.
Dialogue: 0,0:11:40.47,0:11:44.25,中文,,0,0,0,,简而言之  ETAU 是特定的集合
Dialogue: 0,0:11:44.25,0:11:49.36,英文,,0,0,0,,If you played Wordle a lot, then you know those letters by heart now.
Dialogue: 0,0:11:44.25,0:11:49.36,中文,,0,0,0,,如果你玩过很多 Wordle  那么你现在已经把这些字母记住了
Dialogue: 0,0:11:49.36,0:11:53.62,英文,,0,0,0,,But just looking at that, you can get down to 4.1 bits per character.
Dialogue: 0,0:11:49.36,0:11:53.62,中文,,0,0,0,,但仅仅通过观察  你就可以将每个字符降到 4.1 位
Dialogue: 0,0:11:53.62,0:11:57.74,英文,,0,0,0,,And if you just look at relative word frequencies, then you can get down to 2.6 bits.
Dialogue: 0,0:11:53.62,0:11:57.74,中文,,0,0,0,,如果你只看单词的相对频率  那么你可以降到 2.6 位
Dialogue: 0,0:11:57.74,0:12:00.29,英文,,0,0,0,,That's not down to the 1-bit minimum.
Dialogue: 0,0:11:57.74,0:12:00.29,中文,,0,0,0,,这并没有达到 1 位的最小值
Dialogue: 0,0:12:00.29,0:12:02.39,英文,,0,0,0,,But generally speaking, we're able to get close.
Dialogue: 0,0:12:00.29,0:12:02.39,中文,,0,0,0,,但总的来说  我们能够做到接近
Dialogue: 0,0:12:02.39,0:12:06.05,英文,,0,0,0,,And as we compress data, the entropy of the data stays constant.
Dialogue: 0,0:12:02.39,0:12:06.05,中文,,0,0,0,,随着我们压缩数据  数据的熵保持不变
Dialogue: 0,0:12:06.05,0:12:13.77,英文,,0,0,0,,If we have 2 to the 100 different possible strings that you could exist, then you will still have 2 to the 100 different compressed possible strings.
Dialogue: 0,0:12:06.05,0:12:13.77,中文,,0,0,0,,如果我们有 2 的 100 次方个不同的可能字符串  那么你仍然会有 2 的 100 次方个不同的压缩字符串
Dialogue: 0,0:12:13.77,0:12:19.67,英文,,0,0,0,,So the more compressed our data becomes, the more uniformly distributed these underlying bits become.
Dialogue: 0,0:12:13.77,0:12:19.67,中文,,0,0,0,,因此  我们的数据压缩得越多  这些底层位的分布就越均匀
Dialogue: 0,0:12:19.67,0:12:23.45,英文,,0,0,0,,That's actually also a useful measure of how compressed we can get it.
Dialogue: 0,0:12:19.67,0:12:23.45,中文,,0,0,0,,这实际上也是衡量我们压缩程度的一个有用指标
Dialogue: 0,0:12:23.45,0:12:31.90,英文,,0,0,0,,If we can say that there's a 50-50 chance that each next bit is a 1 or a 0, then we're getting to the point where it's basically as compressed as possible.
Dialogue: 0,0:12:23.45,0:12:31.90,中文,,0,0,0,,如果我们可以说每个下一位是 1 或 0 的概率是 50-50  那么我们就达到了基本上尽可能压缩的程度
Dialogue: 0,0:12:31.90,0:12:42.06,英文,,0,0,0,,But if we have this predictability, like with English text, we generally can compress it even further.
Dialogue: 0,0:12:31.90,0:12:42.06,中文,,0,0,0,,但是  如果我们有这种可预测性  就像英语文本一样  我们通常可以进一步压缩它
Dialogue: 0,0:12:42.06,0:12:44.54,英文,,0,0,0,,So let's kind of look at how we can compress this.
Dialogue: 0,0:12:42.06,0:12:44.54,中文,,0,0,0,,让我们来看看如何压缩它
Dialogue: 0,0:12:44.54,0:12:48.14,英文,,0,0,0,,So let's start off with just English text only.
Dialogue: 0,0:12:44.54,0:12:48.14,中文,,0,0,0,,首先让我们从纯英文文本开始
Dialogue: 0,0:12:48.14,0:12:49.68,英文,,0,0,0,,And let's look at how we can compress this.
Dialogue: 0,0:12:48.14,0:12:49.68,中文,,0,0,0,,让我们看看如何压缩它
Dialogue: 0,0:12:49.68,0:12:52.69,英文,,0,0,0,,By default, we're going to have eight bits per character.
Dialogue: 0,0:12:49.68,0:12:52.69,中文,,0,0,0,,默认情况下  每个字符占8比特
Dialogue: 0,0:12:52.69,0:12:55.41,英文,,0,0,0,,So we're going to have to figure out a way to compress this.
Dialogue: 0,0:12:52.69,0:12:55.41,中文,,0,0,0,,所以我们要想办法压缩它
Dialogue: 0,0:12:55.41,0:13:00.11,英文,,0,0,0,,Now, an easy first step is to just use fewer than eight bits for each letter.
Dialogue: 0,0:12:55.41,0:13:00.11,中文,,0,0,0,,一个简单的第一步是每个字母使用少于8比特
Dialogue: 0,0:13:00.11,0:13:03.65,英文,,0,0,0,,So we can just decide what bit strings go with which letters.
Dialogue: 0,0:13:00.11,0:13:03.65,中文,,0,0,0,,我们可以决定哪些比特串对应哪些字母
Dialogue: 0,0:13:03.65,0:13:14.04,英文,,0,0,0,,More generally, we'll say that each symbol, so the letter D, the letter O, the letter G, those are going to correspond to certain binary strings.
Dialogue: 0,0:13:03.65,0:13:14.04,中文,,0,0,0,,更一般地说  我们会说每个符号  例如字母d、字母o、字母g  都将对应于特定的二进制字符串
Dialogue: 0,0:13:14.04,0:13:18.54,英文,,0,0,0,,So one approach is to use, for example, Braille.
Dialogue: 0,0:13:14.04,0:13:18.54,中文,,0,0,0,,因此  一种方法是使用盲文
Dialogue: 0,0:13:18.54,0:13:25.12,英文,,0,0,0,,Braille is an example of how we can take every single one of these letters and compress it down to effectively six bits of data.
Dialogue: 0,0:13:18.54,0:13:25.12,中文,,0,0,0,,盲文是一个例子  说明我们可以将每个字母压缩到6比特数据
Dialogue: 0,0:13:25.12,0:13:31.38,英文,,0,0,0,,We can imagine that we have those six dots, and each one is a one if the dot's there and a zero if the dot's not there.
Dialogue: 0,0:13:25.12,0:13:31.38,中文,,0,0,0,,我们可以想象我们有六个点  如果点存在则每个点为1  如果点不存在则为0
Dialogue: 0,0:13:31.38,0:13:41.19,英文,,0,0,0,,And using this, we can compress any possible string of just alphabetical lowercase letters to six bits per character.
Dialogue: 0,0:13:31.38,0:13:41.19,中文,,0,0,0,,使用这种方法  我们可以将任何可能的小写字母字符串压缩到每个字符6比特
Dialogue: 0,0:13:41.19,0:13:42.65,英文,,0,0,0,,We can go further than this.
Dialogue: 0,0:13:41.19,0:13:42.65,中文,,0,0,0,,我们可以做得更好
Dialogue: 0,0:13:42.65,0:13:46.17,英文,,0,0,0,,We can get down to five bits, but we can't get any further.
Dialogue: 0,0:13:42.65,0:13:46.17,中文,,0,0,0,,我们可以降到5比特  但不能再低了
Dialogue: 0,0:13:46.17,0:13:55.55,英文,,0,0,0,,Because if we have only four bits, we can only handle 16 different letters in our alphabet, and we have 26 different letters in our alphabet.
Dialogue: 0,0:13:46.17,0:13:55.55,中文,,0,0,0,,因为如果我们只有4比特  我们就只能处理字母表中的16个不同的字母  而我们的字母表中有26个不同的字母
Dialogue: 0,0:13:55.55,0:13:57.47,英文,,0,0,0,,How can we get to 5 bits?
Dialogue: 0,0:13:55.55,0:13:57.47,中文,,0,0,0,,我们如何才能达到5比特呢？
Dialogue: 0,0:13:57.47,0:14:03.14,英文,,0,0,0,,Well, the simple one is to convert A into 1, B into 2, C into 3, and so on up to Z into 26.
Dialogue: 0,0:13:57.47,0:14:03.14,中文,,0,0,0,,简单的方法是将 a 转换为1  B转换为2  C转换为3  依此类推  直到Z转换为26
Dialogue: 0,0:14:03.14,0:14:04.86,英文,,0,0,0,,And then you just write that number in binary.
Dialogue: 0,0:14:03.14,0:14:04.86,中文,,0,0,0,,然后你只需用二进制写下这个数字
Dialogue: 0,0:14:04.86,0:14:08.20,英文,,0,0,0,,So A becomes 1, which is 0, 0, 0, 0, 1.
Dialogue: 0,0:14:04.86,0:14:08.20,中文,,0,0,0,,所以 a 变成1  也就是0, 0, 0, 0, 1
Dialogue: 0,0:14:08.20,0:14:11.44,英文,,0,0,0,,C becomes 3, which is 0, 0, 0, 1, 1.
Dialogue: 0,0:14:08.20,0:14:11.44,中文,,0,0,0,,c 变成3  也就是0, 0, 0, 1, 1
Dialogue: 0,0:14:11.44,0:14:14.24,英文,,0,0,0,,And then every single letter ends up becoming that.
Dialogue: 0,0:14:11.44,0:14:14.24,中文,,0,0,0,,然后每个字母都变成了这样
Dialogue: 0,0:14:14.24,0:14:17.00,英文,,0,0,0,,Once you get to Z, it becomes 26, which is 1, 1, 0, 1, 0.
Dialogue: 0,0:14:14.24,0:14:17.00,中文,,0,0,0,,当你到 z 时  它变成26  也就是1, 1, 0, 1, 0
Dialogue: 0,0:14:17.00,0:14:19.02,英文,,0,0,0,,And that would be 5 bits.
Dialogue: 0,0:14:17.00,0:14:19.02,中文,,0,0,0,,那就是5比特
Dialogue: 0,0:14:19.02,0:14:23.06,英文,,0,0,0,,Yeah.
Dialogue: 0,0:14:19.02,0:14:23.06,中文,,0,0,0,,
Dialogue: 0,0:14:23.06,0:14:29.49,英文,,0,0,0,,So one way we can do even better than just the 5-bit limit is to use a variable number of bits for each letter.
Dialogue: 0,0:14:23.06,0:14:29.49,中文,,0,0,0,,所以  我们可以做得比5位限制更好的一种方法是为每个字母使用可变数量的位
Dialogue: 0,0:14:29.49,0:14:32.93,英文,,0,0,0,,So can anyone think of a cipher that does that?
Dialogue: 0,0:14:29.49,0:14:32.93,中文,,0,0,0,,那么  有人能想到一种可以做到这一点的密码吗？
Dialogue: 0,0:14:32.93,0:14:34.23,英文,,0,0,0,,Yeah?
Dialogue: 0,0:14:32.93,0:14:34.23,中文,,0,0,0,,有吗？
Dialogue: 0,0:14:34.23,0:14:36.27,英文,,0,0,0,,Morse code, yes.
Dialogue: 0,0:14:34.23,0:14:36.27,中文,,0,0,0,,莫尔斯电码  是的
Dialogue: 0,0:14:36.27,0:14:41.56,英文,,0,0,0,,In Morse code, every single letter has a slightly different pattern to it.
Dialogue: 0,0:14:36.27,0:14:41.56,中文,,0,0,0,,在莫尔斯电码中  每个字母都有一个略微不同的模式
Dialogue: 0,0:14:41.56,0:14:45.98,英文,,0,0,0,,For example, e is a single dot, because that's a very common letter.
Dialogue: 0,0:14:41.56,0:14:45.98,中文,,0,0,0,,例如  e 是一个点  因为这是一个非常常见的字母
Dialogue: 0,0:14:45.98,0:14:51.51,英文,,0,0,0,,And x is a very uncommon letter, so it has dash, dot, dot, dash, four characters.
Dialogue: 0,0:14:45.98,0:14:51.51,中文,,0,0,0,,而 x 是一个非常不常见的字母  所以它有 4 个字符：划、点、点、划
Dialogue: 0,0:14:51.51,0:14:53.68,英文,,0,0,0,,Each letter is between one and four bits.
Dialogue: 0,0:14:51.51,0:14:53.68,中文,,0,0,0,,每个字母的长度在 1 到 4 位之间
Dialogue: 0,0:14:53.68,0:14:59.92,英文,,0,0,0,,And it's very useful that all these short letters end up being the most common letters.
Dialogue: 0,0:14:53.68,0:14:59.92,中文,,0,0,0,,所有这些短字母最终都是最常见的字母  这非常有用
Dialogue: 0,0:14:59.92,0:15:05.63,英文,,0,0,0,,We can imagine that we can convert this to binary by saying a dash is a one and a dot is a zero.
Dialogue: 0,0:14:59.92,0:15:05.63,中文,,0,0,0,,我们可以想象  我们可以通过将划表示为 1  将点表示为 0 来将其转换为二进制
Dialogue: 0,0:15:05.63,0:15:07.93,英文,,0,0,0,,Unfortunately, we do run into a problem.
Dialogue: 0,0:15:05.63,0:15:07.93,中文,,0,0,0,,不幸的是  我们确实遇到了一个问题
Dialogue: 0,0:15:07.93,0:15:12.48,英文,,0,0,0,,Let's say that I have dash, dash, dot, dash, dash, dot.
Dialogue: 0,0:15:07.93,0:15:12.48,中文,,0,0,0,,假设我有划、划、点、划、划、点
Dialogue: 0,0:15:12.48,0:15:21.18,英文,,0,0,0,,What word did I write?
Dialogue: 0,0:15:12.48,0:15:21.18,中文,,0,0,0,,我写的是什么词？
Dialogue: 0,0:15:21.18,0:15:31.24,英文,,0,0,0,,Any suggestions?
Dialogue: 0,0:15:21.18,0:15:31.24,中文,,0,0,0,,有什么建议吗？
Dialogue: 0,0:15:31.24,0:15:32.80,英文,,0,0,0,,Yeah, GC is possible.
Dialogue: 0,0:15:31.24,0:15:32.80,中文,,0,0,0,,嗯  GC 是可能的
Dialogue: 0,0:15:32.80,0:15:33.78,英文,,0,0,0,,Meme is possible.
Dialogue: 0,0:15:32.80,0:15:33.78,中文,,0,0,0,,Meme 也是可能的
Dialogue: 0,0:15:33.78,0:15:40.56,英文,,0,0,0,,What else?
Dialogue: 0,0:15:33.78,0:15:40.56,中文,,0,0,0,,还有什么？
Dialogue: 0,0:15:40.56,0:15:41.82,英文,,0,0,0,,MP?
Dialogue: 0,0:15:40.56,0:15:41.82,中文,,0,0,0,,MP？
Dialogue: 0,0:15:41.82,0:15:47.26,英文,,0,0,0,,Yeah, if we're British.
Dialogue: 0,0:15:41.82,0:15:47.26,中文,,0,0,0,,嗯  如果我们是英国人的话
Dialogue: 0,0:15:47.26,0:15:48.86,英文,,0,0,0,,Yeah.
Dialogue: 0,0:15:47.26,0:15:48.86,中文,,0,0,0,,是的
Dialogue: 0,0:15:48.86,0:15:49.24,英文,,0,0,0,,QN.
Dialogue: 0,0:15:48.86,0:15:49.24,中文,,0,0,0,,QN
Dialogue: 0,0:15:49.24,0:15:49.85,英文,,0,0,0,,QN.
Dialogue: 0,0:15:49.24,0:15:49.85,中文,,0,0,0,,QN
Dialogue: 0,0:15:49.85,0:15:50.61,英文,,0,0,0,,QN.
Dialogue: 0,0:15:49.85,0:15:50.61,中文,,0,0,0,,QN
Dialogue: 0,0:15:50.61,0:15:52.93,英文,,0,0,0,,Yeah.
Dialogue: 0,0:15:50.61,0:15:52.93,中文,,0,0,0,,
Dialogue: 0,0:15:52.93,0:15:55.03,英文,,0,0,0,,It could be ta-ta, ta-ta.
Dialogue: 0,0:15:52.93,0:15:55.03,中文,,0,0,0,,可能是 ta-ta, ta-ta
Dialogue: 0,0:15:55.03,0:15:58.19,英文,,0,0,0,,Yeah, there's a ton of different things that it could possibly be.
Dialogue: 0,0:15:55.03,0:15:58.19,中文,,0,0,0,,是的  它可能代表很多不同的东西
Dialogue: 0,0:15:58.19,0:16:02.03,英文,,0,0,0,,Here's a set of words that I came up with that were reasonable.
Dialogue: 0,0:15:58.19,0:16:02.03,中文,,0,0,0,,以下是我想到的一些合理的词语组合
Dialogue: 0,0:16:02.03,0:16:08.01,英文,,0,0,0,,Now, in reality in Morse code, there's actually a short pause between each code word to avoid this type of ambiguity.
Dialogue: 0,0:16:02.03,0:16:08.01,中文,,0,0,0,,实际上  在摩尔斯电码中  每个代码字之间实际上都有一个短暂的停顿  以避免这种类型的歧义
Dialogue: 0,0:16:08.01,0:16:15.09,英文,,0,0,0,,So the way that its standard Morse code works is that a dot is one unit of time, a dash is three units of time,
Dialogue: 0,0:16:08.01,0:16:15.09,中文,,0,0,0,,所以标准摩尔斯电码的工作方式是：一个点是一个时间单位  一个破折号是三个时间单位
Dialogue: 0,0:16:15.09,0:16:22.09,英文,,0,0,0,,the time between individual dots and dashes within a letter is one unit, and the time between individual letters is three units.
Dialogue: 0,0:16:15.09,0:16:22.09,中文,,0,0,0,,一个字母内各个点和破折号之间的时间是一个时间单位  各个字母之间的时间是三个时间单位
Dialogue: 0,0:16:22.09,0:16:25.47,英文,,0,0,0,,So using that, you're able to parse this type of ambiguity.
Dialogue: 0,0:16:22.09,0:16:25.47,中文,,0,0,0,,所以使用这种方法  你就能够解析这种类型的歧义
Dialogue: 0,0:16:25.47,0:16:29.19,英文,,0,0,0,,The pause acts as a third symbol for use.
Dialogue: 0,0:16:25.47,0:16:29.19,中文,,0,0,0,,停顿就像第三种符号一样被使用
Dialogue: 0,0:16:29.19,0:16:31.76,英文,,0,0,0,,But without that, it's ambiguous.
Dialogue: 0,0:16:29.19,0:16:31.76,中文,,0,0,0,,但如果没有停顿  就会产生歧义
Dialogue: 0,0:16:31.76,0:16:36.32,英文,,0,0,0,,For the record, I do have a script that looked through a bunch of Morse code.
Dialogue: 0,0:16:31.76,0:16:36.32,中文,,0,0,0,,顺便说一下  我确实有一个脚本  可以查看一堆摩尔斯电码
Dialogue: 0,0:16:36.32,0:16:43.35,英文,,0,0,0,,And the most ambiguous string I could find was dash, dot, dot, dot, dot, dash, dot, dot, dot, dot,
Dialogue: 0,0:16:36.32,0:16:43.35,中文,,0,0,0,,我能找到的最模糊的字符串是破折号、点、点、点、点、破折号、点、点、点、点
Dialogue: 0,0:16:43.35,0:16:49.35,英文,,0,0,0,,which has 23 different English representations that make valid words.
Dialogue: 0,0:16:43.35,0:16:49.35,中文,,0,0,0,,它有 23 种不同的英文表示形式可以构成有效的单词
Dialogue: 0,0:16:49.35,0:16:54.67,英文,,0,0,0,,So a fun exercise is to find all 23 of them.
Dialogue: 0,0:16:49.35,0:16:54.67,中文,,0,0,0,,所以一个有趣的练习是找到所有 23 个单词
Dialogue: 0,0:16:54.67,0:17:04.63,英文,,0,0,0,,An alternative strategy, instead of adding a pause in between, is to avoid this ambiguity by making the code something called a prefix tree.
Dialogue: 0,0:16:54.67,0:17:04.63,中文,,0,0,0,,另一种策略  不是在中间添加停顿  而是通过将代码制成一种称为前缀树的东西来避免这种歧义
Dialogue: 0,0:17:04.63,0:17:08.09,英文,,0,0,0,,So here's kind of the look of how Morse code looks as a tree.
Dialogue: 0,0:17:04.63,0:17:08.09,中文,,0,0,0,,所以这就是摩尔斯电码作为一棵树的样子
Dialogue: 0,0:17:08.09,0:17:12.30,英文,,0,0,0,,And the idea is every single time you go down one layer, you're using a dot or a dash.
Dialogue: 0,0:17:08.09,0:17:12.30,中文,,0,0,0,,这个想法是  每次你向下走一层  你都会用到一个点或一个破折号
Dialogue: 0,0:17:12.30,0:17:21.12,英文,,0,0,0,,So for example, e is a single dot, a is a dot followed by a dash, w is dot dash dash, and so on and so forth.
Dialogue: 0,0:17:12.30,0:17:21.12,中文,,0,0,0,,例如  E 是一个点  A 是一个点后跟一个破折号  W 是点破折号破折号  等等
Dialogue: 0,0:17:21.12,0:17:28.05,英文,,0,0,0,,Now, the reason why we're having struggles with this, the reason why we're able to come up with multiple different interpretations,
Dialogue: 0,0:17:21.12,0:17:28.05,中文,,0,0,0,,我们之所以在这方面遇到困难  之所以能够得出多种不同的解释
Dialogue: 0,0:17:28.05,0:17:36.05,英文,,0,0,0,,is because in this tree, you could potentially stop halfway to one letter and reach a valid letter itself.
Dialogue: 0,0:17:28.05,0:17:36.05,中文,,0,0,0,,是因为在这棵树中  你可能会在到达一个字母的一半时停止  并到达一个有效的字母本身
Dialogue: 0,0:17:36.05,0:17:45.14,英文,,0,0,0,,If we guarantee for a fact that there are none of these prefixes, like E is never a prefix of A, is never a prefix of W,
Dialogue: 0,0:17:36.05,0:17:45.14,中文,,0,0,0,,如果我们能确保没有这些前缀  比如 E 永远不是 A 的前缀  也永远不是 W 的前缀
Dialogue: 0,0:17:45.14,0:17:52.14,英文,,0,0,0,,then we can guarantee that we get exactly one unique representation for every string.
Dialogue: 0,0:17:45.14,0:17:52.14,中文,,0,0,0,,那么我们可以保证每个字符串都只有一个唯一的表示
Dialogue: 0,0:17:52.14,0:17:54.03,英文,,0,0,0,,So here's an example here.
Dialogue: 0,0:17:52.14,0:17:54.03,中文,,0,0,0,,这里有一个例子
Dialogue: 0,0:17:54.03,0:17:58.73,英文,,0,0,0,,It's kind of a silly one where we just have one.
Dialogue: 0,0:17:54.03,0:17:58.73,中文,,0,0,0,,这是一个有点傻的例子  我们只有一个
Dialogue: 0,0:17:58.73,0:18:02.52,英文,,0,0,0,,If it's a one, then it automatically just ends, whereas if it's a zero, we keep going.
Dialogue: 0,0:17:58.73,0:18:02.52,中文,,0,0,0,,如果它是 1  那么它会自动结束  而如果是 0  我们会继续
Dialogue: 0,0:18:02.52,0:18:10.48,英文,,0,0,0,,And the idea is if this was the encoding that we used, then we'd be able to guarantee a particular interpretation of the string.
Dialogue: 0,0:18:02.52,0:18:10.48,中文,,0,0,0,,我们的想法是  如果这是我们使用的编码  那么我们就能够保证对字符串的特定解释
Dialogue: 0,0:18:10.48,0:18:13.42,英文,,0,0,0,,The idea is we look at one bit at a time.
Dialogue: 0,0:18:10.48,0:18:13.42,中文,,0,0,0,,我们的想法是每次看一个比特
Dialogue: 0,0:18:13.42,0:18:16.20,英文,,0,0,0,,For example, this string is five zeros followed by one.
Dialogue: 0,0:18:13.42,0:18:16.20,中文,,0,0,0,,例如  这个字符串是五个 0 后面跟着一个 1
Dialogue: 0,0:18:16.20,0:18:20.01,英文,,0,0,0,,So we go down five zeros, two, three, four, five, followed by one.
Dialogue: 0,0:18:16.20,0:18:20.01,中文,,0,0,0,,所以我们往下走五个 0  二、三、四、五  然后是一个 1
Dialogue: 0,0:18:20.01,0:18:23.01,英文,,0,0,0,,And now we're at the only letter that it could possibly be.
Dialogue: 0,0:18:20.01,0:18:23.01,中文,,0,0,0,,现在我们到了它唯一可能成为的字母
Dialogue: 0,0:18:23.01,0:18:25.63,英文,,0,0,0,,Once we do that, we go back up to the start.
Dialogue: 0,0:18:23.01,0:18:25.63,中文,,0,0,0,,一旦我们这样做  我们就会回到起点
Dialogue: 0,0:18:25.63,0:18:27.03,英文,,0,0,0,,We look at the next one.
Dialogue: 0,0:18:25.63,0:18:27.03,中文,,0,0,0,,我们看看下一个
Dialogue: 0,0:18:27.03,0:18:30.43,英文,,0,0,0,,The only thing that could be is space, and so on and so forth.
Dialogue: 0,0:18:27.03,0:18:30.43,中文,,0,0,0,,唯一可能的是空格  等等
Dialogue: 0,0:18:30.43,0:18:35.49,英文,,0,0,0,,Using this, we're able to get a single unique interpretation of any bit string we want.
Dialogue: 0,0:18:30.43,0:18:35.49,中文,,0,0,0,,使用这种方法  我们能够对任何我们想要的位串进行单一的、唯一的解释
Dialogue: 0,0:18:35.49,0:18:42.87,英文,,0,0,0,,And this is, in general, true regardless of how we do this, as long as we have this type of prefix-free-ness.
Dialogue: 0,0:18:35.49,0:18:42.87,中文,,0,0,0,,一般来说  只要我们有这种无前缀的类型  这就是真的
Dialogue: 0,0:18:42.87,0:18:49.58,英文,,0,0,0,,Effectively, every single letter is on a leaf of the tree, not in a branch.
Dialogue: 0,0:18:42.87,0:18:49.58,中文,,0,0,0,,实际上  每个字母都在树的叶子上  而不是在分支上
Dialogue: 0,0:18:49.58,0:18:59.66,英文,,0,0,0,,On the other hand, this is a very bad one because we now have 27 bits for a Z or Q. That's kind of a lot.
Dialogue: 0,0:18:49.58,0:18:59.66,中文,,0,0,0,,另一方面  这是一个非常糟糕的例子  因为我们现在有 27 位表示 Z 或 Q  这有点多
Dialogue: 0,0:18:59.66,0:19:05.68,英文,,0,0,0,,We kind of want to reduce our number from 8, so this isn't going to be helpful.
Dialogue: 0,0:18:59.66,0:19:05.68,中文,,0,0,0,,我们想把我们的数字从 8 减少  所以这没有帮助
Dialogue: 0,0:19:05.68,0:19:11.93,英文,,0,0,0,,But we can do something like this, where we have the letters show up.
Dialogue: 0,0:19:05.68,0:19:11.93,中文,,0,0,0,,但是我们可以做这样的事情  让字母显示出来
Dialogue: 0,0:19:11.93,0:19:18.73,英文,,0,0,0,,As long as all these letters are on leaves, then we can guarantee that we have at most one valid way of interpreting bitstream.
Dialogue: 0,0:19:11.93,0:19:18.73,中文,,0,0,0,,只要所有这些字母都在叶子上  那么我们就可以保证我们最多有一种有效的方法来解释比特流
Dialogue: 0,0:19:18.73,0:19:24.59,英文,,0,0,0,,There's no way to get an ambiguous string.
Dialogue: 0,0:19:18.73,0:19:24.59,中文,,0,0,0,,不可能得到一个模糊的字符串
Dialogue: 0,0:19:24.59,0:19:27.85,英文,,0,0,0,,Now, some strings are going to be better than others for text.
Dialogue: 0,0:19:24.59,0:19:27.85,中文,,0,0,0,,现在  有些字符串比其他的更适合文本
Dialogue: 0,0:19:27.85,0:19:35.86,英文,,0,0,0,,For example, even this really bad one that we said that was really spindly, that's actually better for certain strings, like eat.
Dialogue: 0,0:19:27.85,0:19:35.86,中文,,0,0,0,,例如  即使是我们之前说的那个非常细长的糟糕字符串  对于某些字符串  比如"EAT"  实际上更好
Dialogue: 0,0:19:35.86,0:19:38.94,英文,,0,0,0,,But it's worse for things like Josh.
Dialogue: 0,0:19:35.86,0:19:38.94,中文,,0,0,0,,但对于像 "JOSH" 这样的字符串来说  它更糟糕
Dialogue: 0,0:19:38.94,0:19:48.02,英文,,0,0,0,,Meanwhile, the one that we had later, this one, this one is actually worse for eat, but it's way better for Josh.
Dialogue: 0,0:19:38.94,0:19:48.02,中文,,0,0,0,,同时  我们后来得到的那个  这个  这个对于 "EAT" 来说实际上更糟糕  但对于 "JOSH" 来说要好得多
Dialogue: 0,0:19:48.02,0:20:00.97,英文,,0,0,0,,So it would be useful to have a way to predict what the best code is for a given text, instead of relying on a fixed code that we use for every single possible stream.
Dialogue: 0,0:19:48.02,0:20:00.97,中文,,0,0,0,,因此  有一种方法可以预测给定文本的最佳代码  而不是依赖于我们对每个可能的流使用的固定代码  这将很有用
Dialogue: 0,0:20:00.97,0:20:04.89,英文,,0,0,0,,So let's take a look at how we might do this.
Dialogue: 0,0:20:00.97,0:20:04.89,中文,,0,0,0,,所以让我们来看看如何做到这一点
Dialogue: 0,0:20:04.89,0:20:08.92,英文,,0,0,0,,So one obvious approach.
Dialogue: 0,0:20:04.89,0:20:08.92,中文,,0,0,0,,所以一个显而易见的方法
Dialogue: 0,0:20:08.92,0:20:10.04,英文,,0,0,0,,Would be to do this.
Dialogue: 0,0:20:08.92,0:20:10.04,中文,,0,0,0,,将是做这个
Dialogue: 0,0:20:10.04,0:20:17.15,英文,,0,0,0,,Well, since we want to maximize the entropy per bit, we're going to want about a 50% zero rate and a 50% one rate.
Dialogue: 0,0:20:10.04,0:20:17.15,中文,,0,0,0,,嗯  由于我们想最大化每比特的熵  我们将需要大约 50% 的零率和 50% 的一率
Dialogue: 0,0:20:17.15,0:20:21.11,英文,,0,0,0,,That way, we maximize the randomness inherent in each bit.
Dialogue: 0,0:20:17.15,0:20:21.11,中文,,0,0,0,,这样  我们就最大化了每个比特中固有的随机性
Dialogue: 0,0:20:21.11,0:20:29.02,英文,,0,0,0,,So what we'll do is we'll count the relative frequencies of all characters in a text, and we'll split into left and right halves of about the same frequency.
Dialogue: 0,0:20:21.11,0:20:29.02,中文,,0,0,0,,所以我们要做的是  我们将计算文本中所有字符的相对频率  然后我们将它们分成左右两半  频率大致相同
Dialogue: 0,0:20:29.02,0:20:34.38,英文,,0,0,0,,The left half gets a leading zero, the right half gets a leading one, and then you recurse down from there.
Dialogue: 0,0:20:29.02,0:20:34.38,中文,,0,0,0,,左半部分得到一个前导零  右半部分得到一个前导一  然后你从那里递归下去
Dialogue: 0,0:20:34.38,0:20:44.50,英文,,0,0,0,,So in this example here, if we have these characters with these frequencies, then we can say that 35 plus 17, that's just about 50.
Dialogue: 0,0:20:34.38,0:20:44.50,中文,,0,0,0,,所以在这个例子中  如果我们有这些频率的字符  那么我们可以说 35 加 17  大约是 50
Dialogue: 0,0:20:44.50,0:20:45.12,英文,,0,0,0,,It's 52.
Dialogue: 0,0:20:44.50,0:20:45.12,中文,,0,0,0,,准确来说是 52
Dialogue: 0,0:20:45.12,0:20:52.69,英文,,0,0,0,,So we're going to take those two, and we're going to assign them the starting value 0.
Dialogue: 0,0:20:45.12,0:20:52.69,中文,,0,0,0,,所以我们要取这两个  并给它们分配起始值 0
Dialogue: 0,0:20:52.69,0:20:56.23,英文,,0,0,0,,And we'll take the remainder of the starting value 1.
Dialogue: 0,0:20:52.69,0:20:56.23,中文,,0,0,0,,我们将取起始值为 1 的其余部分
Dialogue: 0,0:20:56.23,0:20:58.30,英文,,0,0,0,,Then we keep doing this recursively.
Dialogue: 0,0:20:56.23,0:20:58.30,中文,,0,0,0,,然后我们继续递归地这样做
Dialogue: 0,0:20:58.30,0:20:59.52,英文,,0,0,0,,We take the 35 and 17.
Dialogue: 0,0:20:58.30,0:20:59.52,中文,,0,0,0,,我们取 35 和 17
Dialogue: 0,0:20:59.52,0:21:03.03,英文,,0,0,0,,They split into 35 and 17, because that's the best way we can do this.
Dialogue: 0,0:20:59.52,0:21:03.03,中文,,0,0,0,,它们分成 35 和 17  因为这是我们能做的最好的方法
Dialogue: 0,0:21:03.03,0:21:08.55,英文,,0,0,0,,And we split those into the 0 and 1.
Dialogue: 0,0:21:03.03,0:21:08.55,中文,,0,0,0,,我们将它们分成 0 和 1
Dialogue: 0,0:21:08.55,0:21:13.39,英文,,0,0,0,,The other three characters, those frequencies are 0.17, 0.16, 0.15.
Dialogue: 0,0:21:08.55,0:21:13.39,中文,,0,0,0,,其他三个字符  频率分别为 0.17、0.16、0.15
Dialogue: 0,0:21:13.39,0:21:25.00,英文,,0,0,0,,How will you split this so that it's as close to 50-50 as possible?
Dialogue: 0,0:21:13.39,0:21:25.00,中文,,0,0,0,,如何将它们尽可能地分成 50-50 的比例？
Dialogue: 0,0:21:25.00,0:21:27.32,英文,,0,0,0,,Any suggestions?
Dialogue: 0,0:21:25.00,0:21:27.32,中文,,0,0,0,,有什么建议吗？
Dialogue: 0,0:21:27.32,0:21:33.83,英文,,0,0,0,,How do you want to split up the last three characters?
Dialogue: 0,0:21:27.32,0:21:33.83,中文,,0,0,0,,你想如何分割最后三个字符？
Dialogue: 0,0:21:33.83,0:21:37.27,英文,,0,0,0,,Yeah?
Dialogue: 0,0:21:33.83,0:21:37.27,中文,,0,0,0,,嗯？
Dialogue: 0,0:21:37.27,0:21:38.01,英文,,0,0,0,,Yeah.
Dialogue: 0,0:21:37.27,0:21:38.01,中文,,0,0,0,,
Dialogue: 0,0:21:38.01,0:21:40.02,英文,,0,0,0,,The first one's alone.
Dialogue: 0,0:21:38.01,0:21:40.02,中文,,0,0,0,,第一个单独
Dialogue: 0,0:21:40.02,0:21:42.18,英文,,0,0,0,,The one and two are together.
Dialogue: 0,0:21:40.02,0:21:42.18,中文,,0,0,0,,这一个和二个在一起
Dialogue: 0,0:21:42.18,0:21:45.30,英文,,0,0,0,,That does split into a 17 versus a 31.
Dialogue: 0,0:21:42.18,0:21:45.30,中文,,0,0,0,,这样就分成 17 比 31
Dialogue: 0,0:21:45.30,0:21:48.80,英文,,0,0,0,,That's still the best we can do.
Dialogue: 0,0:21:45.30,0:21:48.80,中文,,0,0,0,,这是我们能做的最好的了
Dialogue: 0,0:21:48.80,0:21:51.62,英文,,0,0,0,,And then we just recurse, and we continue this way.
Dialogue: 0,0:21:48.80,0:21:51.62,中文,,0,0,0,,然后我们递归  继续这样做
Dialogue: 0,0:21:51.62,0:21:54.26,英文,,0,0,0,,So using this, we're able to get a prefix-free code.
Dialogue: 0,0:21:51.62,0:21:54.26,中文,,0,0,0,,所以使用这个方法  我们可以得到一个无前缀码
Dialogue: 0,0:21:54.26,0:21:57.39,英文,,0,0,0,,If we want to write the top character, then we just use a 00.
Dialogue: 0,0:21:54.26,0:21:57.39,中文,,0,0,0,,如果我们想写第一个字符  就用 00
Dialogue: 0,0:21:57.39,0:21:59.27,英文,,0,0,0,,If we want the second one, that's a 01.
Dialogue: 0,0:21:57.39,0:21:59.27,中文,,0,0,0,,如果我们想要第二个  那就是 01
Dialogue: 0,0:21:59.27,0:22:03.45,英文,,0,0,0,,The third one is a 110 and a 111, respectively.
Dialogue: 0,0:21:59.27,0:22:03.45,中文,,0,0,0,,第三个分别是 110 和 111
Dialogue: 0,0:22:03.45,0:22:07.02,英文,,0,0,0,,This is a valid prefix-free code.
Dialogue: 0,0:22:03.45,0:22:07.02,中文,,0,0,0,,这是一个有效的无前缀码
Dialogue: 0,0:22:07.02,0:22:10.11,英文,,0,0,0,,It's not the best.
Dialogue: 0,0:22:07.02,0:22:10.11,中文,,0,0,0,,它不是最好的
Dialogue: 0,0:22:10.11,0:22:11.37,英文,,0,0,0,,Why?
Dialogue: 0,0:22:10.11,0:22:11.37,中文,,0,0,0,,为什么？
Dialogue: 0,0:22:11.37,0:22:13.80,英文,,0,0,0,,It's hard to say exactly.
Dialogue: 0,0:22:11.37,0:22:13.80,中文,,0,0,0,,这很难说清楚
Dialogue: 0,0:22:13.80,0:22:17.52,英文,,0,0,0,,But as it turns out, it gets covered a bit more in CS170.
Dialogue: 0,0:22:13.80,0:22:17.52,中文,,0,0,0,,但事实证明  CS170课程会更深入地讲解这个问题
Dialogue: 0,0:22:17.52,0:22:24.75,英文,,0,0,0,,If you're interested, you can show that the Shannon Fano code is actually not the perfect code that you can do.
Dialogue: 0,0:22:17.52,0:22:24.75,中文,,0,0,0,,如果你感兴趣  可以证明香农-范诺编码实际上并不是最优编码方式
Dialogue: 0,0:22:24.75,0:22:30.34,英文,,0,0,0,,And there's a better encoding system called Huffman encoding.
Dialogue: 0,0:22:24.75,0:22:30.34,中文,,0,0,0,,还有一种更好的编码系统叫做霍夫曼编码
Dialogue: 0,0:22:30.34,0:22:32.82,英文,,0,0,0,,So here's kind of the Huffman encoding approach.
Dialogue: 0,0:22:30.34,0:22:32.82,中文,,0,0,0,,这是霍夫曼编码的方法
Dialogue: 0,0:22:32.82,0:22:35.54,英文,,0,0,0,,It's a bit hard to explain why.
Dialogue: 0,0:22:32.82,0:22:35.54,中文,,0,0,0,,解释起来有点难
Dialogue: 0,0:22:35.54,0:22:38.34,英文,,0,0,0,,This is the intuitive one that seems really good.
Dialogue: 0,0:22:35.54,0:22:38.34,中文,,0,0,0,,这个直观的编码方式看起来非常好
Dialogue: 0,0:22:38.34,0:22:40.90,英文,,0,0,0,,As it turns out, it's not the best.
Dialogue: 0,0:22:38.34,0:22:40.90,中文,,0,0,0,,但事实证明  它并不是最好的
Dialogue: 0,0:22:40.90,0:22:46.51,英文,,0,0,0,,And showing the actual intuition behind coming up with this one is actually fairly tricky.
Dialogue: 0,0:22:40.90,0:22:46.51,中文,,0,0,0,,而且  展示这个编码背后的直觉实际上相当棘手
Dialogue: 0,0:22:46.51,0:22:51.17,英文,,0,0,0,,So I'll just kind of show what this encoding process is.
Dialogue: 0,0:22:46.51,0:22:51.17,中文,,0,0,0,,所以我只会简单地展示一下这个编码过程
Dialogue: 0,0:22:51.17,0:22:55.35,英文,,0,0,0,,So suppose we have this text file with this particular data set.
Dialogue: 0,0:22:51.17,0:22:55.35,中文,,0,0,0,,假设我们有一个包含特定数据集的文本文件
Dialogue: 0,0:22:55.35,0:22:57.33,英文,,0,0,0,,So what we're going to do
Dialogue: 0,0:22:55.35,0:22:57.33,中文,,0,0,0,,所以我们要做的是
Dialogue: 0,0:22:57.33,0:23:02.11,英文,,0,0,0,,Is we're going to assign a symbol to a node with each of these weights.
Dialogue: 0,0:22:57.33,0:23:02.11,中文,,0,0,0,,将一个符号分配给每个权重的节点
Dialogue: 0,0:23:02.11,0:23:10.08,英文,,0,0,0,,And what we'll do is at every single step, we'll take the two smallest nodes and we'll merge them into a big node with the weight equal to the sum of that.
Dialogue: 0,0:23:02.11,0:23:10.08,中文,,0,0,0,,每一步  我们将取两个最小的节点  并将它们合并成一个大节点  其权重等于这两个节点权重的总和
Dialogue: 0,0:23:10.08,0:23:17.84,英文,,0,0,0,,And we'll keep doing this until everything is part of a tree.
Dialogue: 0,0:23:10.08,0:23:17.84,中文,,0,0,0,,我们将一直这样做  直到所有节点都成为树的一部分
Dialogue: 0,0:23:17.84,0:23:23.68,英文,,0,0,0,,So as an example here, we take the 4 and the circle.
Dialogue: 0,0:23:17.84,0:23:23.68,中文,,0,0,0,,例如  这里我们取4和圆圈
Dialogue: 0,0:23:23.68,0:23:30.20,英文,,0,0,0,,We'll take these two, because those are the smallest, and we'll turn this into a single node with 31.
Dialogue: 0,0:23:23.68,0:23:30.20,中文,,0,0,0,,我们将取这两个  因为它们是最小的  我们将它们变成一个权重为31的单个节点
Dialogue: 0,0:23:30.20,0:23:31.98,英文,,0,0,0,,At this point, what are the next smallest items?
Dialogue: 0,0:23:30.20,0:23:31.98,中文,,0,0,0,,此时  接下来的最小项是什么？
Dialogue: 0,0:23:31.98,0:23:38.76,英文,,0,0,0,,What are the two smallest ones here?
Dialogue: 0,0:23:31.98,0:23:38.76,中文,,0,0,0,,这里哪两个是最小的？
Dialogue: 0,0:23:38.76,0:23:40.37,英文,,0,0,0,,The 2.17s, yep.
Dialogue: 0,0:23:38.76,0:23:40.37,中文,,0,0,0,,是2.17  对
Dialogue: 0,0:23:40.37,0:23:43.39,英文,,0,0,0,,So we combine those to form a block with this.
Dialogue: 0,0:23:40.37,0:23:43.39,中文,,0,0,0,,所以我们将它们合并  形成一个包含它们的块
Dialogue: 0,0:23:43.39,0:23:46.61,英文,,0,0,0,,What are the two smallest now?
Dialogue: 0,0:23:43.39,0:23:46.61,中文,,0,0,0,,现在最小的两个是什么？
Dialogue: 0,0:23:46.61,0:23:48.37,英文,,0,0,0,,0.35 is that smallest?
Dialogue: 0,0:23:46.61,0:23:48.37,中文,,0,0,0,,0.35是最小的吗？
Dialogue: 0,0:23:48.37,0:23:53.91,英文,,0,0,0,,0.31 and?
Dialogue: 0,0:23:48.37,0:23:53.91,中文,,0,0,0,,0.31和？
Dialogue: 0,0:23:53.91,0:23:54.61,英文,,0,0,0,,0.34.
Dialogue: 0,0:23:53.91,0:23:54.61,中文,,0,0,0,,0.34
Dialogue: 0,0:23:54.61,0:23:58.17,英文,,0,0,0,,So we'll combine those two to form a new node of 0.65 size.
Dialogue: 0,0:23:54.61,0:23:58.17,中文,,0,0,0,,所以我们将这两个组合起来形成一个大小为0.65的新节点
Dialogue: 0,0:23:58.17,0:24:02.31,英文,,0,0,0,,And then what?
Dialogue: 0,0:23:58.17,0:24:02.31,中文,,0,0,0,,然后呢？
Dialogue: 0,0:24:02.31,0:24:02.95,英文,,0,0,0,,Yep.
Dialogue: 0,0:24:02.31,0:24:02.95,中文,,0,0,0,,
Dialogue: 0,0:24:02.95,0:24:08.93,英文,,0,0,0,,And then we just connect the last two to get this.
Dialogue: 0,0:24:02.95,0:24:08.93,中文,,0,0,0,,然后我们只需要连接最后两个得到这个
Dialogue: 0,0:24:08.93,0:24:27.04,英文,,0,0,0,,So how many bits per symbol are we going to need to compress this if we follow this particular Huffman encoding?
Dialogue: 0,0:24:08.93,0:24:27.04,中文,,0,0,0,,如果我们遵循这个特定的霍夫曼编码  我们需要多少位/符号来压缩这个？
Dialogue: 0,0:24:27.04,0:24:32.24,英文,,0,0,0,,How many people say one, or A, answer choice A?
Dialogue: 0,0:24:27.04,0:24:32.24,中文,,0,0,0,,有多少人说一  或者 A   选择 A ？
Dialogue: 0,0:24:32.24,0:24:42.41,英文,,0,0,0,,It takes, on average, 2.6 bits per symbol, because the average of 1, 4, 4, 4, and 4 is 2.6.
Dialogue: 0,0:24:32.24,0:24:42.41,中文,,0,0,0,,平均每个符号需要2.6位  因为1、4、4、4和4的平均值是2.6
Dialogue: 0,0:24:42.41,0:24:43.85,英文,,0,0,0,,How many people say 2.3 bits?
Dialogue: 0,0:24:42.41,0:24:43.85,中文,,0,0,0,,有多少人说2.3位？
Dialogue: 0,0:24:43.85,0:24:47.60,英文,,0,0,0,,A few people.
Dialogue: 0,0:24:43.85,0:24:47.60,中文,,0,0,0,,一些人
Dialogue: 0,0:24:47.60,0:24:54.52,英文,,0,0,0,,How many people think there's not enough information to determine this?
Dialogue: 0,0:24:47.60,0:24:54.52,中文,,0,0,0,,有多少人认为没有足够的信息来确定这个？
Dialogue: 0,0:24:54.52,0:25:02.08,英文,,0,0,0,,All right, so it seems like there were a few answers for B and no answers for A and C. That's actually right.
Dialogue: 0,0:24:54.52,0:25:02.08,中文,,0,0,0,,好的  所以看起来B有几个答案   a 和C没有答案  这实际上是对的
Dialogue: 0,0:25:02.08,0:25:13.31,英文,,0,0,0,,Because every single character shows up with these frequencies, the higher length ones show up less frequently than normal, and the lower frequency ones show up more often than normal.
Dialogue: 0,0:25:02.08,0:25:13.31,中文,,0,0,0,,因为每个字符都以这些频率出现  长度较高的字符出现的频率比正常情况低  而频率较低的字符出现的频率比正常情况高
Dialogue: 0,0:25:13.31,0:25:25.77,英文,,0,0,0,,And if we compress a file with this character distribution, you're going to end up with 2.3 bits per symbol on average.
Dialogue: 0,0:25:13.31,0:25:25.77,中文,,0,0,0,,如果我们用这个字符分布压缩一个文件  你最终会得到平均每个符号2.3位
Dialogue: 0,0:25:25.77,0:25:32.69,英文,,0,0,0,,As an example here, if we had 1,000 characters in this pattern, how many total bits are going to need to encode if we use 32-bit Unicode?
Dialogue: 0,0:25:25.77,0:25:32.69,中文,,0,0,0,,作为一个例子  如果我们有1000个字符按照这种模式排列  如果我们使用32位Unicode  总共需要多少位来编码？
Dialogue: 0,0:25:32.69,0:25:46.34,英文,,0,0,0,,So 32 bits per character.
Dialogue: 0,0:25:32.69,0:25:46.34,中文,,0,0,0,,所以每个字符32位
Dialogue: 0,0:25:46.34,0:25:48.68,英文,,0,0,0,,Any answers?
Dialogue: 0,0:25:46.34,0:25:48.68,中文,,0,0,0,,有答案吗？
Dialogue: 0,0:25:48.68,0:25:50.67,英文,,0,0,0,,We have 1,000 total characters.
Dialogue: 0,0:25:48.68,0:25:50.67,中文,,0,0,0,,我们总共有 1,000 个字符
Dialogue: 0,0:25:50.67,0:25:56.19,英文,,0,0,0,,Each character is going to be 32 bits with the Unicode.
Dialogue: 0,0:25:50.67,0:25:56.19,中文,,0,0,0,,每个字符用 Unicode 表示都是 32 位
Dialogue: 0,0:25:56.19,0:25:58.39,英文,,0,0,0,,Yeah, 32,000 bits.
Dialogue: 0,0:25:56.19,0:25:58.39,中文,,0,0,0,,嗯  32,000 位
Dialogue: 0,0:25:58.39,0:26:03.93,英文,,0,0,0,,If we use our Huffman code, though, we can get it down to 2.3 bits per character.
Dialogue: 0,0:25:58.39,0:26:03.93,中文,,0,0,0,,但是  如果我们使用霍夫曼编码  我们可以将其压缩到每个字符 2.3 位
Dialogue: 0,0:26:03.93,0:26:05.25,英文,,0,0,0,,So how many total bits are we using there?
Dialogue: 0,0:26:03.93,0:26:05.25,中文,,0,0,0,,那我们一共用了多少位呢？
Dialogue: 0,0:26:05.25,0:26:14.94,英文,,0,0,0,,2.3 times 1,000, so 2,300.
Dialogue: 0,0:26:05.25,0:26:14.94,中文,,0,0,0,,2.3 乘以 1,000  所以是 2,300
Dialogue: 0,0:26:14.94,0:26:15.12,英文,,0,0,0,,Yep.
Dialogue: 0,0:26:14.94,0:26:15.12,中文,,0,0,0,,
Dialogue: 0,0:26:15.12,0:26:22.78,英文,,0,0,0,,So this code ends up being 14 times as efficient.
Dialogue: 0,0:26:15.12,0:26:22.78,中文,,0,0,0,,所以这个代码最终效率提高了 14 倍
Dialogue: 0,0:26:22.78,0:26:24.24,英文,,0,0,0,,As our Unicode.
Dialogue: 0,0:26:22.78,0:26:24.24,中文,,0,0,0,,相对于我们的 Unicode 编码
Dialogue: 0,0:26:24.24,0:26:35.07,英文,,0,0,0,,The downside is it can only encode strings with these particular five symbols, and it's only really efficient for this particular frequency pattern.
Dialogue: 0,0:26:24.24,0:26:35.07,中文,,0,0,0,,缺点是它只能对包含这五个特定符号的字符串进行编码  并且它只对这种特定的频率模式真正有效
Dialogue: 0,0:26:35.07,0:26:38.05,英文,,0,0,0,,Yeah.
Dialogue: 0,0:26:35.07,0:26:38.05,中文,,0,0,0,,
Dialogue: 0,0:26:38.05,0:26:53.01,英文,,0,0,0,,So if you look at the Shannon Fano code, you'll actually see that it will average 2.31 bits per symbol, whereas Huffman encoding only averages 2.3 bits per symbol.
Dialogue: 0,0:26:38.05,0:26:53.01,中文,,0,0,0,,所以如果你看一下香农-范诺编码  你会发现它平均每个符号 2.31 位  而霍夫曼编码平均每个符号只有 2.3 位
Dialogue: 0,0:26:53.01,0:26:56.31,英文,,0,0,0,,The Shannon Fano code that we discussed earlier.
Dialogue: 0,0:26:53.01,0:26:56.31,中文,,0,0,0,,我们之前讨论过的香农-范诺编码
Dialogue: 0,0:26:56.31,0:27:02.85,英文,,0,0,0,,It ends up being 2.31 bits per symbol, whereas the Huffman code is only 2.3 bits per symbol.
Dialogue: 0,0:26:56.31,0:27:02.85,中文,,0,0,0,,它最终是每个符号 2.31 位  而霍夫曼编码每个符号只有 2.3 位
Dialogue: 0,0:27:02.85,0:27:11.47,英文,,0,0,0,,As it turns out, we can show that, in general, the Shannon code is always going to be slightly worse than the Huffman code, unless they're the exact same code.
Dialogue: 0,0:27:02.85,0:27:11.47,中文,,0,0,0,,事实证明  一般来说  香农编码总是会比霍夫曼编码差一点  除非它们是完全相同的代码
Dialogue: 0,0:27:11.47,0:27:20.78,英文,,0,0,0,,Kind of the reasoning why is because the Shannon fan-out code actually optimizes the total number of bits if we take one letter of every single one,
Dialogue: 0,0:27:11.47,0:27:20.78,中文,,0,0,0,,原因是香农-范诺编码实际上优化了如果我们取每个符号的一个字母时的总位数
Dialogue: 0,0:27:20.78,0:27:27.78,英文,,0,0,0,,whereas the Huffman code actually takes into account the probability that we get every single character.
Dialogue: 0,0:27:20.78,0:27:27.78,中文,,0,0,0,,而霍夫曼编码实际上考虑了我们得到每个字符的概率
Dialogue: 0,0:27:27.78,0:27:36.32,英文,,0,0,0,,Now, if you look at the actual Shannon entropy of the data set, then you'll see that it's actually 2.233 bits on average.
Dialogue: 0,0:27:27.78,0:27:36.32,中文,,0,0,0,,现在  如果你看一下数据集的实际香农熵  你会发现它平均实际上是 2.233 位
Dialogue: 0,0:27:36.32,0:27:43.08,英文,,0,0,0,,So in theory, the Shannon entropy says that we can compress this down to 2.233 bits.
Dialogue: 0,0:27:36.32,0:27:43.08,中文,,0,0,0,,所以理论上  香农熵说我们可以将其压缩到 2.233 位
Dialogue: 0,0:27:43.08,0:27:52.87,英文,,0,0,0,,In practice, the Huffman code gets us down to 2.3 bits, which is kind of the best we can do.
Dialogue: 0,0:27:43.08,0:27:52.87,中文,,0,0,0,,在实践中  霍夫曼编码将我们压缩到 2.3 位  这已经是我们能做到的最好的了
Dialogue: 0,0:27:52.87,0:27:56.53,英文,,0,0,0,,So how do we actually implement a Huffman code?
Dialogue: 0,0:27:52.87,0:27:56.53,中文,,0,0,0,,那么我们如何实际实现霍夫曼编码呢？
Dialogue: 0,0:27:56.53,0:28:06.94,英文,,0,0,0,,So what data set are we going to be used to encode this, or to run the Huffman encoding algorithm?
Dialogue: 0,0:27:56.53,0:28:06.94,中文,,0,0,0,,那么我们将使用什么数据集来编码这个  或者运行霍夫曼编码算法？
Dialogue: 0,0:28:06.94,0:28:16.02,英文,,0,0,0,,And recall that what we did was we took a bunch of nodes with the individual weights of every single one, and we combined the smallest two repeatedly.
Dialogue: 0,0:28:06.94,0:28:16.02,中文,,0,0,0,,回想一下  我们所做的是  我们获取了一堆节点  每个节点都有各自的权重  然后我们重复地将最小的两个节点组合在一起
Dialogue: 0,0:28:16.02,0:28:23.63,英文,,0,0,0,,What data structure can we use for this?
Dialogue: 0,0:28:16.02,0:28:23.63,中文,,0,0,0,,我们可以使用什么数据结构来实现这个？
Dialogue: 0,0:28:23.63,0:28:28.88,英文,,0,0,0,,And feel free to discuss with your neighbor on this for a bit.
Dialogue: 0,0:28:23.63,0:28:28.88,中文,,0,0,0,,请随意与你的邻居讨论一下这个问题
Dialogue: 0,0:28:28.88,0:28:36.46,英文,,0,0,0,,I'll give a minute.
Dialogue: 0,0:28:28.88,0:28:36.46,中文,,0,0,0,,我给一分钟时间
Dialogue: 0,0:28:36.46,0:28:57.28,英文,,0,0,0,,It lit up.
Dialogue: 0,0:28:36.46,0:28:57.28,中文,,0,0,0,,灯亮了
Dialogue: 0,0:28:57.28,0:29:07.20,英文,,0,0,0,,All right, so what data structure can we use to implement this Huffman encoding system,
Dialogue: 0,0:28:57.28,0:29:05.20,中文,,0,0,0,,好的  那么我们可以使用什么数据结构来实现这个霍夫曼编码系统
Dialogue: 0,0:29:05.20,0:29:12.20,中文,,0,0,0,,在这个系统中  我们取最小的两个节点  然后将它们组合起来？
Dialogue: 0,0:29:07.20,0:29:12.20,英文,,0,0,0,,where we take the smallest two nodes and then we combine it?
Dialogue: 0,0:29:12.20,0:29:26.87,英文,,0,0,0,,How would we run the algorithm itself?
Dialogue: 0,0:29:12.20,0:29:26.87,中文,,0,0,0,,我们将如何运行算法本身？
Dialogue: 0,0:29:26.87,0:29:44.93,英文,,0,0,0,,Well, In order to actually retrieve the individual things, then chances are the easiest approach would probably be to save the resulting hash encoding as an array of bit sequences, and then use the character as an index.
Dialogue: 0,0:29:26.87,0:29:44.93,中文,,0,0,0,, 为了实际检索单个事物  最简单的方法可能是将生成的哈希编码保存为一个比特序列数组  然后使用字符作为索引
Dialogue: 0,0:29:44.93,0:29:47.01,英文,,0,0,0,,Now, you could use it as a HashMap.
Dialogue: 0,0:29:44.93,0:29:47.01,中文,,0,0,0,,现在  你可以把它作为一个哈希表来使用
Dialogue: 0,0:29:47.01,0:29:48.95,英文,,0,0,0,,That is another option.
Dialogue: 0,0:29:47.01,0:29:48.95,中文,,0,0,0,,这是另一种选择
Dialogue: 0,0:29:48.95,0:29:54.93,英文,,0,0,0,,But generally speaking, if our alphabet is small, then it's cheaper to just use a regular array.
Dialogue: 0,0:29:48.95,0:29:54.93,中文,,0,0,0,,但一般来说  如果我们的字母表很小  那么使用常规数组更便宜
Dialogue: 0,0:29:54.93,0:29:57.33,英文,,0,0,0,,The HashMap, it takes a while to do hashing and everything.
Dialogue: 0,0:29:54.93,0:29:57.33,中文,,0,0,0,,哈希表  进行哈希等操作需要一段时间
Dialogue: 0,0:29:57.33,0:30:01.76,英文,,0,0,0,,And there's a huge overhead, a huge factor overhead.
Dialogue: 0,0:29:57.33,0:30:01.76,中文,,0,0,0,,而且有一个巨大的开销  一个巨大的因素开销
Dialogue: 0,0:30:01.76,0:30:11.90,英文,,0,0,0,,So at some point, it's just useful to just use an array directly.
Dialogue: 0,0:30:01.76,0:30:11.90,中文,,0,0,0,,所以在某些情况下  直接使用数组是有用的
Dialogue: 0,0:30:11.90,0:30:14.92,英文,,0,0,0,,Now, when we want to decode.
Dialogue: 0,0:30:11.90,0:30:14.92,中文,,0,0,0,,现在  当我们想要解码的时候
Dialogue: 0,0:30:14.92,0:30:25.43,英文,,0,0,0,,When we want to compute this, actually, the smallest thing we can generally use is a heap, because the heap gets us the way to combine things one at a time.
Dialogue: 0,0:30:14.92,0:30:25.43,中文,,0,0,0,,当我们想要计算这个的时候  实际上  我们通常可以使用最小的东西是一个堆  因为堆可以让我们一次组合一个东西
Dialogue: 0,0:30:25.43,0:30:28.11,英文,,0,0,0,,You take the two minimum things, you combine them into one.
Dialogue: 0,0:30:25.43,0:30:28.11,中文,,0,0,0,,你取两个最小的东西  把它们组合成一个
Dialogue: 0,0:30:28.11,0:30:35.99,英文,,0,0,0,,To find the minimum things, you can put them in a heap, take items out, and then put them back in repeatedly.
Dialogue: 0,0:30:28.11,0:30:35.99,中文,,0,0,0,,要找到最小的东西  你可以把它们放在一个堆里  取出物品  然后重复放回去
Dialogue: 0,0:30:35.99,0:30:38.99,英文,,0,0,0,,Now for decoding.
Dialogue: 0,0:30:35.99,0:30:38.99,中文,,0,0,0,,现在开始解码
Dialogue: 0,0:30:38.99,0:30:44.21,英文,,0,0,0,,What we can do is we can use this longest matching prefix object.
Dialogue: 0,0:30:38.99,0:30:44.21,中文,,0,0,0,,我们可以利用这个最长匹配前缀对象
Dialogue: 0,0:30:44.21,0:30:46.51,英文,,0,0,0,,And the easiest one we can do is a try.
Dialogue: 0,0:30:44.21,0:30:46.51,中文,,0,0,0,,最简单的方法是尝试
Dialogue: 0,0:30:46.51,0:30:51.73,英文,,0,0,0,,A try lets us find where the valid letters are.
Dialogue: 0,0:30:46.51,0:30:51.73,中文,,0,0,0,,尝试可以帮助我们找到有效字母的位置
Dialogue: 0,0:30:51.73,0:31:01.60,英文,,0,0,0,,At this point, it's kind of a binary tree as well, because there's only two possible characters in our data set, 0 and 1.
Dialogue: 0,0:30:51.73,0:31:01.60,中文,,0,0,0,,此时  它也像一颗二叉树  因为我们的数据集中只有两个可能的字符  0 和 1
Dialogue: 0,0:31:01.60,0:31:09.09,英文,,0,0,0,,But it's still overall a try, because we define every single leaf as a valid letter.
Dialogue: 0,0:31:01.60,0:31:09.09,中文,,0,0,0,,但它总体上仍然是一个尝试  因为我们将每个叶子定义为一个有效的字母
Dialogue: 0,0:31:09.09,0:31:19.11,英文,,0,0,0,,So using a tribe, we can see that at every single step, we can find which letter corresponds to which thing.
Dialogue: 0,0:31:09.09,0:31:19.11,中文,,0,0,0,,所以使用尝试  我们可以看到在每一步  我们都可以找到哪个字母对应哪个东西
Dialogue: 0,0:31:19.11,0:31:23.24,英文,,0,0,0,,Now, in practice, we have two different ways we could use Huffman encoding.
Dialogue: 0,0:31:19.11,0:31:23.24,中文,,0,0,0,,现在  在实践中  我们有两种不同的方法可以使用霍夫曼编码
Dialogue: 0,0:31:23.24,0:31:30.91,英文,,0,0,0,,One approach is for every single input type that we could possibly have, we just look at a bunch of these choices,
Dialogue: 0,0:31:23.24,0:31:30.91,中文,,0,0,0,,一种方法是  对于每一种可能的输入类型  我们只需查看一堆这些选择
Dialogue: 0,0:31:30.91,0:31:37.91,英文,,0,0,0,,and then we create a standardized Huffman code for every single type that everyone's going to use in the future.
Dialogue: 0,0:31:30.91,0:31:37.91,中文,,0,0,0,,然后为每一种类型创建一个标准化的霍夫曼编码  供大家将来使用
Dialogue: 0,0:31:37.91,0:31:48.88,英文,,0,0,0,,The other option is that for every single input file we make, we're going to create a unique code just for that file, and we're going to send that code along with the compressed file.
Dialogue: 0,0:31:37.91,0:31:48.88,中文,,0,0,0,,另一种选择是  对于我们制作的每个输入文件  我们将为该文件创建一个唯一的代码  并将该代码与压缩文件一起发送
Dialogue: 0,0:31:48.88,0:31:50.04,英文,,0,0,0,,So which one's better?
Dialogue: 0,0:31:48.88,0:31:50.04,中文,,0,0,0,,那么哪个更好呢？
Dialogue: 0,0:31:50.04,0:31:50.74,英文,,0,0,0,,Which one's worse?
Dialogue: 0,0:31:50.04,0:31:50.74,中文,,0,0,0,,哪个更糟糕呢？
Dialogue: 0,0:31:50.74,0:32:07.07,英文,,0,0,0,,Are there any advantages or disadvantages you can see with each of these options?
Dialogue: 0,0:31:50.74,0:32:07.07,中文,,0,0,0,,你能看到每种选择有哪些优缺点吗？
Dialogue: 0,0:32:07.07,0:32:12.09,英文,,0,0,0,,Well, first of all, how many people think that number one is a better approach?
Dialogue: 0,0:32:07.07,0:32:12.09,中文,,0,0,0,,首先  有多少人认为第一种方法更好？
Dialogue: 0,0:32:12.09,0:32:22.34,英文,,0,0,0,,We should look through every single possible type of data that exists and make a particular Huffman code for every single one of these.
Dialogue: 0,0:32:12.09,0:32:22.34,中文,,0,0,0,,我们应该查看每一种可能存在的数据类型  并为每一种数据类型创建一个特定的霍夫曼编码
Dialogue: 0,0:32:22.34,0:32:26.80,英文,,0,0,0,,How many people think it's better to make the code for every single individual file?
Dialogue: 0,0:32:22.34,0:32:26.80,中文,,0,0,0,,有多少人认为为每个单独的文件创建代码更好？
Dialogue: 0,0:32:26.80,0:32:29.94,英文,,0,0,0,,A few people.
Dialogue: 0,0:32:26.80,0:32:29.94,中文,,0,0,0,,几个人
Dialogue: 0,0:32:29.94,0:32:38.42,英文,,0,0,0,,What would be the advantage to doing that, though?
Dialogue: 0,0:32:29.94,0:32:38.42,中文,,0,0,0,,这样做有什么好处呢？
Dialogue: 0,0:32:38.42,0:32:52.15,英文,,0,0,0,,the first one takes a lot of time and would be inefficient well yes but the point is you can do this uh once and never do it again so like you can imagine that
Dialogue: 0,0:32:38.42,0:32:52.15,中文,,0,0,0,,第一个方法花费很多时间且效率低下  是的  但关键是你可以这样做一次  然后永远不用再做了
Dialogue: 0,0:32:52.15,0:33:06.15,英文,,0,0,0,,in the 1960s someone has uh done this and no one ever needs to do that again okay so any other potential advantages disadvantages
Dialogue: 0,0:32:52.15,0:33:06.15,中文,,0,0,0,,比如  你可以想象在1960年代有人这样做了  而再也没有人需要再做一次了  那么  除此之外还有其他潜在的优缺点吗？
Dialogue: 0,0:33:06.15,0:33:13.37,英文,,0,0,0,,Well, personally, what I would think about is that approach one generally is going to end up resulting in some suboptimal encoding.
Dialogue: 0,0:33:06.15,0:33:13.37,中文,,0,0,0,,嗯  就我个人而言  我认为方法一通常会导致一些次优编码
Dialogue: 0,0:33:13.37,0:33:23.02,英文,,0,0,0,,If you have a system, if you have one that's like tailor-made for your particular data set, then you're going to have a better encoding system.
Dialogue: 0,0:33:13.37,0:33:23.02,中文,,0,0,0,,如果你有一个系统  一个为你特定数据集量身定制的系统  那么你就会有一个更好的编码系统
Dialogue: 0,0:33:23.02,0:33:30.04,英文,,0,0,0,,Like, standard English is useful for most particular Most particularly like texts.
Dialogue: 0,0:33:23.02,0:33:30.04,中文,,0,0,0,,比如  标准英语对大多数特定文本很有用,  特别是像文本之类的
Dialogue: 0,0:33:30.04,0:33:40.88,英文,,0,0,0,,But if you're talking about an essay on zoos and Qatar, then generally speaking, you're going to have quite a different encoding level as standard English.
Dialogue: 0,0:33:30.04,0:33:40.88,中文,,0,0,0,,但如果你说的是一篇关于动物园和卡塔尔的论文  那么一般来说  你的编码水平会与标准英语大不相同
Dialogue: 0,0:33:40.88,0:33:47.15,英文,,0,0,0,,Meanwhile, approach two is going to need you to compute the entire code word table every single time.
Dialogue: 0,0:33:40.88,0:33:47.15,中文,,0,0,0,,同时  方法二需要你在每次计算时都要计算整个码字表
Dialogue: 0,0:33:47.15,0:33:51.85,英文,,0,0,0,,And you're going to need to include that within your compressed bit string.
Dialogue: 0,0:33:47.15,0:33:51.85,中文,,0,0,0,,而且你需要把它包含在你的压缩位串中
Dialogue: 0,0:33:51.85,0:33:58.58,英文,,0,0,0,,So it's going to be a bit longer to run, and it's going to be a bit more data you need to send.
Dialogue: 0,0:33:51.85,0:33:58.58,中文,,0,0,0,,所以运行时间会更长  你需要发送的数据也会更多
Dialogue: 0,0:33:58.58,0:34:05.48,英文,,0,0,0,,On the other hand, generally speaking, the cost of including that code word, generally speaking, it's actually not that much.
Dialogue: 0,0:33:58.58,0:34:05.48,中文,,0,0,0,,另一方面  一般来说  包含这个码字的成本  一般来说  实际上并没有那么多
Dialogue: 0,0:34:05.48,0:34:13.69,英文,,0,0,0,,It scales with the number of different characters you have, whereas the suboptimal encoding, the extra overhead from that scales with the size of the text.
Dialogue: 0,0:34:05.48,0:34:13.69,中文,,0,0,0,,它与你拥有的不同字符的数量成比例  而次优编码  它的额外开销与文本的大小成比例
Dialogue: 0,0:34:13.69,0:34:18.55,英文,,0,0,0,,So the larger the text file becomes, the more useful number two is.
Dialogue: 0,0:34:13.69,0:34:18.55,中文,,0,0,0,,所以文本文件越大  方法二就越有用
Dialogue: 0,0:34:18.55,0:34:24.27,英文,,0,0,0,,And we don't really care about the small files, because we don't really need to compress small files.
Dialogue: 0,0:34:18.55,0:34:24.27,中文,,0,0,0,,我们并不真正在乎小文件  因为我们并不真的需要压缩小文件
Dialogue: 0,0:34:24.27,0:34:29.74,英文,,0,0,0,,So generally speaking, Philosophy 2 ends up getting used in the real world.
Dialogue: 0,0:34:24.27,0:34:29.74,中文,,0,0,0,,所以一般来说  方法二最终会在现实世界中得到应用
Dialogue: 0,0:34:29.74,0:34:34.60,英文,,0,0,0,,So here's kind of how the Huffman compression is going to end up working in general.
Dialogue: 0,0:34:29.74,0:34:34.60,中文,,0,0,0,,所以这就是哈夫曼压缩的工作原理
Dialogue: 0,0:34:34.60,0:34:36.22,英文,,0,0,0,,You count some frequencies.
Dialogue: 0,0:34:34.60,0:34:36.22,中文,,0,0,0,,你计算一些频率
Dialogue: 0,0:34:36.22,0:34:39.10,英文,,0,0,0,,You build the encoding array.
Dialogue: 0,0:34:36.22,0:34:39.10,中文,,0,0,0,,你构建编码数组
Dialogue: 0,0:34:39.10,0:34:41.44,英文,,0,0,0,,You write the decoding trie to the output.
Dialogue: 0,0:34:39.10,0:34:41.44,中文,,0,0,0,,你将解码Trie写入输出
Dialogue: 0,0:34:41.44,0:34:48.31,英文,,0,0,0,,And then you write the code word for each symbol to the output.
Dialogue: 0,0:34:41.44,0:34:48.31,中文,,0,0,0,,然后你将每个符号的码字写入输出
Dialogue: 0,0:34:48.31,0:34:56.19,英文,,0,0,0,,Other than that, you just need a bit more bits to actually define how the output decoding trie is and where the code words start.
Dialogue: 0,0:34:48.31,0:34:56.19,中文,,0,0,0,,除此之外  你还需要更多的位来实际定义输出解码Trie是什么以及码字从哪里开始
Dialogue: 0,0:34:56.19,0:35:03.83,英文,,0,0,0,,But other than that, this is largely A simple way to set this up.
Dialogue: 0,0:34:56.19,0:35:03.83,中文,,0,0,0,,但除此之外  这在很大程度上是一种简单的设置方法
Dialogue: 0,0:35:03.83,0:35:09.98,英文,,0,0,0,,Now when you want to decompress something, what we do is we'll read in the decoding trie and interpret that,
Dialogue: 0,0:35:03.83,0:35:09.98,中文,,0,0,0,,当我们要解压缩某些内容时  我们会读取解码trie并对其进行解释
Dialogue: 0,0:35:09.98,0:35:16.98,英文,,0,0,0,,figure out what the original trie was, and then we're going to just use these codeword bits to walk down the tree one symbol at a time.
Dialogue: 0,0:35:09.98,0:35:16.98,中文,,0,0,0,,弄清楚原始trie是什么  然后我们将使用这些码字位一次一个符号地遍历树
Dialogue: 0,0:35:16.98,0:35:25.50,英文,,0,0,0,,Now, it's important to note that symbols are really just bit sequences, like this character here, the Chinese character 3, that has this particular Unicode pattern, 010011100001001.
Dialogue: 0,0:35:16.98,0:35:25.50,中文,,0,0,0,,现在  重要的是要注意符号实际上只是比特序列  就像这里的字符  汉字3  它具有特定的Unicode模式  010011100001001
Dialogue: 0,0:35:25.50,0:35:39.48,英文,,0,0,0,,So outputting 3, outputting that character, actually means outputting those 32 bits.
Dialogue: 0,0:35:25.50,0:35:39.48,中文,,0,0,0,,所以输出3  输出那个字符  实际上意味着输出那32个位
Dialogue: 0,0:35:39.48,0:35:49.81,英文,,0,0,0,,So given this file, x.txt, we're going to try to compress it by taking every single symbol, count how many there are, and assign it a code based on that.
Dialogue: 0,0:35:39.48,0:35:49.81,中文,,0,0,0,,所以给定这个文件x.txt  我们将尝试通过获取每个符号  计算有多少个符号  并根据它分配一个代码来压缩它
Dialogue: 0,0:35:49.81,0:36:00.41,英文,,0,0,0,,And then we'll just write the codes down and a way to convert from the codes back to the original data later.
Dialogue: 0,0:35:49.81,0:36:00.41,中文,,0,0,0,,然后  我们将只写下代码  以及一种稍后将代码转换回原始数据的方法
Dialogue: 0,0:36:00.41,0:36:03.07,英文,,0,0,0,,Now, there are other approaches for compression.
Dialogue: 0,0:36:00.41,0:36:03.07,中文,,0,0,0,,现在  还有其他压缩方法
Dialogue: 0,0:36:03.07,0:36:10.77,英文,,0,0,0,,For example, there's this thing called rung length encoding, where you replace each symbol by itself concatenated how many times.
Dialogue: 0,0:36:03.07,0:36:10.77,中文,,0,0,0,,例如  有一种叫做游程编码的东西  它用自身连接的次数替换每个符号
Dialogue: 0,0:36:10.77,0:36:21.02,英文,,0,0,0,,So for example, if you have a bunch of x's and a bunch of y's, then you might write this as x10, y4, x5 to represent 10 x's, then four y's, then five x's.
Dialogue: 0,0:36:10.77,0:36:21.02,中文,,0,0,0,,例如  如果你有一堆X和一堆Y  那么你可能会写成X10Y4X5来表示10个X  然后是4个Y  然后是5个X
Dialogue: 0,0:36:21.02,0:36:30.09,英文,,0,0,0,,LZW is actually a really complicated system that searches for common repeated patterns in the input.
Dialogue: 0,0:36:21.02,0:36:30.09,中文,,0,0,0,,LZW实际上是一个非常复杂的系统  它搜索输入中常见的重复模式
Dialogue: 0,0:36:30.09,0:36:35.65,英文,,0,0,0,,Both of those tend to be used in actual zip compression in addition to Huffman encoding.
Dialogue: 0,0:36:30.09,0:36:35.65,中文,,0,0,0,,除了霍夫曼编码之外  这两种方法都倾向于在实际的zip压缩中使用
Dialogue: 0,0:36:35.65,0:36:51.10,英文,,0,0,0,,And the general idea here is that you're trying to exploit these redundancies and the order that already exists in most meaningful data to simplify and shorten the strings that actually have data.
Dialogue: 0,0:36:35.65,0:36:51.10,中文,,0,0,0,,这里的一般想法是  你试图利用这些冗余和大多数有意义数据中已经存在的顺序来简化和缩短实际拥有数据的字符串
Dialogue: 0,0:36:51.10,0:36:58.81,英文,,0,0,0,,If you don't have any existing redundancies, then the size of the file might actually grow larger than the original size.
Dialogue: 0,0:36:51.10,0:36:58.81,中文,,0,0,0,,如果没有现有的冗余  那么文件的大小实际上可能会比原始大小更大
Dialogue: 0,0:36:58.81,0:37:03.01,英文,,0,0,0,,So a compression algorithm doesn't always make something smaller.
Dialogue: 0,0:36:58.81,0:37:03.01,中文,,0,0,0,,因此  压缩算法并不总是使某些东西变小
Dialogue: 0,0:37:03.01,0:37:10.22,英文,,0,0,0,,There's a chance that it actually makes something bigger if it's sufficiently high entropy.
Dialogue: 0,0:37:03.01,0:37:10.22,中文,,0,0,0,,如果它的熵足够高  它实际上有可能使某些东西变大
Dialogue: 0,0:37:10.22,0:37:14.32,英文,,0,0,0,,So we could try to compare the compression algorithms in different ways.
Dialogue: 0,0:37:10.22,0:37:14.32,中文,,0,0,0,,所以我们可以尝试以不同的方式比较压缩算法
Dialogue: 0,0:37:14.32,0:37:23.52,英文,,0,0,0,,To do this, we're going to need to refine how we Define the value of a compression algorithm.
Dialogue: 0,0:37:14.32,0:37:23.52,中文,,0,0,0,,为此  我们需要改进我们 定义压缩算法的价值
Dialogue: 0,0:37:23.52,0:37:27.14,英文,,0,0,0,,So let's kind of start off with just a quick math problem.
Dialogue: 0,0:37:23.52,0:37:27.14,中文,,0,0,0,,让我们先从一个简单的数学问题开始
Dialogue: 0,0:37:27.14,0:37:38.26,英文,,0,0,0,,Let's say that I have stated, I am an algorithm designer, and I've created this super zip algorithm that can compress any bit string you send me, no matter what the string is.
Dialogue: 0,0:37:27.14,0:37:38.26,中文,,0,0,0,,假设我声明  我是一个算法设计者  我创建了这个超级压缩算法  它可以压缩你发送给我的任何位串  无论字符串是什么
Dialogue: 0,0:37:38.26,0:37:40.68,英文,,0,0,0,,It'll compress it by 50%, guaranteed.
Dialogue: 0,0:37:38.26,0:37:40.68,中文,,0,0,0,,它保证压缩50%
Dialogue: 0,0:37:40.68,0:37:43.38,英文,,0,0,0,,You give me a 10-bit string, I give you a 5-bit string.
Dialogue: 0,0:37:40.68,0:37:43.38,中文,,0,0,0,,你给我一个10位字符串  我还你一个5位字符串
Dialogue: 0,0:37:43.38,0:37:47.83,英文,,0,0,0,,You give me a 20-bit string, I give you a 10-bit string.
Dialogue: 0,0:37:43.38,0:37:47.83,中文,,0,0,0,,你给我一个20位字符串  我还你一个10位字符串
Dialogue: 0,0:37:47.83,0:37:50.39,英文,,0,0,0,,Do you believe me?
Dialogue: 0,0:37:47.83,0:37:50.39,中文,,0,0,0,,你信吗？
Dialogue: 0,0:37:50.39,0:37:53.16,英文,,0,0,0,,No, why?
Dialogue: 0,0:37:50.39,0:37:53.16,中文,,0,0,0,,不信  为啥？
Dialogue: 0,0:37:53.16,0:38:04.48,英文,,0,0,0,,Prove that my algorithm doesn't exist.
Dialogue: 0,0:37:53.16,0:38:04.48,中文,,0,0,0,,证明我的算法不存在
Dialogue: 0,0:38:04.48,0:38:11.40,英文,,0,0,0,,Yeah, there's more 10-bit strings than 5-bit strings, so you can't assign a unique 5-bit string to every single 10-bit string.
Dialogue: 0,0:38:04.48,0:38:11.40,中文,,0,0,0,,因为10位字符串的数量比5位字符串多  所以你不可能给每个10位字符串都分配一个唯一的5位字符串
Dialogue: 0,0:38:11.40,0:38:18.37,英文,,0,0,0,,If we were trying to compress this, then what we're going to end up getting is an impossibly small string.
Dialogue: 0,0:38:11.40,0:38:18.37,中文,,0,0,0,,如果我们试图压缩它  那么最终我们会得到一个不可能小的字符串
Dialogue: 0,0:38:18.37,0:38:22.19,英文,,0,0,0,,We won't be able to get unique strings for every single possible 10-bit string.
Dialogue: 0,0:38:18.37,0:38:22.19,中文,,0,0,0,,我们不可能为每个可能的10位字符串都得到唯一的字符串
Dialogue: 0,0:38:22.19,0:38:29.72,英文,,0,0,0,,Another argument that you can make is that you can imagine that if this was true, then I can just compress the compressed file over and over.
Dialogue: 0,0:38:22.19,0:38:29.72,中文,,0,0,0,,另一个你可以提出的论点是  你可以想象  如果这是真的  那么我可以不断地压缩压缩文件
Dialogue: 0,0:38:29.72,0:38:35.83,英文,,0,0,0,,And if I keep compressing it, then eventually I get it down to one bit.
Dialogue: 0,0:38:29.72,0:38:35.83,中文,,0,0,0,,如果我不断压缩它  那么最终我会把它压缩到1位
Dialogue: 0,0:38:35.83,0:38:38.67,英文,,0,0,0,,And that's not really possible.
Dialogue: 0,0:38:35.83,0:38:38.67,中文,,0,0,0,,那是不可能的
Dialogue: 0,0:38:38.67,0:38:46.48,英文,,0,0,0,,If I can compress it this many times, and I should be able to uncompress it this many times as well to get back to the original data set.
Dialogue: 0,0:38:38.67,0:38:46.48,中文,,0,0,0,,如果我可以压缩它这么多  我也应该能够解压它这么多才能回到原始数据集
Dialogue: 0,0:38:46.48,0:38:56.45,英文,,0,0,0,,So the only real way that I can get the compression algorithm to work is if some of these strings end up getting longer.
Dialogue: 0,0:38:46.48,0:38:56.45,中文,,0,0,0,,所以  我能够让压缩算法工作的唯一方法是  让其中一些字符串变得更长
Dialogue: 0,0:38:56.45,0:39:03.31,英文,,0,0,0,,The other example is, as you mentioned, there's very few short strings than long strings.
Dialogue: 0,0:38:56.45,0:39:03.31,中文,,0,0,0,,另一个例子是  正如你提到的  短字符串比长字符串少很多
Dialogue: 0,0:39:03.31,0:39:07.75,英文,,0,0,0,,So you can't guarantee a compression by even 50% once.
Dialogue: 0,0:39:03.31,0:39:07.75,中文,,0,0,0,,所以你不能保证一次压缩50%
Dialogue: 0,0:39:07.75,0:39:08.92,英文,,0,0,0,,It's kind of the exact same argument.
Dialogue: 0,0:39:07.75,0:39:08.92,中文,,0,0,0,,这和刚才的论点完全一样
Dialogue: 0,0:39:08.92,0:39:15.44,英文,,0,0,0,,There's more strings that are 1,000 bits long than there are strings that are less than 1,000 bits long.
Dialogue: 0,0:39:08.92,0:39:15.44,中文,,0,0,0,,1000位长的字符串比小于1000位长的字符串多
Dialogue: 0,0:39:15.44,0:39:19.84,英文,,0,0,0,,This generally means that we cannot compress below the entropy of a data set.
Dialogue: 0,0:39:15.44,0:39:19.84,中文,,0,0,0,,这通常意味着我们不能压缩到低于数据集的熵
Dialogue: 0,0:39:19.84,0:39:28.65,英文,,0,0,0,,And in fact, if we look at all the possible strings of length n, then out of those strings,
Dialogue: 0,0:39:19.84,0:39:28.65,中文,,0,0,0,,事实上  如果我们看所有长度为n的可能字符串  那么在这些字符串中
Dialogue: 0,0:39:28.65,0:39:34.88,英文,,0,0,0,,Some of them are going to need to grow longer, and some of them are going to grow smaller.
Dialogue: 0,0:39:28.65,0:39:34.88,中文,,0,0,0,,其中一些字符串会变得更长  而另一些会变得更短
Dialogue: 0,0:39:34.88,0:39:40.84,英文,,0,0,0,,And we can say that any compression algorithm will, on average, keep the string the same length.
Dialogue: 0,0:39:34.88,0:39:40.84,中文,,0,0,0,,我们可以说  任何压缩算法平均而言都会保持字符串的长度不变
Dialogue: 0,0:39:40.84,0:39:42.54,英文,,0,0,0,,In fact, we can go even further.
Dialogue: 0,0:39:40.84,0:39:42.54,中文,,0,0,0,,事实上  我们还可以更进一步
Dialogue: 0,0:39:42.54,0:39:47.49,英文,,0,0,0,,The only way that we can make a string shorter is by making the average string length longer.
Dialogue: 0,0:39:42.54,0:39:47.49,中文,,0,0,0,,缩短字符串长度的唯一方法是让平均字符串长度更长
Dialogue: 0,0:39:47.49,0:39:57.13,英文,,0,0,0,,The only compression algorithm which achieves exactly the same average size is the one that just returns the original data set back.
Dialogue: 0,0:39:47.49,0:39:57.13,中文,,0,0,0,,唯一能达到完全相同平均大小的压缩算法就是把原始数据集返回的那个
Dialogue: 0,0:39:57.13,0:40:05.35,英文,,0,0,0,,But, fortunately, English isn't completely random strings, so we can compress English words, valid English stuff,
Dialogue: 0,0:39:57.13,0:40:05.35,中文,,0,0,0,,但幸运的是  英语不是完全随机的字符串  所以我们可以压缩英语单词、有效的英语内容
Dialogue: 0,0:40:05.35,0:40:12.35,英文,,0,0,0,,and not worry about the fact that we're making random strings that have no meaning to them slightly longer.
Dialogue: 0,0:40:05.35,0:40:12.35,中文,,0,0,0,,而不必担心我们会让那些没有意义的随机字符串变得更长
Dialogue: 0,0:40:12.35,0:40:16.84,英文,,0,0,0,,In general, the more predictable a data set is, the less information it'll actually carry.
Dialogue: 0,0:40:12.35,0:40:16.84,中文,,0,0,0,,一般来说  一个数据集的可预测性越高  它实际携带的信息就越少
Dialogue: 0,0:40:16.84,0:40:19.66,英文,,0,0,0,,And therefore, the better we can compress that data.
Dialogue: 0,0:40:16.84,0:40:19.66,中文,,0,0,0,,因此  我们就可以更好地压缩这些数据
Dialogue: 0,0:40:19.66,0:40:23.72,英文,,0,0,0,,So if we have English, that's a really easy compressible stuff.
Dialogue: 0,0:40:19.66,0:40:23.72,中文,,0,0,0,,所以如果我们有英语  那是一种非常容易压缩的内容
Dialogue: 0,0:40:23.72,0:40:30.64,英文,,0,0,0,,You can get it down from eight bits per character to like two bits per character fairly quickly.
Dialogue: 0,0:40:23.72,0:40:30.64,中文,,0,0,0,,你可以很快地将其从每个字符8位降低到每个字符2位左右
Dialogue: 0,0:40:30.64,0:40:35.75,英文,,0,0,0,,And in general, actually, most meaningful data that we have is going to be low entropy.
Dialogue: 0,0:40:30.64,0:40:35.75,中文,,0,0,0,,而且实际上  我们拥有的大多数有意义的数据都将是低熵的
Dialogue: 0,0:40:35.75,0:40:38.41,英文,,0,0,0,,Text files, they're two bits per character.
Dialogue: 0,0:40:35.75,0:40:38.41,中文,,0,0,0,,文本文件  它们是每个字符2位
Dialogue: 0,0:40:38.41,0:40:42.07,英文,,0,0,0,,Images, you don't really look at the individual pixels.
Dialogue: 0,0:40:38.41,0:40:42.07,中文,,0,0,0,,图像  你不会真正地去看单个像素
Dialogue: 0,0:40:42.07,0:40:44.45,英文,,0,0,0,,And most pixels are identical to their neighbors.
Dialogue: 0,0:40:42.07,0:40:44.45,中文,,0,0,0,,而且大多数像素都与其相邻像素相同
Dialogue: 0,0:40:44.45,0:40:48.69,英文,,0,0,0,,So you're not going to have significant amounts of data there.
Dialogue: 0,0:40:44.45,0:40:48.69,中文,,0,0,0,,所以你不会在那里有大量的数据
Dialogue: 0,0:40:48.69,0:40:56.02,英文,,0,0,0,,Videos, unless you're watching a blank screen of static, you are generally going to have meaning associated with the data.
Dialogue: 0,0:40:48.69,0:40:56.02,中文,,0,0,0,,视频  除非你正在观看一个空白的静态屏幕  否则你通常会将意义与数据联系起来
Dialogue: 0,0:40:56.02,0:41:00.82,英文,,0,0,0,,The next frame is going to be almost identical to the previous frame, so you don't need to store as much.
Dialogue: 0,0:40:56.02,0:41:00.82,中文,,0,0,0,,下一帧将与前一帧几乎相同  因此你不需要存储那么多
Dialogue: 0,0:41:00.82,0:41:12.72,英文,,0,0,0,,In fact, a lot of compression for actual videos involves taking the difference between the current image and the next image.
Dialogue: 0,0:41:00.82,0:41:12.72,中文,,0,0,0,,事实上  很多实际视频的压缩都涉及到取当前图像和下一图像之间的差异
Dialogue: 0,0:41:12.72,0:41:17.28,英文,,0,0,0,,And you can use that to compress it quite a bit.
Dialogue: 0,0:41:12.72,0:41:17.28,中文,,0,0,0,,你可以用它来压缩它很多
Dialogue: 0,0:41:17.28,0:41:19.88,英文,,0,0,0,,And in general, compression can be slow.
Dialogue: 0,0:41:17.28,0:41:19.88,中文,,0,0,0,,总的来说  压缩可能会很慢
Dialogue: 0,0:41:19.88,0:41:20.62,英文,,0,0,0,,That's fine.
Dialogue: 0,0:41:19.88,0:41:20.62,中文,,0,0,0,,没关系
Dialogue: 0,0:41:20.62,0:41:21.88,英文,,0,0,0,,We only compress it once.
Dialogue: 0,0:41:20.62,0:41:21.88,中文,,0,0,0,,我们只压缩一次
Dialogue: 0,0:41:21.88,0:41:24.42,英文,,0,0,0,,We don't need to decompress it a second time.
Dialogue: 0,0:41:21.88,0:41:24.42,中文,,0,0,0,,我们不需要再次解压缩
Dialogue: 0,0:41:24.42,0:41:27.50,英文,,0,0,0,,So we're perfectly happy making our compression algorithm slow.
Dialogue: 0,0:41:24.42,0:41:27.50,中文,,0,0,0,,所以我们完全乐于让我们的压缩算法变慢
Dialogue: 0,0:41:27.50,0:41:31.55,英文,,0,0,0,,In general, the slower the algorithm is, the better results we can get.
Dialogue: 0,0:41:27.50,0:41:31.55,中文,,0,0,0,,一般来说  算法越慢  我们得到的结果就越好
Dialogue: 0,0:41:31.55,0:41:38.29,英文,,0,0,0,,But regardless of how slow we make our compression algorithm, we can only compress down to the limit of Shannon entropy.
Dialogue: 0,0:41:31.55,0:41:38.29,中文,,0,0,0,,但无论我们让压缩算法多慢  我们只能压缩到香农熵的极限
Dialogue: 0,0:41:38.29,0:41:41.75,英文,,0,0,0,,You can multiply that by a fixed constant, depending on the computation model.
Dialogue: 0,0:41:38.29,0:41:41.75,中文,,0,0,0,,你可以根据计算模型将其乘以一个固定常数
Dialogue: 0,0:41:41.75,0:41:49.14,英文,,0,0,0,,But the point is, the Shannon entropy limits the amount to a theta bound.
Dialogue: 0,0:41:41.75,0:41:49.14,中文,,0,0,0,,但关键是  香农熵将数量限制在一个Θ界限
Dialogue: 0,0:41:49.14,0:41:55.30,英文,,0,0,0,,Now we might ask, does there exist a best possible compression algorithm that exists?
Dialogue: 0,0:41:49.14,0:41:55.30,中文,,0,0,0,,现在我们可能会问  是否存在最佳的压缩算法？
Dialogue: 0,0:41:55.30,0:42:00.51,英文,,0,0,0,,As it turns out, we can't prove that.
Dialogue: 0,0:41:55.30,0:42:00.51,中文,,0,0,0,,事实证明  我们无法证明这一点
Dialogue: 0,0:42:00.51,0:42:09.41,英文,,0,0,0,,In fact, if you can show that a best compression algorithm exists and that it runs in polynomial time, then you have proven that P equals NP.
Dialogue: 0,0:42:00.51,0:42:09.41,中文,,0,0,0,,事实上  如果你能证明存在最佳压缩算法并且它在多项式时间内运行  那么你就证明了P=NP
Dialogue: 0,0:42:09.41,0:42:18.47,英文,,0,0,0,,And if P equals NP, then you earn a million dollars because that is one of the millennium problems.
Dialogue: 0,0:42:09.41,0:42:18.47,中文,,0,0,0,,如果P=NP  那么你就能赚到一百万美元  因为这是千禧年难题之一
Dialogue: 0,0:42:18.47,0:42:19.71,英文,,0,0,0,,So we haven't figured it out.
Dialogue: 0,0:42:18.47,0:42:19.71,中文,,0,0,0,,所以我们还没搞清楚
Dialogue: 0,0:42:19.71,0:42:24.06,英文,,0,0,0,,No one's figured it out in decades.
Dialogue: 0,0:42:19.71,0:42:24.06,中文,,0,0,0,,几十年来没有人能搞清楚
Dialogue: 0,0:42:24.06,0:42:27.66,英文,,0,0,0,,We'll discuss this more when we go talk again on Wednesday.
Dialogue: 0,0:42:24.06,0:42:27.66,中文,,0,0,0,,我们将在周三再次讨论时详细讨论这个问题
Dialogue: 0,0:42:27.66,0:42:34.64,英文,,0,0,0,,And Wednesday, we'll be discussing all about how P and P works and what this problem actually is.
Dialogue: 0,0:42:27.66,0:42:34.64,中文,,0,0,0,,周三  我们将讨论P和P问题的工作原理以及这个问题的实际含义
Dialogue: 0,0:42:34.64,0:42:37.44,英文,,0,0,0,,And we'll get to see how it connects to compression.
Dialogue: 0,0:42:34.64,0:42:37.44,中文,,0,0,0,,我们会看到它如何与压缩连接起来
Dialogue: 0,0:42:37.44,0:42:38.18,英文,,0,0,0,,All right.
Dialogue: 0,0:42:37.44,0:42:38.18,中文,,0,0,0,,好的
Dialogue: 0,0:42:38.18,0:42:38.90,英文,,0,0,0,,That's it for today.
Dialogue: 0,0:42:38.18,0:42:38.90,中文,,0,0,0,,今天就到这里
Dialogue: 0,0:42:38.90,0:42:39.46,英文,,0,0,0,,See you on Wednesday.
Dialogue: 0,0:42:38.90,0:42:39.46,中文,,0,0,0,,周三见
