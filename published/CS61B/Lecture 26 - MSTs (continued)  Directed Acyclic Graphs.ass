[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 3
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Export Encoding: Unicode (UTF-8)
Audio File: D:/python_code/video_tool/video_tool/result/Lecture 02.1 - Number Representation Intro, Bits can be anything.mp4
Video File: D:/python_code/video_tool/video_tool/result/Lecture 02.1 - Number Representation Intro, Bits can be anything.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.375000
Scroll Position: 1152
Active Line: 860
Video Position: 8466

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,14,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.33333,1.33333,2,6,6,8,1
Style: 英文,Arial,24,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1.33333,1.33333,2,2,2,6,1
Style: 中文,微软雅黑,38,&H0029EEF1,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1.33333,1.33333,2,2,2,20,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,
Dialogue: 0,0:00:01.90,0:00:03.05,英文,,0,0,0,,OK, hello.
Dialogue: 0,0:00:01.90,0:00:03.05,中文,,0,0,0,,好 大家好
Dialogue: 0,0:00:03.05,0:00:10.49,英文,,0,0,0,,So I guess you might have missed this if you're watching the recording, but all we said before lecture is, if we don't cover anything today, it won't be on the midterm.
Dialogue: 0,0:00:03.05,0:00:10.49,中文,,0,0,0,,如果你在看录播 可能错过了课前说的话 如果今天没讲的内容 期中考试不会考
Dialogue: 0,0:00:10.49,0:00:13.07,英文,,0,0,0,,So there you go.
Dialogue: 0,0:00:10.49,0:00:13.07,中文,,0,0,0,,就是这样
Dialogue: 0,0:00:13.07,0:00:18.75,英文,,0,0,0,,Last time, we showed you the PRIMS algorithm conceptual version.
Dialogue: 0,0:00:13.07,0:00:18.75,中文,,0,0,0,,上次 我们展示了 prim‘s 算法的概念版本
Dialogue: 0,0:00:18.75,0:00:26.27,英文,,0,0,0,,I won't go through it again, but the idea was we used the cup property over and over again to repeatedly add edges to our minimum spanning tree.
Dialogue: 0,0:00:18.75,0:00:26.27,中文,,0,0,0,,我就不再赘述了 但中心思想是 我们反复使用割属性来为最小生成树添加边
Dialogue: 0,0:00:26.27,0:00:27.75,英文,,0,0,0,,So that worked.
Dialogue: 0,0:00:26.27,0:00:27.75,中文,,0,0,0,,这是可行的
Dialogue: 0,0:00:27.75,0:00:34.62,英文,,0,0,0,,However, we also saw it was kind of slow because you had to consider all the edges over and over and over again.
Dialogue: 0,0:00:27.75,0:00:34.62,中文,,0,0,0,,然而 我们也发现它有点慢 因为你必须一遍又一遍地考虑所有边
Dialogue: 0,0:00:34.62,0:00:38.96,英文,,0,0,0,,So now, I'm going to start off today by showing you a different version of PRIMS.
Dialogue: 0,0:00:34.62,0:00:38.96,中文,,0,0,0,,今天 我将从展示 prim‘s 的不同版本开始
Dialogue: 0,0:00:38.96,0:00:44.04,英文,,0,0,0,,And to be honest, looking at these two versions, it is kind of hard to see that they are the same algorithm.
Dialogue: 0,0:00:38.96,0:00:44.04,中文,,0,0,0,,说实话 看看这两个版本 很难看出它们是同一个算法
Dialogue: 0,0:00:44.04,0:00:48.03,英文,,0,0,0,,So if you want to, you can almost consider this a totally different algorithm.
Dialogue: 0,0:00:44.04,0:00:48.03,中文,,0,0,0,,如果你愿意 你几乎可以把它看作是一个完全不同的算法
Dialogue: 0,0:00:48.03,0:00:53.61,英文,,0,0,0,,And maybe later, you can go back, and once you're a minimum spanning tree expert,
Dialogue: 0,0:00:48.03,0:00:53.61,中文,,0,0,0,,也许以后 等你成为最小生成树专家后 你可以再回来看看 你会意识到
Dialogue: 0,0:00:53.61,0:00:58.81,英文,,0,0,0,,maybe you can go back and you'll realize that deep down, these are actually the same algorithm, and they'll give you the same answer.
Dialogue: 0,0:00:53.61,0:00:58.81,中文,,0,0,0,,从本质上讲 它们实际上是同一个算法 它们会给出相同的答案
Dialogue: 0,0:00:58.81,0:01:01.03,英文,,0,0,0,,That's why they're both called PRIMS algorithm.
Dialogue: 0,0:00:58.81,0:01:01.03,中文,,0,0,0,,这就是为什么它们都被称为 prim‘s 算法的原因
Dialogue: 0,0:01:01.03,0:01:04.29,英文,,0,0,0,,But when I show it to you for the first time, to be honest,
Dialogue: 0,0:01:01.03,0:01:04.29,中文,,0,0,0,,但当我第一次向你展示的时候 老实说
Dialogue: 0,0:01:04.29,0:01:06.56,英文,,0,0,0,,They look kind of different, oh well.
Dialogue: 0,0:01:04.29,0:01:06.56,中文,,0,0,0,,它们看起来有点不同 好吧
Dialogue: 0,0:01:06.56,0:01:08.04,英文,,0,0,0,,So this is what you saw last time.
Dialogue: 0,0:01:06.56,0:01:08.04,中文,,0,0,0,,这就是你上次看到的
Dialogue: 0,0:01:08.04,0:01:16.27,英文,,0,0,0,,You saw it was slow because sometimes when you consider a cut, you have to consider tons and tons of edges crossing the cut.
Dialogue: 0,0:01:08.04,0:01:16.27,中文,,0,0,0,,你看到它很慢 因为有时当你考虑割的时候 你必须考虑大量穿过割的边
Dialogue: 0,0:01:16.27,0:01:17.53,英文,,0,0,0,,So here's our new algorithm.
Dialogue: 0,0:01:16.27,0:01:17.53,中文,,0,0,0,,这是我们的新算法
Dialogue: 0,0:01:17.53,0:01:24.42,英文,,0,0,0,,It's actually inspired by Dijkstra's algorithm, and it's going to look quite different, but I promise you it's the same algorithm deep down.
Dialogue: 0,0:01:17.53,0:01:24.42,中文,,0,0,0,,它实际上是受 Dijkstra’s算法启发的 它看起来会很不一样 但我保证它本质上是同一个算法
Dialogue: 0,0:01:24.42,0:01:26.66,英文,,0,0,0,,So. Remember Dijkstra's algorithm?
Dialogue: 0,0:01:24.42,0:01:26.66,中文,,0,0,0,,还记得 Dijkstra’s算法吗？
Dialogue: 0,0:01:26.66,0:01:34.79,英文,,0,0,0,,What we did was we visited all the vertices in best-first order and relaxed all the outgoing edges, and every edge got relaxed once.
Dialogue: 0,0:01:26.66,0:01:34.79,中文,,0,0,0,,我们所做的是以最佳优先顺序访问所有顶点 并松弛所有出边 每条边都松弛一次
Dialogue: 0,0:01:34.79,0:01:39.61,英文,,0,0,0,,Turns out we can do the same thing for prims to build a minimum spanning tree.
Dialogue: 0,0:01:34.79,0:01:39.61,中文,,0,0,0,,事实证明 我们可以对 prim‘s 做同样的事情来构建最小生成树
Dialogue: 0,0:01:39.61,0:01:46.56,英文,,0,0,0,,And the only difference, this is actually exactly the same as Dijkstra's algorithm, the same old distance-to-array, edge-to-array.
Dialogue: 0,0:01:39.61,0:01:46.56,中文,,0,0,0,,唯一的区别 这实际上与 Dijkstra’s算法完全相同 同样的旧的 distTo 数组和 edgeTo 数组
Dialogue: 0,0:01:46.56,0:01:50.20,英文,,0,0,0,,The only difference is instead of saying distance from the source,
Dialogue: 0,0:01:46.56,0:01:50.20,中文,,0,0,0,,唯一的区别是 与其说是从源头的距离
Dialogue: 0,0:01:50.20,0:01:52.92,英文,,0,0,0,,which was what we cared about in Dijkstra's algorithm.
Dialogue: 0,0:01:50.20,0:01:52.92,中文,,0,0,0,,这是我们在 Dijkstra’s算法中关心的
Dialogue: 0,0:01:52.92,0:01:54.68,英文,,0,0,0,,I'm going to change one word.
Dialogue: 0,0:01:52.92,0:01:54.68,中文,,0,0,0,,我要改一个词
Dialogue: 0,0:01:54.68,0:02:02.20,英文,,0,0,0,,Instead of saying distance from the source vertex, I'm going to say distance from the tree under construction.
Dialogue: 0,0:01:54.68,0:02:02.20,中文,,0,0,0,,与其说距离源顶点的距离 不如说距离正在构建的树的距离
Dialogue: 0,0:02:02.20,0:02:03.75,英文,,0,0,0,,So let's see what that looks like.
Dialogue: 0,0:02:02.20,0:02:03.75,中文,,0,0,0,,让我们看看它是什么样子的
Dialogue: 0,0:02:03.75,0:02:06.59,英文,,0,0,0,,So the first couple of steps are just like Dijkstra's.
Dialogue: 0,0:02:03.75,0:02:06.59,中文,,0,0,0,,前几步就像 Dijkstra 的一样
Dialogue: 0,0:02:06.59,0:02:07.91,英文,,0,0,0,,I add all.
Dialogue: 0,0:02:06.59,0:02:07.91,中文,,0,0,0,,我添加所有
Dialogue: 0,0:02:07.91,0:02:09.77,英文,,0,0,0,,All of my vertices to my fringe.
Dialogue: 0,0:02:07.91,0:02:09.77,中文,,0,0,0,,所有顶点到我的边缘
Dialogue: 0,0:02:09.77,0:02:14.71,英文,,0,0,0,,This is saying that none of these have been visited yet, and I need to visit these one by one.
Dialogue: 0,0:02:09.77,0:02:14.71,中文,,0,0,0,,这意味着这些都没有被访问过 我需要一个一个地访问它们
Dialogue: 0,0:02:14.71,0:02:21.81,英文,,0,0,0,,I will start with the one that's closest to, not the source, but the tree, which currently consists of just A.
Dialogue: 0,0:02:14.71,0:02:26.81,英文,,0,0,0,,So I'll pull A off the fringe, I'll mark it, and I'll relax all of its outgoing edges.
Dialogue: 0,0:02:14.71,0:02:21.81,中文,,0,0,0,,我将从距离树最近的那个开始 而不是距离源头最近的那个 当前树只包含 A
Dialogue: 0,0:02:21.81,0:02:26.81,中文,,0,0,0,,我将 A 从边缘拉出来 标记它 并松弛它所有的出边
Dialogue: 0,0:02:26.81,0:02:28.51,英文,,0,0,0,,So it's almost the same.
Dialogue: 0,0:02:26.81,0:02:28.51,中文,,0,0,0,,几乎是一样的
Dialogue: 0,0:02:28.51,0:02:30.09,英文,,0,0,0,,And here's the one difference.
Dialogue: 0,0:02:28.51,0:02:30.09,中文,,0,0,0,,这是一个不同之处
Dialogue: 0,0:02:30.09,0:02:34.31,英文,,0,0,0,,When I relax the edges, I no longer care about distance from source.
Dialogue: 0,0:02:30.09,0:02:34.31,中文,,0,0,0,,当我松弛边的时候 我不再关心距离源头的距离
Dialogue: 0,0:02:34.31,0:02:35.99,英文,,0,0,0,,because there is no source.
Dialogue: 0,0:02:34.31,0:02:35.99,中文,,0,0,0,,因为没有源头
Dialogue: 0,0:02:35.99,0:02:38.98,英文,,0,0,0,,All I care about is the distance from the tree.
Dialogue: 0,0:02:35.99,0:02:38.98,中文,,0,0,0,,我关心的只是距离树的距离
Dialogue: 0,0:02:38.98,0:02:47.58,英文,,0,0,0,,So if A is the only node in the tree, the minimum spanning tree that I've built so far, how far away is it from B?
Dialogue: 0,0:02:38.98,0:02:47.58,中文,,0,0,0,,如果 A 是树中唯一的节点 是我到目前为止构建的最小生成树 那么它离 B 有多远？
Dialogue: 0,0:02:47.58,0:02:49.40,英文,,0,0,0,,B is 2 away from the tree.
Dialogue: 0,0:02:47.58,0:02:49.40,中文,,0,0,0,,B 距离树 2
Dialogue: 0,0:02:49.40,0:02:52.20,英文,,0,0,0,,This will probably make more sense once I build more of the tree.
Dialogue: 0,0:02:49.40,0:02:52.20,中文,,0,0,0,,当我构建更多的树时 这可能会更有意义
Dialogue: 0,0:02:52.20,0:02:54.72,英文,,0,0,0,,But I can say 2 is better than infinity.
Dialogue: 0,0:02:52.20,0:02:54.72,中文,,0,0,0,,但我可以说 2 比无穷大好
Dialogue: 0,0:02:54.72,0:02:56.20,英文,,0,0,0,,1 is better than infinity.
Dialogue: 0,0:02:54.72,0:02:56.20,中文,,0,0,0,,1 比无穷大好
Dialogue: 0,0:02:56.20,0:02:58.34,英文,,0,0,0,,So both of these relaxations succeed.
Dialogue: 0,0:02:56.20,0:02:58.34,中文,,0,0,0,,这两个松弛都成功了
Dialogue: 0,0:02:58.34,0:03:02.26,英文,,0,0,0,,And things look pretty similar to Dijkstra's so far.
Dialogue: 0,0:02:58.34,0:03:02.26,中文,,0,0,0,,到目前为止 事情看起来与 Dijkstra’s算法非常相似
Dialogue: 0,0:03:02.26,0:03:07.91,英文,,0,0,0,,I will tell you about the dashed edges after probably the whole thing.
Dialogue: 0,0:03:02.26,0:03:07.91,中文,,0,0,0,,我可能会在讲完整个内容之后再告诉你关于虚线边的事情
Dialogue: 0,0:03:07.91,0:03:13.53,英文,,0,0,0,,Then I go back to the fringe and I look, who is closest to the tree under construction?
Dialogue: 0,0:03:07.91,0:03:13.53,中文,,0,0,0,,然后我回到边缘 我看看 谁离正在构建的树最近？
Dialogue: 0,0:03:13.53,0:03:17.21,英文,,0,0,0,,Maybe I do have to tell you briefly about these dashed edges.
Dialogue: 0,0:03:13.53,0:03:17.21,中文,,0,0,0,,也许我确实需要简单地告诉你关于这些虚线边的事情
Dialogue: 0,0:03:17.21,0:03:28.51,英文,,0,0,0,,Really quickly, and I know I'm throwing a lot of information at you, the dashed edges are to say, if you think back to the conceptual version of prints, I was always adding one edge at a time.
Dialogue: 0,0:03:17.21,0:03:28.51,中文,,0,0,0,,很快 我知道我向你抛出了很多信息 虚线边是为了说明 如果你回想一下 prints 的概念版本 我总是每次添加一条边
Dialogue: 0,0:03:28.51,0:03:32.95,英文,,0,0,0,,I considered a cut, added an edge, considered another cut, added an edge.
Dialogue: 0,0:03:28.51,0:03:32.95,中文,,0,0,0,,我考虑了一个割 添加了一条边 考虑了另一个割 添加了一条边
Dialogue: 0,0:03:32.95,0:03:39.25,英文,,0,0,0,,So it's a little bit weird that I am adding two edges in one iteration of this algorithm.
Dialogue: 0,0:03:32.95,0:03:39.25,中文,,0,0,0,,在这个算法的一次迭代中添加两条边有点奇怪
Dialogue: 0,0:03:39.25,0:03:42.75,英文,,0,0,0,,So why am I adding two here when the conceptual version only added one?
Dialogue: 0,0:03:39.25,0:03:42.75,中文,,0,0,0,,那么 为什么我在这里添加了两条边 而概念版本只添加了一条边呢？
Dialogue: 0,0:03:42.75,0:03:43.87,英文,,0,0,0,,Well, not to worry.
Dialogue: 0,0:03:42.75,0:03:43.87,中文,,0,0,0,,好吧 不用担心
Dialogue: 0,0:03:43.87,0:03:52.02,英文,,0,0,0,,I am marking these edges as dashed to say that these are the best known edges for my minimum spanning tree at the moment.
Dialogue: 0,0:03:43.87,0:03:52.02,中文,,0,0,0,,我将这些边标记为虚线 以说明这些是我目前最小生成树的最佳已知边
Dialogue: 0,0:03:52.02,0:04:00.95,英文,,0,0,0,,So these are the best known edges to B and C. However, just like in Dijkstra's algorithm, I have to be brave and be willing to kick these edges out.
Dialogue: 0,0:03:52.02,0:04:00.95,中文,,0,0,0,,这些是到 B 和 C 的最佳已知边 然而 就像在 Dijkstra’s算法中一样 我必须勇敢 愿意踢掉这些边
Dialogue: 0,0:04:00.95,0:04:02.01,英文,,0,0,0,,if I find better ones.
Dialogue: 0,0:04:00.95,0:04:02.01,中文,,0,0,0,,如果我找到更好的边
Dialogue: 0,0:04:02.01,0:04:06.48,英文,,0,0,0,,So by marking them dashed, I'm reminding myself that these are the best known edges so far.
Dialogue: 0,0:04:02.01,0:04:06.48,中文,,0,0,0,,通过将它们标记为虚线 我提醒自己 这些是迄今为止已知的最佳边
Dialogue: 0,0:04:06.48,0:04:16.25,英文,,0,0,0,,But later, if I find a better edge to use in the minimum spanning tree to reach C, I will kick this out and say, you are no longer the best way to reach C.
Dialogue: 0,0:04:06.48,0:04:16.25,中文,,0,0,0,,如果我找到一条更好的边来连接 C 到最小生成树 我将把它踢出去 并说你不再是到达 C 的最佳路径
Dialogue: 0,0:04:16.25,0:04:21.25,英文,,0,0,0,,So go home, think about what your choice is, and we'll put someone else in the minimum spanning tree.
Dialogue: 0,0:04:16.25,0:04:21.25,中文,,0,0,0,,回家吧 想想你的选择是什么 我们会让其他人进入最小生成树
Dialogue: 0,0:04:21.25,0:04:23.03,英文,,0,0,0,,That's what it means for these to be dashed.
Dialogue: 0,0:04:21.25,0:04:23.03,中文,,0,0,0,,这就是它们被标记为虚线的意思
Dialogue: 0,0:04:23.03,0:04:29.38,英文,,0,0,0,,It's kind of the same flavor as Dijkstra's, where we add edges, but we have to be willing to kick them out later.
Dialogue: 0,0:04:23.03,0:04:29.38,中文,,0,0,0,,这与 Dijkstra’s算法的风格有点相似 我们添加边 但我们必须愿意在以后踢掉它们
Dialogue: 0,0:04:29.38,0:04:33.19,英文,,0,0,0,,And I'm marking them dashed to make that very explicit.
Dialogue: 0,0:04:29.38,0:04:33.19,中文,,0,0,0,,我将它们标记为虚线 是为了让这一点非常明确
Dialogue: 0,0:04:33.19,0:04:35.67,英文,,0,0,0,,Okay, so here we go.
Dialogue: 0,0:04:33.19,0:04:35.67,中文,,0,0,0,,好的 我们开始吧
Dialogue: 0,0:04:35.67,0:04:41.37,英文,,0,0,0,,And here's the part that I think is very weird about prims, but It is what it is.
Dialogue: 0,0:04:35.67,0:04:41.37,中文,,0,0,0,,这是我认为关于 prim‘s 非常奇怪的部分 但 就是这样
Dialogue: 0,0:04:41.37,0:04:48.65,英文,,0,0,0,,So when I DQC, that is when I take it off the fringe and I mark it, weirdly enough,
Dialogue: 0,0:04:41.37,0:04:48.65,中文,,0,0,0,,当我 DQC 的时候 也就是说当我把它从边缘拿出来并标记它的时候
Dialogue: 0,0:04:48.65,0:04:56.65,英文,,0,0,0,, that's actually the time when I can tell you for a fact this is the best edge to connect C to the rest of the minimum spanning tree.
Dialogue: 0,0:04:48.65,0:04:56.65,中文,,0,0,0,,奇怪的是 这实际上是我可以告诉你这是连接 C 到最小生成树其余部分的最佳边的时候
Dialogue: 0,0:04:56.65,0:05:01.70,英文,,0,0,0,,To be honest, it's a little bit weird, and I'll probably revisit it at the end, but
Dialogue: 0,0:04:56.65,0:05:01.70,中文,,0,0,0,,说实话 这有点奇怪 我可能会在最后再讨论一下 但
Dialogue: 0,0:05:01.70,0:05:08.84,英文,,0,0,0,,When you remove a vertex, that's actually when you confirm that this is the best edge to connect C to everybody else.
Dialogue: 0,0:05:01.70,0:05:08.84,中文,,0,0,0,,当你移除一个顶点时 实际上就是你确认这是连接 C 到其他所有顶点的最佳边的时候
Dialogue: 0,0:05:08.84,0:05:13.33,英文,,0,0,0,,You will never find a better way to connect C to the rest of the tree.
Dialogue: 0,0:05:08.84,0:05:13.33,中文,,0,0,0,,你永远不会找到更好的方法来连接 C 到树的其余部分
Dialogue: 0,0:05:13.33,0:05:15.61,英文,,0,0,0,,OK, so let's keep running the algorithm.
Dialogue: 0,0:05:13.33,0:05:15.61,中文,,0,0,0,,让我们继续运行算法
Dialogue: 0,0:05:15.61,0:05:18.83,英文,,0,0,0,,I'll go back and revisit those ideas if you need to.
Dialogue: 0,0:05:15.61,0:05:18.83,中文,,0,0,0,,如果你需要 我会回去重温这些想法
Dialogue: 0,0:05:18.83,0:05:22.79,英文,,0,0,0,,So here I am at C. And I'm going to relax all the outgoing edges.
Dialogue: 0,0:05:18.83,0:05:22.79,中文,,0,0,0,,我现在在 C 我要松弛所有出边
Dialogue: 0,0:05:22.79,0:05:25.69,英文,,0,0,0,,So it's pretty similar to what we've done in Dijkstra's.
Dialogue: 0,0:05:22.79,0:05:25.69,中文,,0,0,0,,这与我们在 Dijkstra’s算法中所做的非常相似
Dialogue: 0,0:05:25.69,0:05:31.34,英文,,0,0,0,,But here's the one difference, which is think about the distance from C to B.
Dialogue: 0,0:05:25.69,0:05:31.34,中文,,0,0,0,,但这里有一个不同之处 那就是考虑从 C 到 B 的距离
Dialogue: 0,0:05:31.34,0:05:33.26,英文,,0,0,0,,And this is the part that's a little bit weird.
Dialogue: 0,0:05:31.34,0:05:33.26,中文,,0,0,0,,这是有点奇怪的部分
Dialogue: 0,0:05:33.26,0:05:38.66,英文,,0,0,0,,In Dijkstra's, you would have told me the distance from C to B. You had to, like, add two numbers.
Dialogue: 0,0:05:33.26,0:05:38.66,中文,,0,0,0,,在 Dijkstra’s算法中 你会告诉我从 C 到 B 的距离 你必须像这样 加两个数字
Dialogue: 0,0:05:38.66,0:05:44.48,英文,,0,0,0,,You had to consider how far is it from the source to C, and then how much further to B. That was what Dijkstra said.
Dialogue: 0,0:05:38.66,0:05:44.48,中文,,0,0,0,,你必须考虑从源头到 C 有多远 然后到 B 又有多远 这就是 Dijkstra 说的
Dialogue: 0,0:05:44.48,0:05:47.85,英文,,0,0,0,,But Prim's algorithm doesn't care about distance to source.
Dialogue: 0,0:05:44.48,0:05:47.85,中文,,0,0,0,,但 Prim’s算法不关心到源头的距离
Dialogue: 0,0:05:47.85,0:05:50.75,英文,,0,0,0,,It cares about distance to tree.
Dialogue: 0,0:05:47.85,0:05:50.75,中文,,0,0,0,,它关心到树的距离
Dialogue: 0,0:05:50.75,0:05:56.17,英文,,0,0,0,,So these two marked vertices and this bold edge, this is my tree under construction.
Dialogue: 0,0:05:50.75,0:05:56.17,中文,,0,0,0,,这两个标记的顶点和这条粗体边 就是我正在构建的树
Dialogue: 0,0:05:56.17,0:06:00.77,英文,,0,0,0,,So how far is it from B to anywhere in the tree?
Dialogue: 0,0:05:56.17,0:06:00.77,中文,,0,0,0,,那么从 B 到树中任何地方有多远？
Dialogue: 0,0:06:00.77,0:06:03.58,英文,,0,0,0,,Well, it's no longer 5 plus some other extra cost.
Dialogue: 0,0:06:00.77,0:06:03.58,中文,,0,0,0,,嗯 它不再是 5 加上其他额外的成本了
Dialogue: 0,0:06:03.58,0:06:07.30,英文,,0,0,0,,The distance to the tree from B is just 5.
Dialogue: 0,0:06:03.58,0:06:07.30,中文,,0,0,0,,从 B 到树的距离只有 5
Dialogue: 0,0:06:07.30,0:06:09.78,英文,,0,0,0,,So you lose one of the terms in the addition.
Dialogue: 0,0:06:07.30,0:06:09.78,中文,,0,0,0,,你失去了加法中的一个项
Dialogue: 0,0:06:09.78,0:06:16.43,英文,,0,0,0,,So if I'm asking how far away is it to B if I use this edge from the tree, it's actually just 5.
Dialogue: 0,0:06:09.78,0:06:16.43,中文,,0,0,0,,如果我问如果我使用这条边从树中出来 到 B 有多远 实际上只有 5
Dialogue: 0,0:06:16.43,0:06:19.84,英文,,0,0,0,,It's not 5 plus something else, as it was in Dijkstra's.
Dialogue: 0,0:06:16.43,0:06:19.84,中文,,0,0,0,,它不是 5 加上其他东西 就像在 Dijkstra’s算法中那样
Dialogue: 0,0:06:19.84,0:06:25.62,英文,,0,0,0,,In any case, 5 is not better than 2, so there's no reason to add this edge to the minimum spanning tree.
Dialogue: 0,0:06:19.84,0:06:25.62,中文,,0,0,0,,无论如何 5 不比 2 好 没有理由将这条边添加到最小生成树中
Dialogue: 0,0:06:25.62,0:06:30.78,英文,,0,0,0,,I had a better way to get to b anyway, so this 5 edge, we don't need you.
Dialogue: 0,0:06:25.62,0:06:30.78,中文,,0,0,0,,无论如何 我都有更好的方法到达 b 这条 5 的边 我们不需要你
Dialogue: 0,0:06:30.78,0:06:36.84,英文,,0,0,0,,And then 1 is a better way to get to e, and 15 is a better way to get to f.
Dialogue: 0,0:06:30.78,0:06:36.84,中文,,0,0,0,,然后 1 是到达 e 的更好的方法 15 是到达 f 的更好的方法
Dialogue: 0,0:06:36.84,0:06:43.40,英文,,0,0,0,,So I can update these two best-known ways to get to E and F, or the best-known ways to connect them to the tree.
Dialogue: 0,0:06:36.84,0:06:43.40,中文,,0,0,0,,我可以更新这两个到达 E 和 F 的最佳已知方法 或者连接它们到树的最佳已知方法
Dialogue: 0,0:06:43.40,0:06:45.70,英文,,0,0,0,,And this relaxation fails.
Dialogue: 0,0:06:43.40,0:06:45.70,中文,,0,0,0,,这个松弛失败了
Dialogue: 0,0:06:45.70,0:06:46.92,英文,,0,0,0,,These two succeed.
Dialogue: 0,0:06:45.70,0:06:46.92,中文,,0,0,0,,这两个成功了
Dialogue: 0,0:06:46.92,0:06:53.19,英文,,0,0,0,,And again, the key idea here, the thing that you have to know to mechanically run this algorithm, this number right here is 15.
Dialogue: 0,0:06:46.92,0:06:53.19,中文,,0,0,0,,同样 这里的关键思想 你必须知道才能机械地运行这个算法 就是这里的这个数字是 15
Dialogue: 0,0:06:53.19,0:06:56.41,英文,,0,0,0,,It is not 16.
Dialogue: 0,0:06:53.19,0:06:56.41,中文,,0,0,0,,它不是 16
Dialogue: 0,0:06:56.41,0:07:03.66,英文,,0,0,0,,If we were running Dijkstra's algorithm, you would put 16 here, but we're running Prim's algorithm, so you put 15 here.
Dialogue: 0,0:06:56.41,0:07:03.66,中文,,0,0,0,,如果是运行 Dijkstra’s算法 这里应该填 16 但我们运行的是 Prim’s算法  填 15
Dialogue: 0,0:07:03.66,0:07:07.37,英文,,0,0,0,,If that makes sense, you're all set and everything else is mechanical.
Dialogue: 0,0:07:03.66,0:07:07.37,中文,,0,0,0,,如果理解了 就都搞定了 剩下的都是机械操作
Dialogue: 0,0:07:07.37,0:07:09.09,英文,,0,0,0,,That's probably the weirdest part.
Dialogue: 0,0:07:07.37,0:07:09.09,中文,,0,0,0,,这可能是最奇怪的部分
Dialogue: 0,0:07:09.09,0:07:11.97,英文,,0,0,0,,Okay, I'll finish running this and then we'll take some questions.
Dialogue: 0,0:07:09.09,0:07:11.97,中文,,0,0,0,,我将完成这个运行 然后我们将回答一些问题
Dialogue: 0,0:07:11.97,0:07:15.91,英文,,0,0,0,,So, This relaxation failed, so I'm not even marking it dashed.
Dialogue: 0,0:07:11.97,0:07:15.91,中文,,0,0,0,, 这个松弛失败了 我甚至都没有把它标记为虚线
Dialogue: 0,0:07:15.91,0:07:18.87,英文,,0,0,0,,You're simply not part of the minimum spanning tree.
Dialogue: 0,0:07:15.91,0:07:18.87,中文,,0,0,0,,你根本不是最小生成树的一部分
Dialogue: 0,0:07:18.87,0:07:22.09,英文,,0,0,0,,You're not even a candidate for the minimum spanning tree.
Dialogue: 0,0:07:18.87,0:07:22.09,中文,,0,0,0,,你甚至不是最小生成树的候选者
Dialogue: 0,0:07:22.09,0:07:24.17,英文,,0,0,0,,This edge will simply never be used.
Dialogue: 0,0:07:22.09,0:07:24.17,中文,,0,0,0,,这条边根本就不会被使用
Dialogue: 0,0:07:24.17,0:07:27.48,英文,,0,0,0,,Your relaxation failed, so go home and think about your choices.
Dialogue: 0,0:07:24.17,0:07:27.48,中文,,0,0,0,,你的松弛失败了 回家反省一下你的选择吧
Dialogue: 0,0:07:27.48,0:07:32.52,英文,,0,0,0,,We are not using you as part of the minimum spanning tree.
Dialogue: 0,0:07:27.48,0:07:32.52,中文,,0,0,0,,我们不会把你作为最小生成树的一部分
Dialogue: 0,0:07:32.52,0:07:37.02,英文,,0,0,0,,These two relaxations succeeded, so I will temporarily mark them as provisional edges.
Dialogue: 0,0:07:32.52,0:07:37.02,中文,,0,0,0,,这两个松弛成功了 我将暂时把它们标记为临时边
Dialogue: 0,0:07:37.02,0:07:41.55,英文,,0,0,0,,You are the best known way to connect to E. You are the best known way to connect to F.
Dialogue: 0,0:07:37.02,0:07:41.55,中文,,0,0,0,,你是连接到 E 的最佳已知方式 你是连接到 F 的最佳已知方式
Dialogue: 0,0:07:41.55,0:07:47.55,英文,,0,0,0,,Maybe I will find better ways later, but for now, you're the best I can do, so I'll mark you dashed.
Dialogue: 0,0:07:41.55,0:07:47.55,中文,,0,0,0,,也许我以后会找到更好的方法 但现在 你是我能做的最好的 我将把你标记为虚线
Dialogue: 0,0:07:47.55,0:07:52.00,英文,,0,0,0,,OK, now it's time to go to the fringe and take another vertex.
Dialogue: 0,0:07:47.55,0:07:52.00,中文,,0,0,0,,现在是时候去边缘并取另一个顶点了
Dialogue: 0,0:07:52.00,0:07:58.56,英文,,0,0,0,,So remember, I'm looking at vertices in order of distance from the tree.
Dialogue: 0,0:07:52.00,0:07:58.56,中文,,0,0,0,,记住 我正在按照顶点到树的距离的顺序查看它们
Dialogue: 0,0:07:58.56,0:08:01.00,英文,,0,0,0,,So I have 2, 1, infinity, infinity, 15.
Dialogue: 0,0:07:58.56,0:08:01.00,中文,,0,0,0,,我有 2、1、无穷大、无穷大、15
Dialogue: 0,0:08:01.00,0:08:07.46,英文,,0,0,0,,I will take 1 next, because it's the closest to the tree under construction.
Dialogue: 0,0:08:01.00,0:08:07.46,中文,,0,0,0,,我接下来会取 1 因为它离正在构建的树最近
Dialogue: 0,0:08:07.46,0:08:14.83,英文,,0,0,0,,And here's the kind of weird part, which is as soon as I pull e off the fringe, that's actually committing to an edge.
Dialogue: 0,0:08:07.46,0:08:14.83,中文,,0,0,0,,这里有一个奇怪的部分 就是当我把 e 从边缘拉下来时 实际上就确定了一条边
Dialogue: 0,0:08:14.83,0:08:21.46,英文,,0,0,0,,So every time I take a vertex off the fringe, I'm committing to how I'm going to hook up that vertex to everybody else.
Dialogue: 0,0:08:14.83,0:08:21.46,中文,,0,0,0,,每次我从边缘取一个顶点 我就在确定如何将那个顶点连接到其他所有顶点
Dialogue: 0,0:08:21.46,0:08:24.66,英文,,0,0,0,,So in this case, when I pull e off the fringe,
Dialogue: 0,0:08:21.46,0:08:24.66,中文,,0,0,0,,在这种情况下 当我把 e 从边缘拉下来时
Dialogue: 0,0:08:24.66,0:08:30.29,英文,,0,0,0,,fringe, I'm committing to using the edge going into E. So this used to be provisional.
Dialogue: 0,0:08:24.66,0:08:30.29,中文,,0,0,0,,边缘 我就在确定使用通往 E 的边 这条边以前是临时的
Dialogue: 0,0:08:30.29,0:08:31.87,英文,,0,0,0,,I wasn't sure if it was the best one.
Dialogue: 0,0:08:30.29,0:08:31.87,中文,,0,0,0,,我不确定它是不是最好的
Dialogue: 0,0:08:31.87,0:08:33.59,英文,,0,0,0,,Was there a better way to get to E?
Dialogue: 0,0:08:31.87,0:08:33.59,中文,,0,0,0,,有没有更好的方法到达 E？
Dialogue: 0,0:08:33.59,0:08:41.90,英文,,0,0,0,,But as soon as I mark E and pull E off the fringe, I know for a fact this is the best way to get to E. I'll never find something better.
Dialogue: 0,0:08:33.59,0:08:41.90,中文,,0,0,0,,但是一旦我标记 E 并将 E 从边缘拉下来 我就能确定这是到达 E 的最佳方式 我永远不会找到更好的方法
Dialogue: 0,0:08:41.90,0:08:45.51,英文,,0,0,0,,OK. So now for some relaxations.
Dialogue: 0,0:08:41.90,0:08:45.51,中文,,0,0,0,,现在进行一些松弛
Dialogue: 0,0:08:45.51,0:08:50.37,英文,,0,0,0,,And again, I do not sum two numbers anymore because I only care about distance from the tree.
Dialogue: 0,0:08:45.51,0:08:50.37,中文,,0,0,0,,再说一次 我不再对两个数字求和 因为我只关心到树的距离
Dialogue: 0,0:08:50.37,0:08:55.01,英文,,0,0,0,,A, C, E, this entire thing is my tree under construction.
Dialogue: 0,0:08:50.37,0:08:55.01,中文,,0,0,0,,A、C、E 这整个东西就是我正在构建的树
Dialogue: 0,0:08:55.01,0:08:58.83,英文,,0,0,0,,And I'm asking, how far is it to get from anywhere in this tree to B?
Dialogue: 0,0:08:55.01,0:08:58.83,中文,,0,0,0,,我问的是 从这棵树上的任何地方到达 B 有多远？
Dialogue: 0,0:08:58.83,0:09:00.10,英文,,0,0,0,,Well, that's just three.
Dialogue: 0,0:08:58.83,0:09:00.10,中文,,0,0,0,,嗯 只有 3
Dialogue: 0,0:09:00.10,0:09:01.62,英文,,0,0,0,,That's the distance from.
Dialogue: 0,0:09:00.10,0:09:01.62,中文,,0,0,0,,那就是到
Dialogue: 0,0:09:01.62,0:09:02.84,英文,,0,0,0,,The tree.
Dialogue: 0,0:09:01.62,0:09:02.84,中文,,0,0,0,,树的距离
Dialogue: 0,0:09:02.84,0:09:04.86,英文,,0,0,0,,So 3 is not better than 2.
Dialogue: 0,0:09:02.84,0:09:04.86,中文,,0,0,0,, 3 不比 2 好
Dialogue: 0,0:09:04.86,0:09:06.34,英文,,0,0,0,,So this relaxation fails.
Dialogue: 0,0:09:04.86,0:09:06.34,中文,,0,0,0,,这个松弛失败了
Dialogue: 0,0:09:06.34,0:09:08.54,英文,,0,0,0,,We will never use this edge.
Dialogue: 0,0:09:06.34,0:09:08.54,中文,,0,0,0,,我们永远不会使用这条边
Dialogue: 0,0:09:08.54,0:09:09.70,英文,,0,0,0,,2 is better than infinity.
Dialogue: 0,0:09:08.54,0:09:09.70,中文,,0,0,0,,2 比无穷大好
Dialogue: 0,0:09:09.70,0:09:10.88,英文,,0,0,0,,So we'll use that edge.
Dialogue: 0,0:09:09.70,0:09:10.88,中文,,0,0,0,,我们将使用这条边
Dialogue: 0,0:09:10.88,0:09:11.98,英文,,0,0,0,,3 is better than infinity.
Dialogue: 0,0:09:10.88,0:09:11.98,中文,,0,0,0,,3 比无穷大好
Dialogue: 0,0:09:11.98,0:09:14.14,英文,,0,0,0,,And 4 is better than 15.
Dialogue: 0,0:09:11.98,0:09:14.14,中文,,0,0,0,,4 比 15 好
Dialogue: 0,0:09:14.14,0:09:16.81,英文,,0,0,0,,So here we go.
Dialogue: 0,0:09:14.14,0:09:16.81,中文,,0,0,0,,就这样吧
Dialogue: 0,0:09:16.81,0:09:18.15,英文,,0,0,0,,OK, so let's see.
Dialogue: 0,0:09:16.81,0:09:18.15,中文,,0,0,0,,好的 让我们看看
Dialogue: 0,0:09:18.15,0:09:19.41,英文,,0,0,0,,This realization fails.
Dialogue: 0,0:09:18.15,0:09:19.41,中文,,0,0,0,,这个松弛失败了
Dialogue: 0,0:09:19.41,0:09:21.09,英文,,0,0,0,,We will never use this edge.
Dialogue: 0,0:09:19.41,0:09:21.09,中文,,0,0,0,,我们永远不会使用这条边
Dialogue: 0,0:09:21.09,0:09:22.91,英文,,0,0,0,,These two relaxations succeed.
Dialogue: 0,0:09:21.09,0:09:22.91,中文,,0,0,0,,这两个松弛成功了
Dialogue: 0,0:09:22.91,0:09:25.53,英文,,0,0,0,,I will add them as provisional edges.
Dialogue: 0,0:09:22.91,0:09:25.53,中文,,0,0,0,,我将它们添加为临时边
Dialogue: 0,0:09:25.53,0:09:26.73,英文,,0,0,0,,Maybe I'll use them.
Dialogue: 0,0:09:25.53,0:09:26.73,中文,,0,0,0,,也许我会用到它们
Dialogue: 0,0:09:26.73,0:09:28.67,英文,,0,0,0,,Maybe I'll find something better later.
Dialogue: 0,0:09:26.73,0:09:28.67,中文,,0,0,0,,也许我以后会找到更好的方法
Dialogue: 0,0:09:28.67,0:09:31.72,英文,,0,0,0,,And here, this relaxation succeeds as well.
Dialogue: 0,0:09:28.67,0:09:31.72,中文,,0,0,0,,这里 这个松弛也成功了
Dialogue: 0,0:09:31.72,0:09:39.35,英文,,0,0,0,,Well, so I will add this edge as my best known way to get to F, except I already had a way to get to F.
Dialogue: 0,0:09:31.72,0:09:39.35,中文,,0,0,0,,好吧 我会添加这条边作为到达 F 的最佳已知方式 但我已经有了一种到达 F 的方式
Dialogue: 0,0:09:39.35,0:09:47.35,英文,,0,0,0,,So remember, as in Dijkstra's, Prim's algorithm must be brave and say, I found a better way to get to F.
Dialogue: 0,0:09:39.35,0:09:47.35,中文,,0,0,0,,记住 与 Dijkstra’s算法一样 Prim’s算法必须勇敢地说 我找到了到达 F 的更好方法
Dialogue: 0,0:09:47.35,0:09:55.35,英文,,0,0,0,,So this old provisional edge, the old way I knew to get to F, or the old way to connect F to the rest of the tree,
Dialogue: 0,0:09:47.35,0:09:55.35,中文,,0,0,0,,这条旧的临时边 我以前知道的到达 F 的方法 或者将 F 连接到树的其余部分的旧方法
Dialogue: 0,0:09:55.35,0:09:58.35,英文,,0,0,0,,I'm sorry, but I found someone better.
Dialogue: 0,0:09:55.35,0:09:58.35,中文,,0,0,0,,对不起 但我找到了更好的方法
Dialogue: 0,0:09:58.35,0:10:01.30,英文,,0,0,0,,So you are no longer part of the MST.
Dialogue: 0,0:09:58.35,0:10:01.30,中文,,0,0,0,,你不再是 MST 的一部分了
Dialogue: 0,0:10:01.30,0:10:03.53,英文,,0,0,0,,So look, used to be a provisional edge.
Dialogue: 0,0:10:01.30,0:10:03.53,中文,,0,0,0,,看 以前是临时边
Dialogue: 0,0:10:03.53,0:10:04.91,英文,,0,0,0,,Now it's not.
Dialogue: 0,0:10:03.53,0:10:04.91,中文,,0,0,0,,现在不是了
Dialogue: 0,0:10:04.91,0:10:08.07,英文,,0,0,0,,OK. And now I have some more provisional edges.
Dialogue: 0,0:10:04.91,0:10:08.07,中文,,0,0,0,,现在我有了更多临时边
Dialogue: 0,0:10:08.07,0:10:09.49,英文,,0,0,0,,So this goes onwards.
Dialogue: 0,0:10:08.07,0:10:09.49,中文,,0,0,0,,这将继续下去
Dialogue: 0,0:10:09.49,0:10:13.63,英文,,0,0,0,,I now have these four edges, and I need to pick one to explore next.
Dialogue: 0,0:10:09.49,0:10:13.63,中文,,0,0,0,,我现在有这四条边 我需要选择一条接下来进行探索
Dialogue: 0,0:10:13.63,0:10:14.43,英文,,0,0,0,,I have a tie.
Dialogue: 0,0:10:13.63,0:10:14.43,中文,,0,0,0,,我遇到了平局
Dialogue: 0,0:10:14.43,0:10:20.53,英文,,0,0,0,,I could choose B or D. Both would be valid choices and will give you a minimum spanning tree.
Dialogue: 0,0:10:14.43,0:10:20.53,中文,,0,0,0,,我可以选择 B 或 D 这两个都是有效选择 并且会给你一个最小生成树
Dialogue: 0,0:10:20.53,0:10:23.23,英文,,0,0,0,,I actually don't know what I'm about to choose.
Dialogue: 0,0:10:20.53,0:10:23.23,中文,,0,0,0,,实际上我不知道我将要选择什么
Dialogue: 0,0:10:23.23,0:10:30.85,英文,,0,0,0,,I guess I will choose B next, but you could have chosen D. So I choose B. I relax all of its outgoing edges.
Dialogue: 0,0:10:23.23,0:10:30.85,中文,,0,0,0,,我想我接下来会选择 B 但你也可以选择 D 我选择 B 我松弛它所有出去的边
Dialogue: 0,0:10:30.85,0:10:32.47,英文,,0,0,0,,So here I am.
Dialogue: 0,0:10:30.85,0:10:32.47,中文,,0,0,0,,我就在这里
Dialogue: 0,0:10:32.47,0:10:37.14,英文,,0,0,0,,There's no point relaxing the 5 and the 3, because they point at white vertices.
Dialogue: 0,0:10:32.47,0:10:37.14,中文,,0,0,0,,没有必要松弛 5 和 3 因为它们指向白色顶点
Dialogue: 0,0:10:37.14,0:10:38.96,英文,,0,0,0,,Those relaxations will fail.
Dialogue: 0,0:10:37.14,0:10:38.96,中文,,0,0,0,,那些松弛将会失败
Dialogue: 0,0:10:38.96,0:10:41.06,英文,,0,0,0,,So I'll just check this edge right here.
Dialogue: 0,0:10:38.96,0:10:41.06,中文,,0,0,0,,我只检查这条边
Dialogue: 0,0:10:41.06,0:10:43.02,英文,,0,0,0,,Is 11 better than 2?
Dialogue: 0,0:10:41.06,0:10:43.02,中文,,0,0,0,,11 比 2 好吗？
Dialogue: 0,0:10:43.02,0:10:43.46,英文,,0,0,0,,No.
Dialogue: 0,0:10:43.02,0:10:43.46,中文,,0,0,0,,不好
Dialogue: 0,0:10:43.46,0:10:44.98,英文,,0,0,0,,So this relaxation fails.
Dialogue: 0,0:10:43.46,0:10:44.98,中文,,0,0,0,,这个松弛失败了
Dialogue: 0,0:10:44.98,0:10:46.40,英文,,0,0,0,,I'll never use that edge.
Dialogue: 0,0:10:44.98,0:10:46.40,中文,,0,0,0,,我永远不会使用这条边
Dialogue: 0,0:10:46.40,0:10:47.52,英文,,0,0,0,,And again, that's the key.
Dialogue: 0,0:10:46.40,0:10:47.52,中文,,0,0,0,,再说一次 这才是关键
Dialogue: 0,0:10:47.52,0:10:51.76,英文,,0,0,0,,When I do the relaxation, I'm not adding cost to B or whatever.
Dialogue: 0,0:10:47.52,0:10:51.76,中文,,0,0,0,,当我进行松弛时 我没有增加 B 或任何东西的成本
Dialogue: 0,0:10:51.76,0:10:58.70,英文,,0,0,0,,There's no cost to B. B is part of the tree, and D is 11 away from the tree under construction.
Dialogue: 0,0:10:51.76,0:10:58.70,中文,,0,0,0,,B 没有成本 B 是树的一部分 D 距离正在构建的树 11 个单位
Dialogue: 0,0:10:58.70,0:11:01.91,英文,,0,0,0,,OK. So I'll just run through the last couple steps.
Dialogue: 0,0:10:58.70,0:11:01.91,中文,,0,0,0,,我只运行最后几步
Dialogue: 0,0:11:01.91,0:11:11.75,英文,,0,0,0,,Let's take D. And in this case, if I check D, 2 is better than my best known way to get to E. Is it?
Dialogue: 0,0:11:01.91,0:11:11.75,中文,,0,0,0,,让我们取 D 在这种情况下 如果我检查 D 2 比我到达 E 的最佳已知方式更好 是吗？
Dialogue: 0,0:11:11.75,0:11:13.07,英文,,0,0,0,,Sorry, hold on.
Dialogue: 0,0:11:11.75,0:11:13.07,中文,,0,0,0,,抱歉 稍等
Dialogue: 0,0:11:13.07,0:11:13.79,英文,,0,0,0,,Oh, sorry.
Dialogue: 0,0:11:13.07,0:11:13.79,中文,,0,0,0,,哦 抱歉
Dialogue: 0,0:11:13.79,0:11:15.77,英文,,0,0,0,,I'm going to take, what am I doing here?
Dialogue: 0,0:11:13.79,0:11:15.77,中文,,0,0,0,,我要取 我在这里做什么？
Dialogue: 0,0:11:15.77,0:11:21.42,英文,,0,0,0,,OK, I'm taking D, sorry, and then this 1 is a better way to get to G. So I add it.
Dialogue: 0,0:11:15.77,0:11:21.42,中文,,0,0,0,,我取 D 抱歉 然后这个 1 是到达 G 的更好方式 我添加它
Dialogue: 0,0:11:21.42,0:11:22.50,英文,,0,0,0,,OK, great.
Dialogue: 0,0:11:21.42,0:11:22.50,中文,,0,0,0,,太棒了
Dialogue: 0,0:11:22.50,0:11:26.01,英文,,0,0,0,,And then I take G off the fringe.
Dialogue: 0,0:11:22.50,0:11:26.01,中文,,0,0,0,,然后我从边缘取 G
Dialogue: 0,0:11:26.01,0:11:30.21,英文,,0,0,0,,And then one is a better way to get to f. So I use this edge.
Dialogue: 0,0:11:26.01,0:11:30.21,中文,,0,0,0,,然后 1 是到达 f 的更好方式 我使用这条边
Dialogue: 0,0:11:30.21,0:11:34.51,英文,,0,0,0,,I kick out the old way to get to f. And then I take f off the fringe.
Dialogue: 0,0:11:30.21,0:11:34.51,中文,,0,0,0,,我踢出了到达 f 的旧方法 然后我从边缘取 f
Dialogue: 0,0:11:34.51,0:11:35.55,英文,,0,0,0,,Everyone is marked.
Dialogue: 0,0:11:34.51,0:11:35.55,中文,,0,0,0,,每个人都标记好了
Dialogue: 0,0:11:35.55,0:11:37.47,英文,,0,0,0,,I have my minimum spanning tree.
Dialogue: 0,0:11:35.55,0:11:37.47,中文,,0,0,0,,我的最小生成树已经完成了
Dialogue: 0,0:11:37.47,0:11:39.66,英文,,0,0,0,,Sorry, I kind of fell at the last couple of steps.
Dialogue: 0,0:11:37.47,0:11:39.66,中文,,0,0,0,,抱歉 最后几步我讲的有点磕巴
Dialogue: 0,0:11:39.66,0:11:42.40,英文,,0,0,0,,But hopefully, the overall idea is clear.
Dialogue: 0,0:11:39.66,0:11:42.40,中文,,0,0,0,,但希望整体思路是清晰的
Dialogue: 0,0:11:42.40,0:11:43.40,英文,,0,0,0,,Stop me if you have questions.
Dialogue: 0,0:11:42.40,0:11:43.40,中文,,0,0,0,,有问题就打断我
Dialogue: 0,0:11:43.40,0:11:49.26,英文,,0,0,0,,OK, shoot.
Dialogue: 0,0:11:43.40,0:11:49.26,中文,,0,0,0,,好 问吧
Dialogue: 0,0:11:49.26,0:11:52.90,英文,,0,0,0,,That's a great question, which is, do you get the same tree as Dijkstra's algorithm?
Dialogue: 0,0:11:49.26,0:11:52.90,中文,,0,0,0,,这是一个很好的问题 那就是 你会得到和 Dijkstra’s算法一样的树吗？
Dialogue: 0,0:11:52.90,0:11:58.26,英文,,0,0,0,,Sometimes you might, but in general you won't, because I'm changing the way I'm doing the relaxation.
Dialogue: 0,0:11:52.90,0:11:58.26,中文,,0,0,0,,有时候你可能会 但通常不会 因为我改变了执行 松弛 的方式
Dialogue: 0,0:11:58.26,0:12:01.54,英文,,0,0,0,,So in Dijkstra's, the relaxation check distance from source.
Dialogue: 0,0:11:58.26,0:12:01.54,中文,,0,0,0,,在 Dijkstra’s算法中 松弛 检查的是到源点的距离
Dialogue: 0,0:12:01.54,0:12:03.55,英文,,0,0,0,,Here I'm checking distance from tree.
Dialogue: 0,0:12:01.54,0:12:03.55,中文,,0,0,0,,这里我检查的是到树的距离
Dialogue: 0,0:12:03.55,0:12:06.79,英文,,0,0,0,,That's what helps you build different structures in this one.
Dialogue: 0,0:12:03.55,0:12:06.79,中文,,0,0,0,,这就是为什么在这个算法中可以构建不同的结构的原因
Dialogue: 0,0:12:06.79,0:12:08.39,英文,,0,0,0,,That's a great question, though.
Dialogue: 0,0:12:06.79,0:12:08.39,中文,,0,0,0,,不过 这是一个很好的问题
Dialogue: 0,0:12:08.39,0:12:09.83,英文,,0,0,0,,So you're not guaranteed to get the same answer.
Dialogue: 0,0:12:08.39,0:12:09.83,中文,,0,0,0,,你不一定能得到相同的答案
Dialogue: 0,0:12:09.83,0:12:13.13,英文,,0,0,0,,More questions.
Dialogue: 0,0:12:09.83,0:12:13.13,中文,,0,0,0,,还有其他问题吗？
Dialogue: 0,0:12:13.13,0:12:15.23,英文,,0,0,0,,What is the benefit of using Prim's algorithm?
Dialogue: 0,0:12:13.13,0:12:15.23,中文,,0,0,0,,使用 Prim’s 算法有什么好处？
Dialogue: 0,0:12:15.23,0:12:17.01,英文,,0,0,0,,Well, it's the only one you've seen so far.
Dialogue: 0,0:12:15.23,0:12:17.01,中文,,0,0,0,,嗯 这是你目前为止看到的唯一一种方法
Dialogue: 0,0:12:17.01,0:12:21.12,英文,,0,0,0,,So this is the only known way to compute minimum spanning trees so far.
Dialogue: 0,0:12:17.01,0:12:21.12,中文,,0,0,0,,这是到目前为止计算最小生成树的唯一已知方法
Dialogue: 0,0:12:21.12,0:12:23.46,英文,,0,0,0,,But later, I'll show you some more.
Dialogue: 0,0:12:21.12,0:12:23.46,中文,,0,0,0,,但稍后 我会给你展示更多方法
Dialogue: 0,0:12:23.46,0:12:24.20,英文,,0,0,0,,Other questions?
Dialogue: 0,0:12:23.46,0:12:24.20,中文,,0,0,0,,还有其他问题吗？
Dialogue: 0,0:12:24.20,0:12:26.53,英文,,0,0,0,,Oh, you just want to stall to get things out of scope.
Dialogue: 0,0:12:24.20,0:12:26.53,中文,,0,0,0,,哦 你只是想拖延时间 让一些内容超出范围
Dialogue: 0,0:12:26.53,0:12:32.38,英文,,0,0,0,,OK, what do you want to know? That's a great question.
Dialogue: 0,0:12:26.53,0:12:32.38,中文,,0,0,0,,好吧 你想知道什么？ 这是一个很好的问题
Dialogue: 0,0:12:32.38,0:12:34.96,英文,,0,0,0,,So Dijkstra's, will it explore the entire tree?
Dialogue: 0,0:12:32.38,0:12:34.96,中文,,0,0,0,,那么 Dijkstra’s算法会探索整个树吗？
Dialogue: 0,0:12:34.96,0:12:38.56,英文,,0,0,0,,It will explore all the reachable vertices from your source.
Dialogue: 0,0:12:34.96,0:12:38.56,中文,,0,0,0,,它会探索从源点可达的所有顶点
Dialogue: 0,0:12:38.56,0:12:45.68,英文,,0,0,0,,So in Dijkstra's, you define a source, and it helps you find all the reachable vertices from the source and gives you shortest paths to all of them.
Dialogue: 0,0:12:38.56,0:12:45.68,中文,,0,0,0,,在 Dijkstra’s算法中 你定义了一个源点 它帮助你找到从源点可达的所有顶点 并给出到所有顶点的最短路径
Dialogue: 0,0:12:45.68,0:12:49.70,英文,,0,0,0,,Okay, one more.
Dialogue: 0,0:12:45.68,0:12:49.70,中文,,0,0,0,,再来一个
Dialogue: 0,0:12:49.70,0:12:58.87,英文,,0,0,0,,A to G. Mm-hm. That's a great question.
Dialogue: 0,0:12:49.70,0:12:58.87,中文,,0,0,0,,A 到 G 嗯哼  这是一个很好的问题
Dialogue: 0,0:12:58.87,0:13:03.37,英文,,0,0,0,,Okay, so the question was here, will I choose D to G over E to G?
Dialogue: 0,0:12:58.87,0:13:03.37,中文,,0,0,0,,问题是 我会选择 D 到 G 而不是 E 到 G 吗？
Dialogue: 0,0:13:03.37,0:13:11.38,英文,,0,0,0,,Well, if I use E to G as my way to connect G to everybody else, that costs me three to connect G to the rest of the tree.
Dialogue: 0,0:13:03.37,0:13:11.38,中文,,0,0,0,,嗯 如果我用 E 到 G 作为连接 G 到其他所有节点的方式 那将花费 3 的代价将 G 连接到树的其余部分
Dialogue: 0,0:13:11.38,0:13:16.58,英文,,0,0,0,,If I instead use D to G to connect G to everybody else, it only costs me one.
Dialogue: 0,0:13:11.38,0:13:16.58,中文,,0,0,0,,如果我改为使用 D 到 G 连接 G 到其他所有节点 则只需要花费 1 的代价
Dialogue: 0,0:13:16.58,0:13:19.28,英文,,0,0,0,,This is a better way to connect G to everybody else.
Dialogue: 0,0:13:16.58,0:13:19.28,中文,,0,0,0,,这是将 G 连接到其他所有节点的更好方法
Dialogue: 0,0:13:19.28,0:13:25.85,英文,,0,0,0,,So I'll use this edge and I'll kick out E to G because it's a worse way to connect everybody else.
Dialogue: 0,0:13:19.28,0:13:25.85,中文,,0,0,0,,我将使用这条边 并将 E 到 G 踢掉 因为它是连接其他所有节点的更糟糕的方式
Dialogue: 0,0:13:25.85,0:13:27.82,英文,,0,0,0,,OK, you get one more, and that's it.
Dialogue: 0,0:13:25.85,0:13:27.82,中文,,0,0,0,,你还可以再问一个 就到这里了
Dialogue: 0,0:13:27.82,0:13:29.02,英文,,0,0,0,,OK, what's your question?
Dialogue: 0,0:13:27.82,0:13:29.02,中文,,0,0,0,,你的问题是什么？
Dialogue: 0,0:13:29.02,0:13:37.84,英文,,0,0,0,,Yeah?
Dialogue: 0,0:13:29.02,0:13:37.84,中文,,0,0,0,,是吗？
Dialogue: 0,0:13:37.84,0:13:38.60,英文,,0,0,0,,That's a good question.
Dialogue: 0,0:13:37.84,0:13:38.60,中文,,0,0,0,,这是一个好问题
Dialogue: 0,0:13:38.60,0:13:42.80,英文,,0,0,0,,So why is it the case that if I pull a vertex off the fringe, I'll go find one.
Dialogue: 0,0:13:38.60,0:13:42.80,中文,,0,0,0,,那么为什么当我从边缘拉出一个顶点时 我就会找到一个顶点呢？
Dialogue: 0,0:13:42.80,0:13:49.79,英文,,0,0,0,,OK, why is it the case that as soon as I pull C off the fringe, I know that this is the best way to get to C?
Dialogue: 0,0:13:42.80,0:13:49.79,中文,,0,0,0,,为什么当我把 C 从边缘拉出来时 我就知道这是到达 C 的最佳方式呢？
Dialogue: 0,0:13:49.79,0:13:56.24,英文,,0,0,0,,Roughly speaking, it's because, I don't know if Justin has a better answer to this one, but roughly speaking,
Dialogue: 0,0:13:49.79,0:13:56.24,中文,,0,0,0,,粗略地说 是因为 我不知道 Justin 是否对此有更好的答案 但粗略地说
Dialogue: 0,0:13:56.24,0:14:02.24,英文,,0,0,0,, it's because I'm visiting in order of distance from the tree, and C is the closest thing to the tree so far.
Dialogue: 0,0:13:56.24,0:14:02.24,中文,,0,0,0,,是因为我是按照到树的距离依次访问的 而 C 是到目前为止离树最近的东西
Dialogue: 0,0:14:02.24,0:14:09.63,英文,,0,0,0,,So I don't know if I have a better way to get to C. Does that help?
Dialogue: 0,0:14:02.24,0:14:09.63,中文,,0,0,0,,我不知道我是否有更好的方法到达 C 这有帮助吗？
Dialogue: 0,0:14:09.63,0:14:18.48,英文,,0,0,0,,Every single iteration of Prim's algorithm, we're creating a cut between the nodes that we've already looked at and the nodes that we haven't looked at.
Dialogue: 0,0:14:09.63,0:14:18.48,中文,,0,0,0,,在 Prim’s 算法的每次迭代中 我们都在我们已经看过的节点和我们还没有看过的节点之间创建一个切割
Dialogue: 0,0:14:18.48,0:14:27.34,英文,,0,0,0,,And as from before, we noted that the smallest edge that goes across the cut is guaranteed to be in at least one minimum spanning tree.
Dialogue: 0,0:14:18.48,0:14:27.34,中文,,0,0,0,,正如之前提到的 我们注意到穿过切割的最小边保证至少在一个最小生成树中
Dialogue: 0,0:14:27.34,0:14:36.52,英文,,0,0,0,,So every single time we take the minimum edge that crosses the cut, and that adds one extra vertex to our side of the connected side of the M-tree.
Dialogue: 0,0:14:27.34,0:14:36.52,中文,,0,0,0,,每次我们都取穿过切割的最小边 这会在我们的 M 树的连接侧增加一个额外的顶点
Dialogue: 0,0:14:36.52,0:14:40.08,英文,,0,0,0,,And we guarantee that that must be in the Minimum Spanning Tree.
Dialogue: 0,0:14:36.52,0:14:40.08,中文,,0,0,0,,并且我们保证它必须在最小生成树中
Dialogue: 0,0:14:40.08,0:14:41.08,英文,,0,0,0,,OK, that's a good explanation.
Dialogue: 0,0:14:40.08,0:14:41.08,中文,,0,0,0,,这是一个很好的解释
Dialogue: 0,0:14:41.08,0:14:43.46,英文,,0,0,0,,So you can use the cut property to prove it.
Dialogue: 0,0:14:41.08,0:14:43.46,中文,,0,0,0,,你可以使用切割属性来证明它
Dialogue: 0,0:14:43.46,0:14:49.09,英文,,0,0,0,,Because remember, all we're doing in Prim's algorithm, both versions, is just applying the cut property over and over again.
Dialogue: 0,0:14:43.46,0:14:49.09,中文,,0,0,0,,因为记住 我们在 Prim’s算法的两个版本中所做的只是反复应用切割属性
Dialogue: 0,0:14:49.09,0:14:54.81,英文,,0,0,0,,This one just does it in a more clever way to avoid revisiting edges over and over.
Dialogue: 0,0:14:49.09,0:14:54.81,中文,,0,0,0,,这个版本只是用一种更聪明的方式来避免一遍又一遍地访问边缘
Dialogue: 0,0:14:54.81,0:14:56.43,英文,,0,0,0,,OK, you got like five questions.
Dialogue: 0,0:14:54.81,0:14:56.43,中文,,0,0,0,,你问了大概五个问题
Dialogue: 0,0:14:56.43,0:14:57.23,英文,,0,0,0,,That's it.
Dialogue: 0,0:14:56.43,0:14:57.23,中文,,0,0,0,,就是这样
Dialogue: 0,0:14:57.23,0:15:01.49,英文,,0,0,0,,Okay, so really quickly, we mentioned PRIMs and Dijkstra's are pretty similar.
Dialogue: 0,0:14:57.23,0:15:01.49,中文,,0,0,0,,快速回顾一下 我们提到 Prim’s 和 Dijkstra’s算法非常相似
Dialogue: 0,0:15:01.49,0:15:04.92,英文,,0,0,0,,The only difference is instead of checking distance to a source, which is what we did in Dijkstra's, we said,
Dialogue: 0,0:15:01.49,0:15:04.92,中文,,0,0,0,,唯一的区别是 我们没有像 Dijkstra’s算法那样检查到源点的距离
Dialogue: 0,0:15:04.92,0:15:09.92,英文,,0,0,0,,here's the source, tell me the shortest path to everywhere else.
Dialogue: 0,0:15:04.92,0:15:09.92,中文,,0,0,0,,我们在 Dijkstra’s算法中说 这里是源点 告诉我到其他所有地方的最短路径
Dialogue: 0,0:15:09.92,0:15:16.79,英文,,0,0,0,,PRIM's algorithm said, tell me the closest edge based on distance to the tree under construction.
Dialogue: 0,0:15:09.92,0:15:16.79,中文,,0,0,0,,Prim’s 算法说 根据到正在构建的树的距离 告诉我最近的边
Dialogue: 0,0:15:16.79,0:15:18.29,英文,,0,0,0,,By the way, here's a visual.
Dialogue: 0,0:15:16.79,0:15:18.29,中文,,0,0,0,,顺便说一下 这是一个视觉效果
Dialogue: 0,0:15:18.29,0:15:21.07,英文,,0,0,0,,I'll briefly replay it if you want.
Dialogue: 0,0:15:18.29,0:15:21.07,中文,,0,0,0,,如果你想 我可以简单地重播一下
Dialogue: 0,0:15:21.07,0:15:23.39,英文,,0,0,0,,So on the right, I have Dijkstra's running.
Dialogue: 0,0:15:21.07,0:15:23.39,中文,,0,0,0,,在右边 我运行的是 Dijkstra’s算法
Dialogue: 0,0:15:23.39,0:15:24.39,英文,,0,0,0,,On the left, I have Prince.
Dialogue: 0,0:15:23.39,0:15:24.39,中文,,0,0,0,,在左边 我运行的是 Prim’s算法
Dialogue: 0,0:15:24.39,0:15:28.72,英文,,0,0,0,,And you'll see Dijkstra's has a single source, and it's branching out from the source.
Dialogue: 0,0:15:24.39,0:15:28.72,中文,,0,0,0,,你会看到 Dijkstra’s算法有一个单一的源点 并且它从源点分支出来
Dialogue: 0,0:15:28.72,0:15:33.42,英文,,0,0,0,,It's looking for all the things closer to the source and then all the things further away from the source.
Dialogue: 0,0:15:28.72,0:15:33.42,中文,,0,0,0,,它正在寻找所有离源点更近的东西 然后是所有离源点更远的东西
Dialogue: 0,0:15:33.42,0:15:36.58,英文,,0,0,0,,By contrast, Prim's algorithm, it also had to start somewhere.
Dialogue: 0,0:15:33.42,0:15:36.58,中文,,0,0,0,,相比之下 Prim’s算法也必须从某个地方开始
Dialogue: 0,0:15:36.58,0:15:42.47,英文,,0,0,0,,But you see, it's building this more skeletal structure because it's not trying to find the closest path to one vertex.
Dialogue: 0,0:15:36.58,0:15:42.47,中文,,0,0,0,,但你看到 它正在构建这种更骨骼化的结构 因为它并没有试图找到到一个顶点的最短路径
Dialogue: 0,0:15:42.47,0:15:46.27,英文,,0,0,0,,It's trying to connect up all the vertices in a minimum spanning tree.
Dialogue: 0,0:15:42.47,0:15:46.27,中文,,0,0,0,,它试图将所有顶点连接到一个最小生成树中
Dialogue: 0,0:15:46.27,0:15:47.75,英文,,0,0,0,,So I find this kind of cool.
Dialogue: 0,0:15:46.27,0:15:47.75,中文,,0,0,0,,我觉得这很酷
Dialogue: 0,0:15:47.75,0:15:49.93,英文,,0,0,0,,You can watch it go all the way to the end if you want to.
Dialogue: 0,0:15:47.75,0:15:49.93,中文,,0,0,0,,如果你想的话 你可以看到它一直运行到最后
Dialogue: 0,0:15:49.93,0:15:51.39,英文,,0,0,0,,But there you go.
Dialogue: 0,0:15:49.93,0:15:51.39,中文,,0,0,0,,就是这样
Dialogue: 0,0:15:51.39,0:15:54.14,英文,,0,0,0,,OK. That's fun.
Dialogue: 0,0:15:51.39,0:15:54.14,中文,,0,0,0,,这很有趣
Dialogue: 0,0:15:54.14,0:15:55.98,英文,,0,0,0,,OK, here's some pseudocode.
Dialogue: 0,0:15:54.14,0:15:55.98,中文,,0,0,0,,这里有一些伪代码
Dialogue: 0,0:15:55.98,0:15:58.76,英文,,0,0,0,,I will not read it in too much detail, because it's kind of like Dijkstra's.
Dialogue: 0,0:15:55.98,0:15:58.76,中文,,0,0,0,,我不会太详细地讲解它 因为它有点像 Dijkstra’s算法
Dialogue: 0,0:15:58.76,0:15:59.88,英文,,0,0,0,,You have a fringe.
Dialogue: 0,0:15:58.76,0:15:59.88,中文,,0,0,0,,你有一个边缘
Dialogue: 0,0:15:59.88,0:16:02.10,英文,,0,0,0,,You take things off the fringe.
Dialogue: 0,0:15:59.88,0:16:02.10,中文,,0,0,0,,你从边缘取东西
Dialogue: 0,0:16:02.10,0:16:03.26,英文,,0,0,0,,That's basically it.
Dialogue: 0,0:16:02.10,0:16:03.26,中文,,0,0,0,,基本上就是这样
Dialogue: 0,0:16:03.26,0:16:10.37,英文,,0,0,0,,I guess one minor thing I'll mention is that in code, the dashed lines are not actually represented in any way.
Dialogue: 0,0:16:03.26,0:16:10.37,中文,,0,0,0,,我再提个小细节 代码里这些虚线其实没啥实际意义
Dialogue: 0,0:16:10.37,0:16:17.46,英文,,0,0,0,,The dashed lines are just to remind us that this edge might be kicked out, but in the actual
Dialogue: 0,0:16:10.37,0:16:17.46,中文,,0,0,0,,虚线只是为了提醒我们这条边可能被踢掉 但在实际的
Dialogue: 0,0:16:17.46,0:16:22.86,英文,,0,0,0,,Code. This dashed line is represented by the fact, well, how do I connect D to everybody else?
Dialogue: 0,0:16:17.46,0:16:22.86,中文,,0,0,0,,代码中  这条虚线体现为 嗯 我如何将 D 连接到其他所有节点？
Dialogue: 0,0:16:22.86,0:16:26.82,英文,,0,0,0,,The best known way is to connect it to E. There might be some better way later.
Dialogue: 0,0:16:22.86,0:16:26.82,中文,,0,0,0,,目前已知最好的方法是将其连接到 E 后面可能会有更好的方法
Dialogue: 0,0:16:26.82,0:16:27.78,英文,,0,0,0,,I don't know.
Dialogue: 0,0:16:26.82,0:16:27.78,中文,,0,0,0,,谁知道呢
Dialogue: 0,0:16:27.78,0:16:29.66,英文,,0,0,0,,So that's how I represent it in memory.
Dialogue: 0,0:16:27.78,0:16:29.66,中文,,0,0,0,,这就是我在内存中表示它的方式
Dialogue: 0,0:16:29.66,0:16:33.82,英文,,0,0,0,,But there's nothing special about the dashed line or making it solid.
Dialogue: 0,0:16:29.66,0:16:33.82,中文,,0,0,0,,但是虚线或实线并没有什么特别的
Dialogue: 0,0:16:33.82,0:16:36.96,英文,,0,0,0,,That's just to remind ourselves this edge might get kicked out.
Dialogue: 0,0:16:33.82,0:16:36.96,中文,,0,0,0,,这只是为了提醒我们这条边可能被踢掉
Dialogue: 0,0:16:36.96,0:16:39.30,英文,,0,0,0,,These edges will never get kicked out.
Dialogue: 0,0:16:36.96,0:16:39.30,中文,,0,0,0,,这些边永远不会被踢掉
Dialogue: 0,0:16:39.30,0:16:42.37,英文,,0,0,0,,OK, so just wanted to bring that up.
Dialogue: 0,0:16:39.30,0:16:42.37,中文,,0,0,0,,只是想提一下
Dialogue: 0,0:16:42.37,0:16:44.01,英文,,0,0,0,,But there's the pseudocode.
Dialogue: 0,0:16:42.37,0:16:44.01,中文,,0,0,0,,但这就是伪代码
Dialogue: 0,0:16:44.01,0:16:46.01,英文,,0,0,0,,We'll not read it in detail.
Dialogue: 0,0:16:44.01,0:16:46.01,中文,,0,0,0,,我们不会详细阅读它
Dialogue: 0,0:16:46.01,0:16:51.68,英文,,0,0,0,,OK, the runtime, I will also speedrun this because it's basically the same as Dijkstra's algorithm.
Dialogue: 0,0:16:46.01,0:16:51.68,中文,,0,0,0,,运行时间 我也会快速讲一下 因为它和 Dijkstra’s算法基本一样
Dialogue: 0,0:16:51.68,0:16:59.70,英文,,0,0,0,,This slide is more or less copied from Dijkstra's algorithm because it's pretty much doing the same thing, which is you add everything to the priority queue.
Dialogue: 0,0:16:51.68,0:16:59.70,中文,,0,0,0,,这张幻灯片或多或少是从 Dijkstra’s算法复制过来的 因为它做的几乎是同样的事情 那就是将所有内容添加到优先队列中
Dialogue: 0,0:16:59.70,0:17:02.62,英文,,0,0,0,,you delete everything from the priority queue one by one.
Dialogue: 0,0:16:59.70,0:17:02.62,中文,,0,0,0,,你从优先队列中逐个删除所有内容
Dialogue: 0,0:17:02.62,0:17:05.79,英文,,0,0,0,,And for every single edge, you might have to relax it.
Dialogue: 0,0:17:02.62,0:17:05.79,中文,,0,0,0,,对于每条边 你可能都需要放松它
Dialogue: 0,0:17:05.79,0:17:10.91,英文,,0,0,0,,And when you relax an edge, you need to go and change the priority in the priority queue.
Dialogue: 0,0:17:05.79,0:17:10.91,中文,,0,0,0,,当你放松一条边时 你需要去改变优先队列中的优先级
Dialogue: 0,0:17:10.91,0:17:17.31,英文,,0,0,0,,So this is the exact same analysis as Dijkstra's algorithm because it basically is doing the same thing as Dijkstra's algorithm.
Dialogue: 0,0:17:10.91,0:17:17.31,中文,,0,0,0,,这和 Dijkstra’s算法的分析完全一样 因为它基本上和 Dijkstra’s算法做的是同样的事情
Dialogue: 0,0:17:17.31,0:17:21.58,英文,,0,0,0,,We just changed a tiny little thing about how the relaxation works.
Dialogue: 0,0:17:17.31,0:17:21.58,中文,,0,0,0,,我们只是稍微改变了放松工作的方式
Dialogue: 0,0:17:21.58,0:17:25.50,英文,,0,0,0,,Okay. Same runtime, same sum as last time.
Dialogue: 0,0:17:21.58,0:17:25.50,中文,,0,0,0,,相同的运行时间 与上次相同的总和
Dialogue: 0,0:17:25.50,0:17:28.41,英文,,0,0,0,,Okay. That's all for Prim's algorithm.
Dialogue: 0,0:17:25.50,0:17:28.41,中文,,0,0,0,,这就是 Prim’s算法的全部内容
Dialogue: 0,0:17:28.41,0:17:30.31,英文,,0,0,0,,So you saw two versions of it.
Dialogue: 0,0:17:28.41,0:17:30.31,中文,,0,0,0,,你看到了它的两个版本
Dialogue: 0,0:17:30.31,0:17:33.73,英文,,0,0,0,,I know they look different, but I promise you they're the same deep down.
Dialogue: 0,0:17:30.31,0:17:33.73,中文,,0,0,0,,我知道它们看起来不一样 但我保证它们本质上是一样的
Dialogue: 0,0:17:33.73,0:17:40.54,英文,,0,0,0,,Is everyone ready for Kruskal's algorithm, which is another way to explore minimum spanning trees?
Dialogue: 0,0:17:33.73,0:17:40.54,中文,,0,0,0,,大家准备好学习 Kruskal’s算法了吗？这是探索最小生成树的另一种方法
Dialogue: 0,0:17:40.54,0:17:43.42,英文,,0,0,0,,OK, so Kruskal's is actually a good deal simpler.
Dialogue: 0,0:17:40.54,0:17:43.42,中文,,0,0,0,,Kruskal’s算法实际上要简单得多
Dialogue: 0,0:17:43.42,0:17:44.94,英文,,0,0,0,,So I think you'll like it.
Dialogue: 0,0:17:43.42,0:17:44.94,中文,,0,0,0,,我想你会喜欢的
Dialogue: 0,0:17:44.94,0:17:46.70,英文,,0,0,0,,So here's all I have to do.
Dialogue: 0,0:17:44.94,0:17:46.70,中文,,0,0,0,,我只需要做这些
Dialogue: 0,0:17:46.70,0:17:49.00,英文,,0,0,0,,So I'll just show it to you because it's so simple.
Dialogue: 0,0:17:46.70,0:17:49.00,中文,,0,0,0,,我会直接演示给你看 因为它非常简单
Dialogue: 0,0:17:49.00,0:17:53.75,英文,,0,0,0,,I will take all of the edges, and I'll sort them in order of weight.
Dialogue: 0,0:17:49.00,0:17:53.75,中文,,0,0,0,,我会取所有边 并将它们按权重排序
Dialogue: 0,0:17:53.75,0:17:58.43,英文,,0,0,0,,So here are all of my edges, and I sorted them from the least weight to the most weight.
Dialogue: 0,0:17:53.75,0:17:58.43,中文,,0,0,0,,这里是我的所有边 我将它们从权重最小到权重最大排序
Dialogue: 0,0:17:58.43,0:18:02.91,英文,,0,0,0,,And all I have to do is start at the beginning and check them one by one by one.
Dialogue: 0,0:17:58.43,0:18:02.91,中文,,0,0,0,,我所要做的就是从头开始 逐一检查它们
Dialogue: 0,0:18:02.91,0:18:06.67,英文,,0,0,0,,And I will add an edge to the tree unless I find a cycle.
Dialogue: 0,0:18:02.91,0:18:06.67,中文,,0,0,0,,除非我找到一个循环 否则我会向树中添加一条边
Dialogue: 0,0:18:06.67,0:18:09.93,英文,,0,0,0,,Because if adding an edge creates a cycle, I don't need that edge.
Dialogue: 0,0:18:06.67,0:18:09.93,中文,,0,0,0,,因为如果添加一条边会创建一个循环 那么我就不需要那条边
Dialogue: 0,0:18:09.93,0:18:11.90,英文,,0,0,0,,So let's watch it in action.
Dialogue: 0,0:18:09.93,0:18:11.90,中文,,0,0,0,,让我们看看它是如何工作的
Dialogue: 0,0:18:11.90,0:18:13.44,英文,,0,0,0,,I start at the beginning.
Dialogue: 0,0:18:11.90,0:18:13.44,中文,,0,0,0,,我从头开始
Dialogue: 0,0:18:13.44,0:18:16.62,英文,,0,0,0,,A to C, does that create a cycle?
Dialogue: 0,0:18:13.44,0:18:16.62,中文,,0,0,0,,A 到 C 这会创建一个循环吗？
Dialogue: 0,0:18:16.62,0:18:16.96,英文,,0,0,0,,No.
Dialogue: 0,0:18:16.62,0:18:16.96,中文,,0,0,0,,不会
Dialogue: 0,0:18:16.96,0:18:18.78,英文,,0,0,0,,So I can add A to C.
Dialogue: 0,0:18:16.96,0:18:18.78,中文,,0,0,0,,我能添加 A 到 C
Dialogue: 0,0:18:18.78,0:18:21.11,英文,,0,0,0,,Welcome to the Minimum Spanning Tree.
Dialogue: 0,0:18:18.78,0:18:21.11,中文,,0,0,0,,欢迎来到最小生成树
Dialogue: 0,0:18:21.11,0:18:23.77,英文,,0,0,0,,C to E, will adding this create a cycle?
Dialogue: 0,0:18:21.11,0:18:23.77,中文,,0,0,0,,C 到 E 添加这个会创建一个循环吗？
Dialogue: 0,0:18:23.77,0:18:24.43,英文,,0,0,0,,No.
Dialogue: 0,0:18:23.77,0:18:24.43,中文,,0,0,0,,不会
Dialogue: 0,0:18:24.43,0:18:27.71,英文,,0,0,0,,So I'll add it to the Minimum Spanning Tree.
Dialogue: 0,0:18:24.43,0:18:27.71,中文,,0,0,0,,我会把它添加到最小生成树中
Dialogue: 0,0:18:27.71,0:18:30.97,英文,,0,0,0,,D to G, will that add a cycle?
Dialogue: 0,0:18:27.71,0:18:30.97,中文,,0,0,0,,D 到 G 这会添加一个循环吗？
Dialogue: 0,0:18:30.97,0:18:31.49,英文,,0,0,0,,Nope.
Dialogue: 0,0:18:30.97,0:18:31.49,中文,,0,0,0,,不会
Dialogue: 0,0:18:31.49,0:18:33.39,英文,,0,0,0,,So I'll add it to the Minimum Spanning Tree.
Dialogue: 0,0:18:31.49,0:18:33.39,中文,,0,0,0,,我会把它添加到最小生成树中
Dialogue: 0,0:18:33.39,0:18:43.01,英文,,0,0,0,,By the way, one thing you'll notice at this point is that Kruskal's algorithm will sometimes have a disconnected graph or a disconnected tree under construction.
Dialogue: 0,0:18:33.39,0:18:43.01,中文,,0,0,0,,顺便说一句 此时你会注意到的一件事是 Kruskal’s算法有时在构建过程中会生成一个断开的图或树
Dialogue: 0,0:18:43.01,0:18:46.06,英文,,0,0,0,,So look, I have this edge, this edge, and this edge.
Dialogue: 0,0:18:43.01,0:18:46.06,中文,,0,0,0,,你看 我有这条边、这条边和这条边
Dialogue: 0,0:18:46.06,0:18:48.64,英文,,0,0,0,,And they're not all connected yet, but that's OK.
Dialogue: 0,0:18:46.06,0:18:48.64,中文,,0,0,0,,它们还没有全部连接起来 但这没关系
Dialogue: 0,0:18:48.64,0:18:52.16,英文,,0,0,0,,Because when I finish, all of the edges will be connected.
Dialogue: 0,0:18:48.64,0:18:52.16,中文,,0,0,0,,因为当我完成时 所有边都会连接起来
Dialogue: 0,0:18:52.16,0:18:55.98,英文,,0,0,0,,But sometimes it hops around a little bit, so it has more of a hoppy feeling.
Dialogue: 0,0:18:52.16,0:18:55.98,中文,,0,0,0,,但有时它会跳来跳去 它给人的感觉更像是跳跃
Dialogue: 0,0:18:55.98,0:18:57.44,英文,,0,0,0,,And that's OK, too.
Dialogue: 0,0:18:55.98,0:18:57.44,中文,,0,0,0,,那也没关系
Dialogue: 0,0:18:57.44,0:18:58.58,英文,,0,0,0,,OK, let's keep going.
Dialogue: 0,0:18:57.44,0:18:58.58,中文,,0,0,0,,让我们继续
Dialogue: 0,0:18:58.58,0:19:02.76,英文,,0,0,0,,F to G, are you part of the minimum spanning tree?
Dialogue: 0,0:18:58.58,0:19:02.76,中文,,0,0,0,,F 到 G 你是最小生成树的一部分吗？
Dialogue: 0,0:19:02.76,0:19:03.78,英文,,0,0,0,,Do you create a cycle?
Dialogue: 0,0:19:02.76,0:19:03.78,中文,,0,0,0,,你会创建一个循环吗？
Dialogue: 0,0:19:03.78,0:19:04.44,英文,,0,0,0,,No.
Dialogue: 0,0:19:03.78,0:19:04.44,中文,,0,0,0,,不会
Dialogue: 0,0:19:04.44,0:19:06.63,英文,,0,0,0,,So I can add you to the tree.
Dialogue: 0,0:19:04.44,0:19:06.63,中文,,0,0,0,,我能把你添加到树中
Dialogue: 0,0:19:06.63,0:19:08.61,英文,,0,0,0,,A to B, do you create a cycle?
Dialogue: 0,0:19:06.63,0:19:08.61,中文,,0,0,0,,A 到 B 你会创建一个循环吗？
Dialogue: 0,0:19:08.61,0:19:10.00,英文,,0,0,0,,No.
Dialogue: 0,0:19:08.61,0:19:10.00,中文,,0,0,0,,不会
Dialogue: 0,0:19:10.00,0:19:12.65,英文,,0,0,0,,E to B, OK, finally something interesting happens.
Dialogue: 0,0:19:10.00,0:19:12.65,中文,,0,0,0,,E 到 B 终于发生了一些有趣的事情
Dialogue: 0,0:19:12.65,0:19:18.59,英文,,0,0,0,,Do I want to add E to B into my minimum spanning tree?
Dialogue: 0,0:19:12.65,0:19:18.59,中文,,0,0,0,,我想把 E 到 B 添加到我的最小生成树中吗？
Dialogue: 0,0:19:18.59,0:19:28.74,英文,,0,0,0,,No, because if I add E to B, I create this cycle, C to E to B to A, C to E to B to A. I don't want this edge, because it creates a cycle.
Dialogue: 0,0:19:18.59,0:19:28.74,中文,,0,0,0,,不 因为如果我添加 E 到 B 就会创建这个循环 C 到 E 到 B 到 A C 到 E 到 B 到 A 我不想要这条边 因为它创建了一个循环
Dialogue: 0,0:19:28.74,0:19:31.79,英文,,0,0,0,,So we throw you out, we skip you, and we go on.
Dialogue: 0,0:19:28.74,0:19:31.79,中文,,0,0,0,,我们把你扔出去 跳过你 继续前进
Dialogue: 0,0:19:31.79,0:19:37.87,英文,,0,0,0,,OK. D to E does not create a cycle, so we add U. And at this point, we can stop.
Dialogue: 0,0:19:31.79,0:19:37.87,中文,,0,0,0,,D 到 E 不会创建循环 我们添加 U 此时 我们可以停止了
Dialogue: 0,0:19:37.87,0:19:41.97,英文,,0,0,0,,Because I look, all of the edges are touched by my minimum spanning tree.
Dialogue: 0,0:19:37.87,0:19:41.97,中文,,0,0,0,,因为你看 所有边都被我的最小生成树触及了
Dialogue: 0,0:19:41.97,0:19:45.59,英文,,0,0,0,,Another equivalent way of saying that is I have V minus 1 edges.
Dialogue: 0,0:19:41.97,0:19:45.59,中文,,0,0,0,,另一种等效的说法是我有 V-1 条边
Dialogue: 0,0:19:45.59,0:19:49.20,英文,,0,0,0,,So everybody has been connected by the tree.
Dialogue: 0,0:19:45.59,0:19:49.20,中文,,0,0,0,,每个节点都已经被树连接起来了
Dialogue: 0,0:19:49.20,0:19:50.34,英文,,0,0,0,,So I'm done.
Dialogue: 0,0:19:49.20,0:19:50.34,中文,,0,0,0,,我完成了
Dialogue: 0,0:19:50.34,0:19:52.76,英文,,0,0,0,,I don't even have to look at the rest of these edges.
Dialogue: 0,0:19:50.34,0:19:52.76,中文,,0,0,0,,我甚至不用看剩下的这些边了
Dialogue: 0,0:19:52.76,0:19:53.34,英文,,0,0,0,,So that's it.
Dialogue: 0,0:19:52.76,0:19:53.34,中文,,0,0,0,,就是这样
Dialogue: 0,0:19:53.34,0:19:55.24,英文,,0,0,0,,You look at all the edges one by one.
Dialogue: 0,0:19:53.34,0:19:55.24,中文,,0,0,0,,你逐一查看所有边
Dialogue: 0,0:19:55.24,0:19:58.24,英文,,0,0,0,,And if it doesn't create a cycle, you add the edge.
Dialogue: 0,0:19:55.24,0:19:58.24,中文,,0,0,0,,如果它没有创建循环 就添加这条边
Dialogue: 0,0:19:58.24,0:19:59.44,英文,,0,0,0,,That's it.
Dialogue: 0,0:19:58.24,0:19:59.44,中文,,0,0,0,,就是这样
Dialogue: 0,0:19:59.44,0:20:06.21,英文,,0,0,0,,One tiny little note, this is another one of those things where when you first see the algorithm, it seems kind of mysterious.
Dialogue: 0,0:19:59.44,0:20:06.21,中文,,0,0,0,,一个小小的注意事项 这是另一个当你第一次看到这个算法时 它看起来有点神秘的事情之一
Dialogue: 0,0:20:06.21,0:20:08.29,英文,,0,0,0,,Maybe you have to think about it a little bit more.
Dialogue: 0,0:20:06.21,0:20:08.29,中文,,0,0,0,,也许你需要多考虑一下
Dialogue: 0,0:20:08.29,0:20:13.43,英文,,0,0,0,,But Kruskal's algorithm, I think it's simpler to explain without the cut property, to be honest.
Dialogue: 0,0:20:08.29,0:20:13.43,中文,,0,0,0,,但老实说 我认为 Kruskal’s算法在没有切割属性的情况下更容易解释
Dialogue: 0,0:20:13.43,0:20:20.41,英文,,0,0,0,,But secretly, Kruskal's algorithm is using the cut property in disguise, even though we didn't show it.
Dialogue: 0,0:20:13.43,0:20:20.41,中文,,0,0,0,,但暗地里 Kruskal’s算法是在伪装下使用切割属性 即使我们没有展示它
Dialogue: 0,0:20:20.41,0:20:28.37,英文,,0,0,0,,And if you're curious, you can look at the white and the green markings to see what cut Kruskal's algorithm is thinking about.
Dialogue: 0,0:20:20.41,0:20:28.37,中文,,0,0,0,,如果你好奇的话 你可以看看白色和绿色的标记 看看 Kruskal’s算法在考虑什么切割
Dialogue: 0,0:20:28.37,0:20:39.96,英文,,0,0,0,,Specifically, Kruskal's algorithm is usually thinking about all of, like, one side of the cut is everything connected to, OK, so let's say I'm considering D to G.
Dialogue: 0,0:20:28.37,0:20:39.96,中文,,0,0,0,,具体来说 Kruskal’s算法通常会考虑所有切割的一侧 比如 连接到 假设我正在考虑 D 到 G
Dialogue: 0,0:20:39.96,0:20:52.96,英文,,0,0,0,, I pick either D or G, and I consider all of the edges coming out of D, or all the vertices connected to D, that's one of the cuts, and then everyone else is the other side of the cut.
Dialogue: 0,0:20:39.96,0:20:52.96,中文,,0,0,0,,我选择 D 或 G 并考虑所有从 D 出发的边 或所有连接到 D 的顶点 这是一侧切割 然后其他所有节点都是另一侧切割
Dialogue: 0,0:20:52.96,0:20:57.58,英文,,0,0,0,,Sorry, I'm going to flip that a little bit, but basically,
Dialogue: 0,0:20:52.96,0:20:57.58,中文,,0,0,0,,抱歉 我会稍微改一下说法 但基本上
Dialogue: 0,0:20:57.58,0:21:00.27,英文,,0,0,0,,That's the cut being considered by Kruskal's algorithm.
Dialogue: 0,0:20:57.58,0:21:00.27,中文,,0,0,0,,这就是 Kruskal’s算法所考虑的切割
Dialogue: 0,0:21:00.27,0:21:01.71,英文,,0,0,0,,I guess I'll try it one more time.
Dialogue: 0,0:21:00.27,0:21:01.71,中文,,0,0,0,,我想我会再试一次
Dialogue: 0,0:21:01.71,0:21:05.49,英文,,0,0,0,,But it's not the key to understanding Kruskal's algorithm, so don't worry about it too much.
Dialogue: 0,0:21:01.71,0:21:05.49,中文,,0,0,0,,但这并不是理解 Kruskal’s算法的关键 不要太担心
Dialogue: 0,0:21:05.49,0:21:10.95,英文,,0,0,0,,But the key idea is the cut that Kruskal's algorithm is thinking about is
Dialogue: 0,0:21:05.49,0:21:10.95,中文,,0,0,0,,但关键思想是 Kruskal’s算法所考虑的切割是
Dialogue: 0,0:21:10.95,0:21:17.19,英文,,0,0,0,,Let's see, so if I have an edge like F to G, I consider one of the edges F as part of the cut.
Dialogue: 0,0:21:10.95,0:21:17.19,中文,,0,0,0,,让我们看看 如果我有一条像 F 到 G 的边 我会认为其中一条边 F 是切割的一部分
Dialogue: 0,0:21:17.19,0:21:25.27,英文,,0,0,0,,And everybody who is connected to F, who is connected through edges that are in the minimum spanning tree, that's one side of the cut.
Dialogue: 0,0:21:17.19,0:21:25.27,中文,,0,0,0,,以及所有通过最小生成树中的边连接到 F 的节点 这是一侧切割
Dialogue: 0,0:21:25.27,0:21:28.03,英文,,0,0,0,,And everyone else is the other side of the cut.
Dialogue: 0,0:21:25.27,0:21:28.03,中文,,0,0,0,,而其他所有节点都是另一侧切割
Dialogue: 0,0:21:28.03,0:21:31.48,英文,,0,0,0,,I'll be honest, it's a little bit confusing, but that's the cut being considered.
Dialogue: 0,0:21:28.03,0:21:31.48,中文,,0,0,0,,老实说 这有点令人困惑 但这就是所考虑的切割
Dialogue: 0,0:21:31.48,0:21:33.42,英文,,0,0,0,,Okay, maybe here's a better example.
Dialogue: 0,0:21:31.48,0:21:33.42,中文,,0,0,0,,也许这是一个更好的例子
Dialogue: 0,0:21:33.42,0:21:41.62,英文,,0,0,0,,If I look at this edge and I look at C, C and A are both part of the minimum spanning tree, so they are one side of the cut.
Dialogue: 0,0:21:33.42,0:21:41.62,中文,,0,0,0,,如果我查看这条边并查看 C C 和 A 都是最小生成树的一部分 它们是一侧切割
Dialogue: 0,0:21:41.62,0:21:43.42,英文,,0,0,0,,So I have C, part of the cut.
Dialogue: 0,0:21:41.62,0:21:43.42,中文,,0,0,0,,我把 C 作为切割的一部分
Dialogue: 0,0:21:43.42,0:21:47.21,英文,,0,0,0,,A is connected to C through the MST, so it's also part of the cut.
Dialogue: 0,0:21:43.42,0:21:47.21,中文,,0,0,0,,A 通过 MST 连接到 C 它也是切割的一部分
Dialogue: 0,0:21:47.21,0:21:48.99,英文,,0,0,0,,Everyone else is not part of the cut.
Dialogue: 0,0:21:47.21,0:21:48.99,中文,,0,0,0,,其他所有节点都不是切割的一部分
Dialogue: 0,0:21:48.99,0:21:58.01,英文,,0,0,0,,It's honestly kind of an obscure cut, and I think it makes more sense just to consider I go through all the edges from smallest to largest, so I'll get the minimum spanning tree.
Dialogue: 0,0:21:48.99,0:21:58.01,中文,,0,0,0,,说真的 这个切分有点难理解 我觉得考虑所有边 从最小到最大更合理 这样就能得到最小生成树
Dialogue: 0,0:21:58.01,0:22:01.54,英文,,0,0,0,,But if you're really curious, that's the cut being thought about.
Dialogue: 0,0:21:58.01,0:22:01.54,中文,,0,0,0,,但如果你真的好奇 那就是我考虑的切分
Dialogue: 0,0:22:01.54,0:22:05.98,英文,,0,0,0,,Question?
Dialogue: 0,0:22:01.54,0:22:05.98,中文,,0,0,0,,有疑问吗？
Dialogue: 0,0:22:05.98,0:22:08.14,英文,,0,0,0,,Great question, which I'll answer in the next slide.
Dialogue: 0,0:22:05.98,0:22:08.14,中文,,0,0,0,,好问题 我将在下一张幻灯片中回答
Dialogue: 0,0:22:08.14,0:22:12.17,英文,,0,0,0,,You thought you were going to stall me, but you're just moving me forward.
Dialogue: 0,0:22:08.14,0:22:12.17,中文,,0,0,0,,你以为你会拖住我 但你只是在推动我前进
Dialogue: 0,0:22:12.17,0:22:17.45,英文,,0,0,0,,OK, so Kruskal's algorithm, initially no edges, and I add them one by one.
Dialogue: 0,0:22:12.17,0:22:17.45,中文,,0,0,0,, Kruskal’s算法 最初没有边 我一条一条地添加它们
Dialogue: 0,0:22:17.45,0:22:20.27,英文,,0,0,0,,And here's the cut that I was trying to talk about.
Dialogue: 0,0:22:17.45,0:22:20.27,中文,,0,0,0,,这就是我刚才要讲的切分
Dialogue: 0,0:22:20.27,0:22:23.03,英文,,0,0,0,,If I maybe flubbed it a little bit, there it is in writing.
Dialogue: 0,0:22:20.27,0:22:23.03,中文,,0,0,0,,如果我可能说得有点不清楚 这里有书面说明
Dialogue: 0,0:22:23.03,0:22:26.80,英文,,0,0,0,,So the question that someone asked earlier is, how do you keep track if there's a cycle?
Dialogue: 0,0:22:23.03,0:22:26.80,中文,,0,0,0,,有人之前问的问题是 如何判断是否存在环？
Dialogue: 0,0:22:26.80,0:22:33.26,英文,,0,0,0,,Well, remember last time there was a warm-up where I asked you, if I give you a graph, does it contain cycles?
Dialogue: 0,0:22:26.80,0:22:33.26,中文,,0,0,0,,好吧 还记得上次有一个热身活动 我问你 如果我给你一个图 它是否包含环？
Dialogue: 0,0:22:33.26,0:22:38.69,英文,,0,0,0,,You can actually use either of those algorithms to check if the graph contains a cycle.
Dialogue: 0,0:22:33.26,0:22:38.69,中文,,0,0,0,,你实际上可以使用这两种算法中的任何一种来检查图中是否包含环
Dialogue: 0,0:22:38.69,0:22:42.03,英文,,0,0,0,,And in fact, that's what I'm going to do here.
Dialogue: 0,0:22:38.69,0:22:42.03,中文,,0,0,0,,事实上 这就是我将要在这里做的事情
Dialogue: 0,0:22:42.03,0:22:45.97,英文,,0,0,0,,I'm still going to consider all of the edges one by one.
Dialogue: 0,0:22:42.03,0:22:45.97,中文,,0,0,0,,我仍然会一条一条地考虑所有的边
Dialogue: 0,0:22:45.97,0:22:54.57,英文,,0,0,0,,And here I'm just doing Kruskal's algorithm again, but actually implementing it in a way that you could write in code, as opposed to just looking at the pictures.
Dialogue: 0,0:22:45.97,0:22:54.57,中文,,0,0,0,,在这里 我再次使用 Kruskal’s算法 但实际上是以一种可以用代码编写的方式来实现它 而不是仅仅看图片
Dialogue: 0,0:22:54.57,0:22:59.74,英文,,0,0,0,,So the first thing I have to do is think about, how do I get all the edges in order of weight?
Dialogue: 0,0:22:54.57,0:22:59.74,中文,,0,0,0,,我首先要考虑的是 如何按权重顺序获取所有边？
Dialogue: 0,0:22:59.74,0:23:04.68,英文,,0,0,0,,So how do I get the smallest edges, and then the next smallest edge, and then the next smallest edge?
Dialogue: 0,0:22:59.74,0:23:04.68,中文,,0,0,0,,那么如何获得最小的边 然后是次小的边 然后是再次小的边呢？
Dialogue: 0,0:23:04.68,0:23:10.14,英文,,0,0,0,,Well, I can use a fringe or a priority queue to help me with that.
Dialogue: 0,0:23:04.68,0:23:10.14,中文,,0,0,0,,好吧 我可以使用一个边缘队列或一个优先队列来帮助我做到这一点
Dialogue: 0,0:23:10.14,0:23:15.38,英文,,0,0,0,,Remember, a priority queue lets you grab the smallest item in a collection of items over and over again.
Dialogue: 0,0:23:10.14,0:23:15.38,中文,,0,0,0,,记住 优先队列允许你反复地从一组项目中获取最小的项目
Dialogue: 0,0:23:15.38,0:23:23.51,英文,,0,0,0,,So what I could do is I could insert all of the edges into the priority queue and then pull out items from the priority queue one by one.
Dialogue: 0,0:23:15.38,0:23:23.51,中文,,0,0,0,,我可以做的是 我可以将所有的边插入到优先队列中 然后一条一条地从优先队列中取出项目
Dialogue: 0,0:23:23.51,0:23:26.95,英文,,0,0,0,,That will give me all the edges from smallest to largest.
Dialogue: 0,0:23:23.51,0:23:26.95,中文,,0,0,0,,这将给我所有从最小到最大的边
Dialogue: 0,0:23:26.95,0:23:34.86,英文,,0,0,0,,So one of my data structures to help me is a priority queue to keep track of the smallest edge that I need to check so far.
Dialogue: 0,0:23:26.95,0:23:34.86,中文,,0,0,0,,因此 帮助我的数据结构之一是优先队列 用于跟踪到目前为止我需要检查的最小边
Dialogue: 0,0:23:34.86,0:23:35.92,英文,,0,0,0,,That's great.
Dialogue: 0,0:23:34.86,0:23:35.92,中文,,0,0,0,,那太好了
Dialogue: 0,0:23:35.92,0:23:42.16,英文,,0,0,0,,And then the other data structure I'll use, so I'm using two data structures, priority queue first,
Dialogue: 0,0:23:35.92,0:23:42.16,中文,,0,0,0,,然后我将使用的另一个数据结构 我使用了两个数据结构 首先是优先队列
Dialogue: 0,0:23:42.16,0:23:48.16,英文,,0,0,0,,and then the other data structure I get to use is my weighted quick union, the disjoint sets data structure.
Dialogue: 0,0:23:42.16,0:23:48.16,中文,,0,0,0,,然后我使用的另一个数据结构是我的加权快速合并 即不相交集数据结构
Dialogue: 0,0:23:48.16,0:23:56.33,英文,,0,0,0,,And this is because I remember my trick from last lecture, which is that I can use a weighted quick union to remember if my graph has cycles.
Dialogue: 0,0:23:48.16,0:23:56.33,中文,,0,0,0,,这是因为我记得上一节课的技巧 我可以使用加权快速合并来记住我的图中是否有环
Dialogue: 0,0:23:56.33,0:23:58.23,英文,,0,0,0,,So let's give it a try.
Dialogue: 0,0:23:56.33,0:23:58.23,中文,,0,0,0,,让我们试试吧
Dialogue: 0,0:23:58.23,0:24:01.07,英文,,0,0,0,,Here are all my edges in order of weight.
Dialogue: 0,0:23:58.23,0:24:01.07,中文,,0,0,0,,这是我所有按权重排序的边
Dialogue: 0,0:24:01.07,0:24:05.82,英文,,0,0,0,,You can also think of it as I threw them all into a priority queue and I'm pulling them out one by one.
Dialogue: 0,0:24:01.07,0:24:05.82,中文,,0,0,0,,你也可以认为我把它们都扔进了一个优先队列 然后一条一条地取出它们
Dialogue: 0,0:24:05.82,0:24:10.16,英文,,0,0,0,,The priority queue will give me the smallest weight edge every single time.
Dialogue: 0,0:24:05.82,0:24:10.16,中文,,0,0,0,,优先队列每次都会给我权重最小的边
Dialogue: 0,0:24:10.16,0:24:11.66,英文,,0,0,0,,So here's the edge.
Dialogue: 0,0:24:10.16,0:24:11.66,中文,,0,0,0,,这是这条边
Dialogue: 0,0:24:11.66,0:24:13.14,英文,,0,0,0,,Does it create a cycle?
Dialogue: 0,0:24:11.66,0:24:13.14,中文,,0,0,0,,它会创建环吗？
Dialogue: 0,0:24:13.14,0:24:14.26,英文,,0,0,0,,No.
Dialogue: 0,0:24:13.14,0:24:14.26,中文,,0,0,0,,不会
Dialogue: 0,0:24:14.26,0:24:18.27,英文,,0,0,0,,And now I'm going to remind myself using the weighted quick union.
Dialogue: 0,0:24:14.26,0:24:18.27,中文,,0,0,0,,现在我要用加权快速合并来提醒我自己
Dialogue: 0,0:24:18.27,0:24:21.05,英文,,0,0,0,,By the way, A and C are now connected.
Dialogue: 0,0:24:18.27,0:24:21.05,中文,,0,0,0,,顺便说一下 A 和 C 现在连接起来了
Dialogue: 0,0:24:21.05,0:24:22.45,英文,,0,0,0,,That's what the weighted quick union says.
Dialogue: 0,0:24:21.05,0:24:22.45,中文,,0,0,0,,这就是加权快速合并所说的
Dialogue: 0,0:24:22.45,0:24:24.35,英文,,0,0,0,,It says A and C are now connected.
Dialogue: 0,0:24:22.45,0:24:24.35,中文,,0,0,0,,它说 A 和 C 现在连接起来了
Dialogue: 0,0:24:24.35,0:24:25.71,英文,,0,0,0,,So please remember that.
Dialogue: 0,0:24:24.35,0:24:25.71,中文,,0,0,0,,请记住这一点
Dialogue: 0,0:24:25.71,0:24:28.31,英文,,0,0,0,,OK, let's go to C to E.
Dialogue: 0,0:24:25.71,0:24:28.31,中文,,0,0,0,,让我们转到 C 到 E
Dialogue: 0,0:24:28.31,0:24:30.51,英文,,0,0,0,,Do you create a cycle if I add this edge?
Dialogue: 0,0:24:28.31,0:24:30.51,中文,,0,0,0,,如果我添加这条边 你会创建环吗？
Dialogue: 0,0:24:30.51,0:24:31.17,英文,,0,0,0,,No.
Dialogue: 0,0:24:30.51,0:24:31.17,中文,,0,0,0,,不会
Dialogue: 0,0:24:31.17,0:24:32.83,英文,,0,0,0,,So it's safe to add this edge.
Dialogue: 0,0:24:31.17,0:24:32.83,中文,,0,0,0,,添加这条边是安全的
Dialogue: 0,0:24:32.83,0:24:39.10,英文,,0,0,0,,And I'll use my weighted quick union to remind myself A, C, and E are all connected.
Dialogue: 0,0:24:32.83,0:24:39.10,中文,,0,0,0,,我将使用我的加权快速合并来提醒自己 A、C 和 E 都是连接的
Dialogue: 0,0:24:39.10,0:24:41.62,英文,,0,0,0,,They're all part of the same group.
Dialogue: 0,0:24:39.10,0:24:41.62,中文,,0,0,0,,它们都是同一组的一部分
Dialogue: 0,0:24:41.62,0:24:43.44,英文,,0,0,0,,OK. I keep going.
Dialogue: 0,0:24:41.62,0:24:43.44,中文,,0,0,0,,我继续
Dialogue: 0,0:24:43.44,0:24:45.52,英文,,0,0,0,,D to G does not create a cycle.
Dialogue: 0,0:24:43.44,0:24:45.52,中文,,0,0,0,,D 到 G 不会创建环
Dialogue: 0,0:24:45.52,0:24:46.34,英文,,0,0,0,,I add it.
Dialogue: 0,0:24:45.52,0:24:46.34,中文,,0,0,0,,我添加它
Dialogue: 0,0:24:46.34,0:24:50.84,英文,,0,0,0,,And my weighted quick union reminds me that D and G are now connected.
Dialogue: 0,0:24:46.34,0:24:50.84,中文,,0,0,0,,我的加权快速合并提醒我 D 和 G 现在连接起来了
Dialogue: 0,0:24:50.84,0:24:56.00,英文,,0,0,0,,D and G are not connected to A, C, E, but they are in a group by themselves.
Dialogue: 0,0:24:50.84,0:24:56.00,中文,,0,0,0,,D 和 G 没有连接到 A、C、E 但它们自己在一个组中
Dialogue: 0,0:24:56.00,0:24:57.54,英文,,0,0,0,,So I union them.
Dialogue: 0,0:24:56.00,0:24:57.54,中文,,0,0,0,,我将它们合并
Dialogue: 0,0:24:57.54,0:25:01.91,英文,,0,0,0,,OK, F to G. Are you going to create a cycle if I add this edge?
Dialogue: 0,0:24:57.54,0:25:01.91,中文,,0,0,0,,F 到 G 如果我添加这条边 你会创建环吗？
Dialogue: 0,0:25:01.91,0:25:02.51,英文,,0,0,0,,No.
Dialogue: 0,0:25:01.91,0:25:02.51,中文,,0,0,0,,不会
Dialogue: 0,0:25:02.51,0:25:04.03,英文,,0,0,0,,Safe to add this edge.
Dialogue: 0,0:25:02.51,0:25:04.03,中文,,0,0,0,,添加这条边是安全的
Dialogue: 0,0:25:04.03,0:25:11.61,英文,,0,0,0,,And I union G and F. And by unioning G and F, I now have D, G, and F all part of the same group.
Dialogue: 0,0:25:04.03,0:25:11.61,中文,,0,0,0,,我将 G 和 F 合并 通过合并 G 和 F 我现在让 D、G 和 F 都属于同一组
Dialogue: 0,0:25:11.61,0:25:13.67,英文,,0,0,0,,Look, they're part of the same team.
Dialogue: 0,0:25:11.61,0:25:13.67,中文,,0,0,0,,看 它们属于同一组
Dialogue: 0,0:25:13.67,0:25:25.38,英文,,0,0,0,,So I keep going, A to B. You don't create a cycle, so I add U, and I union up A and B. So now B joins this A, C, E group.
Dialogue: 0,0:25:13.67,0:25:25.38,中文,,0,0,0,,我继续 A 到 B 你不会创建环 我添加 U 并将 A 和 B 合并 现在 B 加入这个 A、C、E 组
Dialogue: 0,0:25:25.38,0:25:26.78,英文,,0,0,0,,All four of them are part of the same group.
Dialogue: 0,0:25:25.38,0:25:26.78,中文,,0,0,0,,它们四个都属于同一组
Dialogue: 0,0:25:26.78,0:25:28.04,英文,,0,0,0,,They're all connected.
Dialogue: 0,0:25:26.78,0:25:28.04,中文,,0,0,0,,它们都连接起来了
Dialogue: 0,0:25:28.04,0:25:30.00,英文,,0,0,0,,And here's the crucial part right here.
Dialogue: 0,0:25:28.04,0:25:30.00,中文,,0,0,0,,这里是最关键的部分
Dialogue: 0,0:25:30.00,0:25:31.32,英文,,0,0,0,,Do you remember this edge?
Dialogue: 0,0:25:30.00,0:25:31.32,中文,,0,0,0,,你还记得这条边吗？
Dialogue: 0,0:25:31.32,0:25:37.46,英文,,0,0,0,,B to E. I do not want to add this edge, because it creates a cycle.
Dialogue: 0,0:25:31.32,0:25:37.46,中文,,0,0,0,,B 到 E 我不想添加这条边 因为它会创建一个环
Dialogue: 0,0:25:37.46,0:25:41.81,英文,,0,0,0,,How do I know, using my weighted quick union, that this creates a cycle?
Dialogue: 0,0:25:37.46,0:25:41.81,中文,,0,0,0,,使用我的加权快速合并 我如何知道这会创建一个环？
Dialogue: 0,0:25:41.81,0:25:47.99,英文,,0,0,0,,Because if I look at my weighted quick union object, I ask, are E and B already connected?
Dialogue: 0,0:25:41.81,0:25:47.99,中文,,0,0,0,,因为如果我查看我的加权快速合并对象 我问 E 和 B 已经连接了吗？
Dialogue: 0,0:25:47.99,0:25:51.75,英文,,0,0,0,,And the weighted quick union says, yes, E and B are part of the same group.
Dialogue: 0,0:25:47.99,0:25:51.75,中文,,0,0,0,,加权快速合并说 是的 E 和 B 属于同一组
Dialogue: 0,0:25:51.75,0:25:55.46,英文,,0,0,0,,That tells me, because they're part of the same group, they're already connected.
Dialogue: 0,0:25:51.75,0:25:55.46,中文,,0,0,0,,这告诉我 因为它们属于同一组 它们已经连接起来了
Dialogue: 0,0:25:55.46,0:26:00.72,英文,,0,0,0,,There is already a way to get from E to B. They're already part of the same group.
Dialogue: 0,0:25:55.46,0:26:00.72,中文,,0,0,0,,已经有一种方法可以从 E 到 B 它们已经是同一组的一部分
Dialogue: 0,0:26:00.72,0:26:06.34,英文,,0,0,0,,So if I add this edge, that is creating another way to get between E and B. That's a cycle.
Dialogue: 0,0:26:00.72,0:26:06.34,中文,,0,0,0,,如果我添加这条边 那就是在 E 和 B 之间创建了另一种路径 那就是一个环
Dialogue: 0,0:26:06.34,0:26:09.09,英文,,0,0,0,,There's two ways to get between the same two vertices.
Dialogue: 0,0:26:06.34,0:26:09.09,中文,,0,0,0,,在相同的两个顶点之间有两条路径
Dialogue: 0,0:26:09.09,0:26:10.53,英文,,0,0,0,,I don't want this edge.
Dialogue: 0,0:26:09.09,0:26:10.53,中文,,0,0,0,,我不想要这条边
Dialogue: 0,0:26:10.53,0:26:14.89,英文,,0,0,0,,And the way to quick union lets me figure that out in an efficient way.
Dialogue: 0,0:26:10.53,0:26:14.89,中文,,0,0,0,,快速合并的方式可以让我有效地解决这个问题
Dialogue: 0,0:26:14.89,0:26:16.81,英文,,0,0,0,,So I check if E and B are connected.
Dialogue: 0,0:26:14.89,0:26:16.81,中文,,0,0,0,,我检查 E 和 B 是否连接
Dialogue: 0,0:26:16.81,0:26:18.48,英文,,0,0,0,,They are already connected.
Dialogue: 0,0:26:16.81,0:26:18.48,中文,,0,0,0,,它们已经连接了
Dialogue: 0,0:26:18.48,0:26:22.58,英文,,0,0,0,,So adding this edge would be a second connection between E and B. I don't want that.
Dialogue: 0,0:26:18.48,0:26:22.58,中文,,0,0,0,,添加这条边将是 E 和 B 之间的第二个连接 我不想要那样
Dialogue: 0,0:26:22.58,0:26:24.32,英文,,0,0,0,,So I don't use this edge.
Dialogue: 0,0:26:22.58,0:26:24.32,中文,,0,0,0,,我不使用这条边
Dialogue: 0,0:26:24.32,0:26:26.06,英文,,0,0,0,,OK, so I do nothing.
Dialogue: 0,0:26:24.32,0:26:26.06,中文,,0,0,0,,我不做任何事情
Dialogue: 0,0:26:26.06,0:26:30.49,英文,,0,0,0,,So I keep going, E and D, are they connected in the weighted quick union?
Dialogue: 0,0:26:26.06,0:26:30.49,中文,,0,0,0,,我继续 E 和 D 它们在加权快速合并中连接了吗？
Dialogue: 0,0:26:30.49,0:26:34.27,英文,,0,0,0,,According to the weighted quick union, are E and D part of the same group?
Dialogue: 0,0:26:30.49,0:26:34.27,中文,,0,0,0,,根据加权快速合并 E 和 D 属于同一组吗？
Dialogue: 0,0:26:34.27,0:26:34.95,英文,,0,0,0,,No.
Dialogue: 0,0:26:34.27,0:26:34.95,中文,,0,0,0,,不
Dialogue: 0,0:26:34.95,0:26:36.37,英文,,0,0,0,,So there's no way to get between them.
Dialogue: 0,0:26:34.95,0:26:36.37,中文,,0,0,0,,没有办法在它们之间移动
Dialogue: 0,0:26:36.37,0:26:38.23,英文,,0,0,0,,It's OK to add this edge.
Dialogue: 0,0:26:36.37,0:26:38.23,中文,,0,0,0,,添加这条边是可以的
Dialogue: 0,0:26:38.23,0:26:41.11,英文,,0,0,0,,And now I have enough edges to complete my tree.
Dialogue: 0,0:26:38.23,0:26:41.11,中文,,0,0,0,,现在我有足够的边来完成我的树
Dialogue: 0,0:26:41.11,0:26:43.72,英文,,0,0,0,,So I declare victory, and I'm all done.
Dialogue: 0,0:26:41.11,0:26:43.72,中文,,0,0,0,,我宣布胜利 我已经完成了
Dialogue: 0,0:26:43.72,0:26:45.90,英文,,0,0,0,,So this is just to make the algorithm faster.
Dialogue: 0,0:26:43.72,0:26:45.90,中文,,0,0,0,,这只是为了让算法更快
Dialogue: 0,0:26:45.90,0:26:50.94,英文,,0,0,0,,I just added a priority queue and a weighted quick union to keep track of all the things I need to.
Dialogue: 0,0:26:45.90,0:26:50.94,中文,,0,0,0,,我添加了一个优先队列和一个加权快速合并来跟踪我需要的所有东西
Dialogue: 0,0:26:50.94,0:26:54.73,英文,,0,0,0,,Do you have a question?
Dialogue: 0,0:26:50.94,0:26:54.73,中文,,0,0,0,,你有什么问题吗？
Dialogue: 0,0:26:54.73,0:26:57.86,英文,,0,0,0,,Would it be OK to connect E to G?
Dialogue: 0,0:26:54.73,0:26:57.86,中文,,0,0,0,,将 E 连接到 G 可以吗？
Dialogue: 0,0:26:57.86,0:27:00.76,英文,,0,0,0,,Oh, as in, like, if I have a tie?
Dialogue: 0,0:26:57.86,0:27:00.76,中文,,0,0,0,,哦 比如 如果我有一个平局？
Dialogue: 0,0:27:00.76,0:27:02.72,英文,,0,0,0,,Hmm, that's a good question.
Dialogue: 0,0:27:00.76,0:27:02.72,中文,,0,0,0,,嗯 这是个好问题
Dialogue: 0,0:27:02.72,0:27:03.50,英文,,0,0,0,,Let's see.
Dialogue: 0,0:27:02.72,0:27:03.50,中文,,0,0,0,,让我们看看
Dialogue: 0,0:27:03.50,0:27:04.40,英文,,0,0,0,,So I'm here.
Dialogue: 0,0:27:03.50,0:27:04.40,中文,,0,0,0,,我在这里
Dialogue: 0,0:27:04.40,0:27:13.61,英文,,0,0,0,,Yeah, I guess you could consider E to G before you consider E to D. So this tree, or this graph, has multiple valid minimum spanning trees.
Dialogue: 0,0:27:04.40,0:27:13.61,中文,,0,0,0,,是的 我想你可以在考虑 E 到 D 之前考虑 E 到 G 这棵树 或者说这个图 有多个有效的最小生成树
Dialogue: 0,0:27:13.61,0:27:14.71,英文,,0,0,0,,It's a good point.
Dialogue: 0,0:27:13.61,0:27:14.71,中文,,0,0,0,,这是个好观点
Dialogue: 0,0:27:14.71,0:27:19.25,英文,,0,0,0,,So when you don't have unique edges or unique edge weights, you might have multiple answers.
Dialogue: 0,0:27:14.71,0:27:19.25,中文,,0,0,0,,当你的边或边权重不唯一时 你可能有多个答案
Dialogue: 0,0:27:19.25,0:27:22.00,英文,,0,0,0,,So yes, I think E to G would be OK here, too.
Dialogue: 0,0:27:19.25,0:27:22.00,中文,,0,0,0,,是的 我认为 E 到 G 在这里也可以
Dialogue: 0,0:27:22.00,0:27:24.18,英文,,0,0,0,,OK, nothing else?
Dialogue: 0,0:27:22.00,0:27:24.18,中文,,0,0,0,,没有其他问题了吗？
Dialogue: 0,0:27:24.18,0:27:28.82,英文,,0,0,0,,OK, so that is how you would actually implement it using data structures.
Dialogue: 0,0:27:24.18,0:27:28.82,中文,,0,0,0,,这就是你如何使用数据结构来实际实现它
Dialogue: 0,0:27:28.82,0:27:32.16,英文,,0,0,0,,So I'll show you a little cartoon of how these things work side by side.
Dialogue: 0,0:27:28.82,0:27:32.16,中文,,0,0,0,,我将向你展示这些东西如何并排工作的小动画
Dialogue: 0,0:27:32.16,0:27:37.61,英文,,0,0,0,,So remember, Prims, it started somewhere and then slowly branched out trying to connect everyone up.
Dialogue: 0,0:27:32.16,0:27:37.61,中文,,0,0,0,,记住 Prim's 算法 它从某个地方开始 然后慢慢地分支出去 试图连接所有人
Dialogue: 0,0:27:37.61,0:27:41.33,英文,,0,0,0,,By contrast, Kruskal's algorithm is more like a grassroots effort.
Dialogue: 0,0:27:37.61,0:27:41.33,中文,,0,0,0,,相比之下 Kruskal’s算法更像是一种基层工作
Dialogue: 0,0:27:41.33,0:27:45.17,英文,,0,0,0,,It hops all over the place, taking all the small edges and adding them.
Dialogue: 0,0:27:41.33,0:27:45.17,中文,,0,0,0,,它到处跳 获取所有小的边并把它们加起来
Dialogue: 0,0:27:45.17,0:27:47.91,英文,,0,0,0,,And at first, this thing doesn't even look like a tree.
Dialogue: 0,0:27:45.17,0:27:47.91,中文,,0,0,0,,一开始 这东西甚至不像一棵树
Dialogue: 0,0:27:47.91,0:27:50.48,英文,,0,0,0,,It looks like a bunch of ants all over the place.
Dialogue: 0,0:27:47.91,0:27:50.48,中文,,0,0,0,,它看起来像一群蚂蚁到处乱爬
Dialogue: 0,0:27:50.48,0:28:00.28,英文,,0,0,0,,But if you watch this demo to completion, slowly more edges get added, and eventually Kruskal's algorithm will connect everybody up into a tree.
Dialogue: 0,0:27:50.48,0:28:00.28,中文,,0,0,0,,但如果你完整地观看这个演示 会慢慢地添加更多的边 最终 Kruskal’s算法会将每个人连接到一棵树中
Dialogue: 0,0:28:00.28,0:28:02.74,英文,,0,0,0,,It just takes a little bit of
Dialogue: 0,0:28:00.28,0:28:02.74,中文,,0,0,0,,只需要一点...
Dialogue: 0,0:28:02.74,0:28:06.93,英文,,0,0,0,,I don't know, patience to watch the edges come together and form a tree.
Dialogue: 0,0:28:02.74,0:28:06.93,中文,,0,0,0,,我不知道 耐心看着这些边汇聚在一起形成一棵树
Dialogue: 0,0:28:06.93,0:28:10.35,英文,,0,0,0,,But ultimately, they both find a tree, which I find pretty cool.
Dialogue: 0,0:28:06.93,0:28:10.35,中文,,0,0,0,,但最终 它们都找到了一棵树 我觉得这很酷
Dialogue: 0,0:28:10.35,0:28:12.49,英文,,0,0,0,,OK, that's the demo.
Dialogue: 0,0:28:10.35,0:28:12.49,中文,,0,0,0,,这就是演示
Dialogue: 0,0:28:12.49,0:28:15.69,英文,,0,0,0,,So quickly, I'll tell you runtime, and then we'll move on.
Dialogue: 0,0:28:12.49,0:28:15.69,中文,,0,0,0,,很快 我会告诉你运行时间 然后我们会继续前进
Dialogue: 0,0:28:15.69,0:28:20.47,英文,,0,0,0,,So if I think about the runtime, there's only two data structures that I used.
Dialogue: 0,0:28:15.69,0:28:20.47,中文,,0,0,0,,如果我考虑运行时间 我只使用了两种数据结构
Dialogue: 0,0:28:20.47,0:28:26.22,英文,,0,0,0,,One of the data structures was the priority queue, and the other data structure was the weighted quick union.
Dialogue: 0,0:28:20.47,0:28:26.22,中文,,0,0,0,,一种数据结构是优先队列 另一种数据结构是加权快速合并
Dialogue: 0,0:28:26.22,0:28:34.24,英文,,0,0,0,,So all I really have to do is count up how many data structure operations are happening and sum them all up and I get my runtime.
Dialogue: 0,0:28:26.22,0:28:34.24,中文,,0,0,0,,我真正要做的就是计算有多少数据结构操作正在发生 并将它们全部加起来 我就可以得到我的运行时间
Dialogue: 0,0:28:34.24,0:28:38.35,英文,,0,0,0,,It's pretty similar to my Dijkstra's and Prim's analysis.
Dialogue: 0,0:28:34.24,0:28:38.35,中文,,0,0,0,,这与我的 Dijkstra's 和 Prim's 分析非常相似
Dialogue: 0,0:28:38.35,0:28:40.75,英文,,0,0,0,,I just have more operations to think about.
Dialogue: 0,0:28:38.35,0:28:40.75,中文,,0,0,0,,我只需要考虑更多的操作
Dialogue: 0,0:28:40.75,0:28:42.51,英文,,0,0,0,,So I'll start with the priority queue.
Dialogue: 0,0:28:40.75,0:28:42.51,中文,,0,0,0,,我将从优先队列开始
Dialogue: 0,0:28:42.51,0:28:44.23,英文,,0,0,0,,What do I do in the priority queue?
Dialogue: 0,0:28:42.51,0:28:44.23,中文,,0,0,0,,我在优先队列中做什么？
Dialogue: 0,0:28:44.23,0:28:49.63,英文,,0,0,0,,The first thing I do is I throw all of the edges into the priority queue.
Dialogue: 0,0:28:44.23,0:28:49.63,中文,,0,0,0,,我做的第一件事是将所有边都放入优先队列
Dialogue: 0,0:28:49.63,0:28:52.15,英文,,0,0,0,,There are E edges in total.
Dialogue: 0,0:28:49.63,0:28:52.15,中文,,0,0,0,,总共有 E 条边
Dialogue: 0,0:28:52.15,0:28:57.42,英文,,0,0,0,,Each time I add an edge to the priority queue, it takes logarithmic time, in the worst case.
Dialogue: 0,0:28:52.15,0:28:57.42,中文,,0,0,0,,每次我向优先队列添加一条边 在最坏的情况下 都需要花费对数时间
Dialogue: 0,0:28:57.42,0:29:02.81,英文,,0,0,0,,So I can say, adding all of the edges takes e log e time.
Dialogue: 0,0:28:57.42,0:29:02.81,中文,,0,0,0,,我可以说 添加所有边需要 E log E 时间
Dialogue: 0,0:29:02.81,0:29:04.01,英文,,0,0,0,,There are e edges.
Dialogue: 0,0:29:02.81,0:29:04.01,中文,,0,0,0,,有 E 条边
Dialogue: 0,0:29:04.01,0:29:07.79,英文,,0,0,0,,I need to throw them all into the priority queue, e log e.
Dialogue: 0,0:29:04.01,0:29:07.79,中文,,0,0,0,,我需要将它们全部放入优先队列 E log E
Dialogue: 0,0:29:07.79,0:29:12.56,英文,,0,0,0,,And then I need to delete a bunch of edges from the priority queue, pull them out one by one.
Dialogue: 0,0:29:07.79,0:29:12.56,中文,,0,0,0,,然后我需要从优先队列中删除一堆边 一条一条地将它们拉出来
Dialogue: 0,0:29:12.56,0:29:23.78,英文,,0,0,0,,A deletion takes logarithmic time, and so I get another factor of E log E. By the way, this is O of E and not just D, because I might be able to stop early.
Dialogue: 0,0:29:12.56,0:29:23.78,中文,,0,0,0,,删除需要对数时间 我得到了另一个 E log E 的因子 顺便说一下 这是 O(E) 而不是 D 因为我可能会提前停止
Dialogue: 0,0:29:23.78,0:29:30.16,英文,,0,0,0,,I might not have to consider all the edges, so I just write O of E here to remind myself that in the worst case,
Dialogue: 0,0:29:23.78,0:29:30.16,中文,,0,0,0,,我可能不必考虑所有边 我在这里只写 O(E) 来提醒自己 在最坏的情况下
Dialogue: 0,0:29:30.16,0:29:37.16,英文,,0,0,0,,I have to pull all of the edges out of the priority queue, but maybe I get lucky and I can stop early, like I did in the demo.
Dialogue: 0,0:29:30.16,0:29:37.16,中文,,0,0,0,,我必须将所有边从优先队列中拉出来 但也许我很幸运 我可以提前停止 就像我在演示中做的那样
Dialogue: 0,0:29:37.16,0:29:43.85,英文,,0,0,0,,But in any case, I get a factor of E log E to delete potentially everything from the priority queue.
Dialogue: 0,0:29:37.16,0:29:43.85,中文,,0,0,0,,但无论如何 我得到了一个 E log E 的因子 用于潜在地从优先队列中删除所有内容
Dialogue: 0,0:29:43.85,0:29:45.13,英文,,0,0,0,,So that's it for the priority queue.
Dialogue: 0,0:29:43.85,0:29:45.13,中文,,0,0,0,,这就是优先队列的部分
Dialogue: 0,0:29:45.13,0:29:51.67,英文,,0,0,0,,These first two rows, I add everything, as in I add all the edges, and then I potentially remove all the edges.
Dialogue: 0,0:29:45.13,0:29:51.67,中文,,0,0,0,,前两行 我添加所有内容 即我添加所有边 然后我潜在地删除所有边
Dialogue: 0,0:29:51.67,0:29:53.50,英文,,0,0,0,,E log E time.
Dialogue: 0,0:29:51.67,0:29:53.50,中文,,0,0,0,,E log E 时间
Dialogue: 0,0:29:53.50,0:29:57.12,英文,,0,0,0,,Okay, now I go to the weighted quick union object.
Dialogue: 0,0:29:53.50,0:29:57.12,中文,,0,0,0,,现在我转到加权快速合并对象
Dialogue: 0,0:29:57.12,0:29:59.18,英文,,0,0,0,,What do I do in the weighted quick union object?
Dialogue: 0,0:29:57.12,0:29:59.18,中文,,0,0,0,,我在加权快速合并对象中做什么？
Dialogue: 0,0:29:59.18,0:30:04.90,英文,,0,0,0,,Well, remember, for every vertex, I potentially have to union it with another vertex.
Dialogue: 0,0:29:59.18,0:30:04.90,中文,,0,0,0,,嗯 请记住 对于每个顶点 我可能必须将其与另一个顶点合并
Dialogue: 0,0:30:04.90,0:30:10.98,英文,,0,0,0,,So there are up to V vertices, and I might have to union up every single vertex.
Dialogue: 0,0:30:04.90,0:30:10.98,中文,,0,0,0,,最多有 V 个顶点 我可能必须将每个顶点都合并起来
Dialogue: 0,0:30:10.98,0:30:14.40,英文,,0,0,0,,So in the worst case, everyone gets union up into one big family.
Dialogue: 0,0:30:10.98,0:30:14.40,中文,,0,0,0,,在最坏的情况下 每个人都将合并成一个大家庭
Dialogue: 0,0:30:14.40,0:30:16.95,英文,,0,0,0,,And so they're up to v vertices.
Dialogue: 0,0:30:14.40,0:30:16.95,中文,,0,0,0,,它们最多有 v 个顶点
Dialogue: 0,0:30:16.95,0:30:19.81,英文,,0,0,0,,I might have to call union once per vertex.
Dialogue: 0,0:30:16.95,0:30:19.81,中文,,0,0,0,,我可能需要为每个顶点调用一次合并操作
Dialogue: 0,0:30:19.81,0:30:27.96,英文,,0,0,0,,And a union operation takes log star of v, where log star was that super slow-growing function from the weighted quick union lecture.
Dialogue: 0,0:30:19.81,0:30:27.96,中文,,0,0,0,,合并操作需要 log* V 的时间 其中 log* 是我们在加权快速合并讲座中看到的那个增长非常缓慢的函数
Dialogue: 0,0:30:27.96,0:30:32.01,英文,,0,0,0,,So I get a runtime of v log star of v.
Dialogue: 0,0:30:27.96,0:30:32.01,中文,,0,0,0,,我得到了 v log* V 的运行时间
Dialogue: 0,0:30:32.01,0:30:32.83,英文,,0,0,0,,Then I have to check.
Dialogue: 0,0:30:32.01,0:30:32.83,中文,,0,0,0,,然后我必须检查
Dialogue: 0,0:30:32.83,0:30:40.54,英文,,0,0,0,,Do you remember, for every single edge, I had to go to the weighted quick union object and ask, are these two edges already connected?
Dialogue: 0,0:30:32.83,0:30:40.54,中文,,0,0,0,,你还记得吗 对于每条边 我都必须去加权快速合并对象并询问 这两条边是否已经连接？
Dialogue: 0,0:30:40.54,0:30:44.66,英文,,0,0,0,,And asking if two edges are connected costs log star of v time.
Dialogue: 0,0:30:40.54,0:30:44.66,中文,,0,0,0,,询问两条边是否连接需要 log* V 的时间
Dialogue: 0,0:30:44.66,0:30:48.65,英文,,0,0,0,,So that creates another factor of e log star of v.
Dialogue: 0,0:30:44.66,0:30:48.65,中文,,0,0,0,,这产生了另一个 E log* V 的因子
Dialogue: 0,0:30:48.65,0:30:56.58,英文,,0,0,0,,Because there are e edges, and for every edge, I need to ask the weighted quick union a question of, are these two vertices already connected?
Dialogue: 0,0:30:48.65,0:30:56.58,中文,,0,0,0,,因为有 E 条边 并且对于每条边 我都需要向加权快速合并询问一个问题 这两个顶点是否已经连接？
Dialogue: 0,0:30:56.58,0:31:03.55,英文,,0,0,0,,So if I sum all of these up, turns out, with a little bit of math that I've described down here,
Dialogue: 0,0:30:56.58,0:31:03.55,中文,,0,0,0,,如果我把所有这些加起来 结果是 通过我在这里描述的一点点数学运算
Dialogue: 0,0:31:03.55,0:31:08.55,英文,,0,0,0,,the dominating term is e log e. It's larger than all the others, so I can write that as my runtime.
Dialogue: 0,0:31:03.55,0:31:08.55,中文,,0,0,0,,主导项是 E log E 它比所有其他项都大 我将其写为我的运行时间
Dialogue: 0,0:31:08.55,0:31:09.59,英文,,0,0,0,,That's kind of a sketch.
Dialogue: 0,0:31:08.55,0:31:09.59,中文,,0,0,0,,这只是一个草图
Dialogue: 0,0:31:09.59,0:31:12.71,英文,,0,0,0,,It's a lot of different steps, so I encourage you to try it out.
Dialogue: 0,0:31:09.59,0:31:12.71,中文,,0,0,0,,它有很多不同的步骤 我鼓励你尝试一下
Dialogue: 0,0:31:12.71,0:31:17.92,英文,,0,0,0,,But that's the rough sketch of how you would prove the runtime of Kruskal's algorithm.
Dialogue: 0,0:31:12.71,0:31:17.92,中文,,0,0,0,,但这就是如何证明 Kruskal’s算法运行时间的粗略草图
Dialogue: 0,0:31:17.92,0:31:20.82,英文,,0,0,0,,Okay, quick question.
Dialogue: 0,0:31:17.92,0:31:20.82,中文,,0,0,0,,快速提问
Dialogue: 0,0:31:20.82,0:31:25.92,英文,,0,0,0,,Yeah, Logstar, it was the runtime that we saw at the end of the Way to Quick Union lecture.
Dialogue: 0,0:31:20.82,0:31:25.92,中文,,0,0,0,,是的 Logstar 它是在加权快速合并讲座结束时看到的运行时间
Dialogue: 0,0:31:25.92,0:31:27.67,英文,,0,0,0,,The question was, what is Logstar?
Dialogue: 0,0:31:25.92,0:31:27.67,中文,,0,0,0,,问题是 什么是 Logstar？
Dialogue: 0,0:31:27.67,0:31:30.35,英文,,0,0,0,,Roughly speaking, I won't talk about it in too much detail.
Dialogue: 0,0:31:27.67,0:31:30.35,中文,,0,0,0,,粗略地说 我不会过多地讨论它
Dialogue: 0,0:31:30.35,0:31:33.03,英文,,0,0,0,,It's a very slow-growing function that's never greater than 5.
Dialogue: 0,0:31:30.35,0:31:33.03,中文,,0,0,0,,它是一个增长非常缓慢的函数 永远不会大于 5
Dialogue: 0,0:31:33.03,0:31:36.51,英文,,0,0,0,,That's all you got to know for this class.
Dialogue: 0,0:31:33.03,0:31:36.51,中文,,0,0,0,,这就是这门课你需要知道的一切
Dialogue: 0,0:31:36.51,0:31:38.15,英文,,0,0,0,,Okay.
Dialogue: 0,0:31:36.51,0:31:38.15,中文,,0,0,0,,
Dialogue: 0,0:31:38.15,0:31:39.95,英文,,0,0,0,,Great, but if you don't like it, you could also use log.
Dialogue: 0,0:31:38.15,0:31:39.95,中文,,0,0,0,,很好 但如果你不喜欢它 你也可以使用 log
Dialogue: 0,0:31:39.95,0:31:41.59,英文,,0,0,0,,You just get a slightly worse bound.
Dialogue: 0,0:31:39.95,0:31:41.59,中文,,0,0,0,,你只会得到一个稍微差一点的界限
Dialogue: 0,0:31:41.59,0:31:45.47,英文,,0,0,0,,OK, so that's our summary of all the minimum spanning tree algorithms we saw.
Dialogue: 0,0:31:41.59,0:31:45.47,中文,,0,0,0,,这就是我们对所有最小生成树算法的总结
Dialogue: 0,0:31:45.47,0:31:47.93,英文,,0,0,0,,We saw prims, and we saw Kruskal's algorithm.
Dialogue: 0,0:31:45.47,0:31:47.93,中文,,0,0,0,,我们看到了 Prim's 也看到了 Kruskal’s算法
Dialogue: 0,0:31:47.93,0:31:49.29,英文,,0,0,0,,Those were our runtimes.
Dialogue: 0,0:31:47.93,0:31:49.29,中文,,0,0,0,,那些是我们的运行时间
Dialogue: 0,0:31:49.29,0:31:50.27,英文,,0,0,0,,Which one is better?
Dialogue: 0,0:31:49.29,0:31:50.27,中文,,0,0,0,,哪一个更好？
Dialogue: 0,0:31:50.27,0:31:53.00,英文,,0,0,0,,It honestly kind of is up to you.
Dialogue: 0,0:31:50.27,0:31:53.00,中文,,0,0,0,,老实说 这取决于你
Dialogue: 0,0:31:53.00,0:31:58.56,英文,,0,0,0,,I'd say log v and log e usually will not show up as a huge difference in real life.
Dialogue: 0,0:31:53.00,0:31:58.56,中文,,0,0,0,,我想说 log V 和 log E 在现实生活中通常不会表现出巨大的差异
Dialogue: 0,0:31:58.56,0:32:00.48,英文,,0,0,0,,So you can pick whichever one you like better.
Dialogue: 0,0:31:58.56,0:32:00.48,中文,,0,0,0,,你可以选择你更喜欢的那一个
Dialogue: 0,0:32:00.48,0:32:06.61,英文,,0,0,0,,Prims is maybe slightly faster at the expense of being a little bit more complicated to implement.
Dialogue: 0,0:32:00.48,0:32:06.61,中文,,0,0,0,,Prim’s算法可能稍微快一点 但代价是实现起来稍微复杂一点
Dialogue: 0,0:32:06.61,0:32:16.43,英文,,0,0,0,,But one thing I will say is, if someone gives you a pre-sorted list of edges, so instead of you having to throw the edges into a heap and figure out what's the smallest edge,
Dialogue: 0,0:32:06.61,0:32:16.43,中文,,0,0,0,,但我可以肯定的是 如果有人给了你一个预先排序的边列表 那么你就不用将边放入堆中并找出哪条边是最小的了
Dialogue: 0,0:32:16.43,0:32:24.43,英文,,0,0,0,,if somehow the graph comes with a list of pre-sorted edges given to you for free, well, then maybe Kruskal's is better,
Dialogue: 0,0:32:16.43,0:32:24.43,中文,,0,0,0,,如果不知何故 图附带了一个免费提供给你的预先排序的边列表 那么也许 Kruskal’s算法更好
Dialogue: 0,0:32:24.43,0:32:33.43,英文,,0,0,0,,because you don't even have to worry about figuring out what the smallest edge is, and these two terms go away, and you're just left with these two smaller terms.
Dialogue: 0,0:32:24.43,0:32:33.43,中文,,0,0,0,,因为你甚至不用担心找出哪条边是最小的 这两个项就消失了 你只剩下这两个较小的项
Dialogue: 0,0:32:33.43,0:32:37.38,英文,,0,0,0,,So if someone gives you pre-sorted edges, then maybe Kruskal's is the winner.
Dialogue: 0,0:32:33.43,0:32:37.38,中文,,0,0,0,,如果有人给了你预先排序的边 那么 Kruskal’s算法可能是赢家
Dialogue: 0,0:32:37.38,0:32:41.46,英文,,0,0,0,,But the honest answer, I would say, is that both of these algorithms are pretty good.
Dialogue: 0,0:32:37.38,0:32:41.46,中文,,0,0,0,,但我诚实的答案是 这两种算法都相当不错
Dialogue: 0,0:32:41.46,0:32:44.18,英文,,0,0,0,,And you can use whichever one you like.
Dialogue: 0,0:32:41.46,0:32:44.18,中文,,0,0,0,,你可以使用你喜欢的任何一个
Dialogue: 0,0:32:44.18,0:32:46.80,英文,,0,0,0,,OK. End of minimum spanning tree.
Dialogue: 0,0:32:44.18,0:32:46.80,中文,,0,0,0,,最小生成树结束
Dialogue: 0,0:32:46.80,0:32:50.32,英文,,0,0,0,,I'm not going to tell you about the history, but here it is if you're curious.
Dialogue: 0,0:32:46.80,0:32:50.32,中文,,0,0,0,,我不会告诉你历史 但如果你好奇 它就在这里
Dialogue: 0,0:32:50.32,0:32:53.86,英文,,0,0,0,,Is there anything else you want to know?
Dialogue: 0,0:32:50.32,0:32:53.86,中文,,0,0,0,,还有什么你想知道的？
Dialogue: 0,0:32:53.86,0:32:54.70,英文,,0,0,0,,Are you out of questions?
Dialogue: 0,0:32:53.86,0:32:54.70,中文,,0,0,0,,你没有问题了吗？
Dialogue: 0,0:32:54.70,0:32:55.86,英文,,0,0,0,,You can't stall me any further?
Dialogue: 0,0:32:54.70,0:32:55.86,中文,,0,0,0,,你不能再拖延我了吗？
Dialogue: 0,0:32:55.86,0:33:01.74,英文,,0,0,0,,OK. And then I'm going to talk about directed acyclic graphs, the last thing you have to know for the midterm.
Dialogue: 0,0:32:55.86,0:33:01.74,中文,,0,0,0,,然后我将讨论有向无环图 这是你在期中考试前必须知道的最后一件事
Dialogue: 0,0:33:01.74,0:33:04.46,英文,,0,0,0,,OK. Let's do it.
Dialogue: 0,0:33:01.74,0:33:04.46,中文,,0,0,0,,开始吧
Dialogue: 0,0:33:04.46,0:33:09.45,英文,,0,0,0,,So directed acyclic graphs, they are a specific type of graph.
Dialogue: 0,0:33:04.46,0:33:09.45,中文,,0,0,0,,有向无环图 它们是一种特定类型的图
Dialogue: 0,0:33:09.45,0:33:11.47,英文,,0,0,0,,Here are all the algorithms we've seen so far.
Dialogue: 0,0:33:09.45,0:33:11.47,中文,,0,0,0,,以下是我们目前为止看到的所有算法
Dialogue: 0,0:33:11.47,0:33:17.19,英文,,0,0,0,,I'm not going to talk about them again, but there are some demos for you from the lecture slides.
Dialogue: 0,0:33:11.47,0:33:17.19,中文,,0,0,0,,我不会再谈论它们了 但有一些来自讲义幻灯片的演示供你参考
Dialogue: 0,0:33:17.19,0:33:19.66,英文,,0,0,0,,So here's your task for the day.
Dialogue: 0,0:33:17.19,0:33:19.66,中文,,0,0,0,,这是你今天的任务
Dialogue: 0,0:33:19.66,0:33:21.12,英文,,0,0,0,,I'm going to give you a graph.
Dialogue: 0,0:33:19.66,0:33:21.12,中文,,0,0,0,,我会给你一个图
Dialogue: 0,0:33:21.12,0:33:22.28,英文,,0,0,0,,Here's a graph.
Dialogue: 0,0:33:21.12,0:33:22.28,中文,,0,0,0,,这是一个图
Dialogue: 0,0:33:22.28,0:33:25.40,英文,,0,0,0,,And I'm going to tell you, just as a word problem,
Dialogue: 0,0:33:22.28,0:33:25.40,中文,,0,0,0,,我会告诉你 就像一个文字问题一样
Dialogue: 0,0:33:25.40,0:33:32.91,英文,,0,0,0,,or a setting to make this hopefully intuitive, that each of these little vertices represents a task.
Dialogue: 0,0:33:25.40,0:33:32.91,中文,,0,0,0,,或者一个场景 希望能让你直观地理解 这些小顶点中的每一个都代表一个任务
Dialogue: 0,0:33:32.91,0:33:37.63,英文,,0,0,0,,So maybe A is like, open the jar of peanut butter.
Dialogue: 0,0:33:32.91,0:33:37.63,中文,,0,0,0,,也许 A 就像 打开花生酱罐子
Dialogue: 0,0:33:37.63,0:33:41.07,英文,,0,0,0,,And B is, take some peanut butter out of the jar.
Dialogue: 0,0:33:37.63,0:33:41.07,中文,,0,0,0,,B 是 从罐子里拿出一些花生酱
Dialogue: 0,0:33:41.07,0:33:44.34,英文,,0,0,0,,And E is, put the peanut butter on the bread.
Dialogue: 0,0:33:41.07,0:33:44.34,中文,,0,0,0,,E 是 把花生酱放在面包上
Dialogue: 0,0:33:44.34,0:33:47.74,英文,,0,0,0,,And C is like, open the bag of bread or whatever.
Dialogue: 0,0:33:44.34,0:33:47.74,中文,,0,0,0,,C 就像 打开面包袋或其他东西
Dialogue: 0,0:33:47.74,0:33:52.44,英文,,0,0,0,,So each of these little vertices represents a task you have to do.
Dialogue: 0,0:33:47.74,0:33:52.44,中文,,0,0,0,,这些小顶点中的每一个都代表你必须完成的任务
Dialogue: 0,0:33:52.44,0:34:00.35,英文,,0,0,0,,And an arrow between two vertices tells you that one of the tasks has to come before the other in some ordering.
Dialogue: 0,0:33:52.44,0:34:00.35,中文,,0,0,0,,两个顶点之间的箭头告诉你 其中一个任务必须在某个顺序中排在另一个之前
Dialogue: 0,0:34:00.35,0:34:07.33,英文,,0,0,0,,So for example, if A is, open the jar of peanut butter, and B is, take some peanut butter out of the jar.
Dialogue: 0,0:34:00.35,0:34:07.33,中文,,0,0,0,,例如 如果 A 是打开花生酱罐子 B 是从罐子里拿出一些花生酱
Dialogue: 0,0:34:07.33,0:34:13.32,英文,,0,0,0,,Well, you have to open the jar before you can take peanut butter out of the jar.
Dialogue: 0,0:34:07.33,0:34:13.32,中文,,0,0,0,,那么 你必须先打开罐子 然后才能从罐子里拿出花生酱
Dialogue: 0,0:34:13.32,0:34:22.33,英文,,0,0,0,,And if E is like putting peanut butter on the bread, you cannot put peanut butter on the bread until you take the peanut butter out of the jar.
Dialogue: 0,0:34:13.32,0:34:22.33,中文,,0,0,0,,如果 E 就像把花生酱放在面包上 那么在你从罐子里拿出花生酱之前 你不能把花生酱放在面包上
Dialogue: 0,0:34:22.33,0:34:25.55,英文,,0,0,0,,So all of this is to say each of these vertices is a task.
Dialogue: 0,0:34:22.33,0:34:25.55,中文,,0,0,0,,所有这些都是说 这些顶点中的每一个都是一个任务
Dialogue: 0,0:34:25.55,0:34:29.19,英文,,0,0,0,,The arrows tell you which tasks have to come before others.
Dialogue: 0,0:34:25.55,0:34:29.19,中文,,0,0,0,,箭头告诉你哪些任务必须排在其他任务之前
Dialogue: 0,0:34:29.19,0:34:32.38,英文,,0,0,0,,And my challenge for you is put the vertices in order.
Dialogue: 0,0:34:29.19,0:34:32.38,中文,,0,0,0,,我对你的挑战是将这些顶点按顺序排列
Dialogue: 0,0:34:32.38,0:34:34.24,英文,,0,0,0,,So give me an ordering.
Dialogue: 0,0:34:32.38,0:34:34.24,中文,,0,0,0,,给我一个排序
Dialogue: 0,0:34:34.24,0:34:39.28,英文,,0,0,0,,of the vertices such that all of the dependencies are satisfied.
Dialogue: 0,0:34:34.24,0:34:39.28,中文,,0,0,0,,顶点的排序 使所有依赖关系都得到满足
Dialogue: 0,0:34:39.28,0:34:41.32,英文,,0,0,0,,I'm not doing anything out of order.
Dialogue: 0,0:34:39.28,0:34:41.32,中文,,0,0,0,,我没有做任何不按顺序的事情
Dialogue: 0,0:34:41.32,0:34:42.36,英文,,0,0,0,,That's what I want.
Dialogue: 0,0:34:41.32,0:34:42.36,中文,,0,0,0,,这就是我想要的
Dialogue: 0,0:34:42.36,0:34:48.67,英文,,0,0,0,,So for example, this ordering is valid because I'm doing A right here before I do B. That's good.
Dialogue: 0,0:34:42.36,0:34:48.67,中文,,0,0,0,,例如 这个排序是有效的 因为我在做 B 之前先做了 A 这很好
Dialogue: 0,0:34:48.67,0:34:52.31,英文,,0,0,0,,I open the jar before I take the peanut butter out of the jar.
Dialogue: 0,0:34:48.67,0:34:52.31,中文,,0,0,0,,我先打开罐子 然后才从罐子里拿出花生酱
Dialogue: 0,0:34:52.31,0:34:57.47,英文,,0,0,0,,And I'm also doing, for example, D right here before I do E. That's good.
Dialogue: 0,0:34:52.31,0:34:57.47,中文,,0,0,0,,还有 比如我在做 E 之前先做 D 这没问题
Dialogue: 0,0:34:57.47,0:34:59.89,英文,,0,0,0,,I want to do D before I do E.
Dialogue: 0,0:34:57.47,0:34:59.89,中文,,0,0,0,,我想在做 E 之前先做 D
Dialogue: 0,0:34:59.89,0:35:03.57,英文,,0,0,0,,So maybe as another example, I could say these are like classes.
Dialogue: 0,0:34:59.89,0:35:03.57,中文,,0,0,0,,也许可以举个例子 我可以说这些就像课程一样
Dialogue: 0,0:35:03.57,0:35:14.44,英文,,0,0,0,,So this could be like, you have to take 61A before you take 61B, and you have to take 61B before you take CS 170, or whatever other class.
Dialogue: 0,0:35:03.57,0:35:14.44,中文,,0,0,0,,这可能就像 你必须先上 61A 才能上 61B 并且你必须先上 61B 才能上 CS 170 或者其他任何课程
Dialogue: 0,0:35:14.44,0:35:19.80,英文,,0,0,0,,And you have to take CS 170 before you take the fancy graduate level class, or whatever.
Dialogue: 0,0:35:14.44,0:35:19.80,中文,,0,0,0,,而且你必须先上 CS 170 才能上高级研究生课程 等等
Dialogue: 0,0:35:19.80,0:35:21.40,英文,,0,0,0,,So you can also think of it that way.
Dialogue: 0,0:35:19.80,0:35:21.40,中文,,0,0,0,,你也可以这样想
Dialogue: 0,0:35:21.40,0:35:27.77,英文,,0,0,0,,But the important thing is, I have a series of tasks, and an ordering is what I want to find.
Dialogue: 0,0:35:21.40,0:35:27.77,中文,,0,0,0,,但重要的是 我有一系列的任务 而我想找到一个排序
Dialogue: 0,0:35:27.77,0:35:31.58,英文,,0,0,0,,OK, so challenge for you is, what's an algorithm for doing this?
Dialogue: 0,0:35:27.77,0:35:31.58,中文,,0,0,0,,那么对你的挑战是 有什么算法可以做到这一点？
Dialogue: 0,0:35:31.58,0:35:33.80,英文,,0,0,0,,I could stare at it and look at the picture.
Dialogue: 0,0:35:31.58,0:35:33.80,中文,,0,0,0,,我可以盯着它看 看看图片
Dialogue: 0,0:35:33.80,0:35:44.71,英文,,0,0,0,,But how would a computer find the best ordering, or an ordering, because there can be multiple, such that all of the dependencies are satisfied?
Dialogue: 0,0:35:33.80,0:35:44.71,中文,,0,0,0,,但是计算机如何找到最佳排序 或者一个排序 因为可以有多个 使得所有依赖关系都得到满足？
Dialogue: 0,0:35:44.71,0:35:47.64,英文,,0,0,0,,So this one, unfortunately, I will just spoil.
Dialogue: 0,0:35:44.71,0:35:47.64,中文,,0,0,0,,这个 不幸的是 我只能剧透了
Dialogue: 0,0:35:47.64,0:35:51.76,英文,,0,0,0,,So the spoiler is, it's actually inspired by depth-first search.
Dialogue: 0,0:35:47.64,0:35:51.76,中文,,0,0,0,,剧透是 它实际上是受深度优先搜索的启发
Dialogue: 0,0:35:51.76,0:35:54.82,英文,,0,0,0,,So our old friend depth-first search is here yet again.
Dialogue: 0,0:35:51.76,0:35:54.82,中文,,0,0,0,,我们的老朋友深度优先搜索又来了
Dialogue: 0,0:35:54.82,0:35:56.02,英文,,0,0,0,,And here's the algorithm.
Dialogue: 0,0:35:54.82,0:35:56.02,中文,,0,0,0,,算法如下
Dialogue: 0,0:35:56.02,0:35:58.56,英文,,0,0,0,,It's kind of silly, and I'll show you why it works.
Dialogue: 0,0:35:56.02,0:35:58.56,中文,,0,0,0,,这有点傻 我会告诉你为什么它有效
Dialogue: 0,0:35:58.56,0:36:00.47,英文,,0,0,0,,You run depth-first search.
Dialogue: 0,0:35:58.56,0:36:00.47,中文,,0,0,0,,你运行深度优先搜索
Dialogue: 0,0:36:00.47,0:36:01.59,英文,,0,0,0,,You get a POST order.
Dialogue: 0,0:36:00.47,0:36:01.59,中文,,0,0,0,,你得到一个 post 顺序
Dialogue: 0,0:36:01.59,0:36:06.37,英文,,0,0,0,,Remember, the POST order is the order in which the depth-first search calls return.
Dialogue: 0,0:36:01.59,0:36:06.37,中文,,0,0,0,,记住 post 顺序是深度优先搜索调用返回的顺序
Dialogue: 0,0:36:06.37,0:36:11.29,英文,,0,0,0,,So you keep track of all the depth-first search calls, and you keep track of the order in which they return.
Dialogue: 0,0:36:06.37,0:36:11.29,中文,,0,0,0,,你要跟踪所有的深度优先搜索调用 并跟踪它们返回的顺序
Dialogue: 0,0:36:11.29,0:36:13.33,英文,,0,0,0,,That's the depth-first search POST order.
Dialogue: 0,0:36:11.29,0:36:13.33,中文,,0,0,0,,这就是深度优先搜索的 post 顺序
Dialogue: 0,0:36:13.33,0:36:14.55,英文,,0,0,0,,And here's the funny part.
Dialogue: 0,0:36:13.33,0:36:14.55,中文,,0,0,0,,有趣的地方来了
Dialogue: 0,0:36:14.55,0:36:22.79,英文,,0,0,0,,You take the POST order, and you reverse it, and you get the topological ordering, which is a fancy way of saying this ordering right here.
Dialogue: 0,0:36:14.55,0:36:22.79,中文,,0,0,0,,你取 post 顺序 然后反转它 你就得到了拓扑排序 这是对这个顺序的一种奇特的说法
Dialogue: 0,0:36:22.79,0:36:26.09,英文,,0,0,0,,So I'll show it to you in action, and then we'll talk about why this works.
Dialogue: 0,0:36:22.79,0:36:26.09,中文,,0,0,0,,我将向你展示它的实际效果 然后我们将讨论它为什么有效
Dialogue: 0,0:36:26.09,0:36:29.79,英文,,0,0,0,,So let's run depth-first search together and see why this works.
Dialogue: 0,0:36:26.09,0:36:29.79,中文,,0,0,0,,让我们一起运行深度优先搜索 看看为什么它有效
Dialogue: 0,0:36:29.79,0:36:36.83,英文,,0,0,0,,So I'll start at A. And remember, I have a call stack to remind myself what functions are still being called and have not returned yet.
Dialogue: 0,0:36:29.79,0:36:36.83,中文,,0,0,0,,我从 A 开始 记住 我有一个调用栈来提醒自己哪些函数仍在被调用 还没有返回
Dialogue: 0,0:36:36.83,0:36:45.10,英文,,0,0,0,,So I'll go A. Then I'll go to one of its neighbors, which is B. Then I'll go to another neighbor, E. I'll go to another neighbor, H. OK, great.
Dialogue: 0,0:36:36.83,0:36:45.10,中文,,0,0,0,,我会去 A 然后我会去它的一个邻居 也就是 B 然后我会去另一个邻居 E 我会去另一个邻居 H 很好
Dialogue: 0,0:36:45.10,0:36:47.68,英文,,0,0,0,,Now I'm at H. H has no more neighbors.
Dialogue: 0,0:36:45.10,0:36:47.68,中文,,0,0,0,,现在我在 H H 没有更多的邻居了
Dialogue: 0,0:36:47.68,0:36:51.40,英文,,0,0,0,,So the depth-first search call to H is ready to return.
Dialogue: 0,0:36:47.68,0:36:51.40,中文,,0,0,0,,对 H 的深度优先搜索调用已经准备好返回了
Dialogue: 0,0:36:51.40,0:36:52.79,英文,,0,0,0,,It's done.
Dialogue: 0,0:36:51.40,0:36:52.79,中文,,0,0,0,,完成了
Dialogue: 0,0:36:52.79,0:36:56.90,英文,,0,0,0,,So my post-order gets H as its first entry.
Dialogue: 0,0:36:52.79,0:36:56.90,中文,,0,0,0,,我的后序将 H 作为它的第一个条目
Dialogue: 0,0:36:56.90,0:37:01.20,英文,,0,0,0,,OK, now I go back to E. And well, if I'm at E, I look.
Dialogue: 0,0:36:56.90,0:37:01.20,中文,,0,0,0,,现在我回到 E 如果我在 E 我看看
Dialogue: 0,0:37:01.20,0:37:04.34,英文,,0,0,0,,There's no more outgoing edges to E. E is marked.
Dialogue: 0,0:37:01.20,0:37:04.34,中文,,0,0,0,,没有更多从 E 出发的边了 E 被标记了
Dialogue: 0,0:37:04.34,0:37:07.44,英文,,0,0,0,,All of its outgoing edges are marked, or go to marked vertices.
Dialogue: 0,0:37:04.34,0:37:07.44,中文,,0,0,0,,它所有的出边都被标记了 或者指向标记的顶点
Dialogue: 0,0:37:07.44,0:37:11.16,英文,,0,0,0,,I'm done with E. So I can add E to my post-order.
Dialogue: 0,0:37:07.44,0:37:11.16,中文,,0,0,0,,我已经完成了 E 我可以在我的后序中添加 E
Dialogue: 0,0:37:11.16,0:37:20.25,英文,,0,0,0,,So I go back to B. And B also has no other vertices that are outgoing and go to a unmarked vertex.
Dialogue: 0,0:37:11.16,0:37:20.25,中文,,0,0,0,,我回到 B B 也没有其他出边指向未标记顶点的顶点
Dialogue: 0,0:37:20.25,0:37:23.73,英文,,0,0,0,,So there's nothing more to do at B. So I can add B to the post-order.
Dialogue: 0,0:37:20.25,0:37:23.73,中文,,0,0,0,, B 没有什么可做的了 我可以在后序中添加 B
Dialogue: 0,0:37:23.73,0:37:27.24,英文,,0,0,0,,I go back to A. Can I add A to the post-order right now?
Dialogue: 0,0:37:23.73,0:37:27.24,中文,,0,0,0,,我回到 A 我现在可以将 A 添加到后序中吗？
Dialogue: 0,0:37:27.24,0:37:29.22,英文,,0,0,0,,Am I done with A?
Dialogue: 0,0:37:27.24,0:37:29.22,中文,,0,0,0,,我完成 A 了吗？
Dialogue: 0,0:37:29.22,0:37:32.60,英文,,0,0,0,,Well, no, because there's still more outgoing edges to explore.
Dialogue: 0,0:37:29.22,0:37:32.60,中文,,0,0,0,,嗯 没有 因为还有更多的出边需要探索
Dialogue: 0,0:37:32.60,0:37:40.13,英文,,0,0,0,,So if I'm at A, I need to go explore D. So here I am exploring D. And I look at D. D has no more outgoing edges.
Dialogue: 0,0:37:32.60,0:37:40.13,中文,,0,0,0,,如果我在 A 我需要去探索 D 我在这里探索 D 我看看 D D 没有更多的出边了
Dialogue: 0,0:37:40.13,0:37:43.17,英文,,0,0,0,,So I'm done with D. I can add it to my post order.
Dialogue: 0,0:37:40.13,0:37:43.17,中文,,0,0,0,,我完成了 D 我可以把它添加到我的后序中
Dialogue: 0,0:37:43.17,0:37:46.23,英文,,0,0,0,,I go back to A. That's what my call stack says.
Dialogue: 0,0:37:43.17,0:37:46.23,中文,,0,0,0,,我回到 A 这就是我的调用栈所说的
Dialogue: 0,0:37:46.23,0:37:48.05,英文,,0,0,0,,This is just the picture from last slide.
Dialogue: 0,0:37:46.23,0:37:48.05,中文,,0,0,0,,这只是上一张幻灯片的图片
Dialogue: 0,0:37:48.05,0:37:51.35,英文,,0,0,0,,I go back to A, because I was done with D.
Dialogue: 0,0:37:48.05,0:37:51.35,中文,,0,0,0,,我回到 A 因为我已经完成了 D
Dialogue: 0,0:37:51.35,0:37:54.90,英文,,0,0,0,,And the call stack said, when you're done with D, go back to A, please.
Dialogue: 0,0:37:51.35,0:37:54.90,中文,,0,0,0,,调用栈说 当你完成 D 后 请回到 A
Dialogue: 0,0:37:54.90,0:38:03.86,英文,,0,0,0,,Here I am at A, and there's no more outgoing edges from A. So it almost looks like I'm done, except I have not done C, F, and G yet.
Dialogue: 0,0:37:54.90,0:38:03.86,中文,,0,0,0,,我在这里 在 A 并且没有更多从 A 出发的边了 看起来我好像完成了 除了我还没有做 C、F 和 G
Dialogue: 0,0:38:03.86,0:38:05.60,英文,,0,0,0,,So here's what I'll do.
Dialogue: 0,0:38:03.86,0:38:05.60,中文,,0,0,0,,这就是我要做的
Dialogue: 0,0:38:05.60,0:38:11.81,英文,,0,0,0,,I'm going to restart depth-first search, because I realized I did depth-first search, but I didn't reach every vertex.
Dialogue: 0,0:38:05.60,0:38:11.81,中文,,0,0,0,,我将重新启动深度优先搜索 因为我意识到我做了深度优先搜索 但我没有到达每个顶点
Dialogue: 0,0:38:11.81,0:38:15.13,英文,,0,0,0,,But I do want an ordering with every single vertex.
Dialogue: 0,0:38:11.81,0:38:15.13,中文,,0,0,0,,但我确实想要一个包含每个顶点的排序
Dialogue: 0,0:38:15.13,0:38:19.65,英文,,0,0,0,,So I'm actually going to restart depth-first search at C and run some more depth-first search.
Dialogue: 0,0:38:15.13,0:38:19.65,中文,,0,0,0,,我实际上要从 C 重新启动深度优先搜索 并运行更多深度优先搜索
Dialogue: 0,0:38:19.65,0:38:21.97,英文,,0,0,0,,I'm like, I love depth-first search too much.
Dialogue: 0,0:38:19.65,0:38:21.97,中文,,0,0,0,,我太喜欢深度优先搜索了
Dialogue: 0,0:38:21.97,0:38:22.63,英文,,0,0,0,,I'm not done.
Dialogue: 0,0:38:21.97,0:38:22.63,中文,,0,0,0,,我还没做完
Dialogue: 0,0:38:22.63,0:38:24.52,英文,,0,0,0,,I want to keep doing depth-first search.
Dialogue: 0,0:38:22.63,0:38:24.52,中文,,0,0,0,,我想继续做深度优先搜索
Dialogue: 0,0:38:24.52,0:38:29.18,英文,,0,0,0,,So I'll go to C, and I'll continue running depth-first search.
Dialogue: 0,0:38:24.52,0:38:29.18,中文,,0,0,0,,我会去 C 然后继续运行深度优先搜索
Dialogue: 0,0:38:29.18,0:38:35.82,英文,,0,0,0,,So I'm at C. I explore F. I explore G. G has no more neighbors, so it returns.
Dialogue: 0,0:38:29.18,0:38:35.82,中文,,0,0,0,,我在 C 我探索 F 我探索 G G 没有更多的邻居了 它返回了
Dialogue: 0,0:38:35.82,0:38:38.42,英文,,0,0,0,,F has no more unmarked neighbors, so it returns.
Dialogue: 0,0:38:35.82,0:38:38.42,中文,,0,0,0,,F 没有更多未标记的邻居了 它返回了
Dialogue: 0,0:38:38.42,0:38:41.34,英文,,0,0,0,,And C has no more unmarked neighbors, so it returns.
Dialogue: 0,0:38:38.42,0:38:41.34,中文,,0,0,0,,C 没有更多未标记的邻居了 它返回了
Dialogue: 0,0:38:41.34,0:38:42.98,英文,,0,0,0,,So that's my postOrder.
Dialogue: 0,0:38:41.34,0:38:42.98,中文,,0,0,0,,这就是我的 postorder
Dialogue: 0,0:38:42.98,0:38:52.46,英文,,0,0,0,,And the only little addition I had to make was restarting depth-first search if I run out of vertices to visit and I still have more to do.
Dialogue: 0,0:38:42.98,0:38:52.46,中文,,0,0,0,,我唯一需要做的一点小补充是 如果我耗尽了要访问的顶点 而我还有更多工作要做 就重新启动深度优先搜索
Dialogue: 0,0:38:52.46,0:38:53.86,英文,,0,0,0,,So there's the postOrder.
Dialogue: 0,0:38:52.46,0:38:53.86,中文,,0,0,0,,这就是 postorder
Dialogue: 0,0:38:53.86,0:38:57.54,英文,,0,0,0,,And here's the interesting part, which is there was my postOrder.
Dialogue: 0,0:38:53.86,0:38:57.54,中文,,0,0,0,,有趣的部分是 那是我的 postorder
Dialogue: 0,0:38:57.54,0:39:01.13,英文,,0,0,0,,And if I take this postOrder and reverse it, see?
Dialogue: 0,0:38:57.54,0:39:01.13,中文,,0,0,0,,如果我取这个 postorder 并反转它 看到吗？
Dialogue: 0,0:39:01.13,0:39:02.25,英文,,0,0,0,,I just reversed it.
Dialogue: 0,0:39:01.13,0:39:02.25,中文,,0,0,0,,我只是反转了它
Dialogue: 0,0:39:02.25,0:39:07.61,英文,,0,0,0,,This is actually a valid ordering of all of the tasks in my graph.
Dialogue: 0,0:39:02.25,0:39:07.61,中文,,0,0,0,,这实际上是我图中所有任务的一个有效排序
Dialogue: 0,0:39:07.61,0:39:12.45,英文,,0,0,0,,So here's my 10-second intuitive explanation, and then I'll try to roughly prove it.
Dialogue: 0,0:39:07.61,0:39:12.45,中文,,0,0,0,,这是我的 10 秒钟直观解释 然后我会尝试粗略地证明它
Dialogue: 0,0:39:12.45,0:39:17.01,英文,,0,0,0,,So my 10-second intuitive explanation is, let's think about depth-first search.
Dialogue: 0,0:39:12.45,0:39:17.01,中文,,0,0,0,,我的 10 秒钟直观解释是 让我们想想深度优先搜索
Dialogue: 0,0:39:17.01,0:39:22.46,英文,,0,0,0,,Depth-first search starts at shallow nodes, like A, and then starts diving deeper.
Dialogue: 0,0:39:17.01,0:39:22.46,中文,,0,0,0,,深度优先搜索从浅节点开始 比如 A 然后开始深入
Dialogue: 0,0:39:22.46,0:39:27.60,英文,,0,0,0,,So we start at A, and then we go deeper and deeper and deeper to go to H.
Dialogue: 0,0:39:22.46,0:39:27.60,中文,,0,0,0,,我们从 A 开始 然后我们越来越深入地去到 H
Dialogue: 0,0:39:27.60,0:39:35.42,英文,,0,0,0,,And because H is the first node that finishes, my post-order is going to have deeper nodes listed first before shallower nodes.
Dialogue: 0,0:39:27.60,0:39:35.42,中文,,0,0,0,,因为 H 是第一个完成的节点 我的后序将首先列出较深的节点 然后再列出较浅的节点
Dialogue: 0,0:39:35.42,0:39:36.68,英文,,0,0,0,,That's what you see here.
Dialogue: 0,0:39:35.42,0:39:36.68,中文,,0,0,0,,这就是你在这里看到的
Dialogue: 0,0:39:36.68,0:39:41.38,英文,,0,0,0,,My deeper nodes, like H and E, appear earlier in my post-order.
Dialogue: 0,0:39:36.68,0:39:41.38,中文,,0,0,0,,我的较深节点 比如 H 和 E 在我的后序中出现得更早
Dialogue: 0,0:39:41.38,0:39:46.51,英文,,0,0,0,,And my shallower nodes, like B and D and A, they appear later.
Dialogue: 0,0:39:41.38,0:39:46.51,中文,,0,0,0,,而我的较浅节点 比如 B、D 和 A 它们出现得更晚
Dialogue: 0,0:39:46.51,0:39:55.82,英文,,0,0,0,,Maybe another way of putting it is if I do depth first search and I think of these as classes, I'm diving all the way down into the hardest graduate level class.
Dialogue: 0,0:39:46.51,0:39:55.82,中文,,0,0,0,,也许另一种说法是 如果我做深度优先搜索 并且我把这些想象成课程 我就会一直深入到最难的研究生课程
Dialogue: 0,0:39:55.82,0:40:01.54,英文,,0,0,0,,And that's the one that shows up first in my post order and all of those easy classes like CS 61 a.
Dialogue: 0,0:39:55.82,0:40:01.54,中文,,0,0,0,,那就是在我的后序中首先出现的那个 以及所有那些简单的课程 比如 CS61A
Dialogue: 0,0:40:01.54,0:40:08.17,英文,,0,0,0,,They're not easy, but the earlier classes, like CS61A, they appear later in my post order.
Dialogue: 0,0:40:01.54,0:40:08.17,中文,,0,0,0,,它们并不简单 但较早的课程 比如 CS61A 它们在我的后序中出现得更晚
Dialogue: 0,0:40:08.17,0:40:17.36,英文,,0,0,0,,So if I take my post order and I reverse it, then I should get the case that all of these earlier classes, like CS61A, they're going to appear earlier, which is what I want.
Dialogue: 0,0:40:08.17,0:40:17.36,中文,,0,0,0,,如果我取我的后序并反转它 那么我应该得到所有这些较早的课程 比如 CS61A 它们会更早出现的情况 这就是我想要的
Dialogue: 0,0:40:17.36,0:40:26.14,英文,,0,0,0,,And all of these hard classes, like the graduate-level fancy class, that's going to appear in the back now because I reversed the list, and that's what I want.
Dialogue: 0,0:40:17.36,0:40:26.14,中文,,0,0,0,,所有这些难的课程 比如研究生水平的高级课程 现在会出现在后面 因为我反转了列表 这就是我想要的
Dialogue: 0,0:40:26.14,0:40:28.73,英文,,0,0,0,,So that's one possible way you can think about it.
Dialogue: 0,0:40:26.14,0:40:28.73,中文,,0,0,0,,这是一种可能的思考方式
Dialogue: 0,0:40:28.73,0:40:32.21,英文,,0,0,0,,Shallow nodes appear later in the poster order.
Dialogue: 0,0:40:28.73,0:40:32.21,中文,,0,0,0,,浅节点在后序中出现得更晚
Dialogue: 0,0:40:32.21,0:40:36.11,英文,,0,0,0,,So when I reverse it, shallow nodes appear first, which is what I want.
Dialogue: 0,0:40:32.21,0:40:36.11,中文,,0,0,0,,当我反转它时 浅节点首先出现 这就是我想要的
Dialogue: 0,0:40:36.11,0:40:42.21,英文,,0,0,0,,By contrast, nodes that are very deep appear first in the poster order, because they're the first ones to finish.
Dialogue: 0,0:40:36.11,0:40:42.21,中文,,0,0,0,,相比之下 非常深的节点首先出现在后序中 因为它们是第一个完成的
Dialogue: 0,0:40:42.21,0:40:46.83,英文,,0,0,0,,And so when I reverse the list, these deeper nodes now appear later.
Dialogue: 0,0:40:42.21,0:40:46.83,中文,,0,0,0,,当我反转列表时 这些较深的节点现在出现得更晚
Dialogue: 0,0:40:46.83,0:40:48.95,英文,,0,0,0,,Sorry, these deeper nodes now appear later.
Dialogue: 0,0:40:46.83,0:40:48.95,中文,,0,0,0,,抱歉 这些较深的节点现在出现得更晚
Dialogue: 0,0:40:48.95,0:40:51.27,英文,,0,0,0,,Yeah, I'm right, which is good.
Dialogue: 0,0:40:48.95,0:40:51.27,中文,,0,0,0,,是的 我是对的 这很好
Dialogue: 0,0:40:51.27,0:40:52.79,英文,,0,0,0,,So that's one way to do it.
Dialogue: 0,0:40:51.27,0:40:52.79,中文,,0,0,0,,这是一种方法
Dialogue: 0,0:40:52.79,0:40:54.65,英文,,0,0,0,,You all have a lot of questions today.
Dialogue: 0,0:40:52.79,0:40:54.65,中文,,0,0,0,,你们今天有很多问题
Dialogue: 0,0:40:54.65,0:40:55.19,英文,,0,0,0,,I wonder why.
Dialogue: 0,0:40:54.65,0:40:55.19,中文,,0,0,0,,我想知道为什么
Dialogue: 0,0:40:55.19,0:41:01.52,英文,,0,0,0,,OK, question?
Dialogue: 0,0:40:55.19,0:41:01.52,中文,,0,0,0,,好的 问题？
Dialogue: 0,0:41:01.52,0:41:03.18,英文,,0,0,0,,The question was, why not add a sentinel?
Dialogue: 0,0:41:01.52,0:41:03.18,中文,,0,0,0,,问题是 为什么不添加一个哨兵？
Dialogue: 0,0:41:03.18,0:41:10.84,英文,,0,0,0,,You probably can.
Dialogue: 0,0:41:03.18,0:41:10.84,中文,,0,0,0,,你可能可以
Dialogue: 0,0:41:10.84,0:41:13.06,英文,,0,0,0,,Yeah, the question was, could I add a sentinel node?
Dialogue: 0,0:41:10.84,0:41:13.06,中文,,0,0,0,,是的 问题是 我是否可以添加一个哨兵节点？
Dialogue: 0,0:41:13.06,0:41:17.11,英文,,0,0,0,,You probably could, but maybe that's not how this was implemented on the slides.
Dialogue: 0,0:41:13.06,0:41:17.11,中文,,0,0,0,,你可能可以 但也许幻灯片上的实现方式不是这样的
Dialogue: 0,0:41:17.11,0:41:19.49,英文,,0,0,0,,But you can experiment with it if you wanted to.
Dialogue: 0,0:41:17.11,0:41:19.49,中文,,0,0,0,,但如果你想的话 你可以尝试一下
Dialogue: 0,0:41:19.49,0:41:22.00,英文,,0,0,0,,OK. Let's keep them quick.
Dialogue: 0,0:41:19.49,0:41:22.00,中文,,0,0,0,,让我们快点
Dialogue: 0,0:41:22.00,0:41:28.11,英文,,0,0,0,,Go.
Dialogue: 0,0:41:22.00,0:41:28.11,中文,,0,0,0,,开始吧
Dialogue: 0,0:41:28.11,0:41:30.57,英文,,0,0,0,,Yeah, that's a great question, so I'll briefly spoil it.
Dialogue: 0,0:41:28.11,0:41:30.57,中文,,0,0,0,,是的 这是一个很好的问题 我会简单地剧透一下
Dialogue: 0,0:41:30.57,0:41:39.31,英文,,0,0,0,,One other note that I had to say before I finish this slide up is that when you pick a starting point, you need to pick a starting point with no incoming edges.
Dialogue: 0,0:41:30.57,0:41:39.31,中文,,0,0,0,,在结束这张幻灯片之前 我还要说一点 那就是当你选择起点时 你需要选择一个没有入边的起点
Dialogue: 0,0:41:39.31,0:41:47.70,英文,,0,0,0,,So for example, it would not be correct to start at H. You cannot start with the hardest class in your DFS post-order.
Dialogue: 0,0:41:39.31,0:41:47.70,中文,,0,0,0,,例如 从 H 开始是不正确的 你不能从 DFS 后序中最难的课程开始
Dialogue: 0,0:41:47.70,0:41:52.02,英文,,0,0,0,,So when you're running DFS, you need to start at a vertex with no incoming edges.
Dialogue: 0,0:41:47.70,0:41:52.02,中文,,0,0,0,,当你运行 DFS 时 你需要从一个没有入边的顶点开始
Dialogue: 0,0:41:52.02,0:41:56.88,英文,,0,0,0,,In this case, A and C are the vertices with no incoming edges.
Dialogue: 0,0:41:52.02,0:41:56.88,中文,,0,0,0,,在本例中 A 和 C 是没有入边的顶点
Dialogue: 0,0:41:56.88,0:42:02.91,英文,,0,0,0,,And if you're really curious, I think there's a bonus slide somewhere where you can see how to find those vertices.
Dialogue: 0,0:41:56.88,0:42:02.91,中文,,0,0,0,,如果你真的很好奇 我想在某张奖励幻灯片中可以看到如何找到这些顶点
Dialogue: 0,0:42:02.91,0:42:06.03,英文,,0,0,0,,Turns out, it doesn't add any asymptotic complexity.
Dialogue: 0,0:42:02.91,0:42:06.03,中文,,0,0,0,,事实证明 它不会增加任何渐近复杂度
Dialogue: 0,0:42:06.03,0:42:07.25,英文,,0,0,0,,But that's a great question.
Dialogue: 0,0:42:06.03,0:42:07.25,中文,,0,0,0,,但这是一个很好的问题
Dialogue: 0,0:42:07.25,0:42:10.47,英文,,0,0,0,,So you've got to start with the vertices with no incoming edges.
Dialogue: 0,0:42:07.25,0:42:10.47,中文,,0,0,0,,你必须从没有入边的顶点开始
Dialogue: 0,0:42:10.47,0:42:13.42,英文,,0,0,0,,OK, question.
Dialogue: 0,0:42:10.47,0:42:13.42,中文,,0,0,0,,好的 问题
Dialogue: 0,0:42:13.42,0:42:14.32,英文,,0,0,0,,Yes, how do you find them?
Dialogue: 0,0:42:13.42,0:42:14.32,中文,,0,0,0,,是的 如何找到它们？
Dialogue: 0,0:42:14.32,0:42:18.73,英文,,0,0,0,,I'm not going to tell you in this lecture, but you can look it up afterwards or come ask us later.
Dialogue: 0,0:42:14.32,0:42:18.73,中文,,0,0,0,,我不会在这节课上告诉你 但你可以在课后查阅或稍后过来问我们
Dialogue: 0,0:42:18.73,0:42:21.29,英文,,0,0,0,,Next.
Dialogue: 0,0:42:18.73,0:42:21.29,中文,,0,0,0,,下一个
Dialogue: 0,0:42:21.29,0:42:25.07,英文,,0,0,0,,What is the runtime of what?
Dialogue: 0,0:42:21.29,0:42:25.07,中文,,0,0,0,,什么的运行时间是多少？
Dialogue: 0,0:42:25.07,0:42:26.41,英文,,0,0,0,,What's the call?
Dialogue: 0,0:42:25.07,0:42:26.41,中文,,0,0,0,,什么调用？
Dialogue: 0,0:42:26.41,0:42:27.77,英文,,0,0,0,,Oh, the reversing runtime?
Dialogue: 0,0:42:26.41,0:42:27.77,中文,,0,0,0,,哦 反转的运行时间？
Dialogue: 0,0:42:27.77,0:42:28.95,英文,,0,0,0,,It's probably just linear, right?
Dialogue: 0,0:42:27.77,0:42:28.95,中文,,0,0,0,,它可能只是线性的 对吧？
Dialogue: 0,0:42:28.95,0:42:30.67,英文,,0,0,0,,Because you just look at the list and reverse it.
Dialogue: 0,0:42:28.95,0:42:30.67,中文,,0,0,0,,因为你只是查看列表并反转它
Dialogue: 0,0:42:30.67,0:42:32.34,英文,,0,0,0,,You can take a list and you can reverse it in linear time.
Dialogue: 0,0:42:30.67,0:42:32.34,中文,,0,0,0,,你可以线性时间内反转一个列表
Dialogue: 0,0:42:32.34,0:42:32.84,英文,,0,0,0,,Linear time.
Dialogue: 0,0:42:32.34,0:42:32.84,中文,,0,0,0,,线性时间
Dialogue: 0,0:42:32.84,0:42:33.44,英文,,0,0,0,,OK.
Dialogue: 0,0:42:32.84,0:42:33.44,中文,,0,0,0,,
Dialogue: 0,0:42:33.44,0:42:35.52,英文,,0,0,0,,The reversing part, at least.
Dialogue: 0,0:42:33.44,0:42:35.52,中文,,0,0,0,,至少反转部分是这样
Dialogue: 0,0:42:35.52,0:42:37.22,英文,,0,0,0,,Nothing else?
Dialogue: 0,0:42:35.52,0:42:37.22,中文,,0,0,0,,没有别的了吗？
Dialogue: 0,0:42:37.22,0:42:39.34,英文,,0,0,0,,OK, good.
Dialogue: 0,0:42:37.22,0:42:39.34,中文,,0,0,0,,好的 很好
Dialogue: 0,0:42:39.34,0:42:44.41,英文,,0,0,0,,So the only final note I had to say was just, you have to restart depth-first search if you run out of nodes.
Dialogue: 0,0:42:39.34,0:42:44.41,中文,,0,0,0,,我最后要说的是 如果节点用完了 你必须重新启动深度优先搜索
Dialogue: 0,0:42:44.41,0:42:49.09,英文,,0,0,0,,Do not clear markings in between, because you don't want to revisit vertices you've already been to.
Dialogue: 0,0:42:44.41,0:42:49.09,中文,,0,0,0,,不要清除中间的标记 因为你不想重新访问已经访问过的顶点
Dialogue: 0,0:42:49.09,0:42:52.35,英文,,0,0,0,,And always start at vertices within degree 0.
Dialogue: 0,0:42:49.09,0:42:52.35,中文,,0,0,0,,始终从度数为 0 的顶点开始
Dialogue: 0,0:42:52.35,0:42:53.47,英文,,0,0,0,,Start at 61A.
Dialogue: 0,0:42:52.35,0:42:53.47,中文,,0,0,0,,从 61A 开始
Dialogue: 0,0:42:53.47,0:42:56.14,英文,,0,0,0,,Do not start at fancy graduate class.
Dialogue: 0,0:42:53.47,0:42:56.14,中文,,0,0,0,,不要从花哨的研究生课程开始
Dialogue: 0,0:42:56.14,0:42:58.12,英文,,0,0,0,,OK, good.
Dialogue: 0,0:42:56.14,0:42:58.12,中文,,0,0,0,,好的 很好
Dialogue: 0,0:42:58.12,0:43:08.31,英文,,0,0,0,,So one other interesting observation is, if I take my ordering, by the way, people call this a topological ordering, and you're about to see why,
Dialogue: 0,0:42:58.12,0:43:08.31,中文,,0,0,0,,另一个有趣的观察是 如果我按照我的顺序排列 顺便说一下 人们称之为拓扑排序 你马上就会明白为什么
Dialogue: 0,0:43:08.31,0:43:15.31,英文,,0,0,0,, is if I take this ordering, and I take these nodes on the graph, and I drag them around
Dialogue: 0,0:43:08.31,0:43:14.31,中文,,0,0,0,,如果我按照这个顺序排列 然后我把图上的这些节点拖动
Dialogue: 0,0:43:14.31,0:43:22.31,中文,,0,0,0,,使 C 在左边 然后是 F 然后是 G、A、D、B、E、H 如果我拖动这些节点
Dialogue: 0,0:43:15.31,0:43:22.31,英文,,0,0,0,,so that C is on the left, and then F, and then G, A, D, B, E, H, if I drag the nodes around,
Dialogue: 0,0:43:22.31,0:43:25.98,英文,,0,0,0,,And then I redraw the graph, I get something pretty interesting.
Dialogue: 0,0:43:22.31,0:43:25.98,中文,,0,0,0,,然后我重新绘制图形 我得到了一些非常有趣的东西
Dialogue: 0,0:43:25.98,0:43:34.92,英文,,0,0,0,,So if I take my topological order, the ordering that I just came up with, and I drag the nodes around on the slide, I'm not changing the graph in any way.
Dialogue: 0,0:43:25.98,0:43:34.92,中文,,0,0,0,,如果我按照我的拓扑顺序 也就是我刚刚提出的顺序 然后我把幻灯片上的节点拖动 我并没有以任何方式改变图形
Dialogue: 0,0:43:34.92,0:43:37.04,英文,,0,0,0,,It's the same nodes and the same edges.
Dialogue: 0,0:43:34.92,0:43:37.04,中文,,0,0,0,,节点和边都是一样的
Dialogue: 0,0:43:37.04,0:43:43.37,英文,,0,0,0,,But if I take my nodes and I drag them around on the slide and put them in this order, look at all my arrows.
Dialogue: 0,0:43:37.04,0:43:43.37,中文,,0,0,0,,但是 如果我把节点拖动到幻灯片上并按这个顺序排列 看看我所有的箭头
Dialogue: 0,0:43:43.37,0:43:46.01,英文,,0,0,0,,They're all pointing to the right.
Dialogue: 0,0:43:43.37,0:43:46.01,中文,,0,0,0,,它们都指向右边
Dialogue: 0,0:43:46.01,0:43:47.05,英文,,0,0,0,,That's kind of cool.
Dialogue: 0,0:43:46.01,0:43:47.05,中文,,0,0,0,,这有点酷
Dialogue: 0,0:43:47.05,0:43:52.30,英文,,0,0,0,,And it makes sense, because remember, my ordering says that all the arrows point to the right.
Dialogue: 0,0:43:47.05,0:43:52.30,中文,,0,0,0,,这是有道理的 因为记住 我的排序说所有的箭头都指向右边
Dialogue: 0,0:43:52.30,0:44:01.57,英文,,0,0,0,,It makes sense, because C has to come before F, F has to come before G, F has to come before E, and so forth.
Dialogue: 0,0:43:52.30,0:44:01.57,中文,,0,0,0,,这是有道理的 因为 C 必须在 F 之前 F 必须在 G 之前 F 必须在 E 之前 等等
Dialogue: 0,0:44:01.57,0:44:09.19,英文,,0,0,0,,Coming up with this order, it also allows me to redraw this graph so that all of the arrows point to the right, which I find pretty cool.
Dialogue: 0,0:44:01.57,0:44:09.19,中文,,0,0,0,,提出这个顺序 它还允许我重新绘制这个图 使所有的箭头都指向右边 我觉得这很酷
Dialogue: 0,0:44:09.19,0:44:18.25,英文,,0,0,0,,That's why it's called a topological sort, by the way, because you're sort of changing the topology or the look of the graph so that all of the arrows point right.
Dialogue: 0,0:44:09.19,0:44:18.25,中文,,0,0,0,,这就是为什么它被称为拓扑排序 顺便说一下 因为你有点改变了图形的拓扑或外观 使所有的箭头都指向右边
Dialogue: 0,0:44:18.25,0:44:23.77,英文,,0,0,0,,And it's good that all of the dependencies point right, because you always want to do things in order.
Dialogue: 0,0:44:18.25,0:44:23.77,中文,,0,0,0,,所有依赖项都指向右边很好 因为你总是希望按顺序做事
Dialogue: 0,0:44:23.77,0:44:29.15,英文,,0,0,0,,So my arrow should always point right, because if I say C has to come before D,
Dialogue: 0,0:44:23.77,0:44:29.15,中文,,0,0,0,,我的箭头应该总是指向右边 因为如果我说 C 必须在 D 之前
Dialogue: 0,0:44:29.15,0:44:36.40,英文,,0,0,0,,This arrow from C to D needs to point to the right to indicate that C came before D. So that's the topological sort.
Dialogue: 0,0:44:29.15,0:44:36.40,中文,,0,0,0,,这个从 C 到 D 的箭头需要指向右边 以表明 C 在 D 之前 这就是拓扑排序
Dialogue: 0,0:44:36.40,0:44:40.08,英文,,0,0,0,,It creates this nice-looking graph where all the arrows point to the right.
Dialogue: 0,0:44:36.40,0:44:40.08,中文,,0,0,0,,它创建了这个漂亮的图形 所有的箭头都指向右边
Dialogue: 0,0:44:40.08,0:44:42.04,英文,,0,0,0,,So it gives you an ordering of tasks.
Dialogue: 0,0:44:40.08,0:44:42.04,中文,,0,0,0,,它给你一个任务排序
Dialogue: 0,0:44:42.04,0:44:48.54,英文,,0,0,0,,It also allows you to redraw the graph so the arrows are all pointing from left to right, which is cool.
Dialogue: 0,0:44:42.04,0:44:48.54,中文,,0,0,0,,它还允许你重新绘制图形 使箭头都从左到右 这很酷
Dialogue: 0,0:44:48.54,0:44:54.20,英文,,0,0,0,,OK. As we mentioned, when you run depth-first search here, you actually need to restart.
Dialogue: 0,0:44:48.54,0:44:54.20,中文,,0,0,0,,正如我们提到的 当你在这里运行深度优先搜索时 你实际上需要重新启动
Dialogue: 0,0:44:54.20,0:44:55.52,英文,,0,0,0,,Enough said about that.
Dialogue: 0,0:44:54.20,0:44:55.52,中文,,0,0,0,,说够了
Dialogue: 0,0:44:55.52,0:44:59.21,英文,,0,0,0,,And how do you find the vertices with no incoming edges?
Dialogue: 0,0:44:55.52,0:44:59.21,中文,,0,0,0,,你如何找到没有入边的顶点？
Dialogue: 0,0:44:59.21,0:45:01.55,英文,,0,0,0,,You can do so, although I'm not going to tell you how.
Dialogue: 0,0:44:59.21,0:45:01.55,中文,,0,0,0,,你可以这样做 但我不会告诉你如何做
Dialogue: 0,0:45:01.55,0:45:03.53,英文,,0,0,0,,So now you know.
Dialogue: 0,0:45:01.55,0:45:03.53,中文,,0,0,0,,现在你知道了
Dialogue: 0,0:45:03.53,0:45:08.83,英文,,0,0,0,,OK, so I guess to test if all of this makes sense, here's another graph.
Dialogue: 0,0:45:03.53,0:45:08.83,中文,,0,0,0,,我想为了测试这一切是否有意义 这里有另一个图
Dialogue: 0,0:45:08.83,0:45:11.62,英文,,0,0,0,,And I want you to find the topological sort.
Dialogue: 0,0:45:08.83,0:45:11.62,中文,,0,0,0,,我想让你找到拓扑排序
Dialogue: 0,0:45:11.62,0:45:13.42,英文,,0,0,0,,And you don't have to use the algorithm from before.
Dialogue: 0,0:45:11.62,0:45:13.42,中文,,0,0,0,,你不必使用以前的算法
Dialogue: 0,0:45:13.42,0:45:16.66,英文,,0,0,0,,You can just be a human and just look at it by eye.
Dialogue: 0,0:45:13.42,0:45:16.66,中文,,0,0,0,,你可以像人一样用眼睛看
Dialogue: 0,0:45:16.66,0:45:18.68,英文,,0,0,0,,So I'll kind of start talking through it.
Dialogue: 0,0:45:16.66,0:45:18.68,中文,,0,0,0,,我要开始讨论它
Dialogue: 0,0:45:18.68,0:45:20.06,英文,,0,0,0,,So I look at this graph.
Dialogue: 0,0:45:18.68,0:45:20.06,中文,,0,0,0,,我看着这个图
Dialogue: 0,0:45:20.06,0:45:22.60,英文,,0,0,0,,And I'm trying to find an ordering for all the tasks.
Dialogue: 0,0:45:20.06,0:45:22.60,中文,,0,0,0,,我正在尝试找到所有任务的顺序
Dialogue: 0,0:45:22.60,0:45:25.64,英文,,0,0,0,,And I say, well, A probably has to come first.
Dialogue: 0,0:45:22.60,0:45:25.64,中文,,0,0,0,,我说 好吧 A 可能必须排在第一位
Dialogue: 0,0:45:25.64,0:45:28.59,英文,,0,0,0,,That seems like the easiest thing in this graph.
Dialogue: 0,0:45:25.64,0:45:28.59,中文,,0,0,0,,这似乎是这个图中最简单的事情
Dialogue: 0,0:45:28.59,0:45:30.07,英文,,0,0,0,,So A comes first.
Dialogue: 0,0:45:28.59,0:45:30.07,中文,,0,0,0,, A 排在第一位
Dialogue: 0,0:45:30.07,0:45:35.26,英文,,0,0,0,,OK, then I can do either B or D. What do you want to do first in a topological ordering?
Dialogue: 0,0:45:30.07,0:45:35.26,中文,,0,0,0,,那么我可以做 B 或 D 在拓扑排序中 你想先做什么？
Dialogue: 0,0:45:35.26,0:45:37.71,英文,,0,0,0,,Do you want to do D first?
Dialogue: 0,0:45:35.26,0:45:37.71,中文,,0,0,0,,你想先做 D 吗？
Dialogue: 0,0:45:37.71,0:45:39.51,英文,,0,0,0,,Or do you want to do B first?
Dialogue: 0,0:45:37.71,0:45:39.51,中文,,0,0,0,,或者你想先做 B 吗？
Dialogue: 0,0:45:39.51,0:45:43.55,英文,,0,0,0,,And remember, this arrow tells me something about the ordering.
Dialogue: 0,0:45:39.51,0:45:43.55,中文,,0,0,0,,记住 这个箭头告诉我一些关于排序的信息
Dialogue: 0,0:45:43.55,0:45:51.11,英文,,0,0,0,,So the arrow constrains, I need to do D before I ever do B. So my topological ordering should be A, and then D,
Dialogue: 0,0:45:43.55,0:45:51.11,中文,,0,0,0,,箭头约束 我需要先做 D 再做 B 我的拓扑排序应该是 A 然后是 D
Dialogue: 0,0:45:51.11,0:45:58.11,英文,,0,0,0,,and then B, because D has to come before B. OK, at this point, I can do either C or E next.
Dialogue: 0,0:45:51.11,0:45:58.11,中文,,0,0,0,,然后是 B 因为 D 必须在 B 之前 在这一点上 我可以先做 C 或 E
Dialogue: 0,0:45:58.11,0:46:00.18,英文,,0,0,0,,Who wants to do C next?
Dialogue: 0,0:45:58.11,0:46:00.18,中文,,0,0,0,,谁想接下来做 C？
Dialogue: 0,0:46:00.18,0:46:01.64,英文,,0,0,0,,Anyone want to do E next?
Dialogue: 0,0:46:00.18,0:46:01.64,中文,,0,0,0,,有人想接下来做 E 吗？
Dialogue: 0,0:46:01.64,0:46:11.53,英文,,0,0,0,,Remember, the arrow says I need to do C before E. So my topological ordering should continue with C and then E. And then finally, I'll do F, whatever that is.
Dialogue: 0,0:46:01.64,0:46:11.53,中文,,0,0,0,,记住 箭头说我需要先做 C 再做 E 我的拓扑排序应该继续是 C 然后是 E 最后 我做 F 不管它是什么
Dialogue: 0,0:46:11.53,0:46:14.71,英文,,0,0,0,,So here's the topological ordering that I just mentioned.
Dialogue: 0,0:46:11.53,0:46:14.71,中文,,0,0,0,,我刚刚提到的拓扑排序是这样的
Dialogue: 0,0:46:14.71,0:46:24.50,英文,,0,0,0,,And again, if you take all of the vertices and you drag them around on the graph, then you will get this structure, where all of the arrows point to the right.
Dialogue: 0,0:46:14.71,0:46:24.50,中文,,0,0,0,,再说一次 如果你把所有的顶点都拖到图上 那么你就会得到这个结构 所有的箭头都指向右边
Dialogue: 0,0:46:24.50,0:46:27.82,英文,,0,0,0,,And that indicates the fact that all of my dependencies are satisfied.
Dialogue: 0,0:46:24.50,0:46:27.82,中文,,0,0,0,,这表明我所有的依赖项都满足了
Dialogue: 0,0:46:27.82,0:46:33.06,英文,,0,0,0,,I'm always doing the thing in the correct order, or the tasks in the correct order.
Dialogue: 0,0:46:27.82,0:46:33.06,中文,,0,0,0,,我总是按照正确的顺序做事情 或者按照正确的顺序做任务
Dialogue: 0,0:46:33.06,0:46:35.22,英文,,0,0,0,,OK, so we found that just by hand.
Dialogue: 0,0:46:33.06,0:46:35.22,中文,,0,0,0,,我们用手就找到了
Dialogue: 0,0:46:35.22,0:46:37.95,英文,,0,0,0,,You could also run the algorithm if you wanted to.
Dialogue: 0,0:46:35.22,0:46:37.95,中文,,0,0,0,,如果你愿意 你也可以运行算法
Dialogue: 0,0:46:37.95,0:46:41.07,英文,,0,0,0,,Now, here's a question that I thought someone would ask, but nobody asked it.
Dialogue: 0,0:46:37.95,0:46:41.07,中文,,0,0,0,,现在 这是我认为有人会问的问题 但没有人问
Dialogue: 0,0:46:41.07,0:46:45.99,英文,,0,0,0,,So I'll answer it for you, which is, what if your graph has cycles?
Dialogue: 0,0:46:41.07,0:46:45.99,中文,,0,0,0,,我来回答你 那就是 如果你的图有环怎么办？
Dialogue: 0,0:46:45.99,0:46:51.42,英文,,0,0,0,,For example, here's a graph with a cycle, A to B to E to H to A.
Dialogue: 0,0:46:45.99,0:46:51.42,中文,,0,0,0,,例如 这是一个有环的图 A 到 B 到 E 到 H 到 A
Dialogue: 0,0:46:51.42,0:46:59.42,英文,,0,0,0,,If I ask you to find a topological sort where all the arrows point to the right on this graph, it turns out there is no answer.
Dialogue: 0,0:46:51.42,0:46:59.42,中文,,0,0,0,,如果我让你找到一个拓扑排序 其中所有箭头都指向这个图的右边 结果是没有答案
Dialogue: 0,0:46:59.42,0:47:02.32,英文,,0,0,0,,The algorithm would simply say, no, I refuse.
Dialogue: 0,0:46:59.42,0:47:02.32,中文,,0,0,0,,该算法只会说 不 我拒绝
Dialogue: 0,0:47:02.32,0:47:04.79,英文,,0,0,0,,There is no valid answer.
Dialogue: 0,0:47:02.32,0:47:04.79,中文,,0,0,0,,没有有效的答案
Dialogue: 0,0:47:04.79,0:47:08.25,英文,,0,0,0,,In other words, there is no way to draw this graph.
Dialogue: 0,0:47:04.79,0:47:08.25,中文,,0,0,0,,换句话说 没有办法画出这个图
Dialogue: 0,0:47:08.25,0:47:11.01,英文,,0,0,0,,in a way such that all of the arrows point to the right.
Dialogue: 0,0:47:08.25,0:47:11.01,中文,,0,0,0,,以使所有箭头都指向右边的方式
Dialogue: 0,0:47:11.01,0:47:18.51,英文,,0,0,0,,There's no way to order these tasks, the tasks in the vertices, such that all of the dependencies are met if there is a cycle.
Dialogue: 0,0:47:11.01,0:47:18.51,中文,,0,0,0,,如果没有环 就无法对这些任务（顶点中的任务）进行排序 以满足所有依赖项
Dialogue: 0,0:47:18.51,0:47:29.79,英文,,0,0,0,,Because for example, if I said, you need to do A before B, and you also need to do B before A, well, then how the heck are you going to do both of those tasks in order?
Dialogue: 0,0:47:18.51,0:47:29.79,中文,,0,0,0,,因为例如 如果我说 你需要先做 A 再做 B 你也需要先做 B 再做 A 那么你到底要如何按顺序完成这两项任务呢？
Dialogue: 0,0:47:29.79,0:47:32.38,英文,,0,0,0,,You have to do A before B, and B before A?
Dialogue: 0,0:47:29.79,0:47:32.38,中文,,0,0,0,,你必须先做 A 再做 B 先做 B 再做 A？
Dialogue: 0,0:47:32.38,0:47:33.66,英文,,0,0,0,,That's not possible.
Dialogue: 0,0:47:32.38,0:47:33.66,中文,,0,0,0,,那是不可能的
Dialogue: 0,0:47:33.66,0:47:40.35,英文,,0,0,0,,So if the graph has cycles, then this problem is undefined, and there is simply no answer.
Dialogue: 0,0:47:33.66,0:47:40.35,中文,,0,0,0,,如果图有环 那么这个问题是未定义的 根本没有答案
Dialogue: 0,0:47:40.35,0:47:48.50,英文,,0,0,0,,For all the graphs that do have an answer, I'm going to introduce a term called directed acyclic graph, or DAG.
Dialogue: 0,0:47:40.35,0:47:48.50,中文,,0,0,0,,对于所有有答案的图 我将介绍一个术语 称为有向无环图 或 DAG
Dialogue: 0,0:47:48.50,0:47:55.44,英文,,0,0,0,,And this is the class of all possible graphs for which you can actually topologically sort them and get this nice order.
Dialogue: 0,0:47:48.50,0:47:55.44,中文,,0,0,0,,这是所有可能图的类 你可以实际对它们进行拓扑排序并得到这个很好的顺序
Dialogue: 0,0:47:55.44,0:47:58.77,英文,,0,0,0,,The properties you need are the graph has to be directed.
Dialogue: 0,0:47:55.44,0:47:58.77,中文,,0,0,0,,你需要的属性是图必须是有向的
Dialogue: 0,0:47:58.77,0:48:01.57,英文,,0,0,0,,There has to be arrows for this problem to even be defined.
Dialogue: 0,0:47:58.77,0:48:01.57,中文,,0,0,0,,必须有箭头才能定义这个问题
Dialogue: 0,0:48:01.57,0:48:06.55,英文,,0,0,0,,Remember, we said A has to come before D. There has to be an arrow for this to make sense.
Dialogue: 0,0:48:01.57,0:48:06.55,中文,,0,0,0,,记住 我们说 A 必须在 D 之前 必须有一个箭头才能使这个有意义
Dialogue: 0,0:48:06.55,0:48:09.38,英文,,0,0,0,,And also, the graph cannot have cycles.
Dialogue: 0,0:48:06.55,0:48:09.38,中文,,0,0,0,,而且 图不能有环
Dialogue: 0,0:48:09.38,0:48:12.16,英文,,0,0,0,,Because if the graph has cycles, there is no solution.
Dialogue: 0,0:48:09.38,0:48:12.16,中文,,0,0,0,,因为如果图有环 就没有解
Dialogue: 0,0:48:12.16,0:48:15.20,英文,,0,0,0,,You cannot solve this problem if there's a cycle.
Dialogue: 0,0:48:12.16,0:48:15.20,中文,,0,0,0,,如果有环 你就无法解决这个问题
Dialogue: 0,0:48:15.20,0:48:23.33,英文,,0,0,0,,So if the graph is directed and has no cycles, you can call it a directed acyclic graph, or DAG.
Dialogue: 0,0:48:15.20,0:48:23.33,中文,,0,0,0,,如果图是有向的并且没有环 你可以称它为有向无环图 或 DAG
Dialogue: 0,0:48:23.33,0:48:25.31,英文,,0,0,0,,And this is a special class of graph.
Dialogue: 0,0:48:23.33,0:48:25.31,中文,,0,0,0,,这是一类特殊的图
Dialogue: 0,0:48:25.31,0:48:27.95,英文,,0,0,0,,So in the real world, there are all sorts of graphs.
Dialogue: 0,0:48:25.31,0:48:27.95,中文,,0,0,0,,在现实世界中 有各种各样的图
Dialogue: 0,0:48:27.95,0:48:29.49,英文,,0,0,0,,There's tons and tons of graphs.
Dialogue: 0,0:48:27.95,0:48:29.49,中文,,0,0,0,,有成千上万的图
Dialogue: 0,0:48:29.49,0:48:34.18,英文,,0,0,0,,But a very special subset of them are directed acyclic graphs.
Dialogue: 0,0:48:29.49,0:48:34.18,中文,,0,0,0,,但其中一个非常特殊的子集是有向无环图
Dialogue: 0,0:48:34.18,0:48:39.64,英文,,0,0,0,,And what's cool is that these subset of graphs, they appear all the time in real life.
Dialogue: 0,0:48:34.18,0:48:39.64,中文,,0,0,0,,很酷的是 这些图的子集在现实生活中经常出现
Dialogue: 0,0:48:39.64,0:48:45.76,英文,,0,0,0,,And there are a lot of algorithms that are specialized to work on DAGs.
Dialogue: 0,0:48:39.64,0:48:45.76,中文,,0,0,0,,有很多算法专门用于 DAG
Dialogue: 0,0:48:45.76,0:48:49.16,英文,,0,0,0,,Can I steal one minute of your time to show you this next topic?
Dialogue: 0,0:48:45.76,0:48:49.16,中文,,0,0,0,,我能占用你一分钟的时间向你展示下一个话题吗？
Dialogue: 0,0:48:49.16,0:48:50.43,英文,,0,0,0,,Am I feeling evil?
Dialogue: 0,0:48:49.16,0:48:50.43,中文,,0,0,0,,我感觉邪恶吗？
Dialogue: 0,0:48:50.43,0:48:54.32,英文,,0,0,0,,I'll briefly do it, but I probably won't test you on it.
Dialogue: 0,0:48:50.43,0:48:54.32,中文,,0,0,0,,我会简单地做一下 但我可能不会考你
Dialogue: 0,0:48:54.32,0:48:55.68,英文,,0,0,0,,Should I do it? OK, I'll do it really quickly.
Dialogue: 0,0:48:54.32,0:48:55.68,中文,,0,0,0,,我应该这样做吗？ 我会很快做完
Dialogue: 0,0:48:55.68,0:49:01.36,英文,,0,0,0,,So the shortest path algorithm, remember, you can use Dijkstra's to run the shortest path algorithm.
Dialogue: 0,0:48:55.68,0:49:01.36,中文,,0,0,0,,最短路径算法 记住 你可以使用 Dijkstra’s算法来运行最短路径算法
Dialogue: 0,0:49:01.36,0:49:03.89,英文,,0,0,0,,That's what you would get if you ran Dijkstra's algorithm.
Dialogue: 0,0:49:01.36,0:49:03.89,中文,,0,0,0,,如果你运行 Dijkstra’s算法 你就会得到这个结果
Dialogue: 0,0:49:03.89,0:49:09.47,英文,,0,0,0,,However, if I introduce negative weights, Dijkstra's algorithm no longer gives you the right answer.
Dialogue: 0,0:49:03.89,0:49:09.47,中文,,0,0,0,,但是 如果我引入负权重 Dijkstra’s算法就不再给你正确的答案
Dialogue: 0,0:49:09.47,0:49:10.91,英文,,0,0,0,,Remember that from last time?
Dialogue: 0,0:49:09.47,0:49:10.91,中文,,0,0,0,,还记得上次吗？
Dialogue: 0,0:49:10.91,0:49:14.91,英文,,0,0,0,,If I use negative weights, Dijkstra's algorithm does not give you the right answer.
Dialogue: 0,0:49:10.91,0:49:14.91,中文,,0,0,0,,如果我使用负权重 Dijkstra’s算法不会给你正确的答案
Dialogue: 0,0:49:14.91,0:49:23.61,英文,,0,0,0,,However, if the graph is a directed acyclic graph, I can actually get the right answer, even with negative edges.
Dialogue: 0,0:49:14.91,0:49:23.61,中文,,0,0,0,,但是 如果图是有向无环图 我实际上可以得到正确的答案 即使有负边
Dialogue: 0,0:49:23.61,0:49:26.33,英文,,0,0,0,,OK, I'm not feeling that evil, so I won't test you on this.
Dialogue: 0,0:49:23.61,0:49:26.33,中文,,0,0,0,,我没有那么邪恶 我不会考你这个问题
Dialogue: 0,0:49:26.33,0:49:28.84,英文,,0,0,0,,You do need to know about DAGs, however.
Dialogue: 0,0:49:26.33,0:49:28.84,中文,,0,0,0,,但是 你需要了解 DAG
Dialogue: 0,0:49:28.84,0:49:31.68,英文,,0,0,0,,You do need to know what a directed acyclic graph is.
Dialogue: 0,0:49:28.84,0:49:31.68,中文,,0,0,0,,你需要知道什么是DAG
Dialogue: 0,0:49:31.68,0:49:36.28,英文,,0,0,0,,You do need to know why I can topologically sort them.
Dialogue: 0,0:49:31.68,0:49:36.28,中文,,0,0,0,,你需要知道为什么我可以对它们进行拓扑排序
Dialogue: 0,0:49:36.28,0:49:38.96,英文,,0,0,0,,But that's probably all you have to know.
Dialogue: 0,0:49:36.28,0:49:38.96,中文,,0,0,0,,但这可能是你必须知道的全部
Dialogue: 0,0:49:38.96,0:49:44.94,英文,,0,0,0,,OK, congrats on stalling a bunch of time out of me, and good luck on your midterm on Thursday.
Dialogue: 0,0:49:38.96,0:49:44.94,中文,,0,0,0,,恭喜你拖延了我很多时间 祝你周四的期中考试好运
Dialogue: 0,0:49:44.94,0:49:49.82,英文,,0,0,0,,OK, I don't know what you are applauding, but I'm glad you enjoyed it.
Dialogue: 0,0:49:44.94,0:49:49.82,中文,,0,0,0,,我不知道你在鼓掌什么 但我很高兴你喜欢它
Dialogue: 0,0:49:49.82,0:49:51.44,英文,,0,0,0,,OK, see you next time.
Dialogue: 0,0:49:49.82,0:49:51.44,中文,,0,0,0,,好的 下次见
