[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 3
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1152
PlayResY: 720

[Aegisub Project Garbage]
Export Encoding: Unicode (UTF-8)
Audio File: D:/python_code/video_tool/video_tool/result/Lecture 5 - Lists 3 DLLists and Arrays.mp4
Video File: D:/python_code/video_tool/video_tool/result/Lecture 5 - Lists 3 DLLists and Arrays.mp4
Video AR Mode: 4
Video AR Value: 1.600000
Video Zoom Percent: 0.500000
Scroll Position: 694
Active Line: 701
Video Position: 57565

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,13,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,90,100,0,0,1,1.33333,1.33333,2,6,6,7,1
Style: 英文,Arial,24,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,90,100,0,0,1,1.33333,1.33333,2,1,1,5,1
Style: 中文,微软雅黑,38,&H0029EEF1,&H000000FF,&H00000000,&H00000000,-1,0,0,0,90,100,0,0,1,1.33333,1.33333,2,2,2,30,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,
Dialogue: 0,0:00:11.47,0:00:16.60,英文,,0,0,0,,Before we get started, were there any questions from the part of Asymptotics 2 that we covered last week?
Dialogue: 0,0:00:11.47,0:00:16.60,中文,,0,0,0,,在我们开始之前 上周我们讲过的渐近分析 2 部分有没有任何问题
Dialogue: 0,0:00:16.60,0:00:20.74,英文,,0,0,0,,Or, sorry, last Wednesday?
Dialogue: 0,0:00:16.60,0:00:20.74,中文,,0,0,0,,或者 抱歉 上个星期三
Dialogue: 0,0:00:20.74,0:00:24.64,英文,,0,0,0,,Yeah, we are running behind on lectures.
Dialogue: 0,0:00:20.74,0:00:24.64,中文,,0,0,0,,是的 我们的讲座进度有点落后了
Dialogue: 0,0:00:24.64,0:00:26.33,英文,,0,0,0,,All right.
Dialogue: 0,0:00:26.33,0:00:31.91,英文,,0,0,0,,If there's nothing, then let's get started with today's stuff.
Dialogue: 0,0:00:26.33,0:00:31.91,中文,,0,0,0,,如果没有什么问题 那么让我们开始今天的内容吧
Dialogue: 0,0:00:31.91,0:00:36.27,英文,,0,0,0,,So let's talk about this function here.
Dialogue: 0,0:00:31.91,0:00:36.27,中文,,0,0,0,,我们来谈谈这个函数
Dialogue: 0,0:00:36.27,0:00:39.63,英文,,0,0,0,,I think, if I remember last time, we covered this very briefly.
Dialogue: 0,0:00:36.27,0:00:39.63,中文,,0,0,0,,我记得上次我们对这个进行了非常简短的介绍
Dialogue: 0,0:00:39.63,0:00:46.00,英文,,0,0,0,,And people said that the runtime of this function is 2 to the n. Does everyone agree with this?
Dialogue: 0,0:00:39.63,0:00:46.00,中文,,0,0,0,,有人说这个函数的运行时间是2的n次方 大家同意吗
Dialogue: 0,0:00:46.00,0:00:53.16,英文,,0,0,0,,The runtime of this function is 2 to the n. Why?
Dialogue: 0,0:00:46.00,0:00:53.16,中文,,0,0,0,,这个函数的运行时间是2的n次方 为什么
Dialogue: 0,0:00:53.16,0:00:57.95,英文,,0,0,0,,How do we explain why this is 2 to the n?
Dialogue: 0,0:00:53.16,0:00:57.95,中文,,0,0,0,,我们如何解释为什么是2的n次方
Dialogue: 0,0:00:57.95,0:01:01.33,英文,,0,0,0,,Any suggestions?
Dialogue: 0,0:00:57.95,0:01:01.33,中文,,0,0,0,,有什么建议吗
Dialogue: 0,0:01:01.33,0:01:13.23,英文,,0,0,0,,Yeah?
Dialogue: 0,0:01:01.33,0:01:13.23,中文,,0,0,0,,是吗
Dialogue: 0,0:01:13.23,0:01:17.48,英文,,0,0,0,,Yeah, what we can say is that there's a total of n of these levels.
Dialogue: 0,0:01:13.23,0:01:17.48,中文,,0,0,0,,是的 我们可以说总共有n个这些级别
Dialogue: 0,0:01:17.48,0:01:20.74,英文,,0,0,0,,This tree grows at a rate of doubling every single time.
Dialogue: 0,0:01:17.48,0:01:20.74,中文,,0,0,0,,这棵树每次都以翻倍的速度增长
Dialogue: 0,0:01:20.74,0:01:33.25,英文,,0,0,0,,So if we have n levels, and each time we go down one level, we double the number of elements, we end up with a total of 2 to the n items at the bottom.
Dialogue: 0,0:01:20.74,0:01:33.25,中文,,0,0,0,,如果我们有n层 每次下降一层 元素数量就翻倍 最终在底部总共有2的n次方个元素
Dialogue: 0,0:01:33.25,0:01:35.15,英文,,0,0,0,,Here we can kind of see how this works.
Dialogue: 0,0:01:33.25,0:01:35.15,中文,,0,0,0,,在这里 我们可以看到这是如何工作的
Dialogue: 0,0:01:35.15,0:01:40.91,英文,,0,0,0,,When we increase the height by 1, we end up making a copy of this tree, and then we add one unit of work.
Dialogue: 0,0:01:35.15,0:01:40.91,中文,,0,0,0,,当我们增加高度1时 我们实际上是复制了这棵树 然后添加了一单位的工作
Dialogue: 0,0:01:40.91,0:01:45.99,英文,,0,0,0,,So it doubles the work and then adds a bit.
Dialogue: 0,0:01:40.91,0:01:45.99,中文,,0,0,0,,它会使工作翻倍 然后再加上一点
Dialogue: 0,0:01:45.99,0:01:51.83,英文,,0,0,0,,So we can kind of see that if it's about doubling every time, then this is just about double the work every step.
Dialogue: 0,0:01:45.99,0:01:51.83,中文,,0,0,0,,我们可以看到 如果每次都是翻倍的话 那么每一步就是差不多翻倍的工作
Dialogue: 0,0:01:51.83,0:01:54.57,英文,,0,0,0,,So 2 to the n makes sense.
Dialogue: 0,0:01:51.83,0:01:54.57,中文,,0,0,0,,2的n次方是有道理的
Dialogue: 0,0:01:54.57,0:01:59.61,英文,,0,0,0,,Now, another approach we could do is just count the number of F3 calls.
Dialogue: 0,0:01:54.57,0:01:59.61,中文,,0,0,0,,现在 另一种方法是只计算f3调用的次数
Dialogue: 0,0:01:59.61,0:02:05.74,英文,,0,0,0,,And if we do that, then we see that the first layer, if we have C of 1, that's just a single unit of work.
Dialogue: 0,0:01:59.61,0:02:05.74,中文,,0,0,0,,如果我们这样做 那么我们会发现 第一层 如果我们有C等于1 那只是一个单位的工作
Dialogue: 0,0:02:05.74,0:02:08.10,英文,,0,0,0,,If you have C of 2, that's three units of work.
Dialogue: 0,0:02:05.74,0:02:08.10,中文,,0,0,0,,如果你有C等于2 那就是三个单位的工作
Dialogue: 0,0:02:08.10,0:02:09.96,英文,,0,0,0,,We have three calls.
Dialogue: 0,0:02:08.10,0:02:09.96,中文,,0,0,0,,我们有三个调用
Dialogue: 0,0:02:09.96,0:02:12.89,英文,,0,0,0,,If you have C of 3, then we do
Dialogue: 0,0:02:09.96,0:02:12.89,中文,,0,0,0,,如果你有C等于3 那么我们就做
Dialogue: 0,0:02:12.89,0:02:17.61,英文,,0,0,0,,4 units of work for this lowest layer, 2 units for the second layer, and 1 unit for this third layer.
Dialogue: 0,0:02:12.89,0:02:17.61,中文,,0,0,0,,这个最底层的工作量是4个单位 第二层是2个单位 第三层是1个单位
Dialogue: 0,0:02:17.61,0:02:18.87,英文,,0,0,0,,So you get 1 plus 2 plus 4.
Dialogue: 0,0:02:17.61,0:02:18.87,中文,,0,0,0,,你得到1加2加4
Dialogue: 0,0:02:18.87,0:02:20.49,英文,,0,0,0,,That's 7.
Dialogue: 0,0:02:18.87,0:02:20.49,中文,,0,0,0,,那就是7
Dialogue: 0,0:02:20.49,0:02:24.67,英文,,0,0,0,,If we keep going, what would be the final term of this sum?
Dialogue: 0,0:02:20.49,0:02:24.67,中文,,0,0,0,,如果我们继续下去 这个总和的最终项会是什么
Dialogue: 0,0:02:24.67,0:02:29.23,英文,,0,0,0,,Like up to n. I think these yell keys have expired.
Dialogue: 0,0:02:24.67,0:02:29.23,中文,,0,0,0,,就像到 n 我觉得这些黄色的键已经过期了
Dialogue: 0,0:02:29.23,0:02:32.36,英文,,0,0,0,,Or whoops.
Dialogue: 0,0:02:29.23,0:02:32.36,中文,,0,0,0,,或者哎呀
Dialogue: 0,0:02:32.36,0:02:35.14,英文,,0,0,0,,Yeah, these yell keys.
Dialogue: 0,0:02:32.36,0:02:35.14,中文,,0,0,0,,是的 这些黄色的键
Dialogue: 0,0:02:35.14,0:02:41.49,英文,,0,0,0,,Yeah, so show of hands, how many people say the final term is n?
Dialogue: 0,0:02:35.14,0:02:41.49,中文,,0,0,0,,是的 那么举手 有多少人认为最终项是 n
Dialogue: 0,0:02:41.49,0:02:45.53,英文,,0,0,0,,How many people say it's B, 2 to the n?
Dialogue: 0,0:02:41.49,0:02:45.53,中文,,0,0,0,,有多少人认为是 B 2 的 n 次方
Dialogue: 0,0:02:45.53,0:02:49.31,英文,,0,0,0,,C, 2 to the n minus 1?
Dialogue: 0,0:02:45.53,0:02:49.31,中文,,0,0,0,,C 2 ^n 次方-1
Dialogue: 0,0:02:49.31,0:02:54.79,英文,,0,0,0,,D, 2 to the n minus 1?
Dialogue: 0,0:02:49.31,0:02:54.79,中文,,0,0,0,,D 2^n-1次方
Dialogue: 0,0:02:54.79,0:02:59.46,英文,,0,0,0,,E, 2 to the n minus 1 minus 1?
Dialogue: 0,0:02:54.79,0:02:59.46,中文,,0,0,0,,E 2的n-1次方-1
Dialogue: 0,0:02:59.46,0:03:02.44,英文,,0,0,0,,I saw, I think, six hands at most for any of these.
Dialogue: 0,0:02:59.46,0:03:02.44,中文,,0,0,0,,我看到 我想 这些中最多有六只手
Dialogue: 0,0:03:02.44,0:03:05.78,英文,,0,0,0,,And there are more than six times five students here.
Dialogue: 0,0:03:02.44,0:03:05.78,中文,,0,0,0,,这里有超过六乘以五的学生
Dialogue: 0,0:03:05.78,0:03:08.72,英文,,0,0,0,,Who didn't vote?
Dialogue: 0,0:03:05.78,0:03:08.72,中文,,0,0,0,,谁没投票
Dialogue: 0,0:03:08.72,0:03:12.10,英文,,0,0,0,,OK, there's more people who voted for that.
Dialogue: 0,0:03:08.72,0:03:12.10,中文,,0,0,0,,投了那个选项的人更多
Dialogue: 0,0:03:12.10,0:03:14.52,英文,,0,0,0,,All right.
Dialogue: 0,0:03:14.52,0:03:21.83,英文,,0,0,0,,So what I would say is that if you look at this pattern, C of 3 has three terms that start at 0, 1, 2.
Dialogue: 0,0:03:14.52,0:03:21.83,中文,,0,0,0,,我想说的是 如果你看这个模式 C的3次方有三项 从0、1、2开始
Dialogue: 0,0:03:21.83,0:03:24.47,英文,,0,0,0,,2 to the 0, 2 to the 1, 2 to the 2.
Dialogue: 0,0:03:21.83,0:03:24.47,中文,,0,0,0,,2的0次方 2的1次方 2的2次方
Dialogue: 0,0:03:24.47,0:03:31.03,英文,,0,0,0,,So if we have n terms here, then it'll go 0, 1, 2, all the way up to n minus 1 here.
Dialogue: 0,0:03:24.47,0:03:31.03,中文,,0,0,0,,如果我们有n项 那么它会从0、1、2一直到n减1
Dialogue: 0,0:03:31.03,0:03:36.74,英文,,0,0,0,,So we should have 2 to the n minus 1 at this last term.
Dialogue: 0,0:03:31.03,0:03:36.74,中文,,0,0,0,,我们应该在这最后一项有2的n减1次方
Dialogue: 0,0:03:36.74,0:03:43.58,英文,,0,0,0,,Now, if we add 1 plus 2 plus 4 plus 8 up to plus 2 to the n minus 1, what does that add up to?
Dialogue: 0,0:03:36.74,0:03:43.58,中文,,0,0,0,,现在 如果我们把1加到2加到4再加到8一直到2的n减1次方 这加起来是多少
Dialogue: 0,0:03:43.58,0:03:43.94,英文,,0,0,0,,Everyone?
Dialogue: 0,0:03:43.58,0:03:43.94,中文,,0,0,0,,大家
Dialogue: 0,0:03:43.94,0:03:50.76,英文,,0,0,0,,2 to the n. Yep.
Dialogue: 0,0:03:43.94,0:03:50.76,中文,,0,0,0,,是的 是2的n次方
Dialogue: 0,0:03:50.76,0:04:00.59,英文,,0,0,0,,Because when we add this up, we use our equation that we had earlier, where if you add these up, you just get the last term.
Dialogue: 0,0:03:50.76,0:04:00.59,中文,,0,0,0,,因为当我们把这些加起来时 我们使用之前的方程式 如果你把这些加起来 你就得到最后一项
Dialogue: 0,0:04:00.59,0:04:04.47,英文,,0,0,0,,Times a constant factor, so it's 2 to the n minus 1 times 2.
Dialogue: 0,0:04:00.59,0:04:04.47,中文,,0,0,0,,乘以一个常数因子 所以它是 2 的 n 减 1次方 乘以 2
Dialogue: 0,0:04:04.47,0:04:12.08,英文,,0,0,0,,That gets us to just 2 to the n. And then you subtract 1, so you get 2 to the n minus 1.
Dialogue: 0,0:04:04.47,0:04:12.08,中文,,0,0,0,,这让我们只得到了 2 的 n 次方 然后你减去 1 所以你得到了 2 的 n 次方减 1
Dialogue: 0,0:04:12.08,0:04:15.92,英文,,0,0,0,,Now, 2 to the n minus 1, that minus 1 doesn't really matter.
Dialogue: 0,0:04:12.08,0:04:15.92,中文,,0,0,0,,现在 2 的 n 次方减 1 那个减 1 实际上并不重要
Dialogue: 0,0:04:15.92,0:04:17.04,英文,,0,0,0,,We can just say that's a constant.
Dialogue: 0,0:04:15.92,0:04:17.04,中文,,0,0,0,,我们可以说那是一个常数
Dialogue: 0,0:04:17.04,0:04:25.37,英文,,0,0,0,,So we can just say that this runtime, or the number of calls, is theta of 2 to the n. Every single call does a constant amount of work.
Dialogue: 0,0:04:17.04,0:04:25.37,中文,,0,0,0,,我们可以说这个运行时间 或者调用次数 是 2 的 n 的Θ阶 每次调用只做一定量的工作
Dialogue: 0,0:04:25.37,0:04:34.47,英文,,0,0,0,,So the number of calls times the amount of work done per call is going to just be 2 to the n.
Dialogue: 0,0:04:25.37,0:04:34.47,中文,,0,0,0,,调用次数乘以每次调用的工作量就会得到 2 的 n
Dialogue: 0,0:04:34.47,0:04:39.29,英文,,0,0,0,,Now, this one's relatively easy to see.
Dialogue: 0,0:04:34.47,0:04:39.29,中文,,0,0,0,,现在 这个相对容易看出来
Dialogue: 0,0:04:39.29,0:04:52.58,英文,,0,0,0,,You can see from this tree that you end up getting 2 to the n. It's important to note that this type of analysis can be quite hard if you even make some slight changes.
Dialogue: 0,0:04:39.29,0:04:52.58,中文,,0,0,0,,你可以从这棵树上看出来 你最终得到的是2的n次方 重要的是要注意 如果稍微做一些小的改变 这种分析可能会变得相当困难
Dialogue: 0,0:04:52.58,0:04:57.42,英文,,0,0,0,,In this above code, we had f3 of n minus 1 plus f3 of n minus 2.
Dialogue: 0,0:04:52.58,0:04:57.42,中文,,0,0,0,,在上面的代码中 我们有f3的n减1加上f3的n减2
Dialogue: 0,0:04:57.42,0:04:59.40,英文,,0,0,0,,I'm going to make one tiny change here.
Dialogue: 0,0:04:57.42,0:04:59.40,中文,,0,0,0,,我要做一个微小的改变在这里
Dialogue: 0,0:04:59.40,0:05:02.95,英文,,0,0,0,,I'm going to change one of those minus 1's to a minus 2.
Dialogue: 0,0:04:59.40,0:05:02.95,中文,,0,0,0,,我要将其中一个减1的地方改成减2
Dialogue: 0,0:05:02.95,0:05:05.27,英文,,0,0,0,,And I'm just going to rename this fib just for fun.
Dialogue: 0,0:05:02.95,0:05:05.27,中文,,0,0,0,,而且 我只是为了好玩把这个fib重新命名一下
Dialogue: 0,0:05:05.27,0:05:07.91,英文,,0,0,0,,I don't know why I named it fib.
Dialogue: 0,0:05:05.27,0:05:07.91,中文,,0,0,0,,我不知道为什么我给它起了个名字叫fib
Dialogue: 0,0:05:07.91,0:05:09.75,英文,,0,0,0,,You know, just having some fun here.
Dialogue: 0,0:05:07.91,0:05:09.75,中文,,0,0,0,,你知道的 就是在这里玩得开心
Dialogue: 0,0:05:09.75,0:05:12.61,英文,,0,0,0,,I like new names.
Dialogue: 0,0:05:09.75,0:05:12.61,中文,,0,0,0,,我喜欢新名字
Dialogue: 0,0:05:12.61,0:05:16.53,英文,,0,0,0,,What's the runtime of this function?
Dialogue: 0,0:05:12.61,0:05:16.53,中文,,0,0,0,,这个函数的运行时间是多少
Dialogue: 0,0:05:16.53,0:05:23.92,英文,,0,0,0,,Let's try talking to your neighbors, see if you can compute what the runtime should be here.
Dialogue: 0,0:05:16.53,0:05:23.92,中文,,0,0,0,,我们试着和你的邻居聊一聊 看看你能不能计算出这里的运行时间应该是多少
Dialogue: 0,0:05:23.92,0:05:33.59,英文,,0,0,0,,Just for a bit.
Dialogue: 0,0:05:23.92,0:05:33.59,中文,,0,0,0,,就只是一会儿
Dialogue: 0,0:05:33.59,0:07:43.23,英文,,0,0,0,,We'll give two minutes for that.
Dialogue: 0,0:05:33.59,0:07:43.23,中文,,0,0,0,,我们给那个两分钟
Dialogue: 0,0:07:43.23,0:07:46.83,英文,,0,0,0,,All right, let's bring everyone back.
Dialogue: 0,0:07:43.23,0:07:46.83,中文,,0,0,0,,让我们把大家都召回来
Dialogue: 0,0:07:46.83,0:07:53.17,英文,,0,0,0,,So did anyone get to an answer of what the runtime of this code is?
Dialogue: 0,0:07:46.83,0:07:53.17,中文,,0,0,0,,有人得出这段代码的运行时间了吗
Dialogue: 0,0:07:53.17,0:07:54.80,英文,,0,0,0,,Yeah?
Dialogue: 0,0:07:53.17,0:07:54.80,中文,,0,0,0,,嗯
Dialogue: 0,0:07:54.80,0:07:55.70,英文,,0,0,0,,Constant.
Dialogue: 0,0:07:54.80,0:07:55.70,中文,,0,0,0,,常数时间
Dialogue: 0,0:07:55.70,0:07:59.82,英文,,0,0,0,,How many people said constant?
Dialogue: 0,0:07:55.70,0:07:59.82,中文,,0,0,0,,有多少人说是常数时间
Dialogue: 0,0:07:59.82,0:08:06.87,英文,,0,0,0,,All right, any other answers?
Dialogue: 0,0:07:59.82,0:08:06.87,中文,,0,0,0,,还有其他答案吗
Dialogue: 0,0:08:06.87,0:08:08.38,英文,,0,0,0,,Yeah?
Dialogue: 0,0:08:06.87,0:08:08.38,中文,,0,0,0,,嗯
Dialogue: 0,0:08:08.38,0:08:09.74,英文,,0,0,0,,Exponential?
Dialogue: 0,0:08:08.38,0:08:09.74,中文,,0,0,0,,指数时间
Dialogue: 0,0:08:09.74,0:08:12.08,英文,,0,0,0,,Yeah, it is exponential.
Dialogue: 0,0:08:09.74,0:08:12.08,中文,,0,0,0,,是的 它是指数的
Dialogue: 0,0:08:12.08,0:08:15.32,英文,,0,0,0,,How many people said some form of exponential?
Dialogue: 0,0:08:12.08,0:08:15.32,中文,,0,0,0,,有多少人说过某种形式的指数
Dialogue: 0,0:08:15.32,0:08:16.18,英文,,0,0,0,,Most people.
Dialogue: 0,0:08:15.32,0:08:16.18,中文,,0,0,0,,大多数人
Dialogue: 0,0:08:16.18,0:08:19.35,英文,,0,0,0,,I think it's fairly agreeable that this is exponential.
Dialogue: 0,0:08:16.18,0:08:19.35,中文,,0,0,0,,我认为这是指数的基础上相当可接受的
Dialogue: 0,0:08:19.35,0:08:21.91,英文,,0,0,0,,The problem is what kind of exponential?
Dialogue: 0,0:08:19.35,0:08:21.91,中文,,0,0,0,,问题是什么样的指数
Dialogue: 0,0:08:21.91,0:08:25.27,英文,,0,0,0,,Yeah?
Dialogue: 0,0:08:21.91,0:08:25.27,中文,,0,0,0,,是吗
Dialogue: 0,0:08:25.27,0:08:27.93,英文,,0,0,0,,Base 5.
Dialogue: 0,0:08:25.27,0:08:27.93,中文,,0,0,0,,基数5
Dialogue: 0,0:08:27.93,0:08:28.61,英文,,0,0,0,,Ooh.
Dialogue: 0,0:08:27.93,0:08:28.61,中文,,0,0,0,,哦
Dialogue: 0,0:08:28.61,0:08:29.22,英文,,0,0,0,,Yeah, 1.618.
Dialogue: 0,0:08:28.61,0:08:29.22,中文,,0,0,0,,是的 1.618
Dialogue: 0,0:08:29.22,0:08:31.68,英文,,0,0,0,,That does seem like a reasonable number.
Dialogue: 0,0:08:29.22,0:08:31.68,中文,,0,0,0,,这似乎是一个合理的数字
Dialogue: 0,0:08:31.68,0:08:38.92,英文,,0,0,0,,How'd you get 1.618?
Dialogue: 0,0:08:31.68,0:08:38.92,中文,,0,0,0,,你怎么得到1.618的
Dialogue: 0,0:08:38.92,0:08:41.17,英文,,0,0,0,,Yeah.
Dialogue: 0,0:08:38.92,0:08:41.17,中文,,0,0,0,,是的
Dialogue: 0,0:08:41.17,0:08:45.81,英文,,0,0,0,,Did anyone get a different base?
Dialogue: 0,0:08:41.17,0:08:45.81,中文,,0,0,0,,有人得到了不同的底数吗
Dialogue: 0,0:08:45.81,0:08:46.85,英文,,0,0,0,,No?
Dialogue: 0,0:08:45.81,0:08:46.85,中文,,0,0,0,,没有
Dialogue: 0,0:08:46.85,0:08:47.69,英文,,0,0,0,,All right.
Dialogue: 0,0:08:47.69,0:08:51.88,英文,,0,0,0,,So ultimately, you are right.
Dialogue: 0,0:08:47.69,0:08:51.88,中文,,0,0,0,,最终 你是对的
Dialogue: 0,0:08:51.88,0:08:53.90,英文,,0,0,0,,It's 1.618.
Dialogue: 0,0:08:51.88,0:08:53.90,中文,,0,0,0,,这是1.618
Dialogue: 0,0:08:53.90,0:08:58.96,英文,,0,0,0,,But you can't really do the simple analysis that we did earlier.
Dialogue: 0,0:08:53.90,0:08:58.96,中文,,0,0,0,,但你不能真的像我们之前那样进行简单的分析
Dialogue: 0,0:08:58.96,0:09:05.83,英文,,0,0,0,,In order to do this analysis, kind of what you need to do is you need to notice that this is representing the Fibonacci numbers.
Dialogue: 0,0:08:58.96,0:09:05.83,中文,,0,0,0,,为了进行这种分析 你需要注意到这代表了斐波那契数
Dialogue: 0,0:09:05.83,0:09:14.15,英文,,0,0,0,,And you just kind of count it in this weird way, where you count the number of leaf nodes, and you count the number of internal nodes separately.
Dialogue: 0,0:09:05.83,0:09:14.15,中文,,0,0,0,,你只需要以一种奇怪的方式计数 其中你分别计算叶节点的数量和内部节点的数量
Dialogue: 0,0:09:14.15,0:09:19.96,英文,,0,0,0,,Now, if you count the number of leaf nodes, each of these leaf nodes correspond to adding one to the total sum.
Dialogue: 0,0:09:14.15,0:09:19.96,中文,,0,0,0,,现在 如果你计算叶节点的数量 每个叶节点都对应将总和增加一
Dialogue: 0,0:09:19.96,0:09:23.62,英文,,0,0,0,,Because every time we have a leaf, we are returning one.
Dialogue: 0,0:09:19.96,0:09:23.62,中文,,0,0,0,,因为每次我们有一个叶子 我们就返回一个
Dialogue: 0,0:09:23.62,0:09:32.65,英文,,0,0,0,,The total number of leaf nodes is therefore going to be the nth Fibonacci number. And the total number of green nodes,
Dialogue: 0,0:09:23.62,0:09:32.65,中文,,0,0,0,,所以叶子节点的总数将是第n个斐波那契数
Dialogue: 0,0:09:32.65,0:09:38.46,英文,,0,0,0,,Well, in order to combine everything, every single step, it adds two numbers together to one.
Dialogue: 0,0:09:32.65,0:09:38.46,中文,,0,0,0,,好吧 为了将一切都组合起来 每一步都将两个数字相加到一个
Dialogue: 0,0:09:38.46,0:09:47.12,英文,,0,0,0,,So if you have this many leaves, you need to have fn-1 green nodes.
Dialogue: 0,0:09:38.46,0:09:47.12,中文,,0,0,0,,如果你有这么多叶子 你就需要有fn-1个绿色节点
Dialogue: 0,0:09:47.12,0:09:50.76,英文,,0,0,0,,If you have five different things that you're adding together, you need to add a total of four times.
Dialogue: 0,0:09:47.12,0:09:50.76,中文,,0,0,0,,如果你有五个不同的东西要加在一起 你需要加总共四次
Dialogue: 0,0:09:50.76,0:09:56.09,英文,,0,0,0,,If you have fn things to add together, then you need to add fn-1 times.
Dialogue: 0,0:09:50.76,0:09:56.09,中文,,0,0,0,,如果你有fn个东西要加在一起 那么你需要加fn-1次
Dialogue: 0,0:09:56.09,0:10:00.79,英文,,0,0,0,,So if we add up the total number of yellow and green things,
Dialogue: 0,0:09:56.09,0:10:00.79,中文,,0,0,0,,如果我们把黄色和绿色的东西的总数加起来
Dialogue: 0,0:10:00.79,0:10:05.79,英文,,0,0,0,, we have a total of 2 times the n-th Fibonacci number minus 1, which is theta of the Fibonacci sequence of n.
Dialogue: 0,0:10:00.79,0:10:05.79,中文,,0,0,0,,我们得到的是第n个斐波那契数的两倍减1 也就是斐波那契序列的theta of n
Dialogue: 0,0:10:05.79,0:10:12.79,英文,,0,0,0,, Now, if you do the math, you can show that this is actually theta of phi to the n.
Dialogue: 0,0:10:05.79,0:10:12.79,中文,,0,0,0,,现在 如果你做数学运算 你可以证明这实际上是phi的n次方的theta
Dialogue: 0,0:10:12.79,0:10:18.79,英文,,0,0,0,,Phi is the golden ratio, 1.618 approximately.
Dialogue: 0,0:10:12.79,0:10:18.79,中文,,0,0,0,,phi是黄金分割比 约为1.618
Dialogue: 0,0:10:18.79,0:10:22.81,英文,,0,0,0,,So each function call does one unit work.
Dialogue: 0,0:10:18.79,0:10:22.81,中文,,0,0,0,,每个函数调用都做一单位的工作
Dialogue: 0,0:10:22.81,0:10:31.15,英文,,0,0,0,,So we can say that the total runtime of this is just about theta 1.618 to the n. This is not within scope.
Dialogue: 0,0:10:22.81,0:10:31.15,中文,,0,0,0,,我们可以说 这个的总运行时间大约是theta 1.618的n次方 这不在讨论范围内
Dialogue: 0,0:10:31.15,0:10:40.02,英文,,0,0,0,,You don't need to know that the Fibonacci numbers are phi to the n. But it's kind of useful to see that there's no magic shortcut here.
Dialogue: 0,0:10:31.15,0:10:40.02,中文,,0,0,0,,你不需要知道斐波那契数是phi的n次方 但是看到这里没有魔术捷径也挺有用的
Dialogue: 0,0:10:40.02,0:10:47.90,英文,,0,0,0,,Just this tiny change that I changed this 1 into a 2 ended up changing the runtime completely.
Dialogue: 0,0:10:40.02,0:10:47.90,中文,,0,0,0,,就是这么微小的改变 我把这个1改成了2 结果完全改变了运行时间
Dialogue: 0,0:10:47.90,0:10:56.72,英文,,0,0,0,,I would say that generally what you should be able to conclude from this particular slide, you should be able to know,
Dialogue: 0,0:10:47.90,0:10:56.72,中文,,0,0,0,,我会说一般来说 你应该能够从这张幻灯片中得出结论
Dialogue: 0,0:10:56.72,0:11:05.72,英文,,0,0,0,,though, that this is O of 2 to the n, because this is strictly going to be faster than the version that we had earlier.
Dialogue: 0,0:10:56.72,0:11:05.72,中文,,0,0,0,,尽管如此 你应该能够知道 这是O of 2的n次方 因为这肯定比我们之前的版本快
Dialogue: 0,0:11:05.72,0:11:08.52,英文,,0,0,0,,This code here was theta of 2 to the n.
Dialogue: 0,0:11:05.72,0:11:08.52,中文,,0,0,0,,这段代码的theta是2的n次方
Dialogue: 0,0:11:08.52,0:11:12.08,英文,,0,0,0,,And this code here is going to do strictly less work.
Dialogue: 0,0:11:08.52,0:11:12.08,中文,,0,0,0,,而这段代码在执行上会做更少的工作
Dialogue: 0,0:11:12.08,0:11:19.09,英文,,0,0,0,,So we can say with this that this is O of 2 to the n. We don't necessarily know that it's going to be exactly 2 to the n.
Dialogue: 0,0:11:12.08,0:11:19.09,中文,,0,0,0,,我们可以说 这是O的2的n次方 我们不一定知道它会是精确的2的n次方
Dialogue: 0,0:11:19.09,0:11:24.09,英文,,0,0,0,, But we can say that it's strictly faster than 2 to the n, or at least faster than 2 to the n.
Dialogue: 0,0:11:19.09,0:11:24.09,中文,,0,0,0,,但我们可以说它严格比2的n次方要快 或者至少比2的n次方要快
Dialogue: 0,0:11:24.09,0:11:27.81,英文,,0,0,0,,So this is kind of where this O notation does sometimes come in handy.
Dialogue: 0,0:11:24.09,0:11:27.81,中文,,0,0,0,,这就是这个O符号有时候确实会派上用场的地方
Dialogue: 0,0:11:27.81,0:11:35.17,英文,,0,0,0,,You find that 2 to the n is like an upper bound, and you will be able to do that math with the material you know in this class.
Dialogue: 0,0:11:27.81,0:11:35.17,中文,,0,0,0,,你会发现2的n次方就像一个上界 你将能够用这门课上学到的知识做数学运算
Dialogue: 0,0:11:35.17,0:11:41.55,英文,,0,0,0,,In order to do the math here to show that it's 1.618 to the n, you actually have to do a lot more work.
Dialogue: 0,0:11:35.17,0:11:41.55,中文,,0,0,0,,为了在这里做数学运算 以显示它是1.618的n次方 你实际上需要做更多的工作
Dialogue: 0,0:11:41.55,0:11:52.45,英文,,0,0,0,,In a similar way, you can also show an omega bound of 2 to the quantity n over 2, because this is strictly better than if we did fib of n minus 2 plus fib of n minus 2.
Dialogue: 0,0:11:41.55,0:11:52.45,中文,,0,0,0,,类似地 你还可以展示2的n除以2的数量的Ω上界 因为这绝对比我们做fib of n减去2加上fib of n减去2要好
Dialogue: 0,0:11:52.45,0:11:59.97,英文,,0,0,0,,And if you were to do that, then you also show this bound is actually 1.414 to the n.
Dialogue: 0,0:11:52.45,0:11:59.97,中文,,0,0,0,,如果你这样做了 那么你还可以证明这个上界实际上是1.414的n次方
Dialogue: 0,0:11:59.97,0:12:08.97,英文,,0,0,0,,So we can see with the information that we have in this class, this is omega 1.414 to the n and O of 2 to the n.
Dialogue: 0,0:11:59.97,0:12:08.97,中文,,0,0,0,,我们可以看到 在这门课上我们所学的信息是Ω 1.414的n次方和O的2的n次方
Dialogue: 0,0:12:08.97,0:12:13.97,英文,,0,0,0,,As it turns out, it's theta of 1.618 to the n, right in the middle.
Dialogue: 0,0:12:08.97,0:12:13.97,中文,,0,0,0,,事实证明 它是Θ 1.618的n次方 正好在中间
Dialogue: 0,0:12:13.97,0:12:16.09,英文,,0,0,0,,Any questions on this example here?
Dialogue: 0,0:12:13.97,0:12:16.09,中文,,0,0,0,,这个例子有什么问题吗
Dialogue: 0,0:12:16.09,0:12:19.91,英文,,0,0,0,,Yeah?
Dialogue: 0,0:12:16.09,0:12:19.91,中文,,0,0,0,,嗯
Dialogue: 0,0:12:19.91,0:12:32.86,英文,,0,0,0,,So if we had fib of n minus 2, or if we did F3 of n minus 2 plus F3 of n minus 2 here, then this would be 2 to the power of n over 2.
Dialogue: 0,0:12:19.91,0:12:32.86,中文,,0,0,0,,如果我们计算 fib 的 n 减 2 或者我们计算 f3 的 n 减 2 加上 f3 的 n 减 2 那么这将是 2 的 n 除以 2 次方
Dialogue: 0,0:12:32.86,0:12:40.24,英文,,0,0,0,,Because it's just the same thing, but instead of doing subtracting by 2 every time, or instead of by 1 every time, we go down by 2 layers every time.
Dialogue: 0,0:12:32.86,0:12:40.24,中文,,0,0,0,,因为这只是相同的事情 但是每次减 2 而不是每次减 1 我们每次都下降 2 层
Dialogue: 0,0:12:40.24,0:12:43.92,英文,,0,0,0,,So we have the number of layers we have.
Dialogue: 0,0:12:40.24,0:12:43.92,中文,,0,0,0,,我们有了我们有的层数
Dialogue: 0,0:12:43.92,0:12:55.50,英文,,0,0,0,,And 2 to the n over 2, if you do your rearrangements, you get 2 to the 1 half to the power of n, which is square root of 2 to the power of n. And square root 2 is 1.414, approximately.
Dialogue: 0,0:12:43.92,0:12:55.50,中文,,0,0,0,,而 2 的 n 除以 2 如果你做你的重新排列 你会得到 2 的 1/2 次方的 n 也就是 2 的 n 次方的平方根 而平方根 2 约等于1.414
Dialogue: 0,0:12:55.50,0:13:01.27,英文,,0,0,0,,So yeah, that's kind of why we're able to say that this code here, it's omega of square root 2 to the n,
Dialogue: 0,0:12:55.50,0:13:01.27,中文,,0,0,0,,是的 这就是为什么我们能够说这段代码的 omega 是 2 的 n 的平方根
Dialogue: 0,0:13:01.27,0:13:07.27,英文,,0,0,0,,and it's O of 2 to the n. So that gives us a range of where we are in.
Dialogue: 0,0:13:01.27,0:13:07.27,中文,,0,0,0,,而它的 O 是 2 的 n 所以这给了我们一个范围 我们在哪里
Dialogue: 0,0:13:07.27,0:13:15.89,英文,,0,0,0,,And as it turns out, we can do the exact calculation to show that it's 1.618 to the n. In practice, you might not even be able to get this theta bound.
Dialogue: 0,0:13:07.27,0:13:15.89,中文,,0,0,0,,原来事实证明 我们可以进行精确计算 显示它是1.618的n次方 实际上 你可能甚至无法得到这个Θ边界
Dialogue: 0,0:13:15.89,0:13:21.29,英文,,0,0,0,,So just having that O and omega bound may be enough for you to say that this is exponential.
Dialogue: 0,0:13:15.89,0:13:21.29,中文,,0,0,0,,只要有了O和ω的边界 你可能就能说这是指数增长
Dialogue: 0,0:13:21.29,0:13:26.62,英文,,0,0,0,,You're not going to be able to run this in a reasonable amount of time.
Dialogue: 0,0:13:21.29,0:13:26.62,中文,,0,0,0,,你不会在合理的时间内运行这个
Dialogue: 0,0:13:26.62,0:13:28.24,英文,,0,0,0,,Any other questions here?
Dialogue: 0,0:13:26.62,0:13:28.24,中文,,0,0,0,,这里还有其他问题吗
Dialogue: 0,0:13:28.24,0:13:39.07,英文,,0,0,0,,Yeah?
Dialogue: 0,0:13:28.24,0:13:39.07,中文,,0,0,0,,嗯
Dialogue: 0,0:13:39.07,0:13:44.57,英文,,0,0,0,,Is there a strategy for computing large numbers and seeing if it approaches an asymptotic?
Dialogue: 0,0:13:39.07,0:13:44.57,中文,,0,0,0,,有没有一种计算大数字并查看其是否趋近于渐近的策略
Dialogue: 0,0:13:44.57,0:13:48.23,英文,,0,0,0,,You know, another word for strategy is shortcut.
Dialogue: 0,0:13:44.57,0:13:48.23,中文,,0,0,0,,你知道 战略的另一个词是捷径
Dialogue: 0,0:13:48.23,0:13:53.30,英文,,0,0,0,,There are no magic shortcuts in asymptotic analysis.
Dialogue: 0,0:13:48.23,0:13:53.30,中文,,0,0,0,,在渐近分析中 没有魔法捷径
Dialogue: 0,0:13:53.30,0:14:02.15,英文,,0,0,0,,Unfortunately, every single problem that you get, which is going to have a completely different reasoning, there's not really any default approach.
Dialogue: 0,0:13:53.30,0:14:02.15,中文,,0,0,0,,不幸的是 你遇到的每个问题都会有完全不同的推理方式 实际上没有任何默认的方法
Dialogue: 0,0:14:02.15,0:14:09.12,英文,,0,0,0,,The only reason why we were able to compute this particular asymptotic is because we knew what the Fibonacci sequence does,
Dialogue: 0,0:14:02.15,0:14:09.12,中文,,0,0,0,,我们之所以能够计算出这个特定的渐近性 唯一的原因是因为我们知道斐波那契数列的性质
Dialogue: 0,0:14:09.12,0:14:15.12,英文,,0,0,0,,and you can prove completely separately that the Fibonacci sequence grows at this rate.
Dialogue: 0,0:14:09.12,0:14:15.12,中文,,0,0,0,,并且你可以完全独立地证明斐波那契数列以这种速度增长
Dialogue: 0,0:14:15.12,0:14:20.60,英文,,0,0,0,,So you are not going to find magic shortcuts that solve every single problem.
Dialogue: 0,0:14:15.12,0:14:20.60,中文,,0,0,0,,你不会找到能解决每个问题的魔法捷径
Dialogue: 0,0:14:20.60,0:14:31.27,英文,,0,0,0,,For any solution you come up with, I can provably find an asymptotic problem that does not work with your given strategy.
Dialogue: 0,0:14:20.60,0:14:31.27,中文,,0,0,0,,无论你想出什么解决方案 我都可以证明找到一个渐近问题 这个解决方案不适用于你的策略
Dialogue: 0,0:14:31.27,0:14:41.68,英文,,0,0,0,,In fact, it is provably true that that's the case, because if it was possible to do that, then you'd prove that math is entirely illogical and that nothing works in reality.
Dialogue: 0,0:14:31.27,0:14:41.68,中文,,0,0,0,,事实上 可以证明这就是情况 因为如果可能做到这一点 那么你将证明数学完全不合乎逻辑 而现实中没有任何东西是有效的
Dialogue: 0,0:14:41.68,0:14:43.25,英文,,0,0,0,,Hopefully, math works.
Dialogue: 0,0:14:41.68,0:14:43.25,中文,,0,0,0,,希望数学有效
Dialogue: 0,0:14:43.25,0:14:44.06,英文,,0,0,0,,Right?
Dialogue: 0,0:14:43.25,0:14:44.06,中文,,0,0,0,,对吧
Dialogue: 0,0:14:44.06,0:14:45.14,英文,,0,0,0,,I'm really hopeful that math works.
Dialogue: 0,0:14:44.06,0:14:45.14,中文,,0,0,0,,我真的很希望数学能奏效
Dialogue: 0,0:14:45.14,0:14:48.72,英文,,0,0,0,,All right.
Dialogue: 0,0:14:48.72,0:14:53.46,英文,,0,0,0,,So let's take a look at another example.
Dialogue: 0,0:14:48.72,0:14:53.46,中文,,0,0,0,,那么让我们来看另一个例子吧
Dialogue: 0,0:14:53.46,0:14:57.60,英文,,0,0,0,,Sorry, this lecture goes over a lot of these examples kind of quickly.
Dialogue: 0,0:14:53.46,0:14:57.60,中文,,0,0,0,,抱歉 这个讲座涉及的例子有点快
Dialogue: 0,0:14:57.60,0:15:00.60,英文,,0,0,0,,This is a completely different example.
Dialogue: 0,0:14:57.60,0:15:00.60,中文,,0,0,0,,这是一个完全不同的例子
Dialogue: 0,0:15:00.60,0:15:04.73,英文,,0,0,0,,So in this one, we're going to talk about this algorithm known as binary search.
Dialogue: 0,0:15:00.60,0:15:04.73,中文,,0,0,0,,那么在这个例子中 我们将讨论被称为二分查找的算法
Dialogue: 0,0:15:04.73,0:15:11.45,英文,,0,0,0,,And the idea is you have a list of sorted items, and you want to find one particular item.
Dialogue: 0,0:15:04.73,0:15:11.45,中文,,0,0,0,,这个想法是你有一列排序好的项目 你想要找到一个特定的项目
Dialogue: 0,0:15:11.45,0:15:18.44,英文,,0,0,0,,Like, let's say that we have all these people here, and we sorted you by when your birthday is.
Dialogue: 0,0:15:11.45,0:15:18.44,中文,,0,0,0,,比如说 我们这里有这么多人 我们按照你们的生日排序了
Dialogue: 0,0:15:18.44,0:15:27.01,英文,,0,0,0,,And if I wanted to figure out if there exists someone in here whose birthday is, pick a random month.
Dialogue: 0,0:15:18.44,0:15:27.01,中文,,0,0,0,,如果我想要弄清楚这里是否存在一个人的生日是随机选取的一个月
Dialogue: 0,0:15:27.01,0:15:28.07,英文,,0,0,0,,December.
Dialogue: 0,0:15:27.01,0:15:28.07,中文,,0,0,0,,十二月
Dialogue: 0,0:15:28.07,0:15:28.47,英文,,0,0,0,,December.
Dialogue: 0,0:15:28.07,0:15:28.47,中文,,0,0,0,,十二月
Dialogue: 0,0:15:28.47,0:15:31.69,英文,,0,0,0,,Pick a random day, someone.
Dialogue: 0,0:15:28.47,0:15:31.69,中文,,0,0,0,,随便选一个日期 某个人
Dialogue: 0,0:15:31.69,0:15:32.61,英文,,0,0,0,,Fifth.
Dialogue: 0,0:15:31.69,0:15:32.61,中文,,0,0,0,,第五
Dialogue: 0,0:15:32.61,0:15:33.21,英文,,0,0,0,,All right.
Dialogue: 0,0:15:33.21,0:15:42.79,英文,,0,0,0,,So if I wanted to ask, if I wanted to find if anyone's birthday was December 5th, then how would I do that?
Dialogue: 0,0:15:33.21,0:15:42.79,中文,,0,0,0,,如果我想问 如果我想找出有没有人的生日是12月5日 那我该怎么做呢
Dialogue: 0,0:15:42.79,0:15:45.21,英文,,0,0,0,,Well, I'm already sorting everyone out.
Dialogue: 0,0:15:42.79,0:15:45.21,中文,,0,0,0,,我已经把每个人都分类好了
Dialogue: 0,0:15:45.21,0:15:53.19,英文,,0,0,0,,So what I do is I'd cut you in half into the people born after July and the people born before July.
Dialogue: 0,0:15:45.21,0:15:53.19,中文,,0,0,0,,我要做的就是把你分成在7月之后出生的人和在7月之前出生的人
Dialogue: 0,0:15:53.19,0:15:56.67,英文,,0,0,0,,Or I'd look in the middle and ask when your birthday is.
Dialogue: 0,0:15:53.19,0:15:56.67,中文,,0,0,0,,或者我会看中间 问你的生日是什么时候
Dialogue: 0,0:15:56.67,0:16:01.66,英文,,0,0,0,,If the middle person's birthday is December 12th,
Dialogue: 0,0:15:56.67,0:16:01.66,中文,,0,0,0,,如果中间那个人的生日是12月12日
Dialogue: 0,0:16:01.66,0:16:08.57,英文,,0,0,0,,Then that means that my December 5th birthday is going to be somewhere in the earlier half of the list.
Dialogue: 0,0:16:01.66,0:16:08.57,中文,,0,0,0,,那么这意味着我的12月5日生日会在名单的前半部分
Dialogue: 0,0:16:08.57,0:16:13.53,英文,,0,0,0,,If the birthday is in July, then that means that it should be in the later half of the list.
Dialogue: 0,0:16:08.57,0:16:13.53,中文,,0,0,0,,如果生日是在七月的话 那意味着它应该在列表的后半部分
Dialogue: 0,0:16:13.53,0:16:16.84,英文,,0,0,0,,So this way, I cut down the total number of people I need to look at in half.
Dialogue: 0,0:16:13.53,0:16:16.84,中文,,0,0,0,,这样一来 我就能把需要查看的人数减少一半
Dialogue: 0,0:16:16.84,0:16:22.54,英文,,0,0,0,,I then go to the middle of that half, and I say, hey, what's your birthday?
Dialogue: 0,0:16:16.84,0:16:22.54,中文,,0,0,0,,然后我去到这一半的中间 然后我说 嘿 你的生日是什么
Dialogue: 0,0:16:22.54,0:16:25.45,英文,,0,0,0,,I'm probably going to get somewhere like September.
Dialogue: 0,0:16:22.54,0:16:25.45,中文,,0,0,0,,我可能会得到九月这样的回答
Dialogue: 0,0:16:25.45,0:16:27.97,英文,,0,0,0,,So if I get September, I'm going to go into the second half.
Dialogue: 0,0:16:25.45,0:16:27.97,中文,,0,0,0,,如果我得到了九月 我就会进入第二半部分
Dialogue: 0,0:16:27.97,0:16:34.06,英文,,0,0,0,,And I can keep doing this, cutting the total number of people I'm looking at in half every single time, until I get to this last person.
Dialogue: 0,0:16:27.97,0:16:34.06,中文,,0,0,0,,我可以一直这样做 每次都把需要查看的人数减少一半 直到我找到最后一个人
Dialogue: 0,0:16:34.06,0:16:35.18,英文,,0,0,0,,Hey, what birthday are you?
Dialogue: 0,0:16:34.06,0:16:35.18,中文,,0,0,0,,嘿 你的生日是什么
Dialogue: 0,0:16:35.18,0:16:39.50,英文,,0,0,0,,And then you're either saying it's December 5th, or you say, no, it's December 6th.
Dialogue: 0,0:16:35.18,0:16:39.50,中文,,0,0,0,,然后你要么说是12月5日 要么说 不 是12月6日
Dialogue: 0,0:16:39.50,0:16:43.46,英文,,0,0,0,,But there's no other people in this group, so that means there's no one there.
Dialogue: 0,0:16:39.50,0:16:43.46,中文,,0,0,0,,但这个群里没有其他人 所以这意味着那里没有人
Dialogue: 0,0:16:43.46,0:16:46.10,英文,,0,0,0,,This is kind of what binary search does.
Dialogue: 0,0:16:43.46,0:16:46.10,中文,,0,0,0,,这就是二分查找的工作原理
Dialogue: 0,0:16:46.10,0:17:09.01,英文,,0,0,0,,You take a list that's sorted, you cut it in half, and see which side your item is.
Dialogue: 0,0:16:46.10,0:17:09.01,中文,,0,0,0,,你拿到一个已排序的列表 把它分成两半 看看你的项在哪一边
Dialogue: 0,0:17:09.01,0:17:13.33,英文,,0,0,0,,So even the best programmers in the world make mistakes.
Dialogue: 0,0:17:09.01,0:17:13.33,中文,,0,0,0,,即使是世界上最好的程序员也会犯错误
Dialogue: 0,0:17:13.33,0:17:14.77,英文,,0,0,0,,Test your code.
Dialogue: 0,0:17:13.33,0:17:14.77,中文,,0,0,0,,测试你的代码
Dialogue: 0,0:17:14.77,0:17:16.79,英文,,0,0,0,,You're going to write bugs in your code.
Dialogue: 0,0:17:14.77,0:17:16.79,中文,,0,0,0,,你会在你的代码中写入错误
Dialogue: 0,0:17:16.79,0:17:21.46,英文,,0,0,0,,Even if you test it all the way, there's still probably a bug somewhere that you haven't caught.
Dialogue: 0,0:17:16.79,0:17:21.46,中文,,0,0,0,,就算你全程测试 还是可能有你没发现的 bug
Dialogue: 0,0:17:21.46,0:17:27.77,英文,,0,0,0,,So just write as many tests as possible.
Dialogue: 0,0:17:21.46,0:17:27.77,中文,,0,0,0,,尽可能多写测试
Dialogue: 0,0:17:27.77,0:17:33.25,英文,,0,0,0,,What do you think the runtime of a binary search is going to be?
Dialogue: 0,0:17:27.77,0:17:33.25,中文,,0,0,0,,你觉得二分查找的运行时间会是多少
Dialogue: 0,0:17:33.25,0:17:41.71,英文,,0,0,0,,Every step, you take your list, you cut it in half, and you ask, is it in the first half or the second half?
Dialogue: 0,0:17:33.25,0:17:41.71,中文,,0,0,0,,每一步 你拿你的列表 把它切成两半 然后问 它在前半部分还是后半部分
Dialogue: 0,0:17:41.71,0:17:45.53,英文,,0,0,0,,And you keep doing that until you get to one unit.
Dialogue: 0,0:17:41.71,0:17:45.53,中文,,0,0,0,,然后你不断重复 直到你只剩一个单位
Dialogue: 0,0:17:45.53,0:17:50.37,英文,,0,0,0,,How many people say this would take constant time, theta 1?
Dialogue: 0,0:17:45.53,0:17:50.37,中文,,0,0,0,,多少人认为这需要常量时间 theta 1
Dialogue: 0,0:17:50.37,0:17:53.43,英文,,0,0,0,,How about log 2 of n?
Dialogue: 0,0:17:50.37,0:17:53.43,中文,,0,0,0,,log 2 的 n 呢
Dialogue: 0,0:17:53.43,0:17:55.35,英文,,0,0,0,,n?
Dialogue: 0,0:17:53.43,0:17:55.35,中文,,0,0,0,,n?
Dialogue: 0,0:17:55.35,0:17:57.71,英文,,0,0,0,,n log n?
Dialogue: 0,0:17:55.35,0:17:57.71,中文,,0,0,0,,n log n?
Dialogue: 0,0:17:57.71,0:17:59.51,英文,,0,0,0,,2 to the n?
Dialogue: 0,0:17:57.71,0:17:59.51,中文,,0,0,0,,2 的 n 次方?
Dialogue: 0,0:17:59.51,0:18:05.71,英文,,0,0,0,,All right, everyone said log 2 of n. Why log 2 of n?
Dialogue: 0,0:17:59.51,0:18:05.71,中文,,0,0,0,,每个人都说 log 2 的 n 为什么是 log 2 的 n
Dialogue: 0,0:18:05.71,0:18:10.38,英文,,0,0,0,,Yeah?
Dialogue: 0,0:18:05.71,0:18:10.38,中文,,0,0,0,,是的
Dialogue: 0,0:18:10.38,0:18:13.52,英文,,0,0,0,,Yeah, every time the length doubles, we add one more step.
Dialogue: 0,0:18:10.38,0:18:13.52,中文,,0,0,0,,是的 每次长度加倍 我们就多加一步
Dialogue: 0,0:18:13.52,0:18:23.19,英文,,0,0,0,,Because if we have it every single step, then that means that doubling once is just going to yield one extra step of work.
Dialogue: 0,0:18:13.52,0:18:23.19,中文,,0,0,0,,因为如果每一步都有 那就意味着只要加倍一次 就会多出一步的工作
Dialogue: 0,0:18:23.19,0:18:28.35,英文,,0,0,0,,Yep, the problem size just keeps adding over and over until it gets down to 1.
Dialogue: 0,0:18:23.19,0:18:28.35,中文,,0,0,0,,是的 问题规模一直不断增加 直到减小到1
Dialogue: 0,0:18:28.35,0:18:43.16,英文,,0,0,0,,One way we can say that is you solve for 1 is equal to n divided by 2 to the power of c. You can just do the math to show that that evaluates to c is equal to log 2 of n. Now, in practice, this is as fast as you need it to be.
Dialogue: 0,0:18:28.35,0:18:43.16,中文,,0,0,0,,有一种说法是 解决1等于n除以2的c次方 你只需要进行一些数学运算来证明c等于n的log2 实际上 这就是你需要的速度
Dialogue: 0,0:18:43.16,0:18:51.38,英文,,0,0,0,,You don't need to do any faster than binary search, because log time is just really, really fast.
Dialogue: 0,0:18:43.16,0:18:51.38,中文,,0,0,0,,你不需要比二分搜索更快 因为对数时间就是非常非常快的
Dialogue: 0,0:18:51.38,0:18:53.86,英文,,0,0,0,,This is kind of this general rule.
Dialogue: 0,0:18:51.38,0:18:53.86,中文,,0,0,0,,这是一种通用规律
Dialogue: 0,0:18:53.86,0:19:04.77,英文,,0,0,0,,If you have one thing that you do, that about takes one nanosecond worth of time, times or divided by a factor of 10.
Dialogue: 0,0:18:53.86,0:19:04.77,中文,,0,0,0,,如果你有一件事情需要一纳秒的时间 乘以或除以10的因子
Dialogue: 0,0:19:04.77,0:19:10.31,英文,,0,0,0,,So if you have a program that's really efficient, you can generally do about a billion things per step.
Dialogue: 0,0:19:04.77,0:19:10.31,中文,,0,0,0,,如果你的程序非常高效 通常你可以在一步中做大约十亿件事情
Dialogue: 0,0:19:10.31,0:19:12.57,英文,,0,0,0,,In order, or per second, sorry.
Dialogue: 0,0:19:10.31,0:19:12.57,中文,,0,0,0,,按顺序 或者每秒 抱歉
Dialogue: 0,0:19:12.57,0:19:22.16,英文,,0,0,0,,Now, if you want a log 2 of 1 billion, then you need 2 to the power 1 billion items, which is significantly larger than the number of atoms in the universe.
Dialogue: 0,0:19:12.57,0:19:22.16,中文,,0,0,0,,现在 如果你想要十亿的对数 2 那么你需要 2 的十亿次方个项目 这比宇宙中的原子数要大得多
Dialogue: 0,0:19:22.16,0:19:32.90,英文,,0,0,0,,So unless you're sorting the number of atoms in a multiverse, you're not going to have to sort more than one second.
Dialogue: 0,0:19:22.16,0:19:32.90,中文,,0,0,0,,除非你要对多宇宙中的原子数进行排序 否则你不会需要排序超过一秒钟的时间
Dialogue: 0,0:19:32.90,0:19:40.87,英文,,0,0,0,,Now, we have here some slides talking about how binary search works exactly, if you want to do the exact math.
Dialogue: 0,0:19:32.90,0:19:40.87,中文,,0,0,0,,现在 我们这里有一些幻灯片 讲述了二分查找的确切工作原理 如果你想要进行精确的数学计算
Dialogue: 0,0:19:40.87,0:19:44.25,英文,,0,0,0,,We're not going to cover this completely here.
Dialogue: 0,0:19:40.87,0:19:44.25,中文,,0,0,0,,我们在这里不会完全覆盖这个
Dialogue: 0,0:19:44.25,0:19:46.45,英文,,0,0,0,,We do have this pre-recorded video here for this.
Dialogue: 0,0:19:44.25,0:19:46.45,中文,,0,0,0,,我们确实有这个预先录制的视频
Dialogue: 0,0:19:46.45,0:19:48.53,英文,,0,0,0,,It's just another example.
Dialogue: 0,0:19:46.45,0:19:48.53,中文,,0,0,0,,这只是另一个例子
Dialogue: 0,0:19:48.53,0:19:53.19,英文,,0,0,0,,But you should be able to do this using the same concepts that we've discussed here.
Dialogue: 0,0:19:48.53,0:19:53.19,中文,,0,0,0,,但是你应该能够使用我们在这里讨论过的相同概念来完成这个
Dialogue: 0,0:19:53.19,0:20:03.68,英文,,0,0,0,,Effectively, once we take this list, we kind of split it in half, and we kind of just do this math, seeing exactly how many calls we have.
Dialogue: 0,0:19:53.19,0:20:03.68,中文,,0,0,0,,有效地 一旦我们拿到这个列表 我们就把它分成两半 然后我们就做这个数学 确切地看到我们有多少个调用
Dialogue: 0,0:20:03.68,0:20:07.78,英文,,0,0,0,,In the worst case, we can see that for n equals 1, the number of minimum calls is 1.
Dialogue: 0,0:20:03.68,0:20:07.78,中文,,0,0,0,,在最坏的情况下 我们可以看到当n等于1时 最小调用次数为1
Dialogue: 0,0:20:07.78,0:20:14.33,英文,,0,0,0,,For n equals 6, you need at least three calls here, because you might have this particular worst-case behavior.
Dialogue: 0,0:20:07.78,0:20:14.33,中文,,0,0,0,,当n等于6时 你至少需要三次调用 因为你可能会遇到这种特定的最坏情况行为
Dialogue: 0,0:20:14.33,0:20:18.68,英文,,0,0,0,,And you can just kind of show this math that it ends up showing up like this.
Dialogue: 0,0:20:14.33,0:20:18.68,中文,,0,0,0,,你可以简单地展示这个数学 它最终会显示出这样的情况
Dialogue: 0,0:20:18.68,0:20:22.02,英文,,0,0,0,,You draw this tree where n equals 3.
Dialogue: 0,0:20:18.68,0:20:22.02,中文,,0,0,0,,你绘制这个树 其中n等于3
Dialogue: 0,0:20:22.02,0:20:24.04,英文,,0,0,0,,In the worst case, you end up at the n equals 1 step.
Dialogue: 0,0:20:22.02,0:20:24.04,中文,,0,0,0,,在最坏的情况下 你最终会在n等于1步骤结束
Dialogue: 0,0:20:24.04,0:20:26.92,英文,,0,0,0,,And n equals 2, you end up in the worst case, n equals 1 step.
Dialogue: 0,0:20:24.04,0:20:26.92,中文,,0,0,0,,当n等于2时 你最终会在最坏的情况下 n等于1步骤结束
Dialogue: 0,0:20:26.92,0:20:32.12,英文,,0,0,0,,And so on and so forth, you can show that these grow at an exponential rate.
Dialogue: 0,0:20:26.92,0:20:32.12,中文,,0,0,0,,等等 你可以展示这些以指数速度增长
Dialogue: 0,0:20:32.12,0:20:42.30,英文,,0,0,0,,And if you do the math, you show that this is log 2 of n. Take the floor of that, and then you add 1.
Dialogue: 0,0:20:32.12,0:20:42.30,中文,,0,0,0,,如果你做了数学运算 你会发现这是n的对数2 取整数部分 然后加1
Dialogue: 0,0:20:42.30,0:20:46.92,英文,,0,0,0,,We can write this as theta of floor log 2 of n. But that's a complicated equation.
Dialogue: 0,0:20:42.30,0:20:46.92,中文,,0,0,0,,我们可以将这写成n的对数2的下取整的theta 但那是一个复杂的方程
Dialogue: 0,0:20:46.92,0:20:48.70,英文,,0,0,0,,I don't like complicated equations.
Dialogue: 0,0:20:46.92,0:20:48.70,中文,,0,0,0,,我不喜欢复杂的方程式
Dialogue: 0,0:20:48.70,0:20:50.88,英文,,0,0,0,,I want a simple theta bound.
Dialogue: 0,0:20:48.70,0:20:50.88,中文,,0,0,0,,我想要一个简单的theta界限
Dialogue: 0,0:20:50.88,0:20:55.54,英文,,0,0,0,,So we're going to mention that we can simplify the following things.
Dialogue: 0,0:20:50.88,0:20:55.54,中文,,0,0,0,,我们要提到我们可以简化以下事情
Dialogue: 0,0:20:55.54,0:20:57.62,英文,,0,0,0,,So here are some properties.
Dialogue: 0,0:20:55.54,0:20:57.62,中文,,0,0,0,,这里有一些性质
Dialogue: 0,0:20:57.62,0:21:01.71,英文,,0,0,0,,If we do the floor of a number, then that's still the theta of the original function.
Dialogue: 0,0:20:57.62,0:21:01.71,中文,,0,0,0,,如果我们对一个数字取整 那仍然是原函数的Θ（大O）阶
Dialogue: 0,0:21:01.71,0:21:10.87,英文,,0,0,0,,Can anyone explain why that's true?
Dialogue: 0,0:21:01.71,0:21:10.87,中文,,0,0,0,,有人能解释为什么这是真的吗
Dialogue: 0,0:21:10.87,0:21:17.15,英文,,0,0,0,,Yeah?
Dialogue: 0,0:21:10.87,0:21:17.15,中文,,0,0,0,,嗯
Dialogue: 0,0:21:17.15,0:21:22.29,英文,,0,0,0,,Yeah, as n grows really large, it doesn't really matter if it's the floor of a number or the number itself.
Dialogue: 0,0:21:17.15,0:21:22.29,中文,,0,0,0,,是的 当 n 变得非常大时 数字的整数部分或数字本身并不重要
Dialogue: 0,0:21:22.29,0:21:27.36,英文,,0,0,0,,In practice, the floor of a number is, at most, that number minus 1.
Dialogue: 0,0:21:22.29,0:21:27.36,中文,,0,0,0,,在实践中 一个数字的整数部分最多也只是该数字减 1
Dialogue: 0,0:21:27.36,0:21:31.04,英文,,0,0,0,,And that number minus 1, that minus 1 factor, we have already ignored that all the time.
Dialogue: 0,0:21:27.36,0:21:31.04,中文,,0,0,0,,而那个减 1 因素 我们一直都忽略了它
Dialogue: 0,0:21:31.04,0:21:32.26,英文,,0,0,0,,We can just ignore that.
Dialogue: 0,0:21:31.04,0:21:32.26,中文,,0,0,0,,我们可以直接忽略它
Dialogue: 0,0:21:32.26,0:21:33.90,英文,,0,0,0,,What about for ceiling of f of n?
Dialogue: 0,0:21:32.26,0:21:33.90,中文,,0,0,0,,对于 f 的 n 的天花板呢
Dialogue: 0,0:21:33.90,0:21:41.49,英文,,0,0,0,,Ceiling of f of n is the same as f of n. Can anyone explain why this is true?
Dialogue: 0,0:21:33.90,0:21:41.49,中文,,0,0,0,,f 的 n 的天花板与 f 的 n 是一样的 有人能解释为什么吗
Dialogue: 0,0:21:41.49,0:21:44.14,英文,,0,0,0,,Yeah?
Dialogue: 0,0:21:41.49,0:21:44.14,中文,,0,0,0,,是的
Dialogue: 0,0:21:44.14,0:21:48.61,英文,,0,0,0,,Yeah, ceiling of n is at most plus 1, so it should be the same growth.
Dialogue: 0,0:21:44.14,0:21:48.61,中文,,0,0,0,,是的 n 的天花板最多加 1 所以它应该是相同的增长
Dialogue: 0,0:21:48.61,0:21:56.62,英文,,0,0,0,,And log p is the same as theta of log q of n for any p and q. Can someone try to explain that one?
Dialogue: 0,0:21:48.61,0:21:56.62,中文,,0,0,0,,对于任意 p 和 q log p 与 log q 的 n 的 theta 是一样的 有人能试着解释一下吗
Dialogue: 0,0:21:56.62,0:21:59.98,英文,,0,0,0,,Yeah?
Dialogue: 0,0:21:56.62,0:21:59.98,中文,,0,0,0,,是的
Dialogue: 0,0:21:59.98,0:22:02.33,英文,,0,0,0,,Yep.
Dialogue: 0,0:21:59.98,0:22:02.33,中文,,0,0,0,,是的
Dialogue: 0,0:22:02.33,0:22:13.12,英文,,0,0,0,,Yeah, there's this change of base formula where if you do log p of n, that's equal to log q of n divided by log q of p. Log q of p is going to be a constant, because p and q are constants.
Dialogue: 0,0:22:02.33,0:22:13.12,中文,,0,0,0,,是的 有一个基变换公式 如果你计算log p的n 那就等于log q的n除以log q的p log q的p会是一个常数 因为p和q都是常数
Dialogue: 0,0:22:13.12,0:22:15.22,英文,,0,0,0,,So that's just off by a constant factor.
Dialogue: 0,0:22:13.12,0:22:15.22,中文,,0,0,0,,这只是一个常数因子的差别
Dialogue: 0,0:22:15.22,0:22:27.32,英文,,0,0,0,,Because of that, when we write down log notations, we generally just write theta of log n. We don't say base, because all the bases just mean the exact same thing.
Dialogue: 0,0:22:15.22,0:22:27.32,中文,,0,0,0,,因此 当我们写下对数符号时 通常只写Θ(log n) 我们不说基数 因为所有的基数都意味着完全相同的事情
Dialogue: 0,0:22:27.32,0:22:34.08,英文,,0,0,0,,So once we do all this, we can show that it does end up becoming theta of log n. And as before, we just ignore the base.
Dialogue: 0,0:22:27.32,0:22:34.08,中文,,0,0,0,,一旦我们做了所有这些 我们可以证明它最终变成了Θ(log n) 就像以前一样 我们只忽略基数
Dialogue: 0,0:22:34.08,0:22:36.30,英文,,0,0,0,,We don't need to worry about the base.
Dialogue: 0,0:22:34.08,0:22:36.30,中文,,0,0,0,,我们不需要担心基数
Dialogue: 0,0:22:36.30,0:22:42.90,英文,,0,0,0,,We just write down log n. Now, we could do this with a recurrence relation.
Dialogue: 0,0:22:36.30,0:22:42.90,中文,,0,0,0,,我们只写下log n 现在 我们可以用递归关系来做这件事
Dialogue: 0,0:22:42.90,0:22:43.78,英文,,0,0,0,,It is complicated.
Dialogue: 0,0:22:42.90,0:22:43.78,中文,,0,0,0,,这很复杂
Dialogue: 0,0:22:43.78,0:22:45.39,英文,,0,0,0,,The math is hard.
Dialogue: 0,0:22:43.78,0:22:45.39,中文,,0,0,0,,数学很难
Dialogue: 0,0:22:45.39,0:22:48.95,英文,,0,0,0,,Please do not do it with this recurrence relation.
Dialogue: 0,0:22:45.39,0:22:48.95,中文,,0,0,0,,请不要用这个递归关系式来做
Dialogue: 0,0:22:48.95,0:22:50.87,英文,,0,0,0,,But you can do it this way.
Dialogue: 0,0:22:48.95,0:22:50.87,中文,,0,0,0,,但你可以用这种方式做
Dialogue: 0,0:22:50.87,0:22:58.85,英文,,0,0,0,,Generally speaking, when you run through an asymptotic problem, there's a lot of different ways that you can solve the exact same problem.
Dialogue: 0,0:22:50.87,0:22:58.85,中文,,0,0,0,,一般来说 当你处理渐近问题时 有很多不同的方法可以解决完全相同的问题
Dialogue: 0,0:22:58.85,0:23:05.68,英文,,0,0,0,,Now, I want to finish off with one final example that we'll come back to later in the class.
Dialogue: 0,0:22:58.85,0:23:05.68,中文,,0,0,0,,现在 我想用一个最后的例子来结束 我们以后会回到课上再讲
Dialogue: 0,0:23:05.68,0:23:07.60,英文,,0,0,0,,And it's kind of the sorting algorithm.
Dialogue: 0,0:23:05.68,0:23:07.60,中文,,0,0,0,,而且它有点像排序算法
Dialogue: 0,0:23:07.60,0:23:19.71,英文,,0,0,0,,In a sorting algorithm, our goal is to kind of order out a list of items according to some comparable.
Dialogue: 0,0:23:07.60,0:23:19.71,中文,,0,0,0,,在排序算法中 我们的目标是根据某种可比较的方式对列表中的项目进行排序
Dialogue: 0,0:23:19.71,0:23:23.61,英文,,0,0,0,,So we assume that the comparison operation is nice.
Dialogue: 0,0:23:19.71,0:23:23.61,中文,,0,0,0,,我们假设比较操作很好
Dialogue: 0,0:23:23.61,0:23:26.79,英文,,0,0,0,,It behaves like comparisons actually do.
Dialogue: 0,0:23:23.61,0:23:26.79,中文,,0,0,0,,它的行为就像实际的比较一样
Dialogue: 0,0:23:26.79,0:23:30.67,英文,,0,0,0,,The exact names of the properties we have is transitive reflexive symmetric.
Dialogue: 0,0:23:26.79,0:23:30.67,中文,,0,0,0,,我们拥有的属性的确切名称是传递性、自反性和对称性
Dialogue: 0,0:23:30.67,0:23:35.63,英文,,0,0,0,,That just basically means that it compares in a similar way to how real numbers compare.
Dialogue: 0,0:23:30.67,0:23:35.63,中文,,0,0,0,,那基本上意味着它以与实数比较类似的方式进行比较
Dialogue: 0,0:23:35.63,0:23:42.00,英文,,0,0,0,,And we also assume that we can compare things in theta of one time, so constant time to do a comparison.
Dialogue: 0,0:23:35.63,0:23:42.00,中文,,0,0,0,,而且我们也假设我们可以在Θ(1)的时间内比较事物 所以进行比较的时间是常数
Dialogue: 0,0:23:42.00,0:23:48.70,英文,,0,0,0,,Given this, here's kind of how we might merge sort
Dialogue: 0,0:23:42.00,0:23:48.70,中文,,0,0,0,,有了这个前提 这里大致是我们如何进行归并排序的想法
Dialogue: 0,0:23:48.70,0:23:59.03,英文,,0,0,0,,The idea is if I wanted to sort everyone here by their birthday, then what I'm going to do is I'm going to cut the room in half down the middle.
Dialogue: 0,0:23:48.70,0:23:59.03,中文,,0,0,0,,这个想法是 如果我想按照大家的生日来排序这里的每个人 那么我要做的就是将房间沿中间切成两半
Dialogue: 0,0:23:59.03,0:24:04.75,英文,,0,0,0,,And what I'm going to do is I'm going to first sort this group of people, then I'm going to sort this group of people.
Dialogue: 0,0:23:59.03,0:24:04.75,中文,,0,0,0,,我要做的是首先对这群人进行排序 然后再对这群人进行排序
Dialogue: 0,0:24:04.75,0:24:14.16,英文,,0,0,0,,And then once I have two giant lists of people sorted, I'm going to try to combine these together to form one megalist of sorted people.
Dialogue: 0,0:24:04.75,0:24:14.16,中文,,0,0,0,,然后 一旦我有两个巨大的排序人员列表 我将尝试将它们合并在一起 形成一个巨大的排序人员的列表
Dialogue: 0,0:24:14.16,0:24:16.30,英文,,0,0,0,,So this is kind of a recursive function.
Dialogue: 0,0:24:14.16,0:24:16.30,中文,,0,0,0,,这有点像一个递归函数
Dialogue: 0,0:24:16.30,0:24:20.02,英文,,0,0,0,,Every single step, we kind of divide the problem into two halves.
Dialogue: 0,0:24:16.30,0:24:20.02,中文,,0,0,0,,在每一步 我们都把问题分成两半
Dialogue: 0,0:24:20.02,0:24:23.65,英文,,0,0,0,,The merging is where we actually do the math.
Dialogue: 0,0:24:20.02,0:24:23.65,中文,,0,0,0,,合并是我们实际进行数学运算的地方
Dialogue: 0,0:24:23.65,0:24:28.19,英文,,0,0,0,,And it's kind of useful to see how we actually do a merge.
Dialogue: 0,0:24:23.65,0:24:28.19,中文,,0,0,0,,看到我们如何实际执行合并是有点有用的
Dialogue: 0,0:24:28.19,0:24:31.89,英文,,0,0,0,,Here's an example of how we might do a merge if we have these people.
Dialogue: 0,0:24:28.19,0:24:31.89,中文,,0,0,0,,这是我们如果有这些人 可能会如何执行合并的示例
Dialogue: 0,0:24:31.89,0:24:34.24,英文,,0,0,0,,What we can do is we can kind of look at this first element.
Dialogue: 0,0:24:31.89,0:24:34.24,中文,,0,0,0,,我们能做的是 我们可以看一下这第一个元素
Dialogue: 0,0:24:34.24,0:24:36.32,英文,,0,0,0,,We see which one's smaller.
Dialogue: 0,0:24:34.24,0:24:36.32,中文,,0,0,0,,我们看哪个小一点
Dialogue: 0,0:24:36.32,0:24:37.82,英文,,0,0,0,,And then we just move that over.
Dialogue: 0,0:24:36.32,0:24:37.82,中文,,0,0,0,,然后我们把那个移到这边
Dialogue: 0,0:24:37.82,0:24:41.44,英文,,0,0,0,,Once we do that, we kind of move to the next item on this list.
Dialogue: 0,0:24:37.82,0:24:41.44,中文,,0,0,0,,一旦我们这样做了 我们就移到这个列表上的下一个项目
Dialogue: 0,0:24:41.44,0:24:42.36,英文,,0,0,0,,We check again.
Dialogue: 0,0:24:41.44,0:24:42.36,中文,,0,0,0,,我们再次检查
Dialogue: 0,0:24:42.36,0:24:45.35,英文,,0,0,0,,And just we repeat doing this.
Dialogue: 0,0:24:42.36,0:24:45.35,中文,,0,0,0,,我们就重复做这个
Dialogue: 0,0:24:45.35,0:24:50.93,英文,,0,0,0,,We keep doing this over and over until we finish going through every single item.
Dialogue: 0,0:24:45.35,0:24:50.93,中文,,0,0,0,,我们一直这样做 一直到我们完成遍历每一个项目为止
Dialogue: 0,0:24:50.93,0:24:54.91,英文,,0,0,0,,And using this, we're able to complete a merge.
Dialogue: 0,0:24:50.93,0:24:54.91,中文,,0,0,0,,通过使用这个 我们能够完成合并
Dialogue: 0,0:24:54.91,0:25:00.56,英文,,0,0,0,,So at each step, we have these pointers pointing to the smallest item that we haven't put in yet.
Dialogue: 0,0:24:54.91,0:25:00.56,中文,,0,0,0,,在每一步 我们有这些指针指向我们还没有放入的最小的项
Dialogue: 0,0:25:00.56,0:25:04.24,英文,,0,0,0,,And this guarantees that we get this right order.
Dialogue: 0,0:25:00.56,0:25:04.24,中文,,0,0,0,,而且这保证了我们得到这个正确的顺序
Dialogue: 0,0:25:04.24,0:25:07.98,英文,,0,0,0,,What's the runtime of this sorting algorithm?
Dialogue: 0,0:25:04.24,0:25:07.98,中文,,0,0,0,,这个排序算法的运行时间是多少
Dialogue: 0,0:25:07.98,0:25:13.28,英文,,0,0,0,,Or what's the runtime of this merge behavior?
Dialogue: 0,0:25:07.98,0:25:13.28,中文,,0,0,0,,或者这个合并行为的运行时间是多少
Dialogue: 0,0:25:13.28,0:25:16.95,英文,,0,0,0,,How many people say theta 1?
Dialogue: 0,0:25:13.28,0:25:16.95,中文,,0,0,0,,有多少人说theta 1
Dialogue: 0,0:25:16.95,0:25:19.83,英文,,0,0,0,,How about log n?
Dialogue: 0,0:25:16.95,0:25:19.83,中文,,0,0,0,,log n呢
Dialogue: 0,0:25:19.83,0:25:22.01,英文,,0,0,0,,n?
Dialogue: 0,0:25:19.83,0:25:22.01,中文,,0,0,0,,n?
Dialogue: 0,0:25:22.01,0:25:24.15,英文,,0,0,0,,n squared.
Dialogue: 0,0:25:22.01,0:25:24.15,中文,,0,0,0,,n 平方
Dialogue: 0,0:25:24.15,0:25:30.01,英文,,0,0,0,,All right, everyone said theta n, except for one person who said a constant.
Dialogue: 0,0:25:24.15,0:25:30.01,中文,,0,0,0,,所有人都说Θ(n) 除了一个人说一个常数
Dialogue: 0,0:25:30.01,0:25:35.01,英文,,0,0,0,,Why theta n?
Dialogue: 0,0:25:30.01,0:25:35.01,中文,,0,0,0,,为什么是Θ(n)
Dialogue: 0,0:25:35.01,0:25:41.29,英文,,0,0,0,,Yeah?
Dialogue: 0,0:25:35.01,0:25:41.29,中文,,0,0,0,,是的
Dialogue: 0,0:25:41.29,0:25:46.09,英文,,0,0,0,,Yep, if we add just one more item to either of these lists, it'll take just one more unit of time.
Dialogue: 0,0:25:41.29,0:25:46.09,中文,,0,0,0,,是的 如果我们只是给这些列表中的任何一个添加一个额外的项目 它将只需要额外的一个时间单位
Dialogue: 0,0:25:46.09,0:25:49.89,英文,,0,0,0,,Because every single time we add a new item, we're just moving it once.
Dialogue: 0,0:25:46.09,0:25:49.89,中文,,0,0,0,,因为每次我们添加一个新项目时 我们只是移动它一次
Dialogue: 0,0:25:49.89,0:25:55.08,英文,,0,0,0,,It takes a constant amount of work to handle each single item.
Dialogue: 0,0:25:49.89,0:25:55.08,中文,,0,0,0,,处理每个单独的项目需要恒定的工作量
Dialogue: 0,0:25:55.08,0:25:59.00,英文,,0,0,0,,So we can kind of simplify this code a bit.
Dialogue: 0,0:25:55.08,0:25:59.00,中文,,0,0,0,,我们可以简化一下这段代码
Dialogue: 0,0:25:59.00,0:26:05.24,英文,,0,0,0,,Just if we're looking for the asymptotic runtime, we can simplify this to only care about the actual run operations.
Dialogue: 0,0:25:59.00,0:26:05.24,中文,,0,0,0,,只要我们在寻找渐近运行时间 我们可以简化为只关心实际运行的操作
Dialogue: 0,0:26:05.24,0:26:10.28,英文,,0,0,0,,I'm going to say that n is a number that represents the size of the list.
Dialogue: 0,0:26:05.24,0:26:10.28,中文,,0,0,0,,我要说n是表示列表大小的数字
Dialogue: 0,0:26:10.28,0:26:15.19,英文,,0,0,0,,And if we do that, then we can kind of see that the sort's runtime looks kind of like this.
Dialogue: 0,0:26:10.28,0:26:15.19,中文,,0,0,0,,如果我们这样做 我们就可以看到排序的运行时间大致是这样的
Dialogue: 0,0:26:15.19,0:26:17.69,英文,,0,0,0,,We start off with a size n array.
Dialogue: 0,0:26:15.19,0:26:17.69,中文,,0,0,0,,我们从一个大小为n的数组开始
Dialogue: 0,0:26:17.69,0:26:20.39,英文,,0,0,0,,We do n over 2 units of work twice.
Dialogue: 0,0:26:17.69,0:26:20.39,中文,,0,0,0,,我们做n/2单位的工作两次
Dialogue: 0,0:26:20.39,0:26:24.73,英文,,0,0,0,,And then we do n units of work at the end for the merge step.
Dialogue: 0,0:26:20.39,0:26:24.73,中文,,0,0,0,,然后我们在最后做 n 单位的工作进行合并步骤
Dialogue: 0,0:26:24.73,0:26:29.88,英文,,0,0,0,,So this is kind of a simplified version of just the runtime calculation.
Dialogue: 0,0:26:24.73,0:26:29.88,中文,,0,0,0,,这其实是一个简化版的运行时间计算
Dialogue: 0,0:26:29.88,0:26:33.58,英文,,0,0,0,,What's the runtime of this code?
Dialogue: 0,0:26:29.88,0:26:33.58,中文,,0,0,0,,这段代码的运行时间是多少
Dialogue: 0,0:26:33.58,0:26:37.62,英文,,0,0,0,,How many people say theta 1?
Dialogue: 0,0:26:33.58,0:26:37.62,中文,,0,0,0,,有多少人说 theta 1
Dialogue: 0,0:26:37.62,0:26:38.68,英文,,0,0,0,,Again?
Dialogue: 0,0:26:37.62,0:26:38.68,中文,,0,0,0,,再一次
Dialogue: 0,0:26:38.68,0:26:41.41,英文,,0,0,0,,You really like constant time here.
Dialogue: 0,0:26:38.68,0:26:41.41,中文,,0,0,0,,你真的喜欢这里的常数时间
Dialogue: 0,0:26:41.41,0:26:44.43,英文,,0,0,0,,Log n. How many people say n?
Dialogue: 0,0:26:41.41,0:26:44.43,中文,,0,0,0,,对数 n 有多少人说 n
Dialogue: 0,0:26:44.43,0:26:47.00,英文,,0,0,0,,A few people.
Dialogue: 0,0:26:44.43,0:26:47.00,中文,,0,0,0,,几个人
Dialogue: 0,0:26:47.00,0:26:49.46,英文,,0,0,0,,n log n?
Dialogue: 0,0:26:47.00,0:26:49.46,中文,,0,0,0,,n 对数 n?
Dialogue: 0,0:26:49.46,0:26:51.98,英文,,0,0,0,,How about n squared?
Dialogue: 0,0:26:49.46,0:26:51.98,中文,,0,0,0,,n 平方怎么样
Dialogue: 0,0:26:51.98,0:26:54.98,英文,,0,0,0,,All right, this one seems like a bit trickier.
Dialogue: 0,0:26:51.98,0:26:54.98,中文,,0,0,0,,这个看起来有点棘手
Dialogue: 0,0:26:54.98,0:27:01.88,英文,,0,0,0,,Some people said n, some people said n log n. Does anyone want to explain why they chose that answer?
Dialogue: 0,0:26:54.98,0:27:01.88,中文,,0,0,0,,有些人说 n 有些人说 n 对数 n 有人想解释为什么选择那个答案吗
Dialogue: 0,0:27:01.88,0:27:13.90,英文,,0,0,0,,Yeah?
Dialogue: 0,0:27:01.88,0:27:13.90,中文,,0,0,0,,嗯
Dialogue: 0,0:27:13.90,0:27:16.13,英文,,0,0,0,,OK, yeah, you have an n here.
Dialogue: 0,0:27:13.90,0:27:16.13,中文,,0,0,0,,这里有个 n
Dialogue: 0,0:27:16.13,0:27:19.87,英文,,0,0,0,,You have an n over 2 plus n over 2, so that's another n. So that would be 2n.
Dialogue: 0,0:27:16.13,0:27:19.87,中文,,0,0,0,,你有n除以2再加上n除以2 所以又是n 这就是2n
Dialogue: 0,0:27:19.87,0:27:21.79,英文,,0,0,0,,But what about this next layer here?
Dialogue: 0,0:27:19.87,0:27:21.79,中文,,0,0,0,,但是这下一层呢
Dialogue: 0,0:27:21.79,0:27:27.87,英文,,0,0,0,,We go down to n over 4, potentially, because this runtime sorting is recursive.
Dialogue: 0,0:27:21.79,0:27:27.87,中文,,0,0,0,,我们可能会降到n除以4 因为这个运行时排序是递归的
Dialogue: 0,0:27:27.87,0:27:36.55,英文,,0,0,0,,If you have 4n over 4s, you're going to end up with n as well.
Dialogue: 0,0:27:27.87,0:27:36.55,中文,,0,0,0,,如果你有4n除以4 最终会得到n
Dialogue: 0,0:27:36.55,0:27:39.29,英文,,0,0,0,,In fact, this is kind of what ends up happening.
Dialogue: 0,0:27:36.55,0:27:39.29,中文,,0,0,0,,事实上 这就是最后发生的事情
Dialogue: 0,0:27:39.29,0:27:48.00,英文,,0,0,0,,If we go down each layer, then we end up adding up everything in that layer to equal n, because there's four children down in the second layer.
Dialogue: 0,0:27:39.29,0:27:48.00,中文,,0,0,0,,如果我们进入每一层 最终我们会把该层中的所有内容相加得到n 因为在第二层有四个子节点
Dialogue: 0,0:27:48.00,0:27:59.94,英文,,0,0,0,,n over 4 plus n over 4 plus n over 4 plus n over 4, that equals n. Generally speaking, each layer down, you double the number of pieces, but each item splits in half.
Dialogue: 0,0:27:48.00,0:27:59.94,中文,,0,0,0,,n除以4加上n除以4再加上n除以4再加上n除以4 这等于n 一般来说 每下降一层 你会使得项目数量翻倍 但每个项目都会减半
Dialogue: 0,0:27:59.94,0:28:05.75,英文,,0,0,0,,So overall, the total runtime at each layer is equal to n.
Dialogue: 0,0:27:59.94,0:28:05.75,中文,,0,0,0,,总的来说 在每个层面上的总运行时间都等于 n
Dialogue: 0,0:28:05.75,0:28:16.02,英文,,0,0,0,,Now, if we have a total of k layers, then our total runtime is going to be n times k, because every single layer does the exact same amount of work.
Dialogue: 0,0:28:05.75,0:28:16.02,中文,,0,0,0,,现在 如果我们有总共 k 层 那么我们的总运行时间将是 n 乘以 k 因为每一层都做相同量的工作
Dialogue: 0,0:28:16.02,0:28:20.74,英文,,0,0,0,,How many layers do we have?
Dialogue: 0,0:28:16.02,0:28:20.74,中文,,0,0,0,,我们有多少层
Dialogue: 0,0:28:20.74,0:28:26.44,英文,,0,0,0,,Log n, yep, because that's the number of times we need to cut something in half before we get down to 1.
Dialogue: 0,0:28:20.74,0:28:26.44,中文,,0,0,0,,log n 是的 因为这是我们需要将某物切成两半的次数 直到达到 1
Dialogue: 0,0:28:26.44,0:28:32.79,英文,,0,0,0,,So if we do this, our overall runtime is going to be n log n. Now, an exact count is going to be kind of tedious.
Dialogue: 0,0:28:26.44,0:28:32.79,中文,,0,0,0,,如果我们这样做 我们的总运行时间将是 n log n 现在 确切的计数会有点繁琐
Dialogue: 0,0:28:32.79,0:28:34.45,英文,,0,0,0,,You don't really need to do an exact count.
Dialogue: 0,0:28:32.79,0:28:34.45,中文,,0,0,0,,你不真的需要进行确切的计数
Dialogue: 0,0:28:34.45,0:28:40.58,英文,,0,0,0,,Most of the time, you can just say it's about n log n, just from this kind of analysis.
Dialogue: 0,0:28:34.45,0:28:40.58,中文,,0,0,0,,大多数时候 你只需说大约是 n log n 仅仅通过这种分析
Dialogue: 0,0:28:40.58,0:28:44.94,英文,,0,0,0,,But you can see exactly how you do that through textbook exercises.
Dialogue: 0,0:28:40.58,0:28:44.94,中文,,0,0,0,,但是你可以通过课本练习确切地看到如何做到这一点
Dialogue: 0,0:28:44.94,0:28:49.81,英文,,0,0,0,,Here is what you would do if you do the actual recurrence relation.
Dialogue: 0,0:28:44.94,0:28:49.81,中文,,0,0,0,,这是如果你执行实际的递归关系时会做的事情
Dialogue: 0,0:28:49.81,0:28:53.89,英文,,0,0,0,,One thing to note is that we use LG here to mean the base 2 logarithm.
Dialogue: 0,0:28:49.81,0:28:53.89,中文,,0,0,0,,需要注意的一点是 这里我们使用LG表示底数为2的对数
Dialogue: 0,0:28:53.89,0:29:05.56,英文,,0,0,0,,It's sometimes called lig of n. But all logarithms are the exact same.
Dialogue: 0,0:28:53.89,0:29:05.56,中文,,0,0,0,,有时候它被称为n的对数 但所有的对数都是完全相同的
Dialogue: 0,0:29:05.56,0:29:16.06,英文,,0,0,0,,Now, it's important to note that this particular property only works with this particular 2 to the n halving and doubling the number.
Dialogue: 0,0:29:05.56,0:29:16.06,中文,,0,0,0,,现在 重要的是要注意 这个特定的属性只适用于这个特定的2的n次方对数和倍增数
Dialogue: 0,0:29:16.06,0:29:23.49,英文,,0,0,0,,If you had n over 2 plus n over 2 plus n over 2, then you end up with a completely different math.
Dialogue: 0,0:29:16.06,0:29:23.49,中文,,0,0,0,,如果你有n除以2再加上n除以2再加上n除以2 那么你得到的将是完全不同的数学
Dialogue: 0,0:29:23.49,0:29:25.62,英文,,0,0,0,,So we're not going to cover this.
Dialogue: 0,0:29:23.49,0:29:25.62,中文,,0,0,0,,我们不会涉及这个
Dialogue: 0,0:29:25.62,0:29:29.74,英文,,0,0,0,,Now, I want to finish off asymptotics with just one brief statement.
Dialogue: 0,0:29:25.62,0:29:29.74,中文,,0,0,0,,现在 我想用一句简短的话来结束渐近符号的讨论
Dialogue: 0,0:29:29.74,0:29:39.29,英文,,0,0,0,,Remember that duplication question from asymptotics 1, where we showed that dupe 1 was running in n squared time, but dupe 2 ran in theta of n time?
Dialogue: 0,0:29:29.74,0:29:39.29,中文,,0,0,0,,还记得渐近符号 1 中的重复问题吗 我们证明了 dup 1 的运行时间是 n 平方 但 dup 2 的时间是 n 的 theta 吗
Dialogue: 0,0:29:39.29,0:29:44.21,英文,,0,0,0,,This dupe 2 only really worked because it was a sorted array.
Dialogue: 0,0:29:39.29,0:29:44.21,中文,,0,0,0,,这个 dup 2 之所以有效 主要是因为它是一个有序数组
Dialogue: 0,0:29:44.21,0:29:47.53,英文,,0,0,0,,So what happens if the input wasn't sorted?
Dialogue: 0,0:29:44.21,0:29:47.53,中文,,0,0,0,,那么 如果输入没有排序会发生什么
Dialogue: 0,0:29:47.53,0:29:50.40,英文,,0,0,0,,Would dupe 2 still work if the input wasn't sorted?
Dialogue: 0,0:29:47.53,0:29:50.40,中文,,0,0,0,,如果输入没有排序 dup 2 仍然有效吗
Dialogue: 0,0:29:50.40,0:29:51.96,英文,,0,0,0,,No.
Dialogue: 0,0:29:50.40,0:29:51.96,中文,,0,0,0,,不会
Dialogue: 0,0:29:51.96,0:29:54.00,英文,,0,0,0,,Would dupe 1 still work?
Dialogue: 0,0:29:51.96,0:29:54.00,中文,,0,0,0,,dup 1 仍然有效吗
Dialogue: 0,0:29:54.00,0:30:05.25,英文,,0,0,0,,Yeah, so are we stuck with an n-squared algorithm when we have an unsorted array?
Dialogue: 0,0:29:54.00,0:30:05.25,中文,,0,0,0,,是的 我们在有一个未排序的数组时 被困在一个n平方的算法里吗
Dialogue: 0,0:30:05.25,0:30:06.39,英文,,0,0,0,,Can we do better than n-squared?
Dialogue: 0,0:30:05.25,0:30:06.39,中文,,0,0,0,,我们能做得比n平方更好吗
Dialogue: 0,0:30:06.39,0:30:14.08,英文,,0,0,0,,Yes.
Dialogue: 0,0:30:06.39,0:30:14.08,中文,,0,0,0,,是的
Dialogue: 0,0:30:14.08,0:30:15.00,英文,,0,0,0,,Yep.
Dialogue: 0,0:30:14.08,0:30:15.00,中文,,0,0,0,,是的
Dialogue: 0,0:30:15.00,0:30:23.48,英文,,0,0,0,,What we can do, instead of running dupe 1, is we can actually just still sort the algorithm, sort the array.
Dialogue: 0,0:30:15.00,0:30:23.48,中文,,0,0,0,,我们可以做的 而不是运行重复1 实际上我们可以仍然对算法进行排序 对数组进行排序
Dialogue: 0,0:30:23.48,0:30:27.63,英文,,0,0,0,,So we sort the array first, and then we run our theta of n algorithm.
Dialogue: 0,0:30:23.48,0:30:27.63,中文,,0,0,0,,我们首先对数组进行排序 然后运行我们的theta n算法
Dialogue: 0,0:30:27.63,0:30:31.91,英文,,0,0,0,,And using that, we end up with an overall theta of n log n algorithm.
Dialogue: 0,0:30:27.63,0:30:31.91,中文,,0,0,0,,通过这样做 我们最终得到一个总体上的theta n log n算法
Dialogue: 0,0:30:31.91,0:30:38.87,英文,,0,0,0,,Now, if you didn't have an n log n sorting algorithm, if you only had an n squared sorting algorithm, you wouldn't be able to speed up your code this way.
Dialogue: 0,0:30:31.91,0:30:38.87,中文,,0,0,0,,现在 如果你没有一个n log n的排序算法 如果你只有一个n平方的排序算法 你就无法通过这种方式加速你的代码
Dialogue: 0,0:30:38.87,0:30:45.94,英文,,0,0,0,,This kind of shows how even some small asymptotic improvements in one program can end up having these massive implications.
Dialogue: 0,0:30:38.87,0:30:45.94,中文,,0,0,0,,这有点显示了即使在一个程序中进行一些小的渐近改进 最终可能会产生巨大的影响
Dialogue: 0,0:30:45.94,0:30:51.00,英文,,0,0,0,,Sometimes you use a sorting algorithm as one subpart of another program.
Dialogue: 0,0:30:45.94,0:30:51.00,中文,,0,0,0,,有时你会将排序算法用作另一个程序的一部分
Dialogue: 0,0:30:51.00,0:31:00.12,英文,,0,0,0,,And if you speed up your sorting algorithm, you can end up speeding up your duplication finding algorithm.
Dialogue: 0,0:30:51.00,0:31:00.12,中文,,0,0,0,,而如果你加速你的排序算法 你就能加速你的重复查找算法
Dialogue: 0,0:31:00.12,0:31:04.36,英文,,0,0,0,,Any questions here?
Dialogue: 0,0:31:00.12,0:31:04.36,中文,,0,0,0,,这里有任何问题吗
Dialogue: 0,0:31:04.36,0:31:10.19,英文,,0,0,0,,Yeah, yes.
Dialogue: 0,0:31:04.36,0:31:10.19,中文,,0,0,0,,是的 有
Dialogue: 0,0:31:10.19,0:31:12.85,英文,,0,0,0,,Yeah, the sorting algorithm takes n log n time.
Dialogue: 0,0:31:10.19,0:31:12.85,中文,,0,0,0,,是的 排序算法需要n log n的时间
Dialogue: 0,0:31:12.85,0:31:15.89,英文,,0,0,0,,And then we add n time to that for the duplication check.
Dialogue: 0,0:31:12.85,0:31:15.89,中文,,0,0,0,,然后我们再加上 n 次以进行重复检查
Dialogue: 0,0:31:15.89,0:31:21.20,英文,,0,0,0,,n log n plus n is just n log n. Yep.
Dialogue: 0,0:31:15.89,0:31:21.20,中文,,0,0,0,,n log n 加 n 只是 n log n 是的
Dialogue: 0,0:31:21.20,0:31:24.58,英文,,0,0,0,,So can we do even better than this?
Dialogue: 0,0:31:21.20,0:31:24.58,中文,,0,0,0,,那么我们能做得比这更好吗
Dialogue: 0,0:31:24.58,0:31:25.82,英文,,0,0,0,,Yes.
Dialogue: 0,0:31:24.58,0:31:25.82,中文,,0,0,0,,是的
Dialogue: 0,0:31:25.82,0:31:29.74,英文,,0,0,0,,Once we get to hashing, we'll find the theta of n algorithm to solve this problem.
Dialogue: 0,0:31:25.82,0:31:29.74,中文,,0,0,0,,一旦我们到达哈希 我们将找到 Θ(n) 算法来解决这个问题
Dialogue: 0,0:31:29.74,0:31:34.24,英文,,0,0,0,,So that's just something to look forward to.
Dialogue: 0,0:31:29.74,0:31:34.24,中文,,0,0,0,,这只是一件期待的事情
Dialogue: 0,0:31:34.24,0:31:35.18,英文,,0,0,0,,Ominous.
Dialogue: 0,0:31:34.24,0:31:35.18,中文,,0,0,0,,不祥
Dialogue: 0,0:31:35.18,0:31:41.97,英文,,0,0,0,,Now, I would like to finish off today's asymptotic section by talking about how n log n is basically the same as n.
Dialogue: 0,0:31:35.18,0:31:41.97,中文,,0,0,0,,现在 我想通过讨论n log n基本上与n相同来结束今天的渐近部分
Dialogue: 0,0:31:41.97,0:31:48.97,英文,,0,0,0,,If you look at this n log n thing for a million items, it takes 20 seconds for n log n.
Dialogue: 0,0:31:41.97,0:31:48.97,中文,,0,0,0,,如果你看看这个n log n的东西 对于一百万个项目 n log n需要20秒
Dialogue: 0,0:31:48.97,0:31:53.97,英文,,0,0,0,,It takes one second for n. It takes 12 days to run an n squared algorithm.
Dialogue: 0,0:31:48.97,0:31:53.97,中文,,0,0,0,,n只需要一秒 运行一个n平方算法需要12天
Dialogue: 0,0:31:53.97,0:32:00.33,英文,,0,0,0,,So going from n squared to n log n is really good.
Dialogue: 0,0:31:53.97,0:32:00.33,中文,,0,0,0,,从n平方到n log n的转变是非常好的
Dialogue: 0,0:32:00.33,0:32:02.09,英文,,0,0,0,,People on Zoom can still hear me, right?
Dialogue: 0,0:32:00.33,0:32:02.09,中文,,0,0,0,,在Zoom上的人们还能听到我说话 对吗
Dialogue: 0,0:32:02.09,0:32:03.09,英文,,0,0,0,,No one's complaining.
Dialogue: 0,0:32:02.09,0:32:03.09,中文,,0,0,0,,没有人抱怨
Dialogue: 0,0:32:03.09,0:32:04.45,英文,,0,0,0,,OK.
Dialogue: 0,0:32:04.45,0:32:07.73,英文,,0,0,0,,This keeps telling me that my speaker is not showing up.
Dialogue: 0,0:32:04.45,0:32:07.73,中文,,0,0,0,,这一直告诉我说我的扬声器没有显示出来
Dialogue: 0,0:32:07.73,0:32:16.20,英文,,0,0,0,,Anyway, so going from n squared to n log n is really big, and it's going to change what problems you can even solve.
Dialogue: 0,0:32:07.73,0:32:16.20,中文,,0,0,0,,无论如何 从n平方到n log n的转变是非常巨大的 并且将改变你甚至可以解决什么问题
Dialogue: 0,0:32:16.20,0:32:19.14,英文,,0,0,0,,Going from n log n to n doesn't really change too much.
Dialogue: 0,0:32:16.20,0:32:19.14,中文,,0,0,0,,从 n log n 到 n 并不会改变太多
Dialogue: 0,0:32:19.14,0:32:23.19,英文,,0,0,0,,It's nice, but it's not a significant change.
Dialogue: 0,0:32:19.14,0:32:23.19,中文,,0,0,0,,这很好 但并没有显著的改变
Dialogue: 0,0:32:23.19,0:32:30.85,英文,,0,0,0,,So I think that's all we'll cover for asymptotics today.
Dialogue: 0,0:32:23.19,0:32:30.85,中文,,0,0,0,,我想今天我们只会讲到渐近性
Dialogue: 0,0:32:30.85,0:32:35.01,英文,,0,0,0,,I gave you 17 minutes for BSTs.
Dialogue: 0,0:32:30.85,0:32:35.01,中文,,0,0,0,,我给你了 17 分钟来讲二叉搜索树
Dialogue: 0,0:32:35.01,0:32:36.29,英文,,0,0,0,,We're running a bit behind.
Dialogue: 0,0:32:35.01,0:32:36.29,中文,,0,0,0,,我们有点落后了
Dialogue: 0,0:32:36.29,0:32:37.23,英文,,0,0,0,,You're so generous.
Dialogue: 0,0:32:36.29,0:32:37.23,中文,,0,0,0,,你真是太慷慨了
Dialogue: 0,0:32:37.23,0:32:37.99,英文,,0,0,0,,OK.
Dialogue: 0,0:32:37.99,0:32:39.83,英文,,0,0,0,,Yeah.
Dialogue: 0,0:32:37.99,0:32:39.83,中文,,0,0,0,,好的
Dialogue: 0,0:32:39.83,0:32:40.93,英文,,0,0,0,,All right.
Dialogue: 0,0:32:40.93,0:32:41.69,英文,,0,0,0,,Let's go.
Dialogue: 0,0:32:40.93,0:32:41.69,中文,,0,0,0,,走吧
Dialogue: 0,0:32:41.69,0:32:42.67,英文,,0,0,0,,Binary search trees.
Dialogue: 0,0:32:41.69,0:32:42.67,中文,,0,0,0,,二叉搜索树
Dialogue: 0,0:32:42.67,0:32:48.08,英文,,0,0,0,,Speedrun.
Dialogue: 0,0:32:42.67,0:32:48.08,中文,,0,0,0,,速通
Dialogue: 0,0:32:48.08,0:32:54.63,英文,,0,0,0,,I think you could just leave that.
Dialogue: 0,0:32:48.08,0:32:54.63,中文,,0,0,0,,我觉得你可以把那个留下来
Dialogue: 0,0:32:54.63,0:32:57.55,英文,,0,0,0,,By the way, if you're freaked out by asymptotics, don't worry.
Dialogue: 0,0:32:54.63,0:32:57.55,中文,,0,0,0,,顺便说一句 如果你对渐近性感到不安 不用担心
Dialogue: 0,0:32:57.55,0:33:01.80,英文,,0,0,0,,There are like tens of thousands of students before you that were also freaked out by asymptotics.
Dialogue: 0,0:32:57.55,0:33:01.80,中文,,0,0,0,,之前有成千上万的学生和你一样对渐近性感到紧张
Dialogue: 0,0:33:01.80,0:33:05.48,英文,,0,0,0,,So you'll get it with practice, I promise.
Dialogue: 0,0:33:01.80,0:33:05.48,中文,,0,0,0,,练习后你肯定能掌握 我保证
Dialogue: 0,0:33:05.48,0:33:06.42,英文,,0,0,0,,Can I have the mic?
Dialogue: 0,0:33:05.48,0:33:06.42,中文,,0,0,0,,我能拿麦克风吗
Dialogue: 0,0:33:06.42,0:33:10.20,英文,,0,0,0,,Or are we just going to be like tethered together?
Dialogue: 0,0:33:06.42,0:33:10.20,中文,,0,0,0,,还是我们只是被一起绑在一起
Dialogue: 0,0:33:10.20,0:33:14.75,英文,,0,0,0,,I'll take you home with me.
Dialogue: 0,0:33:10.20,0:33:14.75,中文,,0,0,0,,我会带你回家的
Dialogue: 0,0:33:14.75,0:33:16.67,英文,,0,0,0,,Let's speed run you through binary search trees.
Dialogue: 0,0:33:14.75,0:33:16.67,中文,,0,0,0,,让我们快速过一遍二叉搜索树
Dialogue: 0,0:33:16.67,0:33:20.49,英文,,0,0,0,,So really quickly, I will introduce a quick vocabulary term.
Dialogue: 0,0:33:16.67,0:33:20.49,中文,,0,0,0,,很快 我会简单介绍一个词汇术语
Dialogue: 0,0:33:20.49,0:33:21.99,英文,,0,0,0,,Look, I'm skipping all the slides.
Dialogue: 0,0:33:20.49,0:33:21.99,中文,,0,0,0,,看 我跳过了所有的幻灯片
Dialogue: 0,0:33:21.99,0:33:24.58,英文,,0,0,0,,So quick idea.
Dialogue: 0,0:33:21.99,0:33:24.58,中文,,0,0,0,,所以快速的想法
Dialogue: 0,0:33:24.58,0:33:26.94,英文,,0,0,0,,Hopefully, you are sick of this idea by now.
Dialogue: 0,0:33:24.58,0:33:26.94,中文,,0,0,0,,希望你现在对这个想法感到厌倦
Dialogue: 0,0:33:26.94,0:33:38.22,英文,,0,0,0,,But we have seen that there is a difference between the interface, which tells us what a List61b can do, what a deck can do, and the implementation, which tells you how to do those things.
Dialogue: 0,0:33:26.94,0:33:38.22,中文,,0,0,0,,但我们已经看到界面和实现之间存在差异 界面告诉我们List61b能做什么 deck能做什么 而实现告诉你如何做这些事情
Dialogue: 0,0:33:38.22,0:33:40.68,英文,,0,0,0,,Hopefully, you're very sick of this idea by now.
Dialogue: 0,0:33:38.22,0:33:40.68,中文,,0,0,0,,希望你现在非常厌倦这个想法
Dialogue: 0,0:33:40.68,0:33:42.50,英文,,0,0,0,,We saw it again with disjoint sets.
Dialogue: 0,0:33:40.68,0:33:42.50,中文,,0,0,0,,我们在不相交集合中再次看到了它
Dialogue: 0,0:33:42.50,0:33:46.61,英文,,0,0,0,,The disjoint sets interface, it just has connected and is connected.
Dialogue: 0,0:33:42.50,0:33:46.61,中文,,0,0,0,,不相交集合的接口只有连接和已连接
Dialogue: 0,0:33:46.61,0:33:49.77,英文,,0,0,0,,And we saw four different ways to actually implement that.
Dialogue: 0,0:33:46.61,0:33:49.77,中文,,0,0,0,,我们看到了四种不同的实现方式
Dialogue: 0,0:33:49.77,0:33:50.95,英文,,0,0,0,,We could use an array.
Dialogue: 0,0:33:49.77,0:33:50.95,中文,,0,0,0,,我们可以使用数组
Dialogue: 0,0:33:50.95,0:33:52.55,英文,,0,0,0,,We could use the list of sets.
Dialogue: 0,0:33:50.95,0:33:52.55,中文,,0,0,0,,我们可以使用集合列表
Dialogue: 0,0:33:52.55,0:33:55.66,英文,,0,0,0,,We could use this parents array structure.
Dialogue: 0,0:33:52.55,0:33:55.66,中文,,0,0,0,,我们可以使用这种父数组结构
Dialogue: 0,0:33:55.66,0:34:00.26,英文,,0,0,0,,So lots of different ways to implement the same interface that people want to see.
Dialogue: 0,0:33:55.66,0:34:00.26,中文,,0,0,0,,有很多不同的方式来实现人们想要看到的相同接口
Dialogue: 0,0:34:00.26,0:34:06.46,英文,,0,0,0,,So the vocabulary term for all this, sometimes people call it an abstract data type.
Dialogue: 0,0:34:00.26,0:34:06.46,中文,,0,0,0,,所有这些的词汇术语 有时人们称之为抽象数据类型
Dialogue: 0,0:34:06.46,0:34:09.24,英文,,0,0,0,,And an abstract data type, it's like the deck interface.
Dialogue: 0,0:34:06.46,0:34:09.24,中文,,0,0,0,,抽象数据类型就像卡组接口一样
Dialogue: 0,0:34:09.24,0:34:12.37,英文,,0,0,0,,It's only defined by what it is able to do.
Dialogue: 0,0:34:09.24,0:34:12.37,中文,,0,0,0,,它仅由其能够做什么来定义
Dialogue: 0,0:34:12.37,0:34:17.09,英文,,0,0,0,,An abstract data type, the deck abstract data type, for example, you can add first.
Dialogue: 0,0:34:12.37,0:34:17.09,中文,,0,0,0,,一个抽象数据类型 比如 你可以添加首项
Dialogue: 0,0:34:17.09,0:34:22.94,英文,,0,0,0,,We don't tell you how to do it, but a user should be able to add first, users should be able to add last, and so forth.
Dialogue: 0,0:34:17.09,0:34:22.94,中文,,0,0,0,,我们不告诉你如何做 但用户应能够添加首项 用户应能够添加末项 等等
Dialogue: 0,0:34:22.94,0:34:25.28,英文,,0,0,0,,And we don't tell you about the implementation.
Dialogue: 0,0:34:22.94,0:34:25.28,中文,,0,0,0,,而我们不告诉你关于实现的事情
Dialogue: 0,0:34:25.28,0:34:31.37,英文,,0,0,0,,So you can kind of think of it like a more philosophical version of the interface that we saw in Java.
Dialogue: 0,0:34:25.28,0:34:31.37,中文,,0,0,0,,你可以把它想象成是我们在Java中看到的接口的更哲学的版本
Dialogue: 0,0:34:31.37,0:34:33.95,英文,,0,0,0,,So sometimes people call that an abstract data type.
Dialogue: 0,0:34:31.37,0:34:33.95,中文,,0,0,0,,有时人们称之为抽象数据类型
Dialogue: 0,0:34:33.95,0:34:35.05,英文,,0,0,0,,Now you know.
Dialogue: 0,0:34:33.95,0:34:35.05,中文,,0,0,0,,现在你知道了
Dialogue: 0,0:34:35.05,0:34:37.65,英文,,0,0,0,,OK, here are some examples that I'm not going to talk about.
Dialogue: 0,0:34:35.05,0:34:37.65,中文,,0,0,0,,这里有一些例子 我不打算讲
Dialogue: 0,0:34:37.65,0:34:38.74,英文,,0,0,0,,You've seen the stack before.
Dialogue: 0,0:34:37.65,0:34:38.74,中文,,0,0,0,,你之前见过这个栈
Dialogue: 0,0:34:38.74,0:34:40.52,英文,,0,0,0,,If you want to, there are videos.
Dialogue: 0,0:34:38.74,0:34:40.52,中文,,0,0,0,,如果你想的话 有视频
Dialogue: 0,0:34:40.52,0:34:45.34,英文,,0,0,0,,Here's a more exotic one called Grabback, which I have literally never seen outside of these slides.
Dialogue: 0,0:34:40.52,0:34:45.34,中文,,0,0,0,,这里有一个更奇特的叫 Grabback 的 我在这些幻灯片之外从未见过
Dialogue: 0,0:34:45.34,0:34:47.50,英文,,0,0,0,,So I guess you won't either.
Dialogue: 0,0:34:45.34,0:34:47.50,中文,,0,0,0,,我猜你也不会
Dialogue: 0,0:34:47.50,0:34:57.17,英文,,0,0,0,,But one thing I like about Java really quickly is that the language of Java, it makes abstract data types like right there in the language, because you can say,
Dialogue: 0,0:34:47.50,0:34:57.17,中文,,0,0,0,,但我真的很喜欢 Java 的一件事是 它的语言让抽象数据类型就像在语言中一样显而易见 因为你可以说
Dialogue: 0,0:34:57.17,0:35:01.13,英文,,0,0,0,,I declare that there is a variable called L, and it's of type list.
Dialogue: 0,0:34:57.17,0:35:01.13,中文,,0,0,0,,我声明有一个叫 L 的变量 它是列表类型
Dialogue: 0,0:35:01.13,0:35:02.17,英文,,0,0,0,,What kind of list?
Dialogue: 0,0:35:01.13,0:35:02.17,中文,,0,0,0,,什么样的列表
Dialogue: 0,0:35:02.17,0:35:02.53,英文,,0,0,0,,I don't know.
Dialogue: 0,0:35:02.17,0:35:02.53,中文,,0,0,0,,我不知道
Dialogue: 0,0:35:02.53,0:35:03.30,英文,,0,0,0,,It's a list.
Dialogue: 0,0:35:02.53,0:35:03.30,中文,,0,0,0,,它是一个列表
Dialogue: 0,0:35:03.30,0:35:04.90,英文,,0,0,0,,It can do list things.
Dialogue: 0,0:35:03.30,0:35:04.90,中文,,0,0,0,,它可以做列表的事情
Dialogue: 0,0:35:04.90,0:35:11.56,英文,,0,0,0,,And then on the right-hand side, you can say, well, specifically, I want the array-based list, or I want the link-list-based list.
Dialogue: 0,0:35:04.90,0:35:11.56,中文,,0,0,0,,然后在右边 你可以说 具体来说 我想要基于数组的列表 或者我想要基于链表的列表
Dialogue: 0,0:35:11.56,0:35:19.41,英文,,0,0,0,,But I kind of like that the Java syntax, it tells a story all about the abstract data type, which I find pretty cool.
Dialogue: 0,0:35:11.56,0:35:19.41,中文,,0,0,0,,但我有点喜欢Java的语法 它讲述了关于抽象数据类型的故事 我觉得挺酷的
Dialogue: 0,0:35:19.41,0:35:21.39,英文,,0,0,0,,OK.
Dialogue: 0,0:35:21.39,0:35:31.22,英文,,0,0,0,,Now that we know what abstract datatypes are, the next two, three-ish lectures will be about implementing two of the most important abstract datatypes ever.
Dialogue: 0,0:35:21.39,0:35:31.22,中文,,0,0,0,,现在我们知道什么是抽象数据类型了 接下来的两三个讲座将是关于实现两个最重要的抽象数据类型之一的
Dialogue: 0,0:35:31.22,0:35:32.86,英文,,0,0,0,,So we've already seen List.
Dialogue: 0,0:35:31.22,0:35:32.86,中文,,0,0,0,,我们已经看过列表了
Dialogue: 0,0:35:32.86,0:35:34.20,英文,,0,0,0,,You're sick of it by now.
Dialogue: 0,0:35:32.86,0:35:34.20,中文,,0,0,0,,你现在已经厌倦了
Dialogue: 0,0:35:34.20,0:35:36.32,英文,,0,0,0,,But there are two more that we're going to implement.
Dialogue: 0,0:35:34.20,0:35:36.32,中文,,0,0,0,,但是还有两个我们要实现的
Dialogue: 0,0:35:36.32,0:35:37.10,英文,,0,0,0,,There's the set.
Dialogue: 0,0:35:36.32,0:35:37.10,中文,,0,0,0,,首先是集合
Dialogue: 0,0:35:37.10,0:35:38.08,英文,,0,0,0,,We've seen that before.
Dialogue: 0,0:35:37.10,0:35:38.08,中文,,0,0,0,,我们之前已经见过了
Dialogue: 0,0:35:38.08,0:35:41.16,英文,,0,0,0,,It's a collection of items, no order, no duplicates.
Dialogue: 0,0:35:38.08,0:35:41.16,中文,,0,0,0,,它是一组项目 没有顺序 也没有重复项
Dialogue: 0,0:35:41.16,0:35:44.26,英文,,0,0,0,,And there's a map, which I think you saw in Homework 0.
Dialogue: 0,0:35:41.16,0:35:44.26,中文,,0,0,0,,有一张地图 我想你在作业 0 中看到了
Dialogue: 0,0:35:44.26,0:35:46.45,英文,,0,0,0,,Maybe you remember dictionaries in Python.
Dialogue: 0,0:35:44.26,0:35:46.45,中文,,0,0,0,,也许你还记得 Python 中的字典
Dialogue: 0,0:35:46.45,0:35:48.65,英文,,0,0,0,,But the idea is you're going to map keys to values.
Dialogue: 0,0:35:46.45,0:35:48.65,中文,,0,0,0,,但是想法是你要将键映射到值
Dialogue: 0,0:35:48.65,0:35:51.87,英文,,0,0,0,,So for example, you might say, jhugs grade is 88.4.
Dialogue: 0,0:35:48.65,0:35:51.87,中文,,0,0,0,,例如 你可能会说 jhugs 的成绩是 88.4
Dialogue: 0,0:35:51.87,0:35:55.55,英文,,0,0,0,,Or you might say, creature sees north neighbor is a plip.
Dialogue: 0,0:35:51.87,0:35:55.55,中文,,0,0,0,,或者你可能会说 creature 看见北邻是 plip
Dialogue: 0,0:35:55.55,0:35:56.63,英文,,0,0,0,,I don't know what a plip is.
Dialogue: 0,0:35:55.55,0:35:56.63,中文,,0,0,0,,我不知道 plip 是什么
Dialogue: 0,0:35:56.63,0:35:59.59,英文,,0,0,0,,But the idea is you're going to map keys to values.
Dialogue: 0,0:35:56.63,0:35:59.59,中文,,0,0,0,,但是想法是你要将键映射到值
Dialogue: 0,0:35:59.59,0:36:02.60,英文,,0,0,0,,Or you're going to map some item to some other item.
Dialogue: 0,0:35:59.59,0:36:02.60,中文,,0,0,0,,或者你要把某个项目映射到另一个项目上
Dialogue: 0,0:36:02.60,0:36:03.85,英文,,0,0,0,,OK.
Dialogue: 0,0:36:03.85,0:36:07.33,英文,,0,0,0,,So that's my really quick speed run of abstract data types.
Dialogue: 0,0:36:03.85,0:36:07.33,中文,,0,0,0,,这就是我对抽象数据类型的快速演示
Dialogue: 0,0:36:07.33,0:36:10.14,英文,,0,0,0,,Here's an example of a map if you were curious.
Dialogue: 0,0:36:07.33,0:36:10.14,中文,,0,0,0,,如果你感兴趣 这里有一个映射的例子
Dialogue: 0,0:36:10.14,0:36:11.54,英文,,0,0,0,,I'm not reading that.
Dialogue: 0,0:36:10.14,0:36:11.54,中文,,0,0,0,,我不会读那个
Dialogue: 0,0:36:11.54,0:36:14.50,英文,,0,0,0,,Any questions so far?
Dialogue: 0,0:36:11.54,0:36:14.50,中文,,0,0,0,,到目前为止有什么问题吗
Dialogue: 0,0:36:14.50,0:36:15.78,英文,,0,0,0,,OK, great.
Dialogue: 0,0:36:14.50,0:36:15.78,中文,,0,0,0,,很好
Dialogue: 0,0:36:15.78,0:36:20.06,英文,,0,0,0,,So we are now going to figure out ways to build sets and maps that are efficient.
Dialogue: 0,0:36:15.78,0:36:20.06,中文,,0,0,0,,我们现在要想办法构建高效的集合和映射
Dialogue: 0,0:36:20.06,0:36:27.17,英文,,0,0,0,,And we're going to use asymptotics to help ourselves prove that, yes, these are the most efficient ways to build sets and maps.
Dialogue: 0,0:36:20.06,0:36:27.17,中文,,0,0,0,,我们将利用渐近符号来帮助我们证明 是的 这些是构建集合和映射的最有效方式
Dialogue: 0,0:36:27.17,0:36:28.27,英文,,0,0,0,,OK, so here we go.
Dialogue: 0,0:36:27.17,0:36:28.27,中文,,0,0,0,,那么我们开始吧
Dialogue: 0,0:36:28.27,0:36:30.17,英文,,0,0,0,,It's time to build a binary search tree.
Dialogue: 0,0:36:28.27,0:36:30.17,中文,,0,0,0,,是时候构建一个二叉搜索树了
Dialogue: 0,0:36:30.17,0:36:34.15,英文,,0,0,0,,This is one of the most beautiful ideas in computer science.
Dialogue: 0,0:36:30.17,0:36:34.15,中文,,0,0,0,,这是计算机科学中最美的想法之一
Dialogue: 0,0:36:34.15,0:36:35.87,英文,,0,0,0,,You'll see this everywhere you go.
Dialogue: 0,0:36:34.15,0:36:35.87,中文,,0,0,0,,你会在任何地方都看到它
Dialogue: 0,0:36:35.87,0:36:39.81,英文,,0,0,0,,When you're on the streets, people will often stop you and ask about binary search trees.
Dialogue: 0,0:36:35.87,0:36:39.81,中文,,0,0,0,,当你在街上时 人们经常会拦住你询问二叉搜索树的事情
Dialogue: 0,0:36:39.81,0:36:41.19,英文,,0,0,0,,Now you know what they are.
Dialogue: 0,0:36:39.81,0:36:41.19,中文,,0,0,0,,现在你知道它们是什么了
Dialogue: 0,0:36:41.19,0:36:43.75,英文,,0,0,0,,OK, maybe I'm overselling a little bit.
Dialogue: 0,0:36:41.19,0:36:43.75,中文,,0,0,0,,好吧 也许我夸大了一点
Dialogue: 0,0:36:43.75,0:36:53.18,英文,,0,0,0,,To kind of build it together, let's go back to your link list and let's think about maybe kind of a strange, exotic way to build a list.
Dialogue: 0,0:36:43.75,0:36:53.18,中文,,0,0,0,,为了有点儿一起构建它 让我们回到你的链表 然后想想也许有点奇怪、新奇的方法来构建一个列表
Dialogue: 0,0:36:53.18,0:36:56.02,英文,,0,0,0,,I'm going to call it the ordered link list.
Dialogue: 0,0:36:53.18,0:36:56.02,中文,,0,0,0,,我要把它叫做有序链表
Dialogue: 0,0:36:56.02,0:36:58.10,英文,,0,0,0,,And the ordered link list, it is a link list.
Dialogue: 0,0:36:56.02,0:36:58.10,中文,,0,0,0,,有序链表 就是一个链表
Dialogue: 0,0:36:58.10,0:37:01.32,英文,,0,0,0,,It's got a sentence and all the items point to the next item.
Dialogue: 0,0:36:58.10,0:37:01.32,中文,,0,0,0,,它有一个句子 所有项目都指向下一个项目
Dialogue: 0,0:37:01.32,0:37:07.97,英文,,0,0,0,,However, When I'm using the OrderedLinkList to build a set, I'm going to ensure that everything stays in order.
Dialogue: 0,0:37:01.32,0:37:07.97,中文,,0,0,0,,然而  当我使用OrderedLinkList来构建一个集合时 我会确保一切都保持有序
Dialogue: 0,0:37:07.97,0:37:10.73,英文,,0,0,0,,So look, A, B, C, D, E, F, G in order.
Dialogue: 0,0:37:07.97,0:37:10.73,中文,,0,0,0,,所以看 按顺序是A B C D E F G
Dialogue: 0,0:37:10.73,0:37:17.30,英文,,0,0,0,,And if I wanted to add something like H, I would have to go through this and find its rightful place and add it at the end.
Dialogue: 0,0:37:10.73,0:37:17.30,中文,,0,0,0,,如果我想添加像H这样的东西 我就得浏览一遍找到它应该处在的位置 然后把它添加到末尾
Dialogue: 0,0:37:17.30,0:37:23.10,英文,,0,0,0,,Or if I wanted to add, I don't know, AA or something, I'd have to put it here in its rightful place.
Dialogue: 0,0:37:17.30,0:37:23.10,中文,,0,0,0,,或者如果我想添加 我不知道 AA或者其他什么 我得把它放到它应该处在的位置
Dialogue: 0,0:37:23.10,0:37:27.33,英文,,0,0,0,,So the OrderedLinkList, it is a linked list, and I'm going to use it to represent the set.
Dialogue: 0,0:37:23.10,0:37:27.33,中文,,0,0,0,,所以OrderedLinkList 它是一个链表 我要用它来表示这个集合
Dialogue: 0,0:37:27.33,0:37:30.47,英文,,0,0,0,,However, I want to keep everything in order.
Dialogue: 0,0:37:27.33,0:37:30.47,中文,,0,0,0,,然而 我想要保持一切都有序
Dialogue: 0,0:37:30.47,0:37:34.12,英文,,0,0,0,,So I guess I could ask you what the runtime is.
Dialogue: 0,0:37:30.47,0:37:34.12,中文,,0,0,0,,我猜我可以问你运行时间是多少
Dialogue: 0,0:37:34.12,0:37:41.55,英文,,0,0,0,,It kind of spoils that one of the operations is theta of n. And in particular, the contains operation has theta of n runtime.
Dialogue: 0,0:37:34.12,0:37:41.55,中文,,0,0,0,,某种程度上 其中一个操作的时间复杂度是Θ(n) 特别是包含操作的运行时间也是Θ(n)
Dialogue: 0,0:37:41.55,0:37:42.49,英文,,0,0,0,,Why is that?
Dialogue: 0,0:37:41.55,0:37:42.49,中文,,0,0,0,,为什么呢
Dialogue: 0,0:37:42.49,0:37:47.86,英文,,0,0,0,,Because if I want to find an item, in the worst case, I might have to scan all the way through the list.
Dialogue: 0,0:37:42.49,0:37:47.86,中文,,0,0,0,,因为如果我要找一个项目 在最坏的情况下 我可能得一直扫描整个列表
Dialogue: 0,0:37:47.86,0:37:48.84,英文,,0,0,0,,That's n items.
Dialogue: 0,0:37:47.86,0:37:48.84,中文,,0,0,0,,那就是n个项目
Dialogue: 0,0:37:48.84,0:37:50.12,英文,,0,0,0,,I have to scan through them.
Dialogue: 0,0:37:48.84,0:37:50.12,中文,,0,0,0,,我得扫描它们
Dialogue: 0,0:37:50.12,0:37:51.52,英文,,0,0,0,,Theta of n runtime.
Dialogue: 0,0:37:50.12,0:37:51.52,中文,,0,0,0,,Θ(n)的运行时间
Dialogue: 0,0:37:51.52,0:37:52.60,英文,,0,0,0,,And same thing with add.
Dialogue: 0,0:37:51.52,0:37:52.60,中文,,0,0,0,,添加操作也是一样的
Dialogue: 0,0:37:52.60,0:37:54.26,英文,,0,0,0,,What if I wanted to add z?
Dialogue: 0,0:37:52.60,0:37:54.26,中文,,0,0,0,,如果我想要添加 z 呢
Dialogue: 0,0:37:54.26,0:37:55.78,英文,,0,0,0,,Well, I'd have to start here.
Dialogue: 0,0:37:54.26,0:37:55.78,中文,,0,0,0,,我得从这里开始
Dialogue: 0,0:37:55.78,0:38:00.21,英文,,0,0,0,,Well, that's not the right place to put z. I can't add it at the beginning, because I want it sorted.
Dialogue: 0,0:37:55.78,0:38:00.21,中文,,0,0,0,,把 z 放在这里不对 我不能把它放在开头 因为我想要排序
Dialogue: 0,0:38:00.21,0:38:04.61,英文,,0,0,0,,So I have to go skip, skip, skip, all the way to z, and then add it there.
Dialogue: 0,0:38:00.21,0:38:04.61,中文,,0,0,0,,我必须跳过 跳过 一直到 z 的位置 然后在那里添加它
Dialogue: 0,0:38:04.61,0:38:06.29,英文,,0,0,0,,Theta of n runtime.
Dialogue: 0,0:38:04.61,0:38:06.29,中文,,0,0,0,,Theta 的 n 运行时间
Dialogue: 0,0:38:06.29,0:38:12.78,英文,,0,0,0,,So the problem here, and maybe you're starting to feel it, is, well, somehow I have this thing sorted.
Dialogue: 0,0:38:06.29,0:38:12.78,中文,,0,0,0,,这里的问题 也许你开始感觉到了 是 我有这个东西已经排序好了
Dialogue: 0,0:38:12.78,0:38:13.56,英文,,0,0,0,,Look, it's so nice.
Dialogue: 0,0:38:12.78,0:38:13.56,中文,,0,0,0,,看 这样挺好
Dialogue: 0,0:38:13.56,0:38:14.54,英文,,0,0,0,,It's sorted.
Dialogue: 0,0:38:13.56,0:38:14.54,中文,,0,0,0,,它已经排好序了
Dialogue: 0,0:38:14.54,0:38:18.46,英文,,0,0,0,,So why am I not taking advantage of the fact that it's sorted?
Dialogue: 0,0:38:14.54,0:38:18.46,中文,,0,0,0,,那么为什么我不利用它已经排序的事实呢
Dialogue: 0,0:38:18.46,0:38:22.87,英文,,0,0,0,,For example, if I want to find if G is in this set,
Dialogue: 0,0:38:18.46,0:38:22.87,中文,,0,0,0,,例如 如果我想要查找 G 是否在这个集合中
Dialogue: 0,0:38:22.87,0:38:30.43,英文,,0,0,0,,Well, I know it's probably going to be near the end and probably not in the beginning, but I'm still forcing myself to scan all the way to the end.
Dialogue: 0,0:38:22.87,0:38:30.43,中文,,0,0,0,,我知道它可能在末尾附近 而且可能不在开头 但我仍然强迫自己扫描到最后
Dialogue: 0,0:38:30.43,0:38:31.67,英文,,0,0,0,,And that seems slow.
Dialogue: 0,0:38:30.43,0:38:31.67,中文,,0,0,0,,而且这看起来很慢
Dialogue: 0,0:38:31.67,0:38:38.67,英文,,0,0,0,,So how can I leverage the power that this thing is in order to maybe make my operations faster?
Dialogue: 0,0:38:31.67,0:38:38.67,中文,,0,0,0,,那么我怎样才能利用这个已经排好序的特性来加速我的操作呢
Dialogue: 0,0:38:38.67,0:38:41.56,英文,,0,0,0,,So I'll give you one idea, and then you can generalize it.
Dialogue: 0,0:38:38.67,0:38:41.56,中文,,0,0,0,,我给你一个想法 然后你可以将其概括
Dialogue: 0,0:38:41.56,0:38:46.34,英文,,0,0,0,,We won't talk about this one, but it's kind of cool if you want to click on the link.
Dialogue: 0,0:38:41.56,0:38:46.34,中文,,0,0,0,,这个我们不讨论 但如果你想点击链接的话 挺酷的
Dialogue: 0,0:38:46.34,0:38:52.36,英文,,0,0,0,,Here's one idea, which is, well, I know the array is sorted, or I know the link list is sorted.
Dialogue: 0,0:38:46.34,0:38:52.36,中文,,0,0,0,,这里有个想法 我知道数组是有序的 或者我知道链表是有序的
Dialogue: 0,0:38:52.36,0:39:00.67,英文,,0,0,0,,So if I want to find something in my set, what if, instead of having the sentinel point at the first item, I have the sentinel point straight in the middle?
Dialogue: 0,0:38:52.36,0:39:00.67,中文,,0,0,0,,如果我想在我的集合中找到某个东西 如果我把哨兵指向第一个项目的位置改为直接指向中间呢
Dialogue: 0,0:39:00.67,0:39:05.99,英文,,0,0,0,,Well, now I have a problem, which is I can't reach C, B, and A. So I'll just turn those links around.
Dialogue: 0,0:39:00.67,0:39:05.99,中文,,0,0,0,,现在我有个问题 那就是我无法到达C、B和A 所以我就把这些链接反过来
Dialogue: 0,0:39:05.99,0:39:10.12,英文,,0,0,0,,And now this structure is kind of nice, because you start in the middle,
Dialogue: 0,0:39:05.99,0:39:10.12,中文,,0,0,0,,现在这个结构还挺不错的 因为你是从中间开始的
Dialogue: 0,0:39:10.12,0:39:15.42,英文,,0,0,0,,And if I'm looking for, say, G, I think, is G bigger than D, or is it less than D?
Dialogue: 0,0:39:10.12,0:39:15.42,中文,,0,0,0,,如果我要找G 我会想 G是比D大还是比D小呢
Dialogue: 0,0:39:15.42,0:39:16.36,英文,,0,0,0,,Well, it's bigger.
Dialogue: 0,0:39:15.42,0:39:16.36,中文,,0,0,0,,嗯 它比D大
Dialogue: 0,0:39:16.36,0:39:23.71,英文,,0,0,0,,So I should turn right and go this way and find G. Or if I want to find A, well, I start at D. That's where the sentinel points.
Dialogue: 0,0:39:16.36,0:39:23.71,中文,,0,0,0,,我应该右转 沿着这条路找G 或者如果我想找A 我从D开始 哨兵指向那里
Dialogue: 0,0:39:23.71,0:39:28.97,英文,,0,0,0,,And I say, well, A is less than D. So I'll turn left, and I'll go this way, and I'll find A. Well, that's great.
Dialogue: 0,0:39:23.71,0:39:28.97,中文,,0,0,0,,然后我说 A小于D 我会左转 沿着这条路走 找到A 那太好了
Dialogue: 0,0:39:28.97,0:39:30.79,英文,,0,0,0,,Now my search time is cut in half.
Dialogue: 0,0:39:28.97,0:39:30.79,中文,,0,0,0,,现在我的搜索时间减半了
Dialogue: 0,0:39:30.79,0:39:35.85,英文,,0,0,0,,I had a million items in my set, but I was pointing at the middle, and my set was sorted.
Dialogue: 0,0:39:30.79,0:39:35.85,中文,,0,0,0,,我的集合中有一百万个项 但我指向中间 我的集合已经排序了
Dialogue: 0,0:39:35.85,0:39:39.64,英文,,0,0,0,,Well, now the time it takes to find my item has been cut in half.
Dialogue: 0,0:39:35.85,0:39:39.64,中文,,0,0,0,,现在找到我的项目所需的时间减半了
Dialogue: 0,0:39:39.64,0:39:41.02,英文,,0,0,0,,It's pretty cool.
Dialogue: 0,0:39:39.64,0:39:41.02,中文,,0,0,0,,这很酷
Dialogue: 0,0:39:41.02,0:39:45.60,英文,,0,0,0,,So question for you, very quickly, is how can we do even better?
Dialogue: 0,0:39:41.02,0:39:45.60,中文,,0,0,0,,很快问你一个问题 我们怎么能做得更好呢
Dialogue: 0,0:39:45.60,0:39:47.98,英文,,0,0,0,,So like, get creative, dream big.
Dialogue: 0,0:39:45.60,0:39:47.98,中文,,0,0,0,,就像这样 发挥创造力 梦想远大
Dialogue: 0,0:39:47.98,0:39:50.05,英文,,0,0,0,,Tell me, how do you make this even better?
Dialogue: 0,0:39:47.98,0:39:50.05,中文,,0,0,0,,告诉我 你怎么样才能让这个变得更好
Dialogue: 0,0:39:50.05,0:39:58.16,英文,,0,0,0,,I want the most beautiful, the quickest possible way to find things in the set.
Dialogue: 0,0:39:50.05,0:39:58.16,中文,,0,0,0,,我想要最漂亮、最快速的方式来在集合中找到东西
Dialogue: 0,0:39:58.16,0:40:00.36,英文,,0,0,0,,Right now I'm using an order link list.
Dialogue: 0,0:39:58.16,0:40:00.36,中文,,0,0,0,,现在我正在使用一个有序链表
Dialogue: 0,0:40:00.36,0:40:01.87,英文,,0,0,0,,I split it down the middle.
Dialogue: 0,0:40:00.36,0:40:01.87,中文,,0,0,0,,我把它从中间分开
Dialogue: 0,0:40:01.87,0:40:11.03,英文,,0,0,0,,So I guess in the interest of time, what if I did the same trick, but I did it on the left side, and then I did the same trick, and I did it on the right side?
Dialogue: 0,0:40:01.87,0:40:11.03,中文,,0,0,0,,我想 为了节省时间 如果我在左边做同样的把戏 然后我在右边也做同样的把戏呢
Dialogue: 0,0:40:11.03,0:40:23.28,英文,,0,0,0,,That is, instead of having D point at C, and then I potentially have to scan through everything to the left of D, what if I actually had D point at B, straight in the middle of the left side?
Dialogue: 0,0:40:11.03,0:40:23.28,中文,,0,0,0,,也就是说 不是让D指向C 然后我可能要扫描D左边的所有内容 如果我让D直接指向B 直接在左边的中间会怎样
Dialogue: 0,0:40:23.28,0:40:27.68,英文,,0,0,0,,And then now I can turn left or right to find the things less than B, things greater than B.
Dialogue: 0,0:40:23.28,0:40:27.68,中文,,0,0,0,,然后现在我可以向左或向右转找到小于B的东西 大于B的东西
Dialogue: 0,0:40:27.68,0:40:29.86,英文,,0,0,0,,What if on the right-hand side, I did the same thing?
Dialogue: 0,0:40:27.68,0:40:29.86,中文,,0,0,0,,如果在右边 我做了同样的事情呢
Dialogue: 0,0:40:29.86,0:40:38.18,英文,,0,0,0,,Instead of having D point at E and having to scan all the way through, I made it skip right into the middle, F, and then I can turn left or right.
Dialogue: 0,0:40:29.86,0:40:38.18,中文,,0,0,0,,不是让D指向E并且必须扫描全部 我让它直接跳到中间的F 然后我可以向左或向右转
Dialogue: 0,0:40:38.18,0:40:39.10,英文,,0,0,0,,Well, pretty good.
Dialogue: 0,0:40:38.18,0:40:39.10,中文,,0,0,0,,相当不错
Dialogue: 0,0:40:39.10,0:40:44.29,英文,,0,0,0,,I'll make one more improvement, which is I will drag the nodes around on the slide to make it look nicer.
Dialogue: 0,0:40:39.10,0:40:44.29,中文,,0,0,0,,我将再做一个改进 就是我将节点拖动到幻灯片上使其看起来更好看
Dialogue: 0,0:40:44.29,0:40:48.23,英文,,0,0,0,,And lo and behold, we have the glorious binary search tree.
Dialogue: 0,0:40:44.29,0:40:48.23,中文,,0,0,0,,瞧 我们有了光荣的二叉搜索树
Dialogue: 0,0:40:48.23,0:40:49.17,英文,,0,0,0,,It's beautiful.
Dialogue: 0,0:40:48.23,0:40:49.17,中文,,0,0,0,,太美了
Dialogue: 0,0:40:49.17,0:40:50.33,英文,,0,0,0,,It's recursive.
Dialogue: 0,0:40:49.17,0:40:50.33,中文,,0,0,0,,这是递归的
Dialogue: 0,0:40:50.33,0:40:53.11,英文,,0,0,0,,And the idea, well, I guess we'll get to the idea in a little bit.
Dialogue: 0,0:40:50.33,0:40:53.11,中文,,0,0,0,,至于这个概念 我想我们马上就会谈到
Dialogue: 0,0:40:53.11,0:40:55.97,英文,,0,0,0,,But we took our list.
Dialogue: 0,0:40:53.11,0:40:55.97,中文,,0,0,0,,但我们拿到了我们的列表
Dialogue: 0,0:40:55.97,0:41:02.22,英文,,0,0,0,,We took our order link list, and we kind of changed the pointers around a little bit to make our search faster, and we got this thing.
Dialogue: 0,0:40:55.97,0:41:02.22,中文,,0,0,0,,我们拿到了我们的订单链表 稍微改变了指针的位置以加快搜索速度 然后我们得到了这个东西
Dialogue: 0,0:41:02.22,0:41:03.55,英文,,0,0,0,,Beautiful.
Dialogue: 0,0:41:02.22,0:41:03.55,中文,,0,0,0,,漂亮
Dialogue: 0,0:41:03.55,0:41:04.91,英文,,0,0,0,,Questions?
Dialogue: 0,0:41:03.55,0:41:04.91,中文,,0,0,0,,有问题吗
Dialogue: 0,0:41:04.91,0:41:06.81,英文,,0,0,0,,By the way, tell me to slow down if it's needed.
Dialogue: 0,0:41:04.91,0:41:06.81,中文,,0,0,0,,顺便说一句 如果需要的话告诉我放慢速度
Dialogue: 0,0:41:06.81,0:41:09.83,英文,,0,0,0,,I'm going a little bit fast just to make sure we're getting through everything.
Dialogue: 0,0:41:06.81,0:41:09.83,中文,,0,0,0,,我稍微走得有点快 只是为了确保我们能够顺利完成所有内容
Dialogue: 0,0:41:09.83,0:41:11.79,英文,,0,0,0,,OK, here are some definitions.
Dialogue: 0,0:41:09.83,0:41:11.79,中文,,0,0,0,,这里有一些定义
Dialogue: 0,0:41:11.79,0:41:13.15,英文,,0,0,0,,Some of them might seem boring.
Dialogue: 0,0:41:11.79,0:41:13.15,中文,,0,0,0,,其中一些可能看起来很无聊
Dialogue: 0,0:41:13.15,0:41:16.79,英文,,0,0,0,,But just to make sure we all know what trees are, we should talk about them.
Dialogue: 0,0:41:13.15,0:41:16.79,中文,,0,0,0,,但为了确保我们都知道树是什么 我们应该谈谈它们
Dialogue: 0,0:41:16.79,0:41:18.29,英文,,0,0,0,,So what's a tree?
Dialogue: 0,0:41:16.79,0:41:18.29,中文,,0,0,0,,那么什么是树
Dialogue: 0,0:41:18.29,0:41:19.38,英文,,0,0,0,,A tree is a set of nodes.
Dialogue: 0,0:41:18.29,0:41:19.38,中文,,0,0,0,,树是一组节点
Dialogue: 0,0:41:19.38,0:41:20.12,英文,,0,0,0,,What are nodes?
Dialogue: 0,0:41:19.38,0:41:20.12,中文,,0,0,0,,什么是节点
Dialogue: 0,0:41:20.12,0:41:22.76,英文,,0,0,0,,They're these little circles you've been seeing on the slide the whole time.
Dialogue: 0,0:41:20.12,0:41:22.76,中文,,0,0,0,,它们就是你一直在幻灯片上看到的这些小圆圈
Dialogue: 0,0:41:22.76,0:41:24.48,英文,,0,0,0,,We call them nodes sometimes.
Dialogue: 0,0:41:22.76,0:41:24.48,中文,,0,0,0,,有时我们称它们为节点
Dialogue: 0,0:41:24.48,0:41:25.76,英文,,0,0,0,,And a set of edges.
Dialogue: 0,0:41:24.48,0:41:25.76,中文,,0,0,0,,还有一组边
Dialogue: 0,0:41:25.76,0:41:26.68,英文,,0,0,0,,What the heck are edges?
Dialogue: 0,0:41:25.76,0:41:26.68,中文,,0,0,0,,边到底是什么
Dialogue: 0,0:41:26.68,0:41:29.50,英文,,0,0,0,,They're these lines that we've been seeing on the slide the whole time.
Dialogue: 0,0:41:26.68,0:41:29.50,中文,,0,0,0,,它们就是我们一直在幻灯片上看到的这些线
Dialogue: 0,0:41:29.50,0:41:31.08,英文,,0,0,0,,So that's what a tree is.
Dialogue: 0,0:41:29.50,0:41:31.08,中文,,0,0,0,,这就是树是什么
Dialogue: 0,0:41:31.08,0:41:35.94,英文,,0,0,0,,You draw a bunch of circles, draw a bunch of lines to connect up the circles, you get a tree.
Dialogue: 0,0:41:31.08,0:41:35.94,中文,,0,0,0,,你画一堆圆圈 画一堆线连接这些圆圈 你就得到了一棵树
Dialogue: 0,0:41:35.94,0:41:45.61,英文,,0,0,0,,However, you cannot go crazy drawing the edges because there's a rule with trees, which is that there is exactly one way to get between any two nodes.
Dialogue: 0,0:41:35.94,0:41:45.61,中文,,0,0,0,,然而 你不能在绘制边缘时变得疯狂 因为树有一个规则 即在任意两个节点之间只有一种方式
Dialogue: 0,0:41:45.61,0:41:48.33,英文,,0,0,0,,So to see what I mean, here are some pictures.
Dialogue: 0,0:41:45.61,0:41:48.33,中文,,0,0,0,,为了看明白我的意思 这里有一些图片
Dialogue: 0,0:41:48.33,0:41:49.37,英文,,0,0,0,,This is a tree.
Dialogue: 0,0:41:48.33,0:41:49.37,中文,,0,0,0,,这是一棵树
Dialogue: 0,0:41:49.37,0:41:49.69,英文,,0,0,0,,Why?
Dialogue: 0,0:41:49.37,0:41:49.69,中文,,0,0,0,,为什么
Dialogue: 0,0:41:49.69,0:41:51.69,英文,,0,0,0,,Because it's got nodes and it's got edges.
Dialogue: 0,0:41:49.69,0:41:51.69,中文,,0,0,0,,因为它有节点 还有边缘
Dialogue: 0,0:41:51.69,0:41:55.67,英文,,0,0,0,,Well, in this case, I didn't draw any edges, but still a tree.
Dialogue: 0,0:41:51.69,0:41:55.67,中文,,0,0,0,,在这种情况下 我没有画任何边缘 但仍然是一棵树
Dialogue: 0,0:41:55.67,0:41:58.05,英文,,0,0,0,,OK, great.
Dialogue: 0,0:41:55.67,0:41:58.05,中文,,0,0,0,,很好
Dialogue: 0,0:41:58.05,0:41:58.59,英文,,0,0,0,,Slow down.
Dialogue: 0,0:41:58.05,0:41:58.59,中文,,0,0,0,,慢下来
Dialogue: 0,0:41:58.59,0:41:59.51,英文,,0,0,0,,OK, sorry.
Dialogue: 0,0:41:58.59,0:41:59.51,中文,,0,0,0,,抱歉
Dialogue: 0,0:41:59.51,0:42:02.36,英文,,0,0,0,,So this is also a tree.
Dialogue: 0,0:41:59.51,0:42:02.36,中文,,0,0,0,,这也是一棵树
Dialogue: 0,0:42:02.36,0:42:02.80,英文,,0,0,0,,Why is that?
Dialogue: 0,0:42:02.36,0:42:02.80,中文,,0,0,0,,为什么呢
Dialogue: 0,0:42:02.80,0:42:03.78,英文,,0,0,0,,Because it's got nodes.
Dialogue: 0,0:42:02.80,0:42:03.78,中文,,0,0,0,,因为它有节点
Dialogue: 0,0:42:03.78,0:42:04.94,英文,,0,0,0,,There they are, the circles.
Dialogue: 0,0:42:03.78,0:42:04.94,中文,,0,0,0,,那些就是圆圈
Dialogue: 0,0:42:04.94,0:42:07.02,英文,,0,0,0,,It's got edges connecting the nodes.
Dialogue: 0,0:42:04.94,0:42:07.02,中文,,0,0,0,,它有连接节点的边
Dialogue: 0,0:42:07.02,0:42:11.40,英文,,0,0,0,,And the constraint that there is exactly one path between any two nodes, it's true.
Dialogue: 0,0:42:07.02,0:42:11.40,中文,,0,0,0,,每两个节点之间只有一条路径的限制是真的
Dialogue: 0,0:42:11.40,0:42:13.00,英文,,0,0,0,,In fact, go home and play with it.
Dialogue: 0,0:42:11.40,0:42:13.00,中文,,0,0,0,,实际上 回家玩玩吧
Dialogue: 0,0:42:13.00,0:42:16.17,英文,,0,0,0,,There's no way to get between, say, the top node and the bottom node.
Dialogue: 0,0:42:13.00,0:42:16.17,中文,,0,0,0,,比如说 顶部节点和底部节点之间没有办法移动
Dialogue: 0,0:42:16.17,0:42:18.89,英文,,0,0,0,,Only one path besides the one path.
Dialogue: 0,0:42:16.17,0:42:18.89,中文,,0,0,0,,除了一条路径以外就只有一条路径
Dialogue: 0,0:42:18.89,0:42:19.96,英文,,0,0,0,,OK.
Dialogue: 0,0:42:19.96,0:42:20.96,英文,,0,0,0,,This is also a tree.
Dialogue: 0,0:42:19.96,0:42:20.96,中文,,0,0,0,,这也是一棵树
Dialogue: 0,0:42:20.96,0:42:29.52,英文,,0,0,0,,And again, if you don't believe me, you go home, you can pick any two nodes, and you'll realize there's only one way to get from this node up top to this node at the bottom.
Dialogue: 0,0:42:20.96,0:42:29.52,中文,,0,0,0,,而且 如果你不信的话 你可以回家 选择任意两个节点 你就会意识到从顶部节点到底部节点只有一种方式
Dialogue: 0,0:42:29.52,0:42:32.25,英文,,0,0,0,,You have to take this path and this set of edges.
Dialogue: 0,0:42:29.52,0:42:32.25,中文,,0,0,0,,你得走这条路径和这组边
Dialogue: 0,0:42:32.25,0:42:34.93,英文,,0,0,0,,There's no other way to get between those two nodes.
Dialogue: 0,0:42:32.25,0:42:34.93,中文,,0,0,0,,没有其他办法可以在这两个节点之间移动
Dialogue: 0,0:42:34.93,0:42:40.10,英文,,0,0,0,,Since this constraint holds, for any pair of nodes you could possibly pick, it's a tree.
Dialogue: 0,0:42:34.93,0:42:40.10,中文,,0,0,0,,因为这个限制成立 对于你可能选择的任意一对节点 它都是一棵树
Dialogue: 0,0:42:40.10,0:42:41.88,英文,,0,0,0,,Okay, what about this one?
Dialogue: 0,0:42:40.10,0:42:41.88,中文,,0,0,0,,那这个呢
Dialogue: 0,0:42:41.88,0:42:42.90,英文,,0,0,0,,Not a tree.
Dialogue: 0,0:42:41.88,0:42:42.90,中文,,0,0,0,,不是一棵树
Dialogue: 0,0:42:42.90,0:42:44.56,英文,,0,0,0,,It's true, there is a set of nodes.
Dialogue: 0,0:42:42.90,0:42:44.56,中文,,0,0,0,,事实上 有一组节点
Dialogue: 0,0:42:44.56,0:42:50.82,英文,,0,0,0,,It is also true that I drew some lines between them, but this is not a tree, because there are two ways to get from the top to the bottom.
Dialogue: 0,0:42:44.56,0:42:50.82,中文,,0,0,0,,也确实我在它们之间画了一些线 但这不是一棵树 因为从顶部到底部有两种方式
Dialogue: 0,0:42:50.82,0:42:53.84,英文,,0,0,0,,Look, I can go left, I can go right.
Dialogue: 0,0:42:50.82,0:42:53.84,中文,,0,0,0,,看 我可以向左走 我可以向右走
Dialogue: 0,0:42:53.84,0:42:55.26,英文,,0,0,0,,And finally, this one.
Dialogue: 0,0:42:53.84,0:42:55.26,中文,,0,0,0,,最后 就是这个
Dialogue: 0,0:42:55.26,0:43:01.68,英文,,0,0,0,,It looks like a tree, but it's not, because again, between this node and this node, I could go this way, I could go this way.
Dialogue: 0,0:42:55.26,0:43:01.68,中文,,0,0,0,,它看起来像一棵树 但实际上并不是 因为在这个节点和这个节点之间 我可以走这条路 也可以走这条路
Dialogue: 0,0:43:01.68,0:43:05.46,英文,,0,0,0,,There are two ways to get between those two nodes, so it's not a tree.
Dialogue: 0,0:43:01.68,0:43:05.46,中文,,0,0,0,,有两种方法可以在这两个节点之间移动 所以它不是一棵树
Dialogue: 0,0:43:05.46,0:43:09.72,英文,,0,0,0,,So, tree, tree, tree, not a tree, not a tree.
Dialogue: 0,0:43:05.46,0:43:09.72,中文,,0,0,0,,树 树 树 不是一棵树 不是一棵树
Dialogue: 0,0:43:09.72,0:43:10.74,英文,,0,0,0,,Someone said, don't slow down.
Dialogue: 0,0:43:09.72,0:43:10.74,中文,,0,0,0,,有人说 不要减速
Dialogue: 0,0:43:10.74,0:43:13.44,英文,,0,0,0,,OK, I'll go faster.
Dialogue: 0,0:43:10.74,0:43:13.44,中文,,0,0,0,,我会加速
Dialogue: 0,0:43:13.44,0:43:15.88,英文,,0,0,0,,OK, so that's a tree.
Dialogue: 0,0:43:13.44,0:43:15.88,中文,,0,0,0,,那就是一棵树
Dialogue: 0,0:43:15.88,0:43:18.38,英文,,0,0,0,,Now I'm going to introduce the idea of a rooted tree.
Dialogue: 0,0:43:15.88,0:43:18.38,中文,,0,0,0,,现在我要介绍一下有根树的概念
Dialogue: 0,0:43:18.38,0:43:19.50,英文,,0,0,0,,So what's a rooted tree?
Dialogue: 0,0:43:18.38,0:43:19.50,中文,,0,0,0,,那么什么是有根树呢
Dialogue: 0,0:43:19.50,0:43:21.79,英文,,0,0,0,,Well, a rooted tree is just a tree.
Dialogue: 0,0:43:19.50,0:43:21.79,中文,,0,0,0,,有根树就是一棵树
Dialogue: 0,0:43:21.79,0:43:22.83,英文,,0,0,0,,There's no difference.
Dialogue: 0,0:43:21.79,0:43:22.83,中文,,0,0,0,,没有区别
Dialogue: 0,0:43:22.83,0:43:27.91,英文,,0,0,0,,However, I'm going to specifically pick one node, and I'm going to make it the root.
Dialogue: 0,0:43:22.83,0:43:27.91,中文,,0,0,0,,不过 我要特别选择一个节点 然后我会让它成为根节点
Dialogue: 0,0:43:27.91,0:43:32.45,英文,,0,0,0,,So I'm going to pick any node that I like, and I'm going to promote it and say, you're the root.
Dialogue: 0,0:43:27.91,0:43:32.45,中文,,0,0,0,,我会选择任何我喜欢的节点 然后提升它 说 你就是根
Dialogue: 0,0:43:32.45,0:43:34.36,英文,,0,0,0,,I have not done anything special with the tree.
Dialogue: 0,0:43:32.45,0:43:34.36,中文,,0,0,0,,我对树没有做任何特殊的处理
Dialogue: 0,0:43:34.36,0:43:36.70,英文,,0,0,0,,I have not changed the way that the tree is built.
Dialogue: 0,0:43:34.36,0:43:36.70,中文,,0,0,0,,我没有改变树的构建方式
Dialogue: 0,0:43:36.70,0:43:40.62,英文,,0,0,0,,But I have chosen a node and said, you're the root.
Dialogue: 0,0:43:36.70,0:43:40.62,中文,,0,0,0,,但我选择了一个节点并说 你就是根
Dialogue: 0,0:43:40.62,0:43:45.65,英文,,0,0,0,,And then I pick up the tree by its root, and I shake it, and all the other nodes kind of fall down below the root.
Dialogue: 0,0:43:40.62,0:43:45.65,中文,,0,0,0,,然后我用根把整棵树摇晃 其他节点就都从根下面掉下来
Dialogue: 0,0:43:45.65,0:43:48.11,英文,,0,0,0,,And I get structures that look like this.
Dialogue: 0,0:43:45.65,0:43:48.11,中文,,0,0,0,,然后我得到这样的结构
Dialogue: 0,0:43:48.11,0:43:55.33,英文,,0,0,0,,So if I define a node to be the root, and there's nothing special about this node, I just picked any node that I felt like, and I said, you're the root.
Dialogue: 0,0:43:48.11,0:43:55.33,中文,,0,0,0,,如果我定义一个节点为根 对这个节点没有什么特殊要求 我只是随便选了一个节点说 你就是根
Dialogue: 0,0:43:55.33,0:43:57.21,英文,,0,0,0,,Then I can define some extra terms.
Dialogue: 0,0:43:55.33,0:43:57.21,中文,,0,0,0,,那么我可以定义一些额外的术语
Dialogue: 0,0:43:57.21,0:44:02.32,英文,,0,0,0,,For example, now I can define that nodes have parents.
Dialogue: 0,0:43:57.21,0:44:02.32,中文,,0,0,0,,举个例子 现在我可以定义节点有父节点
Dialogue: 0,0:44:02.32,0:44:03.26,英文,,0,0,0,,What's a parent?
Dialogue: 0,0:44:02.32,0:44:03.26,中文,,0,0,0,,什么是父节点呢
Dialogue: 0,0:44:03.26,0:44:06.72,英文,,0,0,0,,Well, parent is the first node on the path to the root.
Dialogue: 0,0:44:03.26,0:44:06.72,中文,,0,0,0,,父节点就是通往根节点路径上的第一个节点
Dialogue: 0,0:44:06.72,0:44:10.16,英文,,0,0,0,,So for example, C. So let's say here's a tree.
Dialogue: 0,0:44:06.72,0:44:10.16,中文,,0,0,0,,例如 C 那么假设这是一棵树
Dialogue: 0,0:44:10.16,0:44:13.24,英文,,0,0,0,,It's a rooted tree, because I've defined A to be the root.
Dialogue: 0,0:44:10.16,0:44:13.24,中文,,0,0,0,,这是一棵有根树 因为我已经定义了A为根
Dialogue: 0,0:44:13.24,0:44:14.68,英文,,0,0,0,,So I said, A, you're the root.
Dialogue: 0,0:44:13.24,0:44:14.68,中文,,0,0,0,,我说 A 你是根
Dialogue: 0,0:44:14.68,0:44:21.00,英文,,0,0,0,,I picked up the tree by A, and I shook it, and all the other nodes fell down below A. And I said, C, who is your parent?
Dialogue: 0,0:44:14.68,0:44:21.00,中文,,0,0,0,,我把树拎起来 抖了抖 所有其他节点都掉到A下面 然后我说 C 你的父节点是谁
Dialogue: 0,0:44:21.00,0:44:27.89,英文,,0,0,0,,Well, from the picture, it seems intuitive to say it's B. But you can also use the definition and say, well, B is the parent.
Dialogue: 0,0:44:21.00,0:44:27.89,中文,,0,0,0,,从图片上看 直觉上会说是B 但你也可以用定义来说 B是父节点
Dialogue: 0,0:44:27.89,0:44:29.01,英文,,0,0,0,,How do I know that?
Dialogue: 0,0:44:27.89,0:44:29.01,中文,,0,0,0,,我怎么知道
Dialogue: 0,0:44:29.01,0:44:32.73,英文,,0,0,0,,Because on the path from C to A,
Dialogue: 0,0:44:29.01,0:44:32.73,中文,,0,0,0,,因为从C到A的路径上
Dialogue: 0,0:44:32.73,0:44:35.45,英文,,0,0,0,,B is the first node on the way to the root.
Dialogue: 0,0:44:32.73,0:44:35.45,中文,,0,0,0,,B是通往根的第一个节点
Dialogue: 0,0:44:35.45,0:44:38.41,英文,,0,0,0,,So that's another way to show that B is C's parent.
Dialogue: 0,0:44:35.45,0:44:38.41,中文,,0,0,0,,这是另一种表明B是C的父节点的方法
Dialogue: 0,0:44:38.41,0:44:40.77,英文,,0,0,0,,OK, so what's a root of a tree?
Dialogue: 0,0:44:38.41,0:44:40.77,中文,,0,0,0,,那么树的根是什么
Dialogue: 0,0:44:40.77,0:44:41.71,英文,,0,0,0,,I take a tree.
Dialogue: 0,0:44:40.77,0:44:41.71,中文,,0,0,0,,我来举个树的例子
Dialogue: 0,0:44:41.71,0:44:43.13,英文,,0,0,0,,I pick a node to be the root.
Dialogue: 0,0:44:41.71,0:44:43.13,中文,,0,0,0,,我选择一个节点作为根节点
Dialogue: 0,0:44:43.13,0:44:45.71,英文,,0,0,0,,I shake the tree by its node of the root node.
Dialogue: 0,0:44:43.13,0:44:45.71,中文,,0,0,0,,我通过根节点的节点摇晃树
Dialogue: 0,0:44:45.71,0:44:47.53,英文,,0,0,0,,All the other nodes fall down below it.
Dialogue: 0,0:44:45.71,0:44:47.53,中文,,0,0,0,,所有其他节点都在它下面掉下来
Dialogue: 0,0:44:47.53,0:44:49.65,英文,,0,0,0,,And now I can define things like parents.
Dialogue: 0,0:44:47.53,0:44:49.65,中文,,0,0,0,,现在我可以定义像父母这样的东西
Dialogue: 0,0:44:49.65,0:44:51.22,英文,,0,0,0,,I can also define child.
Dialogue: 0,0:44:49.65,0:44:51.22,中文,,0,0,0,,我还可以定义孩子
Dialogue: 0,0:44:51.22,0:44:58.20,英文,,0,0,0,,So in this case, B's children, further away from the root, are C, C, and C. I can also define leaves.
Dialogue: 0,0:44:51.22,0:44:58.20,中文,,0,0,0,,在这种情况下 离根节点更远的B的孩子是C C和C 我还可以定义叶子
Dialogue: 0,0:44:58.20,0:45:01.65,英文,,0,0,0,,And a leaf is like C. It has no children.
Dialogue: 0,0:44:58.20,0:45:01.65,中文,,0,0,0,,而叶子就像C 它没有孩子
Dialogue: 0,0:45:01.65,0:45:08.31,英文,,0,0,0,,And the reason why this works, by the way, just really quick aside, is that we know from before there's only one unique path to the root.
Dialogue: 0,0:45:01.65,0:45:08.31,中文,,0,0,0,,顺便说一句 这个方法之所以有效是因为我们之前知道到根节点只有一条唯一的路径
Dialogue: 0,0:45:08.31,0:45:11.69,英文,,0,0,0,,If there were two paths to the root, it would not be a tree.
Dialogue: 0,0:45:08.31,0:45:11.69,中文,,0,0,0,,如果有两条路径通向根节点 那就不是树了
Dialogue: 0,0:45:11.69,0:45:16.05,英文,,0,0,0,,So I know for a fact there's always one unique parent.
Dialogue: 0,0:45:11.69,0:45:16.05,中文,,0,0,0,,我确切地知道总会有一个唯一的父节点
Dialogue: 0,0:45:16.05,0:45:24.75,英文,,0,0,0,,And the reason why I know there's one unique parent is because I know there's only one path to the root, and the parent is the first node that I find on my way climbing to the root.
Dialogue: 0,0:45:16.05,0:45:24.75,中文,,0,0,0,,而我知道有一个唯一的父节点的原因是因为我知道到根节点只有一条路径 而父节点是我在往上爬到根节点时找到的第一个节点
Dialogue: 0,0:45:24.75,0:45:26.75,英文,,0,0,0,,OK, final definition.
Dialogue: 0,0:45:24.75,0:45:26.75,中文,,0,0,0,,最后的定义
Dialogue: 0,0:45:26.75,0:45:28.90,英文,,0,0,0,,Sorry, I know it's getting tedious.
Dialogue: 0,0:45:26.75,0:45:28.90,中文,,0,0,0,,抱歉 我知道这变得有点乏味了
Dialogue: 0,0:45:28.90,0:45:32.48,英文,,0,0,0,,I can also define something called a rooted binary tree.
Dialogue: 0,0:45:28.90,0:45:32.48,中文,,0,0,0,,我还可以定义一种叫做有根二叉树的东西
Dialogue: 0,0:45:32.48,0:45:35.58,英文,,0,0,0,,So in this case, it's still a rooted tree, still a tree.
Dialogue: 0,0:45:32.48,0:45:35.58,中文,,0,0,0,,在这种情况下 它仍然是一棵有根树 仍然是一棵树
Dialogue: 0,0:45:35.58,0:45:37.50,英文,,0,0,0,,I still picked a node to be the root.
Dialogue: 0,0:45:35.58,0:45:37.50,中文,,0,0,0,,我仍然选择了一个节点作为根节点
Dialogue: 0,0:45:37.50,0:45:44.85,英文,,0,0,0,,But when I say a rooted binary tree, what I'm doing is I'm also enforcing that every node either has 0, 1, or 2 children.
Dialogue: 0,0:45:37.50,0:45:44.85,中文,,0,0,0,,但当我说一棵有根的二叉树时 我所做的是强制每个节点都有0、1或2个子节点
Dialogue: 0,0:45:44.85,0:45:49.73,英文,,0,0,0,,So for example, this is a rooted binary tree because every node has one child.
Dialogue: 0,0:45:44.85,0:45:49.73,中文,,0,0,0,,例如 这是一棵有根的二叉树 因为每个节点都有一个子节点
Dialogue: 0,0:45:49.73,0:45:55.75,英文,,0,0,0,,This is not a binary tree because B has three children, and that's too many.
Dialogue: 0,0:45:49.73,0:45:55.75,中文,,0,0,0,,这不是一棵二叉树 因为B有三个子节点 那太多了
Dialogue: 0,0:45:55.75,0:45:58.30,英文,,0,0,0,,So what's a binary search tree then?
Dialogue: 0,0:45:55.75,0:45:58.30,中文,,0,0,0,,那么什么是二叉搜索树呢
Dialogue: 0,0:45:58.30,0:46:07.30,英文,,0,0,0,,Well, we've already seen the intuitive picture, but just to clearly define it so we all know what's going on, a binary search tree, it is a rooted binary tree.
Dialogue: 0,0:45:58.30,0:46:07.30,中文,,0,0,0,,好吧 我们已经看过直观的图片 但只是为了清晰地定义它 让我们都知道发生了什么 二叉搜索树 它是一棵有根的二叉树
Dialogue: 0,0:46:07.30,0:46:08.78,英文,,0,0,0,,So it's got to be a tree.
Dialogue: 0,0:46:07.30,0:46:08.78,中文,,0,0,0,,它一定是一棵树
Dialogue: 0,0:46:08.78,0:46:09.94,英文,,0,0,0,,We know what a tree is.
Dialogue: 0,0:46:08.78,0:46:09.94,中文,,0,0,0,,我们知道树是什么
Dialogue: 0,0:46:09.94,0:46:10.94,英文,,0,0,0,,It's got to be rooted.
Dialogue: 0,0:46:09.94,0:46:10.94,中文,,0,0,0,,它必须有根
Dialogue: 0,0:46:10.94,0:46:15.13,英文,,0,0,0,,You have to pick a node to be the root, and everyone else has to fall down below the root.
Dialogue: 0,0:46:10.94,0:46:15.13,中文,,0,0,0,,你必须选择一个节点作为根节点 其他所有节点都必须在根节点下面
Dialogue: 0,0:46:15.13,0:46:19.15,英文,,0,0,0,,And it has to be binary, so every node has to have at most two children.
Dialogue: 0,0:46:15.13,0:46:19.15,中文,,0,0,0,,而且它必须是二叉的 所以每个节点最多只能有两个子节点
Dialogue: 0,0:46:19.15,0:46:22.39,英文,,0,0,0,,Could have one, could have zero, but at most two.
Dialogue: 0,0:46:19.15,0:46:22.39,中文,,0,0,0,,可能有一个 可能没有 但最多两个
Dialogue: 0,0:46:22.39,0:46:27.69,英文,,0,0,0,,And the final thing that binary search trees must obey is the BST property.
Dialogue: 0,0:46:22.39,0:46:27.69,中文,,0,0,0,,二叉搜索树必须遵守的最后一件事是BST属性
Dialogue: 0,0:46:27.69,0:46:36.03,英文,,0,0,0,,And it's something that you kind of already feel, but just to make it very explicit, the BST property says, if you turn left,
Dialogue: 0,0:46:27.69,0:46:36.03,中文,,0,0,0,,其实你已经有这种感觉了 但为了更明确地说明 BST属性表明 如果你向左转
Dialogue: 0,0:46:36.03,0:46:46.22,英文,,0,0,0,,All the keys, all the items in the left subtree are less than x, and all the items in the right subtree are greater than x. And this is a recursive data structure.
Dialogue: 0,0:46:36.03,0:46:46.22,中文,,0,0,0,,左子树中的所有键 所有项目都小于x 而右子树中的所有项目都大于x 这是一种递归的数据结构
Dialogue: 0,0:46:46.22,0:46:52.34,英文,,0,0,0,,So bag is also a binary search tree with two children, and it obeys the BST property.
Dialogue: 0,0:46:46.22,0:46:52.34,中文,,0,0,0,,因此 bag也是一棵有两个孩子的二叉搜索树 并且遵循BST属性
Dialogue: 0,0:46:52.34,0:46:55.46,英文,,0,0,0,,However, if you look at this one on the right, depth
Dialogue: 0,0:46:52.34,0:46:55.46,中文,,0,0,0,,但是 如果你看看右边这个 深度
Dialogue: 0,0:46:55.46,0:46:59.04,英文,,0,0,0,,or the BST rooted at depth is not a binary search tree.
Dialogue: 0,0:46:55.46,0:46:59.04,中文,,0,0,0,,或者以深度为根的BST不是一棵二叉搜索树
Dialogue: 0,0:46:59.04,0:47:02.63,英文,,0,0,0,,Because ears is greater than depth, that's OK.
Dialogue: 0,0:46:59.04,0:47:02.63,中文,,0,0,0,,因为ears大于depth 这是可以的
Dialogue: 0,0:47:02.63,0:47:05.01,英文,,0,0,0,,But fish is not greater than ears.
Dialogue: 0,0:47:02.63,0:47:05.01,中文,,0,0,0,,但fish不大于ears
Dialogue: 0,0:47:05.01,0:47:08.09,英文,,0,0,0,,Fish should be to the right of ears, but it's on the left.
Dialogue: 0,0:47:05.01,0:47:08.09,中文,,0,0,0,,鱼应该在耳朵的右边 但它在左边
Dialogue: 0,0:47:08.09,0:47:09.05,英文,,0,0,0,,That's no good.
Dialogue: 0,0:47:08.09,0:47:09.05,中文,,0,0,0,,那不行
Dialogue: 0,0:47:09.05,0:47:12.42,英文,,0,0,0,,So it does not obey the binary search property.
Dialogue: 0,0:47:09.05,0:47:12.42,中文,,0,0,0,,它不遵守二分搜索的属性
Dialogue: 0,0:47:12.42,0:47:20.23,英文,,0,0,0,,OK, question.
Dialogue: 0,0:47:12.42,0:47:20.23,中文,,0,0,0,,问题
Dialogue: 0,0:47:20.23,0:47:24.80,英文,,0,0,0,,So I guess the question was, does the BSD property enforce that everyone has two children?
Dialogue: 0,0:47:20.23,0:47:24.80,中文,,0,0,0,,我猜问题是 BSD 属性是否强制每个人都有两个孩子
Dialogue: 0,0:47:24.80,0:47:26.32,英文,,0,0,0,,I don't think it does.
Dialogue: 0,0:47:24.80,0:47:26.32,中文,,0,0,0,,我不认为是这样的
Dialogue: 0,0:47:26.32,0:47:32.73,英文,,0,0,0,,I think the property that does enforce two children is the fact that it's a binary tree.
Dialogue: 0,0:47:26.32,0:47:32.73,中文,,0,0,0,,我认为强制两个孩子的属性是它是一个二叉树
Dialogue: 0,0:47:32.73,0:47:34.67,英文,,0,0,0,,Yeah, but it's more definitions.
Dialogue: 0,0:47:32.73,0:47:34.67,中文,,0,0,0,,是的 但它是更多的定义
Dialogue: 0,0:47:34.67,0:47:36.67,英文,,0,0,0,,OK, great question, though.
Dialogue: 0,0:47:34.67,0:47:36.67,中文,,0,0,0,,不过 问题很棒
Dialogue: 0,0:47:36.67,0:47:38.61,英文,,0,0,0,,OK, that's the BSD property.
Dialogue: 0,0:47:36.67,0:47:38.61,中文,,0,0,0,,那就是BSD属性
Dialogue: 0,0:47:38.61,0:47:41.31,英文,,0,0,0,,If you turn left, expect to see things less than yourself.
Dialogue: 0,0:47:38.61,0:47:41.31,中文,,0,0,0,,如果你向左转 期望看到比自己小的东西
Dialogue: 0,0:47:41.31,0:47:47.08,英文,,0,0,0,,If you turn right, expect to see things greater than yourself.
Dialogue: 0,0:47:41.31,0:47:47.08,中文,,0,0,0,,如果你向右转 期望看到比自己大的东西
Dialogue: 0,0:47:47.08,0:47:52.02,英文,,0,0,0,,Yeah, I guess the BSD property implies left and right, so you kind of have to have two.
Dialogue: 0,0:47:47.08,0:47:52.02,中文,,0,0,0,,是的 我猜BSD属性意味着左和右 所以你必须有两个
Dialogue: 0,0:47:52.02,0:47:53.76,英文,,0,0,0,,Otherwise, there's no left and right.
Dialogue: 0,0:47:52.02,0:47:53.76,中文,,0,0,0,,否则 就没有左和右
Dialogue: 0,0:47:53.76,0:47:55.16,英文,,0,0,0,,OK, food for thought.
Dialogue: 0,0:47:53.76,0:47:55.16,中文,,0,0,0,,值得思考
Dialogue: 0,0:47:55.16,0:48:00.31,英文,,0,0,0,,OK, so another quick note, again, just getting through some definitions.
Dialogue: 0,0:47:55.16,0:48:00.31,中文,,0,0,0,,再说一句 再次强调一下 只是在解释一些定义
Dialogue: 0,0:48:00.31,0:48:06.75,英文,,0,0,0,,If you want to build a binary search tree of items, the items that you're putting in the tree, they must have some order to them.
Dialogue: 0,0:48:00.31,0:48:06.75,中文,,0,0,0,,如果你想构建一个二叉搜索树的话 那么放入树中的这些项 它们必须有某种顺序
Dialogue: 0,0:48:06.75,0:48:10.79,英文,,0,0,0,,Because I've been saying things like greater than x and less than x.
Dialogue: 0,0:48:06.75,0:48:10.79,中文,,0,0,0,,因为我一直在说大于 x 和小于 x 这样的话
Dialogue: 0,0:48:10.79,0:48:12.52,英文,,0,0,0,,So you have to enforce an order.
Dialogue: 0,0:48:10.79,0:48:12.52,中文,,0,0,0,,你必须强制一种顺序
Dialogue: 0,0:48:12.52,0:48:16.26,英文,,0,0,0,,And in particular, here are some rules that will help us enforce order.
Dialogue: 0,0:48:12.52,0:48:16.26,中文,,0,0,0,,而且特别地 这里有一些规则可以帮助我们强制顺序
Dialogue: 0,0:48:16.26,0:48:21.50,英文,,0,0,0,,So for example, if I have two items, P and Q, it must be the case that one of them is greater.
Dialogue: 0,0:48:16.26,0:48:21.50,中文,,0,0,0,,比如说 如果我有两个项 p 和 q 那么它们之间必须有一个大于另一个
Dialogue: 0,0:48:21.50,0:48:24.16,英文,,0,0,0,,Either P is greater or Q is greater.
Dialogue: 0,0:48:21.50,0:48:24.16,中文,,0,0,0,,要么p大于q 要么q大于p
Dialogue: 0,0:48:24.16,0:48:28.03,英文,,0,0,0,,And also, this is another rule that hopefully makes sense to us as humans.
Dialogue: 0,0:48:24.16,0:48:28.03,中文,,0,0,0,,还有 这是另一个规则 希望我们作为人类能理解
Dialogue: 0,0:48:28.03,0:48:38.73,英文,,0,0,0,,If P is less than Q and Q is less than R, hopefully we all agree that P must be less than R. If this is not followed, then your sorts will get super weird and things will kind of fall apart.
Dialogue: 0,0:48:28.03,0:48:38.73,中文,,0,0,0,,如果p小于q且q小于r 希望我们都同意P必须小于r 如果不遵循这个规则 你的排序会变得非常奇怪 事情会有点崩溃
Dialogue: 0,0:48:38.73,0:48:40.85,英文,,0,0,0,,So we want these things to be true.
Dialogue: 0,0:48:38.73,0:48:40.85,中文,,0,0,0,,我们希望这些事情成立
Dialogue: 0,0:48:40.85,0:48:48.98,英文,,0,0,0,,So, for example, I could build a binary search tree of, like, images, but it'd be very weird, because can you really say one image is greater than the other?
Dialogue: 0,0:48:40.85,0:48:48.98,中文,,0,0,0,,例如 我可以构建一个二叉搜索树 像图片这样的东西 但那会很奇怪 因为你真的能说一张图片比另一张更大吗
Dialogue: 0,0:48:48.98,0:48:55.02,英文,,0,0,0,,I don't know, maybe you can, but at least as far as I can tell, there's no obvious way to sort images.
Dialogue: 0,0:48:48.98,0:48:55.02,中文,,0,0,0,,我不知道 也许你可以 但至少据我所知 没有明显的方法来排序图片
Dialogue: 0,0:48:55.02,0:49:01.45,英文,,0,0,0,,However, like words, strings, integers, those are things we can put in order, so it's nice.
Dialogue: 0,0:48:55.02,0:49:01.45,中文,,0,0,0,,然而 像单词、字符串、整数这些东西 我们可以排序 所以这很好
Dialogue: 0,0:49:01.45,0:49:10.76,英文,,0,0,0,,One consequence, by the way, of these rules, because we said between p and q, one of them must be greater, we have to enforce that there are no duplicate keys.
Dialogue: 0,0:49:01.45,0:49:10.76,中文,,0,0,0,,顺便提一下 由于我们说在p和q之间 它们中必须有一个大于另一个 因此我们必须强制执行没有重复的键
Dialogue: 0,0:49:10.76,0:49:14.62,英文,,0,0,0,,So I cannot have two things in the binary search tree called dog.
Dialogue: 0,0:49:10.76,0:49:14.62,中文,,0,0,0,,我不能在二叉搜索树中有两个叫做dog的东西
Dialogue: 0,0:49:14.62,0:49:17.44,英文,,0,0,0,,I can't have two things in the binary search tree called bag.
Dialogue: 0,0:49:14.62,0:49:17.44,中文,,0,0,0,,我不能在二叉搜索树中有两个叫做bag的东西
Dialogue: 0,0:49:17.44,0:49:21.79,英文,,0,0,0,,And you might say, but I really want to have two dogs in my binary search tree.
Dialogue: 0,0:49:17.44,0:49:21.79,中文,,0,0,0,,你可能会说 但我真的想在我的二叉搜索树中有两个dog
Dialogue: 0,0:49:21.79,0:49:26.53,英文,,0,0,0,,Well, you can, but that would be a totally different data structure, not the one we're talking about.
Dialogue: 0,0:49:21.79,0:49:26.53,中文,,0,0,0,,你可以 但那将是一个完全不同的数据结构 不是我们正在讨论的那个
Dialogue: 0,0:49:26.53,0:49:29.65,英文,,0,0,0,,So to keep things simple, we're going to say there are no duplicates.
Dialogue: 0,0:49:26.53,0:49:29.65,中文,,0,0,0,,为了保持简单 我们将说没有重复
Dialogue: 0,0:49:29.65,0:49:32.38,英文,,0,0,0,,If you have one dog in the tree, that's it.
Dialogue: 0,0:49:29.65,0:49:32.38,中文,,0,0,0,,如果你在树中有一只狗 就这样
Dialogue: 0,0:49:32.38,0:49:33.62,英文,,0,0,0,,You can only have one.
Dialogue: 0,0:49:32.38,0:49:33.62,中文,,0,0,0,,你只能有一个
Dialogue: 0,0:49:33.62,0:49:36.87,英文,,0,0,0,,And that's probably OK, because remember, the whole point of building this,
Dialogue: 0,0:49:33.62,0:49:36.87,中文,,0,0,0,,而且这可能没问题 因为记住 建造这个的整个目的
Dialogue: 0,0:49:36.87,0:49:43.05,英文,,0,0,0,,maybe you remember from, I don't know, two minutes ago, the whole point of building this is to implement sets and maps.
Dialogue: 0,0:49:36.87,0:49:43.05,中文,,0,0,0,,也许你还记得刚才两分钟前说的 建造这个的整个目的是为了实现集合和映射
Dialogue: 0,0:49:43.05,0:49:44.29,英文,,0,0,0,,And remember a set?
Dialogue: 0,0:49:43.05,0:49:44.29,中文,,0,0,0,,还记得集合吗
Dialogue: 0,0:49:44.29,0:49:45.51,英文,,0,0,0,,No duplicates.
Dialogue: 0,0:49:44.29,0:49:45.51,中文,,0,0,0,,没有重复的元素
Dialogue: 0,0:49:45.51,0:49:51.13,英文,,0,0,0,,So probably OK that as we're implementing binary search trees, we don't have duplicates.
Dialogue: 0,0:49:45.51,0:49:51.13,中文,,0,0,0,,可能没问题 因为在我们实现二叉搜索树时 我们不允许有重复的元素
Dialogue: 0,0:49:51.13,0:49:52.43,英文,,0,0,0,,It's probably OK.
Dialogue: 0,0:49:51.13,0:49:52.43,中文,,0,0,0,,这可能没问题
Dialogue: 0,0:49:52.43,0:50:00.86,英文,,0,0,0,,OK, just to prove to you how easy binary search trees are, I'm going to talk about the contains algorithm in one minute, because it's that easy.
Dialogue: 0,0:49:52.43,0:50:00.86,中文,,0,0,0,,只是为了向你证明二叉搜索树有多容易 我将在一分钟内讲解包含算法 因为它就是这么简单
Dialogue: 0,0:50:00.86,0:50:03.67,英文,,0,0,0,,OK, that's also an excuse to keep you here for one more minute.
Dialogue: 0,0:50:00.86,0:50:03.67,中文,,0,0,0,,好吧 这也是一个借口让你在这多待一分钟
Dialogue: 0,0:50:03.67,0:50:05.53,英文,,0,0,0,,So here's the algorithm.
Dialogue: 0,0:50:03.67,0:50:05.53,中文,,0,0,0,,这就是算法
Dialogue: 0,0:50:05.53,0:50:07.73,英文,,0,0,0,,All that it is, you start at the root.
Dialogue: 0,0:50:05.53,0:50:07.73,中文,,0,0,0,,所有它就是 你从根开始
Dialogue: 0,0:50:07.73,0:50:12.07,英文,,0,0,0,,If the thing you're looking for is equal, you're looking for dog, you return, you found it.
Dialogue: 0,0:50:07.73,0:50:12.07,中文,,0,0,0,,如果你要找的东西相等 你要找的是狗 你返回 你找到了
Dialogue: 0,0:50:12.07,0:50:16.98,英文,,0,0,0,,Otherwise, if the thing you're looking for is less than dog, go left, search the left subtree.
Dialogue: 0,0:50:12.07,0:50:16.98,中文,,0,0,0,,否则 如果你要找的东西小于狗 向左走 搜索左子树
Dialogue: 0,0:50:16.98,0:50:20.16,英文,,0,0,0,,If it's greater than dog, go right, search the right subtree.
Dialogue: 0,0:50:16.98,0:50:20.16,中文,,0,0,0,,如果它大于狗 向右走 搜索右子树
Dialogue: 0,0:50:20.16,0:50:21.18,英文,,0,0,0,,There's the pseudocode.
Dialogue: 0,0:50:20.16,0:50:21.18,中文,,0,0,0,,这是伪代码
Dialogue: 0,0:50:21.18,0:50:26.83,英文,,0,0,0,,I'm not going to make you read it, but as you're implementing this in lab, hint, hint, you can come back and refer to this.
Dialogue: 0,0:50:21.18,0:50:26.83,中文,,0,0,0,,我不会让你读它 但是当你在实验室实现它时 提示 你可以回来参考一下
Dialogue: 0,0:50:26.83,0:50:27.23,英文,,0,0,0,,See?
Dialogue: 0,0:50:26.83,0:50:27.23,中文,,0,0,0,,明白了吗
Dialogue: 0,0:50:27.23,0:50:28.07,英文,,0,0,0,,It was that easy.
Dialogue: 0,0:50:27.23,0:50:28.07,中文,,0,0,0,,就是这么简单
Dialogue: 0,0:50:28.07,0:50:28.53,英文,,0,0,0,,One minute.
Dialogue: 0,0:50:28.07,0:50:28.53,中文,,0,0,0,,一分钟
Dialogue: 0,0:50:28.53,0:50:30.41,英文,,0,0,0,,So you recursively search.
Dialogue: 0,0:50:28.53,0:50:30.41,中文,,0,0,0,,你进行递归搜索
Dialogue: 0,0:50:30.41,0:50:33.06,英文,,0,0,0,,If the thing you're looking for is less than, you go left.
Dialogue: 0,0:50:30.41,0:50:33.06,中文,,0,0,0,,如果你要找的东西比当前节点小 你就往左走
Dialogue: 0,0:50:33.06,0:50:35.80,英文,,0,0,0,,If the thing you're looking for is greater than, you go right.
Dialogue: 0,0:50:33.06,0:50:35.80,中文,,0,0,0,,如果你要找的东西比当前节点大 你就往右走
Dialogue: 0,0:50:35.80,0:50:39.20,英文,,0,0,0,,And the base case is if you find it or if you fall off the tree.
Dialogue: 0,0:50:35.80,0:50:39.20,中文,,0,0,0,,基本情况是如果你找到它或者你从树上掉下来了
Dialogue: 0,0:50:39.20,0:50:39.60,英文,,0,0,0,,OK.
Dialogue: 0,0:50:39.60,0:50:40.70,英文,,0,0,0,,More on this next time.
Dialogue: 0,0:50:39.60,0:50:40.70,中文,,0,0,0,,下次会更详细介绍
Dialogue: 0,0:50:40.70,0:50:41.41,英文,,0,0,0,,So come back next time.
Dialogue: 0,0:50:40.70,0:50:41.41,中文,,0,0,0,,下次记得回来
Dialogue: 0,0:50:41.41,0:50:42.93,英文,,0,0,0,,We'll finish binary search trees.
Dialogue: 0,0:50:41.41,0:50:42.93,中文,,0,0,0,,我们会完成二叉搜索树
Dialogue: 0,0:50:42.93,0:50:46.17,英文,,0,0,0,,I hope you enjoyed the asymptotics.
Dialogue: 0,0:50:42.93,0:50:46.17,中文,,0,0,0,,希望你喜欢渐近分析
Dialogue: 0,0:50:46.17,0:50:47.17,英文,,0,0,0,,But that's all I got.
Dialogue: 0,0:50:46.17,0:50:47.17,中文,,0,0,0,,但这就是我全部的内容
Dialogue: 0,0:50:47.17,0:50:49.39,英文,,0,0,0,,So we'll see you next time.
Dialogue: 0,0:50:47.17,0:50:49.39,中文,,0,0,0,,那么下次我们就见了
Dialogue: 0,0:50:49.39,0:50:51.99,英文,,0,0,0,,OK.
Dialogue: 0,0:50:51.99,0:50:53.75,英文,,0,0,0,,I mean, we basically got through what I wanted to.
Dialogue: 0,0:50:51.99,0:50:53.75,中文,,0,0,0,,我是说 我们基本上已经完成了我想做的事情
Dialogue: 0,0:50:53.75,0:50:56.80,英文,,0,0,0,,I missed insert, but we can do insert next time.
Dialogue: 0,0:50:53.75,0:50:56.80,中文,,0,0,0,,我错过了插入 但我们下次可以做插入
Dialogue: 0,0:50:56.80,0:50:57.40,英文,,0,0,0,,Insert is quite quick.
Dialogue: 0,0:50:56.80,0:50:57.40,中文,,0,0,0,,插入很快
