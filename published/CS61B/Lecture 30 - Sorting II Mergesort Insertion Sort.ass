[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 3
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Export Encoding: Unicode (UTF-8)
Audio File: D:/python_code/video_tool/video_tool/result/Lecture 02.1 - Number Representation Intro, Bits can be anything.mp4
Video File: D:/python_code/video_tool/video_tool/result/Lecture 02.1 - Number Representation Intro, Bits can be anything.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.375000
Scroll Position: 799
Active Line: 805
Video Position: 8466

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,14,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.33333,1.33333,2,6,6,8,1
Style: 英文,Arial,24,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1.33333,1.33333,2,2,2,6,1
Style: 中文,微软雅黑,38,&H0029EEF1,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1.33333,1.33333,2,2,2,20,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,
Dialogue: 0,0:00:04.81,0:00:10.13,英文,,0,0,0,,I'm going to start talking about sorting.
Dialogue: 0,0:00:04.81,0:00:10.13,中文,,0,0,0,,我要开始讲排序了
Dialogue: 0,0:00:10.13,0:00:13.41,英文,,0,0,0,,OK.
Dialogue: 0,0:00:10.13,0:00:13.41,中文,,0,0,0,,
Dialogue: 0,0:00:13.41,0:00:13.83,英文,,0,0,0,,OK.
Dialogue: 0,0:00:13.41,0:00:13.83,中文,,0,0,0,,好的
Dialogue: 0,0:00:13.83,0:00:16.80,英文,,0,0,0,,Announcements.
Dialogue: 0,0:00:13.83,0:00:16.80,中文,,0,0,0,,通知
Dialogue: 0,0:00:16.80,0:00:22.70,英文,,0,0,0,,How's everyone doing?
Dialogue: 0,0:00:16.80,0:00:22.70,中文,,0,0,0,,大家都好吗？
Dialogue: 0,0:00:22.70,0:00:25.74,英文,,0,0,0,,The midterm was like a week ago.
Dialogue: 0,0:00:22.70,0:00:25.74,中文,,0,0,0,,期中考试好像是一周前的事了
Dialogue: 0,0:00:25.74,0:00:27.96,英文,,0,0,0,,Are you still booing me?
Dialogue: 0,0:00:25.74,0:00:27.96,中文,,0,0,0,,你们还在嘘我吗？
Dialogue: 0,0:00:27.96,0:00:30.18,英文,,0,0,0,,Anyway, what's going on with the class?
Dialogue: 0,0:00:27.96,0:00:30.18,中文,,0,0,0,,总之 这门课进行得怎么样？
Dialogue: 0,0:00:30.18,0:00:31.00,英文,,0,0,0,,Project 2B is due.
Dialogue: 0,0:00:30.18,0:00:31.00,中文,,0,0,0,,Project 2B 要到期了
Dialogue: 0,0:00:31.00,0:00:32.10,英文,,0,0,0,,I don't have the website, though.
Dialogue: 0,0:00:31.00,0:00:32.10,中文,,0,0,0,,但我没有网站
Dialogue: 0,0:00:32.10,0:00:35.08,英文,,0,0,0,,Yeah, get out the website.
Dialogue: 0,0:00:32.10,0:00:35.08,中文,,0,0,0,,是的 把网站弄出来
Dialogue: 0,0:00:35.08,0:00:40.41,英文,,0,0,0,,It's fine.
Dialogue: 0,0:00:35.08,0:00:40.41,中文,,0,0,0,,没关系
Dialogue: 0,0:00:40.41,0:00:41.13,英文,,0,0,0,,Yeah.
Dialogue: 0,0:00:40.41,0:00:41.13,中文,,0,0,0,,是的
Dialogue: 0,0:00:41.13,0:00:45.69,英文,,0,0,0,,Seems like Project 2B and 2C were due Monday.
Dialogue: 0,0:00:41.13,0:00:45.69,中文,,0,0,0,,Project 2B 和 2C 似乎周一就要到期了
Dialogue: 0,0:00:45.69,0:00:51.73,英文,,0,0,0,,So if you're on extensions, I guess it's coming up now.
Dialogue: 0,0:00:45.69,0:00:51.73,中文,,0,0,0,,如果你们延期了 我猜现在就快到期了
Dialogue: 0,0:00:51.73,0:00:53.94,英文,,0,0,0,,Other than that, Project 3 is getting started.
Dialogue: 0,0:00:51.73,0:00:53.94,中文,,0,0,0,,除此之外 Project 3 就要开始了
Dialogue: 0,0:00:53.94,0:00:57.48,英文,,0,0,0,,It's a great project to work on.
Dialogue: 0,0:00:53.94,0:00:57.48,中文,,0,0,0,,这是一个很棒的项目
Dialogue: 0,0:00:57.48,0:00:58.76,英文,,0,0,0,,One last thing.
Dialogue: 0,0:00:57.48,0:00:58.76,中文,,0,0,0,,最后一件事
Dialogue: 0,0:00:58.76,0:01:03.27,英文,,0,0,0,,We do have our second software engineering lecture running this Friday.
Dialogue: 0,0:00:58.76,0:01:03.27,中文,,0,0,0,,我们第二次软件工程讲座将于本周五举行
Dialogue: 0,0:01:03.27,0:01:05.27,英文,,0,0,0,,I'm unfortunately not going to be here.
Dialogue: 0,0:01:03.27,0:01:05.27,中文,,0,0,0,,不幸的是 我不能来
Dialogue: 0,0:01:05.27,0:01:06.87,英文,,0,0,0,,I'm flying out to St.
Dialogue: 0,0:01:05.27,0:01:06.87,中文,,0,0,0,,我要飞去圣路易斯看日食
Dialogue: 0,0:01:06.87,0:01:08.27,英文,,0,0,0,,Louis for the Eclipse.
Dialogue: 0,0:01:06.87,0:01:08.27,中文,,0,0,0,,有趣
Dialogue: 0,0:01:08.27,0:01:11.12,英文,,0,0,0,,Fun.
Dialogue: 0,0:01:08.27,0:01:11.12,中文,,0,0,0,,有趣
Dialogue: 0,0:01:11.12,0:01:15.69,英文,,0,0,0,,So yeah, Perrin's going to be around to monitor the situation.
Dialogue: 0,0:01:11.12,0:01:15.69,中文,,0,0,0,,PerriN 会来监控情况
Dialogue: 0,0:01:15.69,0:01:25.01,英文,,0,0,0,,We'll have our guest lecturers come up and talk a bit more about how Project 3 works and how you can work in a team most effectively.
Dialogue: 0,0:01:15.69,0:01:25.01,中文,,0,0,0,,我们将邀请客座讲师来谈谈 Project 3 是如何运作的 以及如何在团队中高效工作
Dialogue: 0,0:01:25.01,0:01:28.94,英文,,0,0,0,,Sounds good.
Dialogue: 0,0:01:25.01,0:01:28.94,中文,,0,0,0,,听起来不错
Dialogue: 0,0:01:28.94,0:01:33.12,英文,,0,0,0,,For people on recording, we do that every day, but this is the first time you've seen it on tape.
Dialogue: 0,0:01:28.94,0:01:33.12,中文,,0,0,0,,对于观看录音的人来说 我们每天都这样做 但这是你们第一次在录像中看到它
Dialogue: 0,0:01:33.12,0:01:36.99,英文,,0,0,0,,OK, let's talk about more sorting.
Dialogue: 0,0:01:33.12,0:01:36.99,中文,,0,0,0,,好的 让我们来谈谈更多关于排序的内容
Dialogue: 0,0:01:36.99,0:01:43.29,英文,,0,0,0,,So you've seen two sort algorithms so far, selection sort and heap sort.
Dialogue: 0,0:01:36.99,0:01:43.29,中文,,0,0,0,,到目前为止 你们已经看到了两种排序算法 选择排序和堆排序
Dialogue: 0,0:01:43.29,0:01:48.90,英文,,0,0,0,,And today, I will show you two and maybe three, if time permits, sorts.
Dialogue: 0,0:01:43.29,0:01:48.90,中文,,0,0,0,,今天 我将向你们展示两种 如果时间允许的话 三种排序算法
Dialogue: 0,0:01:48.90,0:01:50.82,英文,,0,0,0,,So I hope everyone's ready.
Dialogue: 0,0:01:48.90,0:01:50.82,中文,,0,0,0,,我希望大家都准备好了
Dialogue: 0,0:01:50.82,0:01:52.05,英文,,0,0,0,,OK.
Dialogue: 0,0:01:50.82,0:01:52.05,中文,,0,0,0,,
Dialogue: 0,0:01:52.05,0:01:56.89,英文,,0,0,0,,So before I talk about Merge Sort, I will quickly show you Selection Sort.
Dialogue: 0,0:01:52.05,0:01:56.89,中文,,0,0,0,,在我讲合并排序之前 我将快速向你们展示选择排序
Dialogue: 0,0:01:56.89,0:02:03.89,英文,,0,0,0,,And remember, Selection Sort, the way it worked was I had an array, and I repeatedly find the smallest item, swapped it to the front.
Dialogue: 0,0:01:56.89,0:02:03.89,中文,,0,0,0,,记住 选择排序的工作方式是我有一个数组 我反复找到最小的元素 把它交换到前面
Dialogue: 0,0:02:03.89,0:02:10.12,英文,,0,0,0,,And when I swapped it to the front, I knew that was its true place, and I could fix it, and I never had to move it again.
Dialogue: 0,0:02:03.89,0:02:10.12,中文,,0,0,0,,当我把它交换到前面时 我知道那是它真正的位置 我可以修复它 而且我再也不用移动它了
Dialogue: 0,0:02:10.12,0:02:14.34,英文,,0,0,0,,And then I could sort the remaining unfixed items.
Dialogue: 0,0:02:10.12,0:02:14.34,中文,,0,0,0,,然后我可以对剩下的未修复的元素进行排序
Dialogue: 0,0:02:14.34,0:02:22.63,英文,,0,0,0,,And we also saw that this is n squared runtime, because, well, at the first step, I have to scan n things to find the smallest item.
Dialogue: 0,0:02:14.34,0:02:22.63,中文,,0,0,0,,我们也看到这是 N^2运行时间 因为 嗯 在第一步 我必须扫描 N 个元素才能找到最小的元素
Dialogue: 0,0:02:22.63,0:02:26.27,英文,,0,0,0,,Then I have to scan n minus 1 things to find the smallest item.
Dialogue: 0,0:02:22.63,0:02:26.27,中文,,0,0,0,,然后我必须扫描 N-1 个元素才能找到最小的元素
Dialogue: 0,0:02:26.27,0:02:28.27,英文,,0,0,0,,Then I have to scan n over 2 things.
Dialogue: 0,0:02:26.27,0:02:28.27,中文,,0,0,0,,然后我必须扫描 N 除以 2 个元素
Dialogue: 0,0:02:28.27,0:02:35.88,英文,,0,0,0,,And if I add that all up, well, that ends up being an n squared sum, or theta of n squared.
Dialogue: 0,0:02:28.27,0:02:35.88,中文,,0,0,0,,如果我把这些都加起来 嗯 那最终就会是一个 N^2和 或者说是 θ(N^2)
Dialogue: 0,0:02:35.88,0:02:44.27,英文,,0,0,0,,OK, so here I'm going to introduce something that's a little bit maybe vague, but hopefully helps us with our intuition.
Dialogue: 0,0:02:35.88,0:02:44.27,中文,,0,0,0,,好的 所以在这里我要介绍一些可能有点模糊的东西 但希望能帮助我们建立直觉
Dialogue: 0,0:02:44.27,0:02:53.83,英文,,0,0,0,,So if I say that this runtime is theta of n squared, then I could roughly say, it's not an exact count, but I could maybe roughly say that
Dialogue: 0,0:02:44.27,0:02:53.83,中文,,0,0,0,,如果我说这个运行时间是 θ(N^2) 那么我可以粗略地说 这不是一个精确的计数 但我可以粗略地说
Dialogue: 0,0:02:53.83,0:03:02.83,英文,,0,0,0,,if I had an input size of size 64, well, then I could say the rough runtime is 4,096 arbitrary units of time.
Dialogue: 0,0:02:53.83,0:03:02.83,中文,,0,0,0,,如果我有一个大小为 64 的输入 嗯 那么我可以说运行时间大约是 4096 个任意时间单位
Dialogue: 0,0:03:02.83,0:03:05.39,英文,,0,0,0,,And that number is 64 squared.
Dialogue: 0,0:03:02.83,0:03:05.39,中文,,0,0,0,,这个数字是 64 的平方
Dialogue: 0,0:03:05.39,0:03:18.34,英文,,0,0,0,,So it's kind of a guess, but If I'm saying that the algorithm is n squared, then I could maybe say, if the size of the input is 64, then my runtime is approximately 64 squared.
Dialogue: 0,0:03:05.39,0:03:18.34,中文,,0,0,0,,这是一种猜测 但是如果我说算法是 N^2 那么我可能会说 如果输入的大小是 64 那么我的运行时间大约是 64 的平方
Dialogue: 0,0:03:18.34,0:03:23.38,英文,,0,0,0,,It's not perfect, but it's good enough for the analysis that we're about to do.
Dialogue: 0,0:03:18.34,0:03:23.38,中文,,0,0,0,,它并不完美 但对于我们即将进行的分析来说已经足够好了
Dialogue: 0,0:03:23.38,0:03:25.21,英文,,0,0,0,,OK.
Dialogue: 0,0:03:23.38,0:03:25.21,中文,,0,0,0,,
Dialogue: 0,0:03:25.21,0:03:25.73,英文,,0,0,0,,Good.
Dialogue: 0,0:03:25.21,0:03:25.73,中文,,0,0,0,,好的
Dialogue: 0,0:03:25.73,0:03:28.40,英文,,0,0,0,,So that's the first prelude to merge sort.
Dialogue: 0,0:03:25.73,0:03:28.40,中文,,0,0,0,,这就是归并排序的第一个前奏
Dialogue: 0,0:03:28.40,0:03:29.76,英文,,0,0,0,,We remember selection sort.
Dialogue: 0,0:03:28.40,0:03:29.76,中文,,0,0,0,,我们记得选择排序
Dialogue: 0,0:03:29.76,0:03:31.20,英文,,0,0,0,,We remember its runtime.
Dialogue: 0,0:03:29.76,0:03:31.20,中文,,0,0,0,,我们记得它的运行时间
Dialogue: 0,0:03:31.20,0:03:39.00,英文,,0,0,0,,And we also found out that if you want to, you can kind of approximate how long it takes by substituting in specific numbers.
Dialogue: 0,0:03:31.20,0:03:39.00,中文,,0,0,0,,而且我们还发现 如果你想的话 你可以通过代入特定的数字来近似地计算它需要多长时间
Dialogue: 0,0:03:39.00,0:03:41.51,英文,,0,0,0,,And that's just for the purpose of seeing the analysis.
Dialogue: 0,0:03:39.00,0:03:41.51,中文,,0,0,0,,这只是为了看分析
Dialogue: 0,0:03:41.51,0:03:43.75,英文,,0,0,0,,That's not an exact counter or anything.
Dialogue: 0,0:03:41.51,0:03:43.75,中文,,0,0,0,,那不是一个精确的计数器或任何东西
Dialogue: 0,0:03:43.75,0:03:45.17,英文,,0,0,0,,OK.
Dialogue: 0,0:03:43.75,0:03:45.17,中文,,0,0,0,,
Dialogue: 0,0:03:45.17,0:03:51.45,英文,,0,0,0,,The second thing you have to see before I can fully present merge sort is an operation called merging.
Dialogue: 0,0:03:45.17,0:03:51.45,中文,,0,0,0,,在我完整介绍归并排序之前 你必须看到的第二件事是一个叫做合并的操作
Dialogue: 0,0:03:51.45,0:03:54.41,英文,,0,0,0,,So the operation merging is as follows.
Dialogue: 0,0:03:51.45,0:03:54.41,中文,,0,0,0,,所以合并操作如下
Dialogue: 0,0:03:54.41,0:03:56.81,英文,,0,0,0,,Let's say I give you two sorted arrays.
Dialogue: 0,0:03:54.41,0:03:56.81,中文,,0,0,0,,假设我给你两个排序数组
Dialogue: 0,0:03:56.81,0:03:59.04,英文,,0,0,0,,They're completely separate, and each one is sorted.
Dialogue: 0,0:03:56.81,0:03:59.04,中文,,0,0,0,,它们是完全分开的 每个都是排序好的
Dialogue: 0,0:03:59.04,0:04:03.76,英文,,0,0,0,,And I want you to combine them into one really big sorted array.
Dialogue: 0,0:03:59.04,0:04:03.76,中文,,0,0,0,,我想让你把它们合并成一个非常大的排序数组
Dialogue: 0,0:04:03.76,0:04:12.66,英文,,0,0,0,,So the question for you is, how do I take those two arrays and merge them together into a really big array, knowing that both of the two input arrays are sorted?
Dialogue: 0,0:04:03.76,0:04:12.66,中文,,0,0,0,,你的问题是 我怎么把这两个数组合并成一个非常大的数组 要知道这两个输入数组都是排序好的？
Dialogue: 0,0:04:12.66,0:04:15.15,英文,,0,0,0,,Also, how do I get that stupid zoom
Dialogue: 0,0:04:12.66,0:04:15.15,中文,,0,0,0,,还有 我怎么才能把那个愚蠢的缩放弄好
Dialogue: 0,0:04:15.15,0:04:21.91,英文,,0,0,0,,OK, well, we're working on it.
Dialogue: 0,0:04:15.15,0:04:21.91,中文,,0,0,0,,好的 好吧 我们正在努力
Dialogue: 0,0:04:21.91,0:04:24.55,英文,,0,0,0,,I guess let's go find a demo for merging.
Dialogue: 0,0:04:21.91,0:04:24.55,中文,,0,0,0,,我想我们去找一个合并的演示
Dialogue: 0,0:04:24.55,0:04:26.49,英文,,0,0,0,,Oh, I forgot I linked to an external demo.
Dialogue: 0,0:04:24.55,0:04:26.49,中文,,0,0,0,,哦 我忘了我链接到一个外部演示
Dialogue: 0,0:04:26.49,0:04:28.83,英文,,0,0,0,,OK, well, here's the demo for merging.
Dialogue: 0,0:04:26.49,0:04:28.83,中文,,0,0,0,,好的 好吧 这是合并的演示
Dialogue: 0,0:04:28.83,0:04:30.17,英文,,0,0,0,,So I have two arrays.
Dialogue: 0,0:04:28.83,0:04:30.17,中文,,0,0,0,,我有两个数组
Dialogue: 0,0:04:30.17,0:04:31.79,英文,,0,0,0,,Both of them are sorted.
Dialogue: 0,0:04:30.17,0:04:31.79,中文,,0,0,0,,它们都是排序好的
Dialogue: 0,0:04:31.79,0:04:38.76,英文,,0,0,0,,And my goal is to create one large array containing all the same elements that's also sorted.
Dialogue: 0,0:04:31.79,0:04:38.76,中文,,0,0,0,,我的目标是创建一个包含所有相同元素的大数组 它也是排序好的
Dialogue: 0,0:04:38.76,0:04:40.04,英文,,0,0,0,,So here's the algorithm.
Dialogue: 0,0:04:38.76,0:04:40.04,中文,,0,0,0,,这就是算法
Dialogue: 0,0:04:40.04,0:04:45.90,英文,,0,0,0,,It's kind of what you'd expect, which is I will look at the smallest item in the first two arrays.
Dialogue: 0,0:04:40.04,0:04:45.90,中文,,0,0,0,,这有点像你所期望的 也就是我将查看前两个数组中最小的项
Dialogue: 0,0:04:45.90,0:04:47.86,英文,,0,0,0,,or in the only two arrays, I guess.
Dialogue: 0,0:04:45.90,0:04:47.86,中文,,0,0,0,,或者说 我猜是在仅有的两个数组中
Dialogue: 0,0:04:47.86,0:04:50.27,英文,,0,0,0,,And well, where do I know what the smallest item is?
Dialogue: 0,0:04:47.86,0:04:50.27,中文,,0,0,0,,那么 我知道最小的项在哪里？
Dialogue: 0,0:04:50.27,0:04:52.11,英文,,0,0,0,,It's at the front, because they're sorted.
Dialogue: 0,0:04:50.27,0:04:52.11,中文,,0,0,0,,它在最前面 因为它们是排序好的
Dialogue: 0,0:04:52.11,0:04:57.41,英文,,0,0,0,,So 2 and 4, which one should I copy into the big, gigantic array first?
Dialogue: 0,0:04:52.11,0:04:57.41,中文,,0,0,0,,那么2和4 我应该先把哪个复制到那个巨大无比的数组中？
Dialogue: 0,0:04:57.41,0:04:59.45,英文,,0,0,0,,Well, 2, because it's smaller.
Dialogue: 0,0:04:57.41,0:04:59.45,中文,,0,0,0,,嗯 2 因为它比较小
Dialogue: 0,0:04:59.45,0:05:01.03,英文,,0,0,0,,So I copy the 2 over.
Dialogue: 0,0:04:59.45,0:05:01.03,中文,,0,0,0,,我把2复制过去
Dialogue: 0,0:05:01.03,0:05:02.21,英文,,0,0,0,,OK, great.
Dialogue: 0,0:05:01.03,0:05:02.21,中文,,0,0,0,,好的 很好
Dialogue: 0,0:05:02.21,0:05:06.87,英文,,0,0,0,,Now I look at what's the smallest item on the left that I haven't copied yet?
Dialogue: 0,0:05:02.21,0:05:06.87,中文,,0,0,0,,现在我看看左边还没有复制的最小的项是什么？
Dialogue: 0,0:05:06.87,0:05:07.95,英文,,0,0,0,,Well, it's 3.
Dialogue: 0,0:05:06.87,0:05:07.95,中文,,0,0,0,,嗯 是3
Dialogue: 0,0:05:07.95,0:05:10.00,英文,,0,0,0,,And I know that because the array's sorted.
Dialogue: 0,0:05:07.95,0:05:10.00,中文,,0,0,0,,我知道这一点是因为数组是排序好的
Dialogue: 0,0:05:10.00,0:05:13.20,英文,,0,0,0,,What's the smallest item on the right that hasn't been copied yet?
Dialogue: 0,0:05:10.00,0:05:13.20,中文,,0,0,0,,右边还没有被复制的最小的项是什么？
Dialogue: 0,0:05:13.20,0:05:14.22,英文,,0,0,0,,It's still 4.
Dialogue: 0,0:05:13.20,0:05:14.22,中文,,0,0,0,,仍然是4
Dialogue: 0,0:05:14.22,0:05:15.80,英文,,0,0,0,,The 4 hasn't been copied yet.
Dialogue: 0,0:05:14.22,0:05:15.80,中文,,0,0,0,,4还没有被复制
Dialogue: 0,0:05:15.80,0:05:17.82,英文,,0,0,0,,So on the left, I have 3.
Dialogue: 0,0:05:15.80,0:05:17.82,中文,,0,0,0,,所以在左边 我有3
Dialogue: 0,0:05:17.82,0:05:19.36,英文,,0,0,0,,On the right, I have 4.
Dialogue: 0,0:05:17.82,0:05:19.36,中文,,0,0,0,,在右边 我有4
Dialogue: 0,0:05:19.36,0:05:21.08,英文,,0,0,0,,Which one should I copy next?
Dialogue: 0,0:05:19.36,0:05:21.08,中文,,0,0,0,,我接下来应该复制哪个？
Dialogue: 0,0:05:21.08,0:05:22.60,英文,,0,0,0,,I'll copy the 3 next.
Dialogue: 0,0:05:21.08,0:05:22.60,中文,,0,0,0,,我接下来会复制3
Dialogue: 0,0:05:22.60,0:05:23.04,英文,,0,0,0,,OK, great.
Dialogue: 0,0:05:22.60,0:05:23.04,中文,,0,0,0,,好的 很好
Dialogue: 0,0:05:23.04,0:05:24.34,英文,,0,0,0,,There's the 3.
Dialogue: 0,0:05:23.04,0:05:24.34,中文,,0,0,0,,3在那里
Dialogue: 0,0:05:24.34,0:05:27.16,英文,,0,0,0,,Then I ask again, what's the smallest thing on the left side?
Dialogue: 0,0:05:24.34,0:05:27.16,中文,,0,0,0,,然后我再问一次 左边最小的东西是什么？
Dialogue: 0,0:05:27.16,0:05:28.24,英文,,0,0,0,,Well, it's 6.
Dialogue: 0,0:05:27.16,0:05:28.24,中文,,0,0,0,,嗯 是6
Dialogue: 0,0:05:28.24,0:05:29.84,英文,,0,0,0,,What's the smallest thing on the right side?
Dialogue: 0,0:05:28.24,0:05:29.84,中文,,0,0,0,,右边最小的东西是什么？
Dialogue: 0,0:05:29.84,0:05:30.64,英文,,0,0,0,,It's still 4.
Dialogue: 0,0:05:29.84,0:05:30.64,中文,,0,0,0,,仍然是4
Dialogue: 0,0:05:30.64,0:05:32.48,英文,,0,0,0,,It's still waiting to be copied.
Dialogue: 0,0:05:30.64,0:05:32.48,中文,,0,0,0,,它还在等着被复制
Dialogue: 0,0:05:32.48,0:05:34.60,英文,,0,0,0,,This time, 4 is less than 6.
Dialogue: 0,0:05:32.48,0:05:34.60,中文,,0,0,0,,这次 4小于6
Dialogue: 0,0:05:34.60,0:05:35.56,英文,,0,0,0,,So we'll copy the 4.
Dialogue: 0,0:05:34.60,0:05:35.56,中文,,0,0,0,,所以我们会复制4
Dialogue: 0,0:05:35.56,0:05:37.75,英文,,0,0,0,,OK, good.
Dialogue: 0,0:05:35.56,0:05:37.75,中文,,0,0,0,,好的 很好
Dialogue: 0,0:05:37.75,0:05:38.53,英文,,0,0,0,,What's next?
Dialogue: 0,0:05:37.75,0:05:38.53,中文,,0,0,0,,接下来呢？
Dialogue: 0,0:05:38.53,0:05:40.48,英文,,0,0,0,,On the left, the 6 has not been copied.
Dialogue: 0,0:05:38.53,0:05:40.48,中文,,0,0,0,,左边 6 还没被复制
Dialogue: 0,0:05:40.48,0:05:43.16,英文,,0,0,0,,It's still the smallest item that has not been copied.
Dialogue: 0,0:05:40.48,0:05:43.16,中文,,0,0,0,,它仍然是未被复制的最小项
Dialogue: 0,0:05:43.16,0:05:46.40,英文,,0,0,0,,On the right side, 5 is the next thing to be copied.
Dialogue: 0,0:05:43.16,0:05:46.40,中文,,0,0,0,,在右侧 5 是下一个要复制的元素
Dialogue: 0,0:05:46.40,0:05:47.86,英文,,0,0,0,,Which one is less?
Dialogue: 0,0:05:46.40,0:05:47.86,中文,,0,0,0,,哪个更小？
Dialogue: 0,0:05:47.86,0:05:50.10,英文,,0,0,0,,Well, it's 5, so I'll copy the 5.
Dialogue: 0,0:05:47.86,0:05:50.10,中文,,0,0,0,,嗯 是 5 所以我复制 5
Dialogue: 0,0:05:50.10,0:05:52.28,英文,,0,0,0,,And hopefully, you're getting the hang of it.
Dialogue: 0,0:05:50.10,0:05:52.28,中文,,0,0,0,,希望你已经掌握了窍门
Dialogue: 0,0:05:52.28,0:05:55.52,英文,,0,0,0,,So next, 6 and 7, I'll copy the 6.
Dialogue: 0,0:05:52.28,0:05:55.52,中文,,0,0,0,,接下来 6 和 7 我复制 6
Dialogue: 0,0:05:55.52,0:05:55.74,英文,,0,0,0,,Good.
Dialogue: 0,0:05:55.52,0:05:55.74,中文,,0,0,0,,很好
Dialogue: 0,0:05:55.74,0:05:58.12,英文,,0,0,0,,10 and 7, I'll copy the 7.
Dialogue: 0,0:05:55.74,0:05:58.12,中文,,0,0,0,,10 和 7 我复制 7
Dialogue: 0,0:05:58.12,0:06:00.18,英文,,0,0,0,,Good.
Dialogue: 0,0:05:58.12,0:06:00.18,中文,,0,0,0,,很好
Dialogue: 0,0:06:00.18,0:06:01.98,英文,,0,0,0,,8 and 10, I'll copy the 8.
Dialogue: 0,0:06:00.18,0:06:01.98,中文,,0,0,0,,8 和 10 我复制 8
Dialogue: 0,0:06:01.98,0:06:06.68,英文,,0,0,0,,And at this point, I have run out of items to copy on the right array.
Dialogue: 0,0:06:01.98,0:06:06.68,中文,,0,0,0,,这时 右边的数组已经没有要复制的元素了
Dialogue: 0,0:06:06.68,0:06:08.69,英文,,0,0,0,,All the items on the right are done.
Dialogue: 0,0:06:06.68,0:06:08.69,中文,,0,0,0,,右边的所有元素都完成了
Dialogue: 0,0:06:08.69,0:06:14.91,英文,,0,0,0,,So all I have to do is go to my left array and copy all the remaining items one by one until I'm done.
Dialogue: 0,0:06:08.69,0:06:14.91,中文,,0,0,0,,我只需要去左边的数组 将剩下的元素逐个复制 直到完成
Dialogue: 0,0:06:14.91,0:06:16.65,英文,,0,0,0,,So that's my merging process.
Dialogue: 0,0:06:14.91,0:06:16.65,中文,,0,0,0,,这就是我的合并过程
Dialogue: 0,0:06:16.65,0:06:21.23,英文,,0,0,0,,I took two sorted arrays, and I created one larger array.
Dialogue: 0,0:06:16.65,0:06:21.23,中文,,0,0,0,,我取了两个已排序的数组 并创建了一个更大的数组
Dialogue: 0,0:06:21.23,0:06:24.19,英文,,0,0,0,,Thoughts, opinions, questions on merging?
Dialogue: 0,0:06:21.23,0:06:24.19,中文,,0,0,0,,关于合并的想法、意见或问题？
Dialogue: 0,0:06:24.19,0:06:27.67,英文,,0,0,0,,Try and guess what the runtime is while I go find the original slides.
Dialogue: 0,0:06:24.19,0:06:27.67,中文,,0,0,0,,在我去找原始幻灯片的时候 试着猜猜运行时间是多少
Dialogue: 0,0:06:27.67,0:06:30.49,英文,,0,0,0,,OK.
Dialogue: 0,0:06:27.67,0:06:30.49,中文,,0,0,0,,
Dialogue: 0,0:06:30.49,0:06:32.93,英文,,0,0,0,,OK, so there's the picture you just saw.
Dialogue: 0,0:06:30.49,0:06:32.93,中文,,0,0,0,,好的 这就是你刚才看到的图片
Dialogue: 0,0:06:32.93,0:06:41.05,英文,,0,0,0,,So the question for you is, what's the runtime of merge sort with respect to n if that's the length of both of the arrays?
Dialogue: 0,0:06:32.93,0:06:41.05,中文,,0,0,0,,你的问题是 如果 N 是这两个数组的长度 那么归并排序的运行时间是多少？
Dialogue: 0,0:06:41.05,0:06:44.81,英文,,0,0,0,,So this array and this array, if I add them all up, I get n items.
Dialogue: 0,0:06:41.05,0:06:44.81,中文,,0,0,0,,如果我把这个数组和这个数组的所有元素加起来 我就得到了 N 个元素
Dialogue: 0,0:06:44.81,0:06:52.31,英文,,0,0,0,,Or in other words, this gigantic merged array has size n. What's the runtime of merge sort with respect to n?
Dialogue: 0,0:06:44.81,0:06:52.31,中文,,0,0,0,,换句话说 这个巨大的合并数组的大小为 N 归并排序的运行时间是多少？
Dialogue: 0,0:06:52.31,0:06:53.11,英文,,0,0,0,,Thoughts, guesses?
Dialogue: 0,0:06:52.31,0:06:53.11,中文,,0,0,0,,想法 猜测？
Dialogue: 0,0:06:53.11,0:06:53.93,英文,,0,0,0,,We'll do hands.
Dialogue: 0,0:06:53.11,0:06:53.93,中文,,0,0,0,,我们将举手
Dialogue: 0,0:06:53.93,0:06:54.77,英文,,0,0,0,,Theta 1?
Dialogue: 0,0:06:53.93,0:06:54.77,中文,,0,0,0,,θ(1)？
Dialogue: 0,0:06:54.77,0:06:57.26,英文,,0,0,0,,Any log n takers?
Dialogue: 0,0:06:54.77,0:06:57.26,中文,,0,0,0,,有对数 N 的吗？
Dialogue: 0,0:06:57.26,0:06:58.06,英文,,0,0,0,,n takers?
Dialogue: 0,0:06:57.26,0:06:58.06,中文,,0,0,0,,N 的吗？
Dialogue: 0,0:06:58.06,0:06:58.32,英文,,0,0,0,,Some?
Dialogue: 0,0:06:58.06,0:06:58.32,中文,,0,0,0,,一些？
Dialogue: 0,0:06:58.32,0:06:59.86,英文,,0,0,0,,OK, n squared?
Dialogue: 0,0:06:58.32,0:06:59.86,中文,,0,0,0,,好的 N^2？
Dialogue: 0,0:06:59.86,0:07:05.96,英文,,0,0,0,,I also think it's n. And the rough idea is, well, I have to look, or I have to copy n items.
Dialogue: 0,0:06:59.86,0:07:05.96,中文,,0,0,0,,我也认为是 N 大致的想法是 我必须查看或复制 N 个元素
Dialogue: 0,0:07:05.96,0:07:10.83,英文,,0,0,0,,And every step that I copy an item, I do a comparison, and that takes constant time.
Dialogue: 0,0:07:05.96,0:07:10.83,中文,,0,0,0,,每当我复制一个元素时 我都会进行比较 这需要常数时间
Dialogue: 0,0:07:10.83,0:07:14.86,英文,,0,0,0,,So it's a linear time merging algorithm.
Dialogue: 0,0:07:10.83,0:07:14.86,中文,,0,0,0,,它是一个线性时间合并算法
Dialogue: 0,0:07:14.86,0:07:16.68,英文,,0,0,0,,OK, so we saw SelectionSort.
Dialogue: 0,0:07:14.86,0:07:16.68,中文,,0,0,0,,好的 我们看到了 SelectioNSort(选择排序)
Dialogue: 0,0:07:16.68,0:07:19.54,英文,,0,0,0,,We saw this merging operation.
Dialogue: 0,0:07:16.68,0:07:19.54,中文,,0,0,0,,我们看到了这个合并操作
Dialogue: 0,0:07:19.54,0:07:25.35,英文,,0,0,0,,And so now, here comes the trick that's going to unlock MergeSort for us.
Dialogue: 0,0:07:19.54,0:07:25.35,中文,,0,0,0,,现在 我们将要解锁 MergeSort(归并排序) 的技巧来了
Dialogue: 0,0:07:25.35,0:07:35.72,英文,,0,0,0,,So first, we remember that if I had an input array of size 64 and I SelectionSorted it, by the way, SS stands for SelectionSort on this slide,
Dialogue: 0,0:07:25.35,0:07:35.72,中文,,0,0,0,,我们记得 如果我有一个大小为 64 的输入数组 并对其进行 SelectioNSort（SS 在此幻灯片上代表 SelectioNSort）
Dialogue: 0,0:07:35.72,0:07:39.72,英文,,0,0,0,,well, that's going to take roughly 4,096 arbitrary units of time.
Dialogue: 0,0:07:35.72,0:07:39.72,中文,,0,0,0,,那么这将花费大约 4,096 个任意时间单位
Dialogue: 0,0:07:39.72,0:07:42.50,英文,,0,0,0,,And this is just me kind of guessing at how long this would take.
Dialogue: 0,0:07:39.72,0:07:42.50,中文,,0,0,0,,这只是我的一种猜测 猜测这需要多长时间
Dialogue: 0,0:07:42.50,0:07:43.88,英文,,0,0,0,,It's not an exact count.
Dialogue: 0,0:07:42.50,0:07:43.88,中文,,0,0,0,,这不是一个确切的数字
Dialogue: 0,0:07:43.88,0:07:47.92,英文,,0,0,0,,But I can use it to compare against other algorithms if I'm careful.
Dialogue: 0,0:07:43.88,0:07:47.92,中文,,0,0,0,,但是如果我小心的话 我可以使用它来与其他算法进行比较
Dialogue: 0,0:07:47.92,0:07:51.73,英文,,0,0,0,,But here's my trick, which is I realized that selection sorting this big array was slow.
Dialogue: 0,0:07:47.92,0:07:51.73,中文,,0,0,0,,但我的技巧是 我意识到对这个大数组进行选择排序很慢
Dialogue: 0,0:07:51.73,0:07:53.39,英文,,0,0,0,,It's n squared.
Dialogue: 0,0:07:51.73,0:07:53.39,中文,,0,0,0,,它是 N^2
Dialogue: 0,0:07:53.39,0:07:59.47,英文,,0,0,0,,So what if instead of sorting one big array, which is slow, I sort two smaller arrays, which are fast?
Dialogue: 0,0:07:53.39,0:07:59.47,中文,,0,0,0,,那么 如果我不对一个大数组进行排序（这很慢） 而是对两个较小的数组进行排序（这很快）呢？
Dialogue: 0,0:07:59.47,0:08:06.21,英文,,0,0,0,,So I could take this big array, and I could split it into two smaller arrays, each of size 32.
Dialogue: 0,0:07:59.47,0:08:06.21,中文,,0,0,0,,我可以把这个大数组分成两个较小的数组 每个数组的大小为 32
Dialogue: 0,0:08:06.21,0:08:08.35,英文,,0,0,0,,And then I'll selection sort the first half.
Dialogue: 0,0:08:06.21,0:08:08.35,中文,,0,0,0,,然后我将对前半部分进行选择排序
Dialogue: 0,0:08:08.35,0:08:10.57,英文,,0,0,0,,Then I'll selection sort the second half.
Dialogue: 0,0:08:08.35,0:08:10.57,中文,,0,0,0,,然后我将对后半部分进行选择排序
Dialogue: 0,0:08:10.57,0:08:11.95,英文,,0,0,0,,OK, that's good.
Dialogue: 0,0:08:10.57,0:08:11.95,中文,,0,0,0,,好的 这很好
Dialogue: 0,0:08:11.95,0:08:15.78,英文,,0,0,0,,But I'm still not done, because now I have two smaller arrays which are sorted.
Dialogue: 0,0:08:11.95,0:08:15.78,中文,,0,0,0,,但我还没有完成 因为现在我有两个较小的数组 它们是排序的
Dialogue: 0,0:08:15.78,0:08:16.90,英文,,0,0,0,,But that's not my answer.
Dialogue: 0,0:08:15.78,0:08:16.90,中文,,0,0,0,,但这并不是我的答案
Dialogue: 0,0:08:16.90,0:08:19.18,英文,,0,0,0,,I want the big final array.
Dialogue: 0,0:08:16.90,0:08:19.18,中文,,0,0,0,,我想要最终的那个大数组
Dialogue: 0,0:08:19.18,0:08:22.68,英文,,0,0,0,,So if I have two smaller sorted arrays, how do I get the big one?
Dialogue: 0,0:08:19.18,0:08:22.68,中文,,0,0,0,,如果我有两个小的已排序数组 如何得到大的排序数组？
Dialogue: 0,0:08:22.68,0:08:26.56,英文,,0,0,0,,Well, we could just use the merging operation that we just saw.
Dialogue: 0,0:08:22.68,0:08:26.56,中文,,0,0,0,,我们可以使用刚才看到的合并操作
Dialogue: 0,0:08:26.56,0:08:28.74,英文,,0,0,0,,So I selection sort the left half.
Dialogue: 0,0:08:26.56,0:08:28.74,中文,,0,0,0,,我对左半部分进行选择排序
Dialogue: 0,0:08:28.74,0:08:30.39,英文,,0,0,0,,I selection sort the right half.
Dialogue: 0,0:08:28.74,0:08:30.39,中文,,0,0,0,,对右半部分进行选择排序
Dialogue: 0,0:08:30.39,0:08:40.27,英文,,0,0,0,,And then using my new merging operation, I merge the two sorted arrays together into one large size 64 sorted array.
Dialogue: 0,0:08:30.39,0:08:40.27,中文,,0,0,0,,然后使用新的合并操作 将两个已排序数组合并成一个大小为 64 的已排序数组
Dialogue: 0,0:08:40.27,0:08:41.65,英文,,0,0,0,,So how long does this take?
Dialogue: 0,0:08:40.27,0:08:41.65,中文,,0,0,0,,那么这需要多长时间？
Dialogue: 0,0:08:41.65,0:08:55.84,英文,,0,0,0,,If I use a similar analysis from before, I could say, well, the size 32 array, it takes approximately 32 squared time to complete, which is 1,024 arbitrary units of time.
Dialogue: 0,0:08:41.65,0:08:55.84,中文,,0,0,0,,如果我使用之前类似的分析 我可以说 大小为 32 的数组 完成排序大约需要 32 的平方时间 也就是 1,024 个任意时间单位
Dialogue: 0,0:08:55.84,0:08:57.54,英文,,0,0,0,,And same with the right half.
Dialogue: 0,0:08:55.84,0:08:57.54,中文,,0,0,0,,右半部分也是一样
Dialogue: 0,0:08:57.54,0:09:03.11,英文,,0,0,0,,The 32-sized array takes 1,024 arbitrary units of time to complete.
Dialogue: 0,0:08:57.54,0:09:03.11,中文,,0,0,0,,大小为 32 的数组完成排序需要 1,024 个任意时间单位
Dialogue: 0,0:09:03.11,0:09:05.75,英文,,0,0,0,,I have to sort both the left half and the right half.
Dialogue: 0,0:09:03.11,0:09:05.75,中文,,0,0,0,,我必须对左半部分和右半部分进行排序
Dialogue: 0,0:09:05.75,0:09:12.54,英文,,0,0,0,,So if I add them up, I get 2,048 arbitrary units of time to do the selection sorting.
Dialogue: 0,0:09:05.75,0:09:12.54,中文,,0,0,0,,如果我把它们加起来 我需要 2,048 个任意时间单位来完成选择排序
Dialogue: 0,0:09:12.54,0:09:16.62,英文,,0,0,0,,But I'm not done, because I still have to merge the two halves together.
Dialogue: 0,0:09:12.54,0:09:16.62,中文,,0,0,0,,但我还没有完成 因为我仍然需要将这两半合并在一起
Dialogue: 0,0:09:16.62,0:09:20.31,英文,,0,0,0,,And I remember that merging is a linear time operation.
Dialogue: 0,0:09:16.62,0:09:20.31,中文,,0,0,0,,我记得合并是一个线性时间操作
Dialogue: 0,0:09:20.31,0:09:28.61,英文,,0,0,0,,So if I have 64 items to merge, it will take me approximately 64 arbitrary units of time to merge them.
Dialogue: 0,0:09:20.31,0:09:28.61,中文,,0,0,0,,如果我有 64 个项目要合并 我将需要大约 64 个任意时间单位来合并它们
Dialogue: 0,0:09:28.61,0:09:30.04,英文,,0,0,0,,So I can add everything up.
Dialogue: 0,0:09:28.61,0:09:30.04,中文,,0,0,0,,我可以把所有东西加起来
Dialogue: 0,0:09:30.04,0:09:33.18,英文,,0,0,0,,There are two selection sorts I have to do, plus a merge.
Dialogue: 0,0:09:30.04,0:09:33.18,中文,,0,0,0,,我需要做两次选择排序 再加上一次合并
Dialogue: 0,0:09:33.18,0:09:34.96,英文,,0,0,0,,And if I add them all up,
Dialogue: 0,0:09:33.18,0:09:34.96,中文,,0,0,0,,如果我把它们都加起来
Dialogue: 0,0:09:34.96,0:09:39.24,英文,,0,0,0,,I get 2,112 arbitrary units of time.
Dialogue: 0,0:09:34.96,0:09:39.24,中文,,0,0,0,,我得到 2,112 个任意时间单位
Dialogue: 0,0:09:39.24,0:09:41.66,英文,,0,0,0,,And you'll notice that's less than 4,096.
Dialogue: 0,0:09:39.24,0:09:41.66,中文,,0,0,0,,你会注意到这比 4,096 少
Dialogue: 0,0:09:41.66,0:09:45.96,英文,,0,0,0,,So whatever I did, it seems like I did a pretty good job.
Dialogue: 0,0:09:41.66,0:09:45.96,中文,,0,0,0,,无论我做了什么 看起来我做得都很好
Dialogue: 0,0:09:45.96,0:09:54.93,英文,,0,0,0,,I took something that used to take around 4,000 units of time, whatever that is, and now using the same metric, it's 2,000 units of time.
Dialogue: 0,0:09:45.96,0:09:54.93,中文,,0,0,0,,我把原来需要大约 4,000 个时间单位的东西 现在用同样的指标 变成了 2,000 个时间单位
Dialogue: 0,0:09:54.93,0:10:03.69,英文,,0,0,0,,It's not an exact count, but it at least shows me that my algorithm has gotten faster just by using this little trick where I split the array up.
Dialogue: 0,0:09:54.93,0:10:03.69,中文,,0,0,0,,这不是一个确切的数字 但它至少向我表明 我的算法通过使用这个将数组分成两半的小技巧变得更快了
Dialogue: 0,0:10:03.69,0:10:08.58,英文,,0,0,0,,By the way, if the arbitrary units of time thing is making you uncomfy, that's okay.
Dialogue: 0,0:10:03.69,0:10:08.58,中文,,0,0,0,,顺便说一下 如果任意时间单位让你感到不舒服 没关系
Dialogue: 0,0:10:08.58,0:10:13.52,英文,,0,0,0,,You could also do the analysis using n, and you'd get an expression that looks like this.
Dialogue: 0,0:10:08.58,0:10:13.52,中文,,0,0,0,,你也可以用 N 来做分析 你会得到一个像这样的表达式
Dialogue: 0,0:10:13.52,0:10:23.17,英文,,0,0,0,,So the merging would be n time, and then each of these two selection sorts, well, it's size n over 2, the algorithm is n squared, and there's two of them.
Dialogue: 0,0:10:13.52,0:10:23.17,中文,,0,0,0,,合并将是 N 时间 然后这两个选择排序中的每一个 嗯 它是大小 N/2 算法是 N^2 并且有两个
Dialogue: 0,0:10:23.17,0:10:25.19,英文,,0,0,0,,So you can use the math to
Dialogue: 0,0:10:23.17,0:10:25.19,中文,,0,0,0,,所以你可以用数学来...
Dialogue: 0,0:10:25.19,0:10:28.81,英文,,0,0,0,,But I find it a little bit more intuitive and beautiful to see.
Dialogue: 0,0:10:25.19,0:10:28.81,中文,,0,0,0,,但我发现这样更直观、更漂亮
Dialogue: 0,0:10:28.81,0:10:31.05,英文,,0,0,0,,Look, I went from 4,000 to 2,000.
Dialogue: 0,0:10:28.81,0:10:31.05,中文,,0,0,0,,看 我从 4,000 变成了 2,000
Dialogue: 0,0:10:31.05,0:10:33.10,英文,,0,0,0,,I get an emotional reaction from that.
Dialogue: 0,0:10:31.05,0:10:33.10,中文,,0,0,0,,我从中得到了情感上的反应
Dialogue: 0,0:10:33.10,0:10:35.82,英文,,0,0,0,,Hits me in the gut when I see 4,000 to 2,000.
Dialogue: 0,0:10:33.10,0:10:35.82,中文,,0,0,0,,当我看到从 4,000 到 2,000 时 我的内心受到了冲击
Dialogue: 0,0:10:35.82,0:10:43.05,英文,,0,0,0,,But if you like to, and if this impresses you, you're totally welcome to use the mathematical expression as well.
Dialogue: 0,0:10:35.82,0:10:43.05,中文,,0,0,0,,但是如果你喜欢 并且如果这让你印象深刻 你完全可以使用数学表达式
Dialogue: 0,0:10:43.05,0:10:48.52,英文,,0,0,0,,One thing I will say, though, is that asymptotically, the algorithm is still in the theta n squared family.
Dialogue: 0,0:10:43.05,0:10:48.52,中文,,0,0,0,,不过 我要说的一件事是 渐近地 该算法仍然属于 θ(N^2) 族
Dialogue: 0,0:10:48.52,0:10:52.58,英文,,0,0,0,,Remember, there are so many different functions in the theta of n squared family.
Dialogue: 0,0:10:48.52,0:10:52.58,中文,,0,0,0,,记住 θ(N^2) 族中有许多不同的函数
Dialogue: 0,0:10:52.58,0:10:53.70,英文,,0,0,0,,This is one of them.
Dialogue: 0,0:10:52.58,0:10:53.70,中文,,0,0,0,,这是其中之一
Dialogue: 0,0:10:53.70,0:10:57.60,英文,,0,0,0,,After dropping all the constants, it's still theta n squared.
Dialogue: 0,0:10:53.70,0:10:57.60,中文,,0,0,0,,在删除所有常数之后 它仍然是 θ(N^2)
Dialogue: 0,0:10:57.60,0:11:00.42,英文,,0,0,0,,But it's a faster theta n squared.
Dialogue: 0,0:10:57.60,0:11:00.42,中文,,0,0,0,,但它是一个更快的 θ(N^2)
Dialogue: 0,0:11:00.42,0:11:09.62,英文,,0,0,0,,So it's still n squared asymptotically, but maybe the constant's a little bit better, as we saw when we did estimated counts.
Dialogue: 0,0:11:00.42,0:11:09.62,中文,,0,0,0,,它渐近地仍然是 N^2 但也许常数更好一些 正如我们做估计计数时看到的那样
Dialogue: 0,0:11:09.62,0:11:17.17,英文,,0,0,0,,So that's our first improvement to selection sort, which is split it in half, selection sort each side, merge them back up.
Dialogue: 0,0:11:09.62,0:11:17.17,中文,,0,0,0,,这是我们对选择排序的第一个改进 就是把它分成两半 对每一半进行选择排序 然后再合并
Dialogue: 0,0:11:17.17,0:11:22.05,英文,,0,0,0,,And I did some analysis to show it's faster, but it's still unsquared.
Dialogue: 0,0:11:17.17,0:11:22.05,中文,,0,0,0,,我做了一些分析来表明它更快 但它仍然是 N^2
Dialogue: 0,0:11:22.05,0:11:23.38,英文,,0,0,0,,Thoughts, questions?
Dialogue: 0,0:11:22.05,0:11:23.38,中文,,0,0,0,,想法 问题？
Dialogue: 0,0:11:23.38,0:11:24.80,英文,,0,0,0,,You're not impressed yet?
Dialogue: 0,0:11:23.38,0:11:24.80,中文,,0,0,0,,你还没有印象深刻？
Dialogue: 0,0:11:24.80,0:11:30.79,英文,,0,0,0,,OK, well, maybe I'll impress you with this next trick, which is, we shouldn't be satisfied at this point,
Dialogue: 0,0:11:24.80,0:11:30.79,中文,,0,0,0,,好吧 也许我会用下一个技巧让你印象深刻 那就是 我们不应该满足于这一点
Dialogue: 0,0:11:30.79,0:11:36.79,英文,,0,0,0,,because we found something that makes selection sort faster, which is to split into two halves, then selection sort it back.
Dialogue: 0,0:11:30.79,0:11:36.79,中文,,0,0,0,,因为我们发现了一些让选择排序更快的方法 那就是分成两半 然后选择排序回来
Dialogue: 0,0:11:36.79,0:11:40.74,英文,,0,0,0,,So what if we just tried the same trick again?
Dialogue: 0,0:11:36.79,0:11:40.74,中文,,0,0,0,,如果我们再尝试一下同样的技巧呢？
Dialogue: 0,0:11:40.74,0:11:51.44,英文,,0,0,0,,So instead of sorting this big 32-sized array using selection sort, what if I also split that 32-sized array into two smaller arrays of size 16?
Dialogue: 0,0:11:40.74,0:11:51.44,中文,,0,0,0,,与其使用选择排序来排序这个大小为 32 的大数组 不如将这个大小为 32 的数组也分成两个大小为 16 的较小数组？
Dialogue: 0,0:11:51.44,0:11:57.56,英文,,0,0,0,,And for my other size 32 array, I also split it into two smaller arrays of size 16.
Dialogue: 0,0:11:51.44,0:11:57.56,中文,,0,0,0,,对于我另一个大小为 32 的数组 我也把它分成两个大小为 16 的较小数组
Dialogue: 0,0:11:57.56,0:11:58.84,英文,,0,0,0,,Well, now.
Dialogue: 0,0:11:57.56,0:11:58.84,中文,,0,0,0,,好吧 现在...
Dialogue: 0,0:11:58.84,0:12:03.39,英文,,0,0,0,,I have to selection sort four arrays, each of size 16.
Dialogue: 0,0:11:58.84,0:12:03.39,中文,,0,0,0,,我必须对四个大小为 16 的数组进行选择排序
Dialogue: 0,0:12:03.39,0:12:04.95,英文,,0,0,0,,But that's not my final answer.
Dialogue: 0,0:12:03.39,0:12:04.95,中文,,0,0,0,,但这不是我的最终答案
Dialogue: 0,0:12:04.95,0:12:06.93,英文,,0,0,0,,My final answer shouldn't be four separate arrays.
Dialogue: 0,0:12:04.95,0:12:06.93,中文,,0,0,0,,我的最终答案不应该是四个单独的数组
Dialogue: 0,0:12:06.93,0:12:08.67,英文,,0,0,0,,It should be one big array.
Dialogue: 0,0:12:06.93,0:12:08.67,中文,,0,0,0,,它应该是一个大数组
Dialogue: 0,0:12:08.67,0:12:13.47,英文,,0,0,0,,So I have to take my four smaller arrays and merge them back up into one big array.
Dialogue: 0,0:12:08.67,0:12:13.47,中文,,0,0,0,,我得把我的四个小数组合并成一个大数组
Dialogue: 0,0:12:13.47,0:12:18.53,英文,,0,0,0,,And I think the most natural approach to do this is to do a two-layer merge.
Dialogue: 0,0:12:13.47,0:12:18.53,中文,,0,0,0,,我认为最自然的方法是进行两层合并
Dialogue: 0,0:12:18.53,0:12:26.63,英文,,0,0,0,,So I take two of the size 16 arrays, build a size 32 array, and then I take the other two size 16 arrays,
Dialogue: 0,0:12:18.53,0:12:26.63,中文,,0,0,0,,我取两个大小为 16 的数组 构建一个大小为 32 的数组 然后我取另外两个大小为 16 的数组
Dialogue: 0,0:12:26.63,0:12:35.63,英文,,0,0,0,,build a second size 32 array, and finally, I take my two size 32 arrays, and I merge them back together into one size 64 array.
Dialogue: 0,0:12:26.63,0:12:35.63,中文,,0,0,0,,构建第二个大小为 32 的数组 最后 我把我的两个大小为 32 的数组合并成一个大小为 64 的数组
Dialogue: 0,0:12:35.63,0:12:37.75,英文,,0,0,0,,So it's kind of like what you'd expect.
Dialogue: 0,0:12:35.63,0:12:37.75,中文,,0,0,0,,这就像你期望的那样
Dialogue: 0,0:12:37.75,0:12:44.52,英文,,0,0,0,,I pulled the same trick, but on those two size 32 arrays, and now I have a two-layer merge.
Dialogue: 0,0:12:37.75,0:12:44.52,中文,,0,0,0,,我用了同样的技巧 但在那两个大小为 32 的数组上 现在我得到了一个两层合并
Dialogue: 0,0:12:44.52,0:12:45.39,英文,,0,0,0,,Okay.
Dialogue: 0,0:12:44.52,0:12:45.39,中文,,0,0,0,,
Dialogue: 0,0:12:45.39,0:12:49.85,英文,,0,0,0,,So again, we can use some rough numbers to see how much faster this is.
Dialogue: 0,0:12:45.39,0:12:49.85,中文,,0,0,0,,我们可以再次使用一些粗略的数字来看看这有多快
Dialogue: 0,0:12:49.85,0:12:54.25,英文,,0,0,0,,And if you don't like it, feel free to use expressions in terms of n. It's the same thing.
Dialogue: 0,0:12:49.85,0:12:54.25,中文,,0,0,0,,如果你不喜欢它 可以随意使用 N 的表达式 这是一样的
Dialogue: 0,0:12:54.25,0:12:55.79,英文,,0,0,0,,But let's see.
Dialogue: 0,0:12:54.25,0:12:55.79,中文,,0,0,0,,但是让我们看看
Dialogue: 0,0:12:55.79,0:12:59.59,英文,,0,0,0,,Well, first I have to selection sort four of these small arrays.
Dialogue: 0,0:12:55.79,0:12:59.59,中文,,0,0,0,,嗯 首先我必须对四个小数组进行选择排序
Dialogue: 0,0:12:59.59,0:13:06.47,英文,,0,0,0,,Each one takes 16 squared arbitrary units of time, which is approximately 256.
Dialogue: 0,0:12:59.59,0:13:06.47,中文,,0,0,0,,每个都需要 16 平方个任意时间单位 大约是 256
Dialogue: 0,0:13:06.47,0:13:09.23,英文,,0,0,0,,There are four smaller arrays I have to sort.
Dialogue: 0,0:13:06.47,0:13:09.23,中文,,0,0,0,,我有四个较小的数组需要排序
Dialogue: 0,0:13:09.23,0:13:13.67,英文,,0,0,0,,So I have 4 times 256 at this bottom level.
Dialogue: 0,0:13:09.23,0:13:13.67,中文,,0,0,0,,我在这一层有 4 乘以 256
Dialogue: 0,0:13:13.67,0:13:15.59,英文,,0,0,0,,And then I have to do a bunch of merging.
Dialogue: 0,0:13:13.67,0:13:15.59,中文,,0,0,0,,然后我必须做一堆合并
Dialogue: 0,0:13:15.59,0:13:18.68,英文,,0,0,0,,In particular, I need to merge two of these size 16 arrays.
Dialogue: 0,0:13:15.59,0:13:18.68,中文,,0,0,0,,特别是 我需要合并这两个大小为 16 的数组
Dialogue: 0,0:13:18.68,0:13:20.94,英文,,0,0,0,,I know merging is linear time, so that costs me 32.
Dialogue: 0,0:13:18.68,0:13:20.94,中文,,0,0,0,,我知道合并是线性时间 所以这花费了我 32
Dialogue: 0,0:13:20.94,0:13:24.16,英文,,0,0,0,,And then over here, I have to do another merge.
Dialogue: 0,0:13:20.94,0:13:24.16,中文,,0,0,0,,然后在这里 我必须做另一个合并
Dialogue: 0,0:13:24.16,0:13:25.92,英文,,0,0,0,,That costs me another 32.
Dialogue: 0,0:13:24.16,0:13:25.92,中文,,0,0,0,,这又花费了我 32
Dialogue: 0,0:13:25.92,0:13:29.66,英文,,0,0,0,,And then I have to do one big merge, and that costs me another 64.
Dialogue: 0,0:13:25.92,0:13:29.66,中文,,0,0,0,,然后我必须做一个大的合并 这又花费了我 64
Dialogue: 0,0:13:29.66,0:13:42.38,英文,,0,0,0,,So if I add everything up, look, I've gone from 4,096 if I use just selection sort. And now I'm all the way down to 1,152, even better.
Dialogue: 0,0:13:29.66,0:13:42.38,中文,,0,0,0,,如果我把所有东西加起来 看 如果我只使用选择排序 我已经从 4096 已经降到了 1152 甚至更好
Dialogue: 0,0:13:42.38,0:13:47.15,英文,,0,0,0,,If you did this with expressions, it would unfortunately still be n squared.
Dialogue: 0,0:13:42.38,0:13:47.15,中文,,0,0,0,,如果你用表达式来做这件事 不幸的是它仍然是 N^2
Dialogue: 0,0:13:47.15,0:13:54.14,英文,,0,0,0,,But we can see that in real life, in various experiments, this would generally be faster, which is pretty cool.
Dialogue: 0,0:13:47.15,0:13:54.14,中文,,0,0,0,,但是我们可以看到 在现实生活中 在各种实验中 这通常会更快 这很酷
Dialogue: 0,0:13:54.14,0:13:55.50,英文,,0,0,0,,OK.
Dialogue: 0,0:13:54.14,0:13:55.50,中文,,0,0,0,,
Dialogue: 0,0:13:55.50,0:13:56.63,英文,,0,0,0,,So are you satisfied?
Dialogue: 0,0:13:55.50,0:13:56.63,中文,,0,0,0,,你满意了吗？
Dialogue: 0,0:13:56.63,0:14:01.25,英文,,0,0,0,,Should we go home and say, we're done, we split it into four, and everything's good?
Dialogue: 0,0:13:56.63,0:14:01.25,中文,,0,0,0,,我们应该回家说 我们完成了 我们把它分成四份 一切都好吗？
Dialogue: 0,0:14:01.25,0:14:07.59,英文,,0,0,0,,Well, what if we get even more bold and we say, what if I split the 16 into two smaller arrays of size 8,
Dialogue: 0,0:14:01.25,0:14:07.59,中文,,0,0,0,,嗯 如果我们更加大胆 我们说 如果我把 16 分成两个大小为 8 的较小数组
Dialogue: 0,0:14:07.59,0:14:13.59,英文,,0,0,0,,and then I split each of those into arrays of size 4, and then I split again, and I split again?
Dialogue: 0,0:14:07.59,0:14:13.59,中文,,0,0,0,,然后我把每个数组分成大小为 4 的数组 然后我再拆分 再拆分呢？
Dialogue: 0,0:14:13.59,0:14:15.71,英文,,0,0,0,,Well, you could keep doing that.
Dialogue: 0,0:14:13.59,0:14:15.71,中文,,0,0,0,,嗯 你可以一直这样做
Dialogue: 0,0:14:15.71,0:14:21.77,英文,,0,0,0,,And so that's what we could try, which is we keep splitting and splitting and splitting, and we selection sort the smaller arrays.
Dialogue: 0,0:14:15.71,0:14:21.77,中文,,0,0,0,,我们可以尝试这样做 那就是我们不断地拆分、拆分、拆分 然后对较小的数组进行选择排序
Dialogue: 0,0:14:21.77,0:14:26.80,英文,,0,0,0,,But if you keep splitting and splitting, this is the part that's kind of mind-bending.
Dialogue: 0,0:14:21.77,0:14:26.80,中文,,0,0,0,,但是如果你一直拆分、拆分 这就是有点让人费解的部分
Dialogue: 0,0:14:26.80,0:14:31.66,英文,,0,0,0,,If I split all the way down to 1, how do you selection sort an array of size 1?
Dialogue: 0,0:14:26.80,0:14:31.66,中文,,0,0,0,,如果我一路拆分到 1 你如何对大小为 1 的数组进行选择排序？
Dialogue: 0,0:14:31.66,0:14:32.36,英文,,0,0,0,,Is that fast?
Dialogue: 0,0:14:31.66,0:14:32.36,中文,,0,0,0,,那快吗？
Dialogue: 0,0:14:32.36,0:14:34.16,英文,,0,0,0,,Yeah, it's pretty fast.
Dialogue: 0,0:14:32.36,0:14:34.16,中文,,0,0,0,,是的 它很快
Dialogue: 0,0:14:34.16,0:14:37.19,英文,,0,0,0,,Do you need to selection sort an array of size 1?
Dialogue: 0,0:14:34.16,0:14:37.19,中文,,0,0,0,,你需要对大小为 1 的数组进行选择排序吗？
Dialogue: 0,0:14:37.19,0:14:40.22,英文,,0,0,0,,Like if I gave you an array with one item, how do you sort it?
Dialogue: 0,0:14:37.19,0:14:40.22,中文,,0,0,0,,比如 如果我给你一个只有一个项目的数组 你如何排序？
Dialogue: 0,0:14:40.22,0:14:42.20,英文,,0,0,0,,You just look at it, and you're like, done.
Dialogue: 0,0:14:40.22,0:14:42.20,中文,,0,0,0,,你只要看看它 你就说 好了
Dialogue: 0,0:14:42.20,0:14:42.94,英文,,0,0,0,,It's sorted, right?
Dialogue: 0,0:14:42.20,0:14:42.94,中文,,0,0,0,,它已经排序好了 对吧？
Dialogue: 0,0:14:42.94,0:14:50.73,英文,,0,0,0,,So well, maybe if I split all the way down to arrays of size 1, there's no need to even use selection sort at all.
Dialogue: 0,0:14:42.94,0:14:50.73,中文,,0,0,0,,如果我一路拆分到大小为 1 的数组 甚至不需要使用选择排序
Dialogue: 0,0:14:50.73,0:14:52.25,英文,,0,0,0,,I split all the way down.
Dialogue: 0,0:14:50.73,0:14:52.25,中文,,0,0,0,,我一路拆分到底
Dialogue: 0,0:14:52.25,0:14:58.07,英文,,0,0,0,,And now, instead of using selection sort at any point, I actually let all the merges
Dialogue: 0,0:14:52.25,0:14:58.07,中文,,0,0,0,,现在 我不再在任何时候使用选择排序 而是让所有的合并
Dialogue: 0,0:14:58.07,0:15:00.25,英文,,0,0,0,,do the sorting for me.
Dialogue: 0,0:14:58.07,0:15:00.25,中文,,0,0,0,,为我进行排序
Dialogue: 0,0:15:00.25,0:15:06.88,英文,,0,0,0,,So it's kind of mind-bending that I went from making a selection sort a little bit better to going all the way down to the base case.
Dialogue: 0,0:15:00.25,0:15:06.88,中文,,0,0,0,,从让选择排序变得更好一点 到一直到基本情况 这有点让人费解
Dialogue: 0,0:15:06.88,0:15:10.02,英文,,0,0,0,,And suddenly, there's no more selection sorting to be done.
Dialogue: 0,0:15:06.88,0:15:10.02,中文,,0,0,0,,突然间 不再需要进行选择排序了
Dialogue: 0,0:15:10.02,0:15:12.56,英文,,0,0,0,,I go all the way down to arrays of size 1.
Dialogue: 0,0:15:10.02,0:15:12.56,中文,,0,0,0,,我一路拆分到大小为 1 的数组
Dialogue: 0,0:15:12.56,0:15:15.70,英文,,0,0,0,,And my base case is, how do you sort an array of size 1?
Dialogue: 0,0:15:12.56,0:15:15.70,中文,,0,0,0,,我的基本情况是 你如何对大小为 1 的数组进行排序？
Dialogue: 0,0:15:15.70,0:15:15.94,英文,,0,0,0,,Done.
Dialogue: 0,0:15:15.70,0:15:15.94,中文,,0,0,0,,完成了
Dialogue: 0,0:15:15.94,0:15:16.54,英文,,0,0,0,,It's right there.
Dialogue: 0,0:15:15.94,0:15:16.54,中文,,0,0,0,,就在那里
Dialogue: 0,0:15:16.54,0:15:19.75,英文,,0,0,0,,So what if I did that?
Dialogue: 0,0:15:16.54,0:15:19.75,中文,,0,0,0,,如果我那样做呢？
Dialogue: 0,0:15:19.75,0:15:29.98,英文,,0,0,0,,And so now the question for you is, well, what happens if I use this merging and splitting operation all the way down as far as I can go?
Dialogue: 0,0:15:19.75,0:15:29.98,中文,,0,0,0,,所以现在你的问题就是说 如果我尽可能地使用这种合并和拆分操作 会发生什么？
Dialogue: 0,0:15:29.98,0:15:36.42,英文,,0,0,0,,Do I still get an n-squared algorithm, or has the asymptotic character completely changed?
Dialogue: 0,0:15:29.98,0:15:36.42,中文,,0,0,0,,我还会得到 N^2算法吗 还是渐进特征完全改变了？
Dialogue: 0,0:15:36.42,0:15:37.70,英文,,0,0,0,,kind of interesting.
Dialogue: 0,0:15:36.42,0:15:37.70,中文,,0,0,0,,有点意思
Dialogue: 0,0:15:37.70,0:15:39.29,英文,,0,0,0,,So I can do the math.
Dialogue: 0,0:15:37.70,0:15:39.29,中文,,0,0,0,,我可以做数学运算
Dialogue: 0,0:15:39.29,0:15:40.79,英文,,0,0,0,,I'm not going to do so on this slide.
Dialogue: 0,0:15:39.29,0:15:40.79,中文,,0,0,0,,我不会在这张幻灯片上做
Dialogue: 0,0:15:40.79,0:15:48.11,英文,,0,0,0,,But if you computed, you would actually get 384 arbitrary units of time if you split all the way down.
Dialogue: 0,0:15:40.79,0:15:48.11,中文,,0,0,0,,但如果你计算的话 如果你一路拆分下去 实际上会得到 384 个任意时间单位
Dialogue: 0,0:15:48.11,0:15:50.81,英文,,0,0,0,,And you did in selection sort of the arrays of size 1.
Dialogue: 0,0:15:48.11,0:15:50.81,中文,,0,0,0,,你在选择排序大小为 1 的数组时就是这样做的
Dialogue: 0,0:15:50.81,0:15:54.67,英文,,0,0,0,,So I actually went from 4,096 all the way down to this.
Dialogue: 0,0:15:50.81,0:15:54.67,中文,,0,0,0,,我实际上是从 4,096 一路降到这个
Dialogue: 0,0:15:54.67,0:15:57.40,英文,,0,0,0,,But the question was, if I did it in terms of n,
Dialogue: 0,0:15:54.67,0:15:57.40,中文,,0,0,0,,但问题是 如果我用 N 表示
Dialogue: 0,0:15:57.40,0:16:02.68,英文,,0,0,0,,Would I still have an n squared function with just a lot of smaller constants?
Dialogue: 0,0:15:57.40,0:16:02.68,中文,,0,0,0,,我是否仍然会有一个 N^2函数 只是常数小很多？
Dialogue: 0,0:16:02.68,0:16:09.61,英文,,0,0,0,,Or would this actually be a totally different asymptotic behavior, which is kind of interesting?
Dialogue: 0,0:16:02.68,0:16:09.61,中文,,0,0,0,,或者这实际上会是一种完全不同的渐进行为 这有点意思？
Dialogue: 0,0:16:09.61,0:16:11.89,英文,,0,0,0,,So that's what we're going to explore next.
Dialogue: 0,0:16:09.61,0:16:11.89,中文,,0,0,0,,这就是我们接下来要探讨的内容
Dialogue: 0,0:16:11.89,0:16:21.49,英文,,0,0,0,,But are we feeling OK about this new fancy algorithm where I split all the way down to the bottom, and I let the merging do all the work?
Dialogue: 0,0:16:11.89,0:16:21.49,中文,,0,0,0,,但是我们对这个新的奇特算法感觉如何 我把它一路拆分到底部 让合并来完成所有的工作？
Dialogue: 0,0:16:21.49,0:16:22.80,英文,,0,0,0,,It's kind of cool.
Dialogue: 0,0:16:21.49,0:16:22.80,中文,,0,0,0,,这有点酷
Dialogue: 0,0:16:22.80,0:16:24.50,英文,,0,0,0,,OK.
Dialogue: 0,0:16:22.80,0:16:24.50,中文,,0,0,0,,
Dialogue: 0,0:16:24.50,0:16:26.76,英文,,0,0,0,,So order of growth.
Dialogue: 0,0:16:24.50,0:16:26.76,中文,,0,0,0,,所以增长顺序
Dialogue: 0,0:16:26.76,0:16:32.32,英文,,0,0,0,,I think you might have seen this when we talked about the asymptotics lecture, or maybe some of the asymptotics assignments.
Dialogue: 0,0:16:26.76,0:16:32.32,中文,,0,0,0,,我想你可能在我们谈论渐近性讲座或一些渐近性作业时见过这个
Dialogue: 0,0:16:32.32,0:16:33.88,英文,,0,0,0,,So maybe it looks familiar.
Dialogue: 0,0:16:32.32,0:16:33.88,中文,,0,0,0,,它看起来可能很熟悉
Dialogue: 0,0:16:33.88,0:16:40.27,英文,,0,0,0,,But the worst case runtime of merge sort, I could do the same analysis that I've been doing over and over again.
Dialogue: 0,0:16:33.88,0:16:40.27,中文,,0,0,0,,但是归并排序的最坏情况运行时间 我可以做我一直在重复做的相同分析
Dialogue: 0,0:16:40.27,0:16:45.83,英文,,0,0,0,,But instead of using actual numbers, I will now substitute in n. So let's do it.
Dialogue: 0,0:16:40.27,0:16:45.83,中文,,0,0,0,,但是现在我将用 N 代替实际数字  让我们开始吧
Dialogue: 0,0:16:45.83,0:16:47.95,英文,,0,0,0,,At the very top level,
Dialogue: 0,0:16:45.83,0:16:47.95,中文,,0,0,0,,在最顶层
Dialogue: 0,0:16:47.95,0:16:51.31,英文,,0,0,0,,And here, by level, I'm talking about splitting the array up over and over.
Dialogue: 0,0:16:47.95,0:16:51.31,中文,,0,0,0,,在这里 按层级 我指的是将数组一遍又一遍地拆分
Dialogue: 0,0:16:51.31,0:16:58.62,英文,,0,0,0,,At the very top level, when I had just one big array, well, what work did I have to do at this level?
Dialogue: 0,0:16:51.31,0:16:58.62,中文,,0,0,0,,在最顶层 当我只有一个大数组时 那么 我需要在这个层级做什么工作？
Dialogue: 0,0:16:58.62,0:17:06.59,英文,,0,0,0,,I had to take two small arrays of size n over 2 and merge them into an array of size n. So I did n work at the top level.
Dialogue: 0,0:16:58.62,0:17:06.59,中文,,0,0,0,,我必须取两个大小为 N/2 的小数组 并将它们合并成一个大小为 N 的数组  所以我顶层做了 N 个工作
Dialogue: 0,0:17:06.59,0:17:07.95,英文,,0,0,0,,What about this next level?
Dialogue: 0,0:17:06.59,0:17:07.95,中文,,0,0,0,,下一层呢？
Dialogue: 0,0:17:07.95,0:17:10.23,英文,,0,0,0,,Well, I have this array of size n over 2.
Dialogue: 0,0:17:07.95,0:17:10.23,中文,,0,0,0,,嗯 我有一个大小为 N/2 的数组
Dialogue: 0,0:17:10.23,0:17:11.76,英文,,0,0,0,,How was that array produced?
Dialogue: 0,0:17:10.23,0:17:11.76,中文,,0,0,0,,这个数组是怎么产生的？
Dialogue: 0,0:17:11.76,0:17:16.00,英文,,0,0,0,,Who gave me this size n over 2 array, and how much work did they do?
Dialogue: 0,0:17:11.76,0:17:16.00,中文,,0,0,0,,谁给了我这个大小为 N/2 的数组 他们做了多少工作？
Dialogue: 0,0:17:16.00,0:17:26.43,英文,,0,0,0,,Well, whoever produced this n over 2 array had to take two smaller arrays of n over 4, merge them into an array of size n over 2, and that took n over 2 work.
Dialogue: 0,0:17:16.00,0:17:26.43,中文,,0,0,0,,嗯 任何生成这个 N/2 数组的人 都必须取两个较小的 N/4 数组 将它们合并成一个大小为 N/2 的数组 这需要 N/2 的工作量
Dialogue: 0,0:17:26.43,0:17:32.83,英文,,0,0,0,,And likewise, whoever produced this n over 2 array had to do n over 2 work of merging.
Dialogue: 0,0:17:26.43,0:17:32.83,中文,,0,0,0,,同样地 任何生成这个 N/2 数组的人 都必须做 N/2 的合并工作
Dialogue: 0,0:17:32.83,0:17:42.26,英文,,0,0,0,,So in total, at this layer, I have n over 2 plus n over 2, which is still n. So I still have n layers at the n amount of work at this layer.
Dialogue: 0,0:17:32.83,0:17:42.26,中文,,0,0,0,,总的来说 在这一层 我有 N/2 加 N/2 仍然是 N  我仍然有 N 层 在这一层有 N 量的工作
Dialogue: 0,0:17:42.26,0:17:43.64,英文,,0,0,0,,What about this next layer?
Dialogue: 0,0:17:42.26,0:17:43.64,中文,,0,0,0,,下一层呢？
Dialogue: 0,0:17:43.64,0:17:45.36,英文,,0,0,0,,There are four arrays here.
Dialogue: 0,0:17:43.64,0:17:45.36,中文,,0,0,0,,这里有四个数组
Dialogue: 0,0:17:45.36,0:17:47.50,英文,,0,0,0,,Each one is of size n over 4.
Dialogue: 0,0:17:45.36,0:17:47.50,中文,,0,0,0,,每个数组的大小都是 N/4
Dialogue: 0,0:17:47.50,0:17:52.64,英文,,0,0,0,,How long does it take to produce an array of size n over 4 in this particular algorithm?
Dialogue: 0,0:17:47.50,0:17:52.64,中文,,0,0,0,,在这个特定的算法中 生成一个大小为 N/4 的数组需要多长时间？
Dialogue: 0,0:17:52.64,0:17:58.03,英文,,0,0,0,,It takes n over 4 time, because all the arrays are produced from a merging operation.
Dialogue: 0,0:17:52.64,0:17:58.03,中文,,0,0,0,,这需要 N/4 时间 因为所有数组都是通过合并操作生成的
Dialogue: 0,0:17:58.03,0:17:59.73,英文,,0,0,0,,So if I have four arrays,
Dialogue: 0,0:17:58.03,0:17:59.73,中文,,0,0,0,,如果我有四个数组
Dialogue: 0,0:17:59.73,0:18:05.53,英文,,0,0,0,,Each one of size n over 4, and each one takes n over 4 time to produce.
Dialogue: 0,0:17:59.73,0:18:05.53,中文,,0,0,0,,每个数组的大小都是 N/4 每个数组都需要 N/4 的时间来生成
Dialogue: 0,0:18:05.53,0:18:14.56,英文,,0,0,0,,Well, then the total amount of work done here is 4 times n over 4, which turns out still be n. And if you do it again at the next layer, you have 8 arrays.
Dialogue: 0,0:18:05.53,0:18:14.56,中文,,0,0,0,,那么 这里完成的总工作量是 4 乘以 N/4 结果仍然是 N  如果你在下一层再做一次 你就有 8 个数组
Dialogue: 0,0:18:14.56,0:18:18.76,英文,,0,0,0,,Each one takes n over 8 time to produce, and you get n again.
Dialogue: 0,0:18:14.56,0:18:18.76,中文,,0,0,0,,每个数组需要 N/8 的时间来生成 你又得到了 N
Dialogue: 0,0:18:18.76,0:18:29.97,英文,,0,0,0,,So it seems like at every level, the amount of work done is n, n, n, n. And so if I want to add up the total amount of work done, I just have to figure out how many levels are there.
Dialogue: 0,0:18:18.76,0:18:29.97,中文,,0,0,0,,看起来在每一层 完成的工作量都是 N N N N  如果我想把完成的总工作量加起来 我只需要算出有多少层
Dialogue: 0,0:18:29.97,0:18:35.03,英文,,0,0,0,,So the first level, the eraser of size n, and then n over 2, and then n over 4, n over 8.
Dialogue: 0,0:18:29.97,0:18:35.03,中文,,0,0,0,,第一层 大小为 N 的橡皮擦 然后是 N/2 然后是 N/4 N/8
Dialogue: 0,0:18:35.03,0:18:37.37,英文,,0,0,0,,So I can count up how many levels are there.
Dialogue: 0,0:18:35.03,0:18:37.37,中文,,0,0,0,,我可以计算出有多少层
Dialogue: 0,0:18:37.37,0:18:41.70,英文,,0,0,0,,In other words, how many times do I have to divide n by 2 until I hit 1?
Dialogue: 0,0:18:37.37,0:18:41.70,中文,,0,0,0,,换句话说 我必须将 N 除以 2 多少次才能达到 1？
Dialogue: 0,0:18:41.70,0:18:48.04,英文,,0,0,0,,Well, that's the log n sequence, again, from all the asymptotics that you spend so much time practicing.
Dialogue: 0,0:18:41.70,0:18:48.04,中文,,0,0,0,,嗯 这就是 log N 序列 再一次 来自你花了那么多时间练习的所有渐近性
Dialogue: 0,0:18:48.04,0:18:50.60,英文,,0,0,0,,So overall, the picture is like this.
Dialogue: 0,0:18:48.04,0:18:50.60,中文,,0,0,0,,总的来说 图片是这样的
Dialogue: 0,0:18:50.60,0:18:54.70,英文,,0,0,0,,At every layer of work, or at every layer, there's n work done in total.
Dialogue: 0,0:18:50.60,0:18:54.70,中文,,0,0,0,,在每一层工作中 或在每一层 总共完成了 N 个工作
Dialogue: 0,0:18:54.70,0:19:03.21,英文,,0,0,0,,There are log base 2 of n levels, because that's how many times I have to split the array before I get to the base case of size 1 arrays.
Dialogue: 0,0:18:54.70,0:19:03.21,中文,,0,0,0,,有 log 以 2 为底的 N 层 因为这就是在我得到大小为 1 的数组的基本情况之前必须拆分数组的次数
Dialogue: 0,0:19:03.21,0:19:10.38,英文,,0,0,0,,So my overall runtime is theta n log n. That's kind of cool, because it's no longer theta of n squared.
Dialogue: 0,0:19:03.21,0:19:10.38,中文,,0,0,0,,我的总运行时间是 theta N log N  这有点酷 因为它不再是 θ(N) 平方了
Dialogue: 0,0:19:10.38,0:19:17.81,英文,,0,0,0,,By splitting all the way down, I totally changed and improved the asymptotic behavior of this particular sort.
Dialogue: 0,0:19:10.38,0:19:17.81,中文,,0,0,0,,通过一路拆分到底 我完全改变并改进了这个特定排序的渐近行为
Dialogue: 0,0:19:17.81,0:19:22.15,英文,,0,0,0,,By the way, if you're not comfortable with the fact that, well, what if n was 7?
Dialogue: 0,0:19:17.81,0:19:22.15,中文,,0,0,0,,对了 如果你不太适应 嗯……如果 N 是 7 怎么办？
Dialogue: 0,0:19:22.15,0:19:25.64,英文,,0,0,0,,And then when I split in 2, I can't really evenly split in 2.
Dialogue: 0,0:19:22.15,0:19:25.64,中文,,0,0,0,,然后当我把它分成两半时 我不能真的平均分成两半
Dialogue: 0,0:19:25.64,0:19:28.62,英文,,0,0,0,,One of the arrays would be size 3, and one of them would be size 4.
Dialogue: 0,0:19:25.64,0:19:28.62,中文,,0,0,0,,其中一个数组的大小将是 3 另一个数组的大小将是 4
Dialogue: 0,0:19:28.62,0:19:29.84,英文,,0,0,0,,Well, good for you.
Dialogue: 0,0:19:28.62,0:19:29.84,中文,,0,0,0,,嗯 那对你来说很好
Dialogue: 0,0:19:29.84,0:19:33.98,英文,,0,0,0,,You can totally do the analysis even if n is in the power of 2.
Dialogue: 0,0:19:29.84,0:19:33.98,中文,,0,0,0,,即使 N 不是 2 的幂 你也可以完全进行分析
Dialogue: 0,0:19:33.98,0:19:36.98,英文,,0,0,0,,But the exact count would be a little bit more tedious.
Dialogue: 0,0:19:33.98,0:19:36.98,中文,,0,0,0,,但确切的计数会有点麻烦
Dialogue: 0,0:19:36.98,0:19:40.68,英文,,0,0,0,,But it's still possible, and you would still get n log n.
Dialogue: 0,0:19:36.98,0:19:40.68,中文,,0,0,0,,但这仍然是可能的 你仍然会得到 N log N
Dialogue: 0,0:19:40.68,0:19:41.61,英文,,0,0,0,,I won't do it here.
Dialogue: 0,0:19:40.68,0:19:41.61,中文,,0,0,0,,我不会在这里做
Dialogue: 0,0:19:41.61,0:19:51.76,英文,,0,0,0,,Hopefully, this is good enough to convince you it's n log n. But if you want to, you could be more rigorous and also deal with facts like n could be odd or something like that.
Dialogue: 0,0:19:41.61,0:19:51.76,中文,,0,0,0,,希望这足以让你相信它是 N log N 但如果你愿意 你可以更严格 也可以处理 N 是奇数之类的事实
Dialogue: 0,0:19:51.76,0:19:53.32,英文,,0,0,0,,OK.
Dialogue: 0,0:19:51.76,0:19:53.32,中文,,0,0,0,,
Dialogue: 0,0:19:53.32,0:19:55.20,英文,,0,0,0,,Great, so that's merge sort.
Dialogue: 0,0:19:53.32,0:19:55.20,中文,,0,0,0,,太好了 这就是归并排序
Dialogue: 0,0:19:55.20,0:19:56.76,英文,,0,0,0,,Now we've seen it.
Dialogue: 0,0:19:55.20,0:19:56.76,中文,,0,0,0,,现在我们已经看到了
Dialogue: 0,0:19:56.76,0:20:00.76,英文,,0,0,0,,What happens is you take every array, and you split it into two halves.
Dialogue: 0,0:19:56.76,0:20:00.76,中文,,0,0,0,,发生的事情是你取每个数组 并把它分成两半
Dialogue: 0,0:20:00.76,0:20:02.29,英文,,0,0,0,,You merge sort the left half.
Dialogue: 0,0:20:00.76,0:20:02.29,中文,,0,0,0,,你对左半部分进行归并排序
Dialogue: 0,0:20:02.29,0:20:03.87,英文,,0,0,0,,You merge sort the right half.
Dialogue: 0,0:20:02.29,0:20:03.87,中文,,0,0,0,,你对右半部分进行归并排序
Dialogue: 0,0:20:03.87,0:20:08.79,英文,,0,0,0,,And by merge sort, I mean recursively perform the algorithm that you've already done.
Dialogue: 0,0:20:03.87,0:20:08.79,中文,,0,0,0,,归并排序 我的意思是递归地执行你已经完成的算法
Dialogue: 0,0:20:08.79,0:20:13.92,英文,,0,0,0,,And the base case is if you split all the way down to arrays of size 1, then there's nothing to do.
Dialogue: 0,0:20:08.79,0:20:13.92,中文,,0,0,0,,基本情况是 如果你一直拆分到大小为 1 的数组 那就没什么可做的了
Dialogue: 0,0:20:13.92,0:20:17.46,英文,,0,0,0,,So that is merge sort.
Dialogue: 0,0:20:13.92,0:20:17.46,中文,,0,0,0,,这就是归并排序
Dialogue: 0,0:20:17.46,0:20:22.35,英文,,0,0,0,,That's how you describe top-down merge sort in a couple of sentences.
Dialogue: 0,0:20:17.46,0:20:22.35,中文,,0,0,0,,这就是你用几句话描述自顶向下归并排序的方式
Dialogue: 0,0:20:22.35,0:20:25.07,英文,,0,0,0,,Here's a reminder of merging, although I won't do it again.
Dialogue: 0,0:20:22.35,0:20:25.07,中文,,0,0,0,,这里提醒一下合并 虽然我不会再做了
Dialogue: 0,0:20:25.07,0:20:30.61,英文,,0,0,0,,And so remember, you split the array into two halves, and you merge sort the left half recursively.
Dialogue: 0,0:20:25.07,0:20:30.61,中文,,0,0,0,,记住 你把数组分成两半 然后递归地对左半部分进行归并排序
Dialogue: 0,0:20:30.61,0:20:39.12,英文,,0,0,0,,So whatever algorithm we're doing right now with all the merges, do it on the left half, then do it again on the right half, and finally, merge everything together.
Dialogue: 0,0:20:30.61,0:20:39.12,中文,,0,0,0,,无论我们现在用所有的合并做什么算法 都在左半部分做 然后在右半部分再做一次 最后 把所有的东西合并在一起
Dialogue: 0,0:20:39.12,0:20:43.91,英文,,0,0,0,,By the way, if you want to know how to implement this in code,
Dialogue: 0,0:20:39.12,0:20:44.61,中文,,0,0,0,,顺便说一下 如果你想知道如何在代码中实现这一点
Dialogue: 0,0:20:43.91,0:20:51.91,英文,,0,0,0,,you could perhaps have two integers, i and j, to keep track of the next index of this red array and the next index of this blue array.
Dialogue: 0,0:20:44.61,0:20:51.91,中文,,0,0,0,,你也许可以用两个整数 i 和 j 来跟踪这个红色数组的下一个索引和这个蓝色数组的下一个索引
Dialogue: 0,0:20:51.91,0:20:53.25,英文,,0,0,0,,So if you want to, you could do that.
Dialogue: 0,0:20:51.91,0:20:53.25,中文,,0,0,0,,如果你想 你可以这样做
Dialogue: 0,0:20:53.25,0:20:54.63,英文,,0,0,0,,But the idea is kind of the same.
Dialogue: 0,0:20:53.25,0:20:54.63,中文,,0,0,0,,但想法是一样的
Dialogue: 0,0:20:54.63,0:20:56.87,英文,,0,0,0,,2 and 17, I'll copy the 2.
Dialogue: 0,0:20:54.63,0:20:56.87,中文,,0,0,0,,2 和 17 我将复制 2
Dialogue: 0,0:20:56.87,0:20:58.82,英文,,0,0,0,,15 and 17, I'll copy the 15.
Dialogue: 0,0:20:56.87,0:20:58.82,中文,,0,0,0,,15 和 17 我将复制 15
Dialogue: 0,0:20:58.82,0:21:00.26,英文,,0,0,0,,And you get the idea.
Dialogue: 0,0:20:58.82,0:21:00.26,中文,,0,0,0,,你明白了吧
Dialogue: 0,0:21:00.26,0:21:00.90,英文,,0,0,0,,OK.
Dialogue: 0,0:21:00.26,0:21:00.90,中文,,0,0,0,,
Dialogue: 0,0:21:00.90,0:21:02.44,英文,,0,0,0,,Copy the 17.
Dialogue: 0,0:21:00.90,0:21:02.44,中文,,0,0,0,,复制 17
Dialogue: 0,0:21:02.44,0:21:05.26,英文,,0,0,0,,I copied the 19, 26, 32.
Dialogue: 0,0:21:02.44,0:21:05.26,中文,,0,0,0,,我复制了 19、26、32
Dialogue: 0,0:21:05.26,0:21:10.80,英文,,0,0,0,,And since the left array is out of elements, I just copy everything from the right, and I'm done.
Dialogue: 0,0:21:05.26,0:21:10.80,中文,,0,0,0,,由于左侧数组没有元素 我只是从右侧复制所有内容 就完成了
Dialogue: 0,0:21:10.80,0:21:12.24,英文,,0,0,0,,That's merge sort.
Dialogue: 0,0:21:10.80,0:21:12.24,中文,,0,0,0,,这就是归并排序
Dialogue: 0,0:21:12.24,0:21:12.99,英文,,0,0,0,,OK.
Dialogue: 0,0:21:12.24,0:21:12.99,中文,,0,0,0,,
Dialogue: 0,0:21:12.99,0:21:16.09,英文,,0,0,0,,We've now seen three sorts.
Dialogue: 0,0:21:12.99,0:21:16.09,中文,,0,0,0,,我们现在已经看到了三种排序
Dialogue: 0,0:21:16.09,0:21:18.89,英文,,0,0,0,,Your chance to ask any questions you have about any of the three.
Dialogue: 0,0:21:16.09,0:21:18.89,中文,,0,0,0,,你有机会问任何关于这三种排序的问题
Dialogue: 0,0:21:18.89,0:21:19.85,英文,,0,0,0,,We saw selection sort.
Dialogue: 0,0:21:18.89,0:21:19.85,中文,,0,0,0,,我们看到了选择排序
Dialogue: 0,0:21:19.85,0:21:21.01,英文,,0,0,0,,It was our very first one.
Dialogue: 0,0:21:19.85,0:21:21.01,中文,,0,0,0,,这是我们的第一个
Dialogue: 0,0:21:21.01,0:21:25.13,英文,,0,0,0,,It was slow, because we looked at the elements over and over again.
Dialogue: 0,0:21:21.01,0:21:25.13,中文,,0,0,0,,它很慢 因为我们一遍又一遍地查看元素
Dialogue: 0,0:21:25.13,0:21:26.41,英文,,0,0,0,,Then we saw heap sort.
Dialogue: 0,0:21:25.13,0:21:26.41,中文,,0,0,0,,然后我们看到了堆排序
Dialogue: 0,0:21:26.41,0:21:31.60,英文,,0,0,0,,And we also saw a little trick to do it in place, so you don't have to create a bunch of extra arrays.
Dialogue: 0,0:21:26.41,0:21:31.60,中文,,0,0,0,,我们还看到了一个就地执行的小技巧 这样你就不必创建一堆额外的数组
Dialogue: 0,0:21:31.60,0:21:35.12,英文,,0,0,0,,But heapsort turns out most people don't use it in real life.
Dialogue: 0,0:21:31.60,0:21:35.12,中文,,0,0,0,,但事实证明 大多数人在现实生活中并不使用堆排序
Dialogue: 0,0:21:35.12,0:21:36.98,英文,,0,0,0,,I forget if I said this last time.
Dialogue: 0,0:21:35.12,0:21:36.98,中文,,0,0,0,,我忘了我上次是否说过这个
Dialogue: 0,0:21:36.98,0:21:39.16,英文,,0,0,0,,Something you'll see more in 6th UNC.
Dialogue: 0,0:21:36.98,0:21:39.16,中文,,0,0,0,,你会在第六届 UNC 中看到更多的东西
Dialogue: 0,0:21:39.16,0:21:43.27,英文,,0,0,0,,But it turns out heapsort, if you try it in practice, it's just not that good.
Dialogue: 0,0:21:39.16,0:21:43.27,中文,,0,0,0,,但事实证明 如果你在实践中尝试堆排序 它并没有那么好
Dialogue: 0,0:21:43.27,0:21:47.37,英文,,0,0,0,,It's a little bit slower than other sorts like merge sort, so no one really uses it.
Dialogue: 0,0:21:43.27,0:21:47.37,中文,,0,0,0,,它比其他排序（如归并排序）慢一点 所以没有人真正使用它
Dialogue: 0,0:21:47.37,0:21:50.97,英文,,0,0,0,,Although I find it kind of pretty to use a data structure to sort.
Dialogue: 0,0:21:47.37,0:21:50.97,中文,,0,0,0,,虽然我发现使用数据结构来排序有点漂亮
Dialogue: 0,0:21:50.97,0:21:52.81,英文,,0,0,0,,And then finally, today, we saw merge sort.
Dialogue: 0,0:21:50.97,0:21:52.81,中文,,0,0,0,,最后 今天 我们看到了归并排序
Dialogue: 0,0:21:52.81,0:21:55.23,英文,,0,0,0,,It's a beautiful recursive algorithm.
Dialogue: 0,0:21:52.81,0:21:55.23,中文,,0,0,0,,这是一个美丽的递归算法
Dialogue: 0,0:21:55.23,0:21:58.31,英文,,0,0,0,,In practice, if you ran experiments, it's faster than heap sort.
Dialogue: 0,0:21:55.23,0:21:58.31,中文,,0,0,0,,在实践中 如果你进行实验 它比堆排序快
Dialogue: 0,0:21:58.31,0:22:05.50,英文,,0,0,0,,And my space complexity is theta of n, because I had to create this extra array to finish my merging.
Dialogue: 0,0:21:58.31,0:22:05.50,中文,,0,0,0,,我的空间复杂度是θ(N) 因为我必须创建这个额外的数组来完成合并
Dialogue: 0,0:22:05.50,0:22:06.94,英文,,0,0,0,,Thoughts, questions?
Dialogue: 0,0:22:05.50,0:22:06.94,中文,,0,0,0,,想法 问题？
Dialogue: 0,0:22:06.94,0:22:07.26,英文,,0,0,0,,Yeah.
Dialogue: 0,0:22:06.94,0:22:07.26,中文,,0,0,0,,嗯
Dialogue: 0,0:22:07.26,0:22:07.36,英文,,0,0,0,,Yeah.
Dialogue: 0,0:22:07.26,0:22:07.36,中文,,0,0,0,,嗯
Dialogue: 0,0:22:07.36,0:22:15.42,英文,,0,0,0,,Is it possible to merge sort in parallel?
Dialogue: 0,0:22:07.36,0:22:15.42,中文,,0,0,0,,是否可以并行进行归并排序？
Dialogue: 0,0:22:15.42,0:22:19.12,英文,,0,0,0,,Mm, that's a good question, which is, could I do merge sort operations in parallel?
Dialogue: 0,0:22:15.42,0:22:19.12,中文,,0,0,0,,嗯 这是一个好问题 就是 我能否并行进行归并排序操作？
Dialogue: 0,0:22:19.12,0:22:19.74,英文,,0,0,0,,Justin looked up.
Dialogue: 0,0:22:19.12,0:22:19.74,中文,,0,0,0,,贾斯汀抬起头
Dialogue: 0,0:22:19.74,0:22:55.11,英文,,0,0,0,,Do you have an answer?
Dialogue: 0,0:22:19.74,0:22:55.11,中文,,0,0,0,,你有答案吗？
Dialogue: 0,0:22:55.11,0:22:56.21,英文,,0,0,0,,OK, that's a good answer.
Dialogue: 0,0:22:55.11,0:22:56.21,中文,,0,0,0,,好的 这是一个很好的答案
Dialogue: 0,0:22:56.21,0:22:57.95,英文,,0,0,0,,I'll repeat it quickly for folks on the recording.
Dialogue: 0,0:22:56.21,0:22:57.95,中文,,0,0,0,,我会快速地为录音的人重复一遍
Dialogue: 0,0:22:57.95,0:23:01.94,英文,,0,0,0,,But basically, what we said was, is it possible to do merge sort in parallel?
Dialogue: 0,0:22:57.95,0:23:01.94,中文,,0,0,0,,但基本上 我们说的是 是否可以并行进行归并排序？
Dialogue: 0,0:23:01.94,0:23:04.28,英文,,0,0,0,,And you'll see more parallel code in later classes.
Dialogue: 0,0:23:01.94,0:23:04.28,中文,,0,0,0,,在后面的课程中 您将看到更多并行代码
Dialogue: 0,0:23:04.28,0:23:09.62,英文,,0,0,0,,But the idea is maybe you give the left half to one computer, and you give the right half to a different computer.
Dialogue: 0,0:23:04.28,0:23:09.62,中文,,0,0,0,,但想法是 也许你把左半部分给一台计算机 把右半部分给另一台计算机
Dialogue: 0,0:23:09.62,0:23:10.94,英文,,0,0,0,,They do the work at the same time.
Dialogue: 0,0:23:09.62,0:23:10.94,中文,,0,0,0,,他们同时做这项工作
Dialogue: 0,0:23:10.94,0:23:12.96,英文,,0,0,0,,They report back to you, and you do the merge.
Dialogue: 0,0:23:10.94,0:23:12.96,中文,,0,0,0,,他们向你报告 然后你进行合并
Dialogue: 0,0:23:12.96,0:23:14.12,英文,,0,0,0,,It's possible.
Dialogue: 0,0:23:12.96,0:23:14.12,中文,,0,0,0,,这是可能的
Dialogue: 0,0:23:14.12,0:23:19.92,英文,,0,0,0,,And I don't know if you'll get asymptotic speedup, because organizing all the parallel computers can take time, too.
Dialogue: 0,0:23:14.12,0:23:19.92,中文,,0,0,0,,我不知道你是否会得到渐近加速 因为组织所有并行计算机也需要时间
Dialogue: 0,0:23:19.92,0:23:22.10,英文,,0,0,0,,And it's not something we'll analyze in this class.
Dialogue: 0,0:23:19.92,0:23:22.10,中文,,0,0,0,,这不是我们在这门课上要分析的内容
Dialogue: 0,0:23:22.10,0:23:24.16,英文,,0,0,0,,But it's an interesting thought.
Dialogue: 0,0:23:22.10,0:23:24.16,中文,,0,0,0,,但这是一个有趣的想法
Dialogue: 0,0:23:24.16,0:23:25.48,英文,,0,0,0,,Any other?
Dialogue: 0,0:23:24.16,0:23:25.48,中文,,0,0,0,,还有其他吗？
Dialogue: 0,0:23:25.48,0:23:27.52,英文,,0,0,0,,Interesting thoughts?
Dialogue: 0,0:23:25.48,0:23:27.52,中文,,0,0,0,,有趣的想法？
Dialogue: 0,0:23:27.52,0:23:28.60,英文,,0,0,0,,OK.
Dialogue: 0,0:23:27.52,0:23:28.60,中文,,0,0,0,,
Dialogue: 0,0:23:28.60,0:23:28.82,英文,,0,0,0,,Great.
Dialogue: 0,0:23:28.60,0:23:28.82,中文,,0,0,0,,太棒了
Dialogue: 0,0:23:28.82,0:23:30.64,英文,,0,0,0,,So those are our three sorts so far.
Dialogue: 0,0:23:28.82,0:23:30.64,中文,,0,0,0,,到目前为止 这是我们的三种排序
Dialogue: 0,0:23:30.64,0:23:34.45,英文,,0,0,0,,I have one more to show you, I guess, which is insertion sort.
Dialogue: 0,0:23:30.64,0:23:34.45,中文,,0,0,0,,我想我还有一个要给你看的 那就是插入排序
Dialogue: 0,0:23:34.45,0:23:36.65,英文,,0,0,0,,So hopefully you're ready.
Dialogue: 0,0:23:34.45,0:23:36.65,中文,,0,0,0,,希望你准备好了
Dialogue: 0,0:23:36.65,0:23:37.61,英文,,0,0,0,,OK.
Dialogue: 0,0:23:36.65,0:23:37.61,中文,,0,0,0,,
Dialogue: 0,0:23:37.61,0:23:38.93,英文,,0,0,0,,Here's insertion sort.
Dialogue: 0,0:23:37.61,0:23:38.93,中文,,0,0,0,,这是插入排序
Dialogue: 0,0:23:38.93,0:23:42.93,英文,,0,0,0,,So insertion sort says, well, first, I have no output.
Dialogue: 0,0:23:38.93,0:23:42.93,中文,,0,0,0,,插入排序说 好吧 首先 我没有输出
Dialogue: 0,0:23:42.93,0:23:44.03,英文,,0,0,0,,Here's my input.
Dialogue: 0,0:23:42.93,0:23:44.03,中文,,0,0,0,,这是我的输入
Dialogue: 0,0:23:44.03,0:23:44.93,英文,,0,0,0,,And so here's what I'll do.
Dialogue: 0,0:23:44.03,0:23:44.93,中文,,0,0,0,,这就是我要做的
Dialogue: 0,0:23:44.93,0:23:47.17,英文,,0,0,0,,It's one of those things where I don't really know how to say it.
Dialogue: 0,0:23:44.93,0:23:47.17,中文,,0,0,0,,这是我真不知道该怎么说的事情之一
Dialogue: 0,0:23:47.17,0:23:51.08,英文,,0,0,0,,But I think once I show it to you, you'll see what I'm trying to get at.
Dialogue: 0,0:23:47.17,0:23:51.08,中文,,0,0,0,,但我认为一旦我把它展示给你 你就会明白我的意思
Dialogue: 0,0:23:51.08,0:23:54.00,英文,,0,0,0,,So I will first put the 32 in the output array.
Dialogue: 0,0:23:51.08,0:23:54.00,中文,,0,0,0,,我将首先将 32 放入输出数组中
Dialogue: 0,0:23:54.00,0:23:56.64,英文,,0,0,0,,That one is almost so simple, I can't describe it.
Dialogue: 0,0:23:54.00,0:23:56.64,中文,,0,0,0,,这几乎太简单了 我无法描述它
Dialogue: 0,0:23:56.64,0:23:58.02,英文,,0,0,0,,Now let's look at the 15.
Dialogue: 0,0:23:56.64,0:23:58.02,中文,,0,0,0,,现在让我们看看 15
Dialogue: 0,0:23:58.02,0:24:04.00,英文,,0,0,0,,So my choice for you is, would you like the 15 to go to the left of 32 or to the right of 32?
Dialogue: 0,0:23:58.02,0:24:04.00,中文,,0,0,0,,我的选择是 你希望 15 在 32 的左边还是右边？
Dialogue: 0,0:24:04.00,0:24:08.29,英文,,0,0,0,,Well, I like it to the left because it's less than 32.
Dialogue: 0,0:24:04.00,0:24:08.29,中文,,0,0,0,,嗯 我喜欢它在左边 因为它小于 32
Dialogue: 0,0:24:08.29,0:24:09.57,英文,,0,0,0,,What about this 2?
Dialogue: 0,0:24:08.29,0:24:09.57,中文,,0,0,0,,那这个 2 呢？
Dialogue: 0,0:24:09.57,0:24:12.35,英文,,0,0,0,,Do you want it to be to the left of the 15?
Dialogue: 0,0:24:09.57,0:24:12.35,中文,,0,0,0,,你希望它在 15 的左边吗？
Dialogue: 0,0:24:12.35,0:24:15.59,英文,,0,0,0,,Do you want it to slot in between the 15 and the 32?
Dialogue: 0,0:24:12.35,0:24:15.59,中文,,0,0,0,,你希望它插在 15 和 32 之间吗？
Dialogue: 0,0:24:15.59,0:24:18.59,英文,,0,0,0,,Or do you want it to be to the right of 32?
Dialogue: 0,0:24:15.59,0:24:18.59,中文,,0,0,0,,或者你希望它在 32 的右边？
Dialogue: 0,0:24:18.59,0:24:23.24,英文,,0,0,0,,Well, I think it should be on the left, because it's less than 15 and 32.
Dialogue: 0,0:24:18.59,0:24:23.24,中文,,0,0,0,,嗯 我认为它应该在左边 因为它小于 15 和 32
Dialogue: 0,0:24:23.24,0:24:24.32,英文,,0,0,0,,What about 17?
Dialogue: 0,0:24:23.24,0:24:24.32,中文,,0,0,0,,那 17 呢？
Dialogue: 0,0:24:24.32,0:24:26.76,英文,,0,0,0,,Where should it slot in this output array?
Dialogue: 0,0:24:24.32,0:24:26.76,中文,,0,0,0,,它应该插在这个输出数组的什么位置？
Dialogue: 0,0:24:26.76,0:24:30.38,英文,,0,0,0,,I want to slot it right there in between 15 and 32.
Dialogue: 0,0:24:26.76,0:24:30.38,中文,,0,0,0,,我想把它插在 15 和 32 之间
Dialogue: 0,0:24:30.38,0:24:31.86,英文,,0,0,0,,What about the 19?
Dialogue: 0,0:24:30.38,0:24:31.86,中文,,0,0,0,,那 19 呢？
Dialogue: 0,0:24:31.86,0:24:32.70,英文,,0,0,0,,Where does it slot?
Dialogue: 0,0:24:31.86,0:24:32.70,中文,,0,0,0,,它插在哪里？
Dialogue: 0,0:24:32.70,0:24:34.34,英文,,0,0,0,,It slots right there.
Dialogue: 0,0:24:32.70,0:24:34.34,中文,,0,0,0,,它插在那里
Dialogue: 0,0:24:34.34,0:24:39.64,英文,,0,0,0,,So insertion sort looks at every element and somehow slots it into its correct place.
Dialogue: 0,0:24:34.34,0:24:39.64,中文,,0,0,0,,插入排序会查看每个元素 并以某种方式将其插入到正确的位置
Dialogue: 0,0:24:39.64,0:24:41.82,英文,,0,0,0,,So 26, where does it slot?
Dialogue: 0,0:24:39.64,0:24:41.82,中文,,0,0,0,,那么 26 应该放在哪里？
Dialogue: 0,0:24:41.82,0:24:42.72,英文,,0,0,0,,Between the 19 and the 32.
Dialogue: 0,0:24:41.82,0:24:42.72,中文,,0,0,0,,放在 19 和 32 之间
Dialogue: 0,0:24:42.72,0:24:44.71,英文,,0,0,0,,41, it slots at the very end.
Dialogue: 0,0:24:42.72,0:24:44.71,中文,,0,0,0,,41 放在最后面
Dialogue: 0,0:24:44.71,0:24:48.41,英文,,0,0,0,,17, right there.
Dialogue: 0,0:24:44.71,0:24:48.41,中文,,0,0,0,,17 放在这里
Dialogue: 0,0:24:48.41,0:24:49.75,英文,,0,0,0,,17 right there.
Dialogue: 0,0:24:48.41,0:24:49.75,中文,,0,0,0,,17 放在这里
Dialogue: 0,0:24:49.75,0:24:52.58,英文,,0,0,0,,So that's insertion sort, naive version.
Dialogue: 0,0:24:49.75,0:24:52.58,中文,,0,0,0,,这就是插入排序的简单版本
Dialogue: 0,0:24:52.58,0:24:57.93,英文,,0,0,0,,I take every element, and I slot it into the correct place in my output array.
Dialogue: 0,0:24:52.58,0:24:57.93,中文,,0,0,0,,我会遍历每个元素 然后把它放在输出数组的正确位置
Dialogue: 0,0:24:57.93,0:24:59.87,英文,,0,0,0,,So that's the picture.
Dialogue: 0,0:24:57.93,0:24:59.87,中文,,0,0,0,,这就是整个过程
Dialogue: 0,0:24:59.87,0:25:02.57,英文,,0,0,0,,I don't know how else to describe it besides showing you the picture.
Dialogue: 0,0:24:59.87,0:25:02.57,中文,,0,0,0,,除了展示图片 我不知道还能怎么描述它
Dialogue: 0,0:25:02.57,0:25:04.84,英文,,0,0,0,,But that's naive insertion sort.
Dialogue: 0,0:25:02.57,0:25:04.84,中文,,0,0,0,,但这就是简单的插入排序
Dialogue: 0,0:25:04.84,0:25:09.96,英文,,0,0,0,,Now, one problem with naive insertion sort is, how would you actually build this in Java?
Dialogue: 0,0:25:04.84,0:25:09.96,中文,,0,0,0,,现在 简单插入排序的一个问题是 如何在 Java 中实现它？
Dialogue: 0,0:25:09.96,0:25:13.36,英文,,0,0,0,,Because here, I'm showing you slotting elements in between arrays.
Dialogue: 0,0:25:09.96,0:25:13.36,中文,,0,0,0,,因为在这里 我展示的是在数组之间插入元素
Dialogue: 0,0:25:13.36,0:25:18.83,英文,,0,0,0,,But that's not really something you can do with an array in Java, maybe if you used a list or something.
Dialogue: 0,0:25:13.36,0:25:18.83,中文,,0,0,0,,但在 Java 中 这并不是真正可以对数组进行的操作 除非使用列表之类的
Dialogue: 0,0:25:18.83,0:25:21.91,英文,,0,0,0,,But I haven't really presented this as a full algorithm.
Dialogue: 0,0:25:18.83,0:25:21.91,中文,,0,0,0,,但我还没有将它作为一个完整的算法展示出来
Dialogue: 0,0:25:21.91,0:25:23.59,英文,,0,0,0,,So I'm going to show it to you one more time.
Dialogue: 0,0:25:21.91,0:25:23.59,中文,,0,0,0,,我将再演示一遍
Dialogue: 0,0:25:23.59,0:25:25.25,英文,,0,0,0,,It's going to look a little bit different.
Dialogue: 0,0:25:23.59,0:25:25.25,中文,,0,0,0,,它看起来会有点不同
Dialogue: 0,0:25:25.25,0:25:33.80,英文,,0,0,0,,but it's gonna be more realistic to implement than the naive picture I'm showing, although in both cases, the operations I'm doing are the exact same.
Dialogue: 0,0:25:25.25,0:25:33.80,中文,,0,0,0,,但这比我展示的简单图片更接近实际的实现方式 尽管在两种情况下 我做的操作都是完全一样的
Dialogue: 0,0:25:33.80,0:25:35.13,英文,,0,0,0,,Okay.
Dialogue: 0,0:25:33.80,0:25:35.13,中文,,0,0,0,,
Dialogue: 0,0:25:35.13,0:25:37.09,英文,,0,0,0,,So let's do it in place.
Dialogue: 0,0:25:35.13,0:25:37.09,中文,,0,0,0,,让我们原地进行排序
Dialogue: 0,0:25:37.09,0:25:39.09,英文,,0,0,0,,At first, the algorithm might look different.
Dialogue: 0,0:25:37.09,0:25:39.09,中文,,0,0,0,,起初 这个算法可能看起来有所不同
Dialogue: 0,0:25:39.09,0:25:44.79,英文,,0,0,0,,If you go home and think about it, maybe one night when you're sleeping, you'll be like, wait, they're actually the same.
Dialogue: 0,0:25:39.09,0:25:44.79,中文,,0,0,0,,如果你回家后思考一下 也许有一天晚上在你睡觉的时候 你会突然意识到 等等 它们实际上是一样的
Dialogue: 0,0:25:44.79,0:25:48.89,英文,,0,0,0,,But for now, if you want to treat it as something a little bit different, it's OK.
Dialogue: 0,0:25:44.79,0:25:48.89,中文,,0,0,0,,但现在 如果你想把它当作一些不同的东西 也没关系
Dialogue: 0,0:25:48.89,0:25:50.51,英文,,0,0,0,,So here we go.
Dialogue: 0,0:25:48.89,0:25:50.51,中文,,0,0,0,,那么 我们开始吧
Dialogue: 0,0:25:50.51,0:25:55.64,英文,,0,0,0,,Not only am I going to make this more realistic to implement, I'm also going to do it in place.
Dialogue: 0,0:25:50.51,0:25:55.64,中文,,0,0,0,,我不仅要让它更接近实际的实现方式 而且还要原地进行排序
Dialogue: 0,0:25:55.64,0:25:59.12,英文,,0,0,0,,So I don't need a new output array where I'm slotting elements left and right.
Dialogue: 0,0:25:55.64,0:25:59.12,中文,,0,0,0,,我不需要一个新的输出数组 在其中左右插入元素
Dialogue: 0,0:25:59.12,0:26:01.16,英文,,0,0,0,,I will do everything in place.
Dialogue: 0,0:25:59.12,0:26:01.16,中文,,0,0,0,,我会在原地完成所有操作
Dialogue: 0,0:26:01.16,0:26:06.36,英文,,0,0,0,,So I'll start at the left, I'll go all the way to the right, and I will consider every element.
Dialogue: 0,0:26:01.16,0:26:06.36,中文,,0,0,0,,我将从左边开始 一直走到右边 并考虑每个元素
Dialogue: 0,0:26:06.36,0:26:11.99,英文,,0,0,0,,And for every element that I consider, I will say, 32, you are now the traveling item.
Dialogue: 0,0:26:06.36,0:26:11.99,中文,,0,0,0,,对于我考虑的每个元素 我会说 32 你现在是旅行的项目
Dialogue: 0,0:26:11.99,0:26:22.10,英文,,0,0,0,,So pack your bags, you're going on a trip, and you're going to start moving backwards, that is, toward the left, until you find your rightful place.
Dialogue: 0,0:26:11.99,0:26:22.10,中文,,0,0,0,,打包好你的行李 你将开始一段旅程 你将开始向左移动 直到你找到你应该待的正确位置
Dialogue: 0,0:26:22.10,0:26:25.32,英文,,0,0,0,,Again, the first example is almost too simple to describe.
Dialogue: 0,0:26:22.10,0:26:25.32,中文,,0,0,0,,同样 第一个例子几乎太简单了 难以描述
Dialogue: 0,0:26:25.32,0:26:27.24,英文,,0,0,0,,The 32, it packs its bags.
Dialogue: 0,0:26:25.32,0:26:27.24,中文,,0,0,0,,32 打包好行李
Dialogue: 0,0:26:27.24,0:26:28.34,英文,,0,0,0,,It looks to its left.
Dialogue: 0,0:26:27.24,0:26:28.34,中文,,0,0,0,,它向左看
Dialogue: 0,0:26:28.34,0:26:29.51,英文,,0,0,0,,There's nowhere to go.
Dialogue: 0,0:26:28.34,0:26:29.51,中文,,0,0,0,,无处可去
Dialogue: 0,0:26:29.51,0:26:31.43,英文,,0,0,0,,So its journey is over.
Dialogue: 0,0:26:29.51,0:26:31.43,中文,,0,0,0,,它的旅程结束了
Dialogue: 0,0:26:31.43,0:26:33.01,英文,,0,0,0,,It stays there.
Dialogue: 0,0:26:31.43,0:26:33.01,中文,,0,0,0,,它留在了那里
Dialogue: 0,0:26:33.01,0:26:34.37,英文,,0,0,0,,OK, here comes the 15.
Dialogue: 0,0:26:33.01,0:26:34.37,中文,,0,0,0,,好的 15 来了
Dialogue: 0,0:26:34.37,0:26:35.97,英文,,0,0,0,,So the 15 is now the traveler.
Dialogue: 0,0:26:34.37,0:26:35.97,中文,,0,0,0,,现在 15 是旅行者
Dialogue: 0,0:26:35.97,0:26:37.57,英文,,0,0,0,,So 15, pack your bags.
Dialogue: 0,0:26:35.97,0:26:37.57,中文,,0,0,0,,所以 15 打包你的行李
Dialogue: 0,0:26:37.57,0:26:38.79,英文,,0,0,0,,You're going on a trip.
Dialogue: 0,0:26:37.57,0:26:38.79,中文,,0,0,0,,你将开始一段旅程
Dialogue: 0,0:26:38.79,0:26:43.77,英文,,0,0,0,,And you're going to start moving toward the left until you find your rightful place.
Dialogue: 0,0:26:38.79,0:26:43.77,中文,,0,0,0,,你将开始向左移动 直到你找到你应该待的正确位置
Dialogue: 0,0:26:43.77,0:26:48.14,英文,,0,0,0,,So 15 looks to the left and says, should I be to the right of 32?
Dialogue: 0,0:26:43.77,0:26:48.14,中文,,0,0,0,,所以 15 向左看 然后说 我应该在 32 的右边吗？
Dialogue: 0,0:26:48.14,0:26:49.58,英文,,0,0,0,,No, because I'm less than 32.
Dialogue: 0,0:26:48.14,0:26:49.58,中文,,0,0,0,,不 因为我小于 32
Dialogue: 0,0:26:49.58,0:26:51.90,英文,,0,0,0,,So I'm going to travel to the left.
Dialogue: 0,0:26:49.58,0:26:51.90,中文,,0,0,0,,所以我要向左移动
Dialogue: 0,0:26:51.90,0:26:57.40,英文,,0,0,0,,And the way that I travel is I'm going to swap elements until I find my rightful place.
Dialogue: 0,0:26:51.90,0:26:57.40,中文,,0,0,0,,我移动的方式是交换元素 直到我找到我应该待的正确位置
Dialogue: 0,0:26:57.40,0:27:01.64,英文,,0,0,0,,So 32, 15 should not be to the right of 32.
Dialogue: 0,0:26:57.40,0:27:01.64,中文,,0,0,0,,所以 32 15 不应该在 32 的右边
Dialogue: 0,0:27:01.64,0:27:03.34,英文,,0,0,0,,So they will swap places.
Dialogue: 0,0:27:01.64,0:27:03.34,中文,,0,0,0,,它们会交换位置
Dialogue: 0,0:27:03.34,0:27:07.05,英文,,0,0,0,,And you can view it as the 15 traveling toward the left.
Dialogue: 0,0:27:03.34,0:27:07.05,中文,,0,0,0,,你可以把它看作是 15 向左移动
Dialogue: 0,0:27:07.05,0:27:10.43,英文,,0,0,0,,And now the 15 looks toward the left and says, there's nowhere else for me to go.
Dialogue: 0,0:27:07.05,0:27:10.43,中文,,0,0,0,,现在 15 向左看 然后说 我没有别的地方可去了
Dialogue: 0,0:27:10.43,0:27:13.03,英文,,0,0,0,,I must be in the right place.
Dialogue: 0,0:27:10.43,0:27:13.03,中文,,0,0,0,,我一定是在正确的位置
Dialogue: 0,0:27:13.03,0:27:13.75,英文,,0,0,0,,Good.
Dialogue: 0,0:27:13.03,0:27:13.75,中文,,0,0,0,,很好
Dialogue: 0,0:27:13.75,0:27:15.07,英文,,0,0,0,,Now we look at the 2.
Dialogue: 0,0:27:13.75,0:27:15.07,中文,,0,0,0,,现在我们来看看 2
Dialogue: 0,0:27:15.07,0:27:17.21,英文,,0,0,0,,The 2 is ready to take its trip.
Dialogue: 0,0:27:15.07,0:27:17.21,中文,,0,0,0,,2 准备开始它的旅程
Dialogue: 0,0:27:17.21,0:27:21.42,英文,,0,0,0,,So it looks to the left and says, I have some swapping to do, so I'll swap to the left of 32.
Dialogue: 0,0:27:17.21,0:27:21.42,中文,,0,0,0,,它向左看 说 我需要做一些交换 所以我会交换到 32 的左边
Dialogue: 0,0:27:21.42,0:27:25.18,英文,,0,0,0,,You see 2, it's moving toward the left.
Dialogue: 0,0:27:21.42,0:27:25.18,中文,,0,0,0,,你看到 2 它正在向左移动
Dialogue: 0,0:27:25.18,0:27:27.74,英文,,0,0,0,,And the way that I move is I swap elements.
Dialogue: 0,0:27:25.18,0:27:27.74,中文,,0,0,0,,而我移动的方式是交换元素
Dialogue: 0,0:27:27.74,0:27:29.22,英文,,0,0,0,,So the 32 gets swapped.
Dialogue: 0,0:27:27.74,0:27:29.22,中文,,0,0,0,,所以 32 被交换了
Dialogue: 0,0:27:29.22,0:27:33.01,英文,,0,0,0,,And now the 2 looks to this left and says, am I in the right place?
Dialogue: 0,0:27:29.22,0:27:33.01,中文,,0,0,0,,现在 2 向左看 问 我在正确的位置吗？
Dialogue: 0,0:27:33.01,0:27:35.35,英文,,0,0,0,,No, because I shouldn't be to the right of 15.
Dialogue: 0,0:27:33.01,0:27:35.35,中文,,0,0,0,,不 因为我不应该在 15 的右边
Dialogue: 0,0:27:35.35,0:27:37.83,英文,,0,0,0,,So I will swap places with 15 as well.
Dialogue: 0,0:27:35.35,0:27:37.83,中文,,0,0,0,,我还要和 15 交换位置
Dialogue: 0,0:27:37.83,0:27:41.22,英文,,0,0,0,,And you can view that as the 2 traveling even further.
Dialogue: 0,0:27:37.83,0:27:41.22,中文,,0,0,0,,你可以把这看作是 2 走得更远了
Dialogue: 0,0:27:41.22,0:27:42.80,英文,,0,0,0,,And finally, it travels.
Dialogue: 0,0:27:41.22,0:27:42.80,中文,,0,0,0,,最后 它到达了目的地
Dialogue: 0,0:27:42.80,0:27:43.90,英文,,0,0,0,,And it looks to its left.
Dialogue: 0,0:27:42.80,0:27:43.90,中文,,0,0,0,,它向左看
Dialogue: 0,0:27:43.90,0:27:45.78,英文,,0,0,0,,There's nowhere else to go.
Dialogue: 0,0:27:43.90,0:27:45.78,中文,,0,0,0,,没有别的地方可去了
Dialogue: 0,0:27:45.78,0:27:47.81,英文,,0,0,0,,So it's happy where it is.
Dialogue: 0,0:27:45.78,0:27:47.81,中文,,0,0,0,,它对现在的位置很满意
Dialogue: 0,0:27:47.81,0:27:49.99,英文,,0,0,0,,Now we do the 17 and we travel.
Dialogue: 0,0:27:47.81,0:27:49.99,中文,,0,0,0,,现在我们来看 17 它也要开始移动了
Dialogue: 0,0:27:49.99,0:27:52.83,英文,,0,0,0,,So it looks to its left, the 32, we need to swap.
Dialogue: 0,0:27:49.99,0:27:52.83,中文,,0,0,0,,它向左看 是 32 我们需要交换
Dialogue: 0,0:27:52.83,0:27:55.30,英文,,0,0,0,,In other words, the 17 has to start traveling.
Dialogue: 0,0:27:52.83,0:27:55.30,中文,,0,0,0,,换句话说 17 必须开始它的旅程
Dialogue: 0,0:27:55.30,0:27:55.92,英文,,0,0,0,,Good.
Dialogue: 0,0:27:55.30,0:27:55.92,中文,,0,0,0,,很好
Dialogue: 0,0:27:55.92,0:27:59.14,英文,,0,0,0,,Now the 17 looks to its left and says, should I go further?
Dialogue: 0,0:27:55.92,0:27:59.14,中文,,0,0,0,,现在 17 向左看 问 我应该继续往前吗？
Dialogue: 0,0:27:59.14,0:28:00.96,英文,,0,0,0,,Well, no, because I'm greater than 15.
Dialogue: 0,0:27:59.14,0:28:00.96,中文,,0,0,0,,不用 因为我比 15 大
Dialogue: 0,0:28:00.96,0:28:02.45,英文,,0,0,0,,So I'm happy where I am.
Dialogue: 0,0:28:00.96,0:28:02.45,中文,,0,0,0,,我很满意我现在的位置
Dialogue: 0,0:28:02.45,0:28:03.75,英文,,0,0,0,,This is my right place.
Dialogue: 0,0:28:02.45,0:28:03.75,中文,,0,0,0,,这是我应该在的地方
Dialogue: 0,0:28:03.75,0:28:04.97,英文,,0,0,0,,I will stay.
Dialogue: 0,0:28:03.75,0:28:04.97,中文,,0,0,0,,我会留在这里
Dialogue: 0,0:28:04.97,0:28:06.86,英文,,0,0,0,,My trip is over.
Dialogue: 0,0:28:04.97,0:28:06.86,中文,,0,0,0,,我的旅程结束了
Dialogue: 0,0:28:06.86,0:28:07.90,英文,,0,0,0,,OK, good.
Dialogue: 0,0:28:06.86,0:28:07.90,中文,,0,0,0,,
Dialogue: 0,0:28:07.90,0:28:08.48,英文,,0,0,0,,Then we look at the 19.
Dialogue: 0,0:28:07.90,0:28:08.48,中文,,0,0,0,,然后我们来看 19
Dialogue: 0,0:28:08.48,0:28:10.40,英文,,0,0,0,,It travels.
Dialogue: 0,0:28:08.48,0:28:10.40,中文,,0,0,0,,它开始移动
Dialogue: 0,0:28:10.40,0:28:14.38,英文,,0,0,0,,And in this case, it has to do one swap, and it's happy where it is.
Dialogue: 0,0:28:10.40,0:28:14.38,中文,,0,0,0,,在这种情况下 它只需要交换一次 就到了它应该在的位置
Dialogue: 0,0:28:14.38,0:28:14.70,英文,,0,0,0,,OK, good.
Dialogue: 0,0:28:14.38,0:28:14.70,中文,,0,0,0,,
Dialogue: 0,0:28:14.70,0:28:17.70,英文,,0,0,0,,The 26, it travels once, and it's happy where it is.
Dialogue: 0,0:28:14.70,0:28:17.70,中文,,0,0,0,,26 它移动一次 就到了它应该在的位置
Dialogue: 0,0:28:17.70,0:28:22.94,英文,,0,0,0,,The 41, it doesn't need to travel at all, because it looks to its left and says, I'm happy where I am.
Dialogue: 0,0:28:17.70,0:28:22.94,中文,,0,0,0,,41 它根本不需要移动 因为它向左看 说 我很满意我现在的位置
Dialogue: 0,0:28:22.94,0:28:26.53,英文,,0,0,0,,And then this 17, it's going to have to travel some distance.
Dialogue: 0,0:28:22.94,0:28:26.53,中文,,0,0,0,,然后这个 17 它将不得不移动一段距离
Dialogue: 0,0:28:26.53,0:28:31.41,英文,,0,0,0,,And if you feel like it's a long distance, then you might have a bad feeling about the runtime we're about to do.
Dialogue: 0,0:28:26.53,0:28:31.41,中文,,0,0,0,,如果你觉得这是一段很长的距离 那么你可能会对我们即将要做的运行时间感到担忧
Dialogue: 0,0:28:31.41,0:28:34.57,英文,,0,0,0,,But this 17 is going to have to travel all the way back.
Dialogue: 0,0:28:31.41,0:28:34.57,中文,,0,0,0,,但这个 17 将不得不一路返回
Dialogue: 0,0:28:34.57,0:28:40.85,英文,,0,0,0,,So if you just stare at the blue, you don't look at the numbers and you stare at the blue, look, the 17 is gonna travel back.
Dialogue: 0,0:28:34.57,0:28:40.85,中文,,0,0,0,,如果你只盯着蓝色看 不要看数字 你会看到 17 会一路返回
Dialogue: 0,0:28:40.85,0:28:43.72,英文,,0,0,0,,See how it took a trip from over here to over here?
Dialogue: 0,0:28:40.85,0:28:43.72,中文,,0,0,0,,看到它是如何从这里移动到那里的吗？
Dialogue: 0,0:28:43.72,0:28:44.76,英文,,0,0,0,,Okay, good.
Dialogue: 0,0:28:43.72,0:28:44.76,中文,,0,0,0,,
Dialogue: 0,0:28:44.76,0:28:48.18,英文,,0,0,0,,But the way that you actually implement that traveling is you do swaps.
Dialogue: 0,0:28:44.76,0:28:48.18,中文,,0,0,0,,但你实际实现这种移动的方式是进行交换
Dialogue: 0,0:28:48.18,0:28:54.30,英文,,0,0,0,,So the 17 and the 41 swap, and then the 17 and the 32 swap, and then the 17 and the 26 swap.
Dialogue: 0,0:28:48.18,0:28:54.30,中文,,0,0,0,,所以 17 和 41 交换 然后 17 和 32 交换 然后 17 和 26 交换
Dialogue: 0,0:28:54.30,0:29:03.74,英文,,0,0,0,,So the swapping is how I actually implement the traveling without having to create, for example, a new output array or a fancy data structure like a list.
Dialogue: 0,0:28:54.30,0:29:03.74,中文,,0,0,0,,交换是我实际实现移动的方式 而不需要创建新的输出数组或像列表这样的复杂数据结构
Dialogue: 0,0:29:03.74,0:29:05.89,英文,,0,0,0,,Get good, and then finally, here's the 17.
Dialogue: 0,0:29:03.74,0:29:05.89,中文,,0,0,0,,很好 最后 17 在这里
Dialogue: 0,0:29:05.89,0:29:11.01,英文,,0,0,0,,And I swim it, or swap it, all the way till it finds its rightful place.
Dialogue: 0,0:29:05.89,0:29:11.01,中文,,0,0,0,,我把它一路交换 直到它找到它正确的位置
Dialogue: 0,0:29:11.01,0:29:15.95,英文,,0,0,0,,OK, that's actually the same algorithm as the one you just saw, where I slotted elements in place.
Dialogue: 0,0:29:11.01,0:29:15.95,中文,,0,0,0,,好的 这实际上和你们刚才看到的算法一样 我把元素插入到位
Dialogue: 0,0:29:15.95,0:29:23.11,英文,,0,0,0,,And if you think about it, at a deep level, they're basically doing the same thing, which is I'm taking every element, and I'm slotting it in its right place.
Dialogue: 0,0:29:15.95,0:29:23.11,中文,,0,0,0,,如果你仔细想想 在深层次上 它们基本上做的是同一件事 那就是我把每个元素都放在它正确的位置上
Dialogue: 0,0:29:23.11,0:29:26.77,英文,,0,0,0,,But this version is more realistic for me to implement in code.
Dialogue: 0,0:29:23.11,0:29:26.77,中文,,0,0,0,,但是这个版本对我来说在代码中实现起来更现实
Dialogue: 0,0:29:26.77,0:29:29.40,英文,,0,0,0,,And it also doesn't require a separate output array.
Dialogue: 0,0:29:26.77,0:29:29.40,中文,,0,0,0,,而且它也不需要单独的输出数组
Dialogue: 0,0:29:29.40,0:29:31.63,英文,,0,0,0,,That's why it's in place.
Dialogue: 0,0:29:29.40,0:29:31.63,中文,,0,0,0,,这就是为什么它是原地排序
Dialogue: 0,0:29:31.63,0:29:33.80,英文,,0,0,0,,OK, that's insertion sort.
Dialogue: 0,0:29:31.63,0:29:33.80,中文,,0,0,0,,好的 这就是插入排序
Dialogue: 0,0:29:33.80,0:29:35.52,英文,,0,0,0,,Satisfied with it?
Dialogue: 0,0:29:33.80,0:29:35.52,中文,,0,0,0,,满意吗？
Dialogue: 0,0:29:35.52,0:29:36.02,英文,,0,0,0,,OK.
Dialogue: 0,0:29:35.52,0:29:36.02,中文,,0,0,0,,
Dialogue: 0,0:29:36.02,0:29:42.95,英文,,0,0,0,,By the way, just because I know a lot of text popped up in the process of this demo, I will say there is an invariant,
Dialogue: 0,0:29:36.02,0:29:42.95,中文,,0,0,0,,顺便说一下 我知道在这个演示过程中出现了很多文本 但我只想说这里有一个不变性
Dialogue: 0,0:29:42.95,0:29:47.95,英文,,0,0,0,,which is that when you designate, say, 26 to be the traveler, everyone to the left of 26 is already sorted.
Dialogue: 0,0:29:42.95,0:29:47.95,中文,,0,0,0,,那就是当你指定 26 为旅行者时 26 左边的每个人都已经排好序了
Dialogue: 0,0:29:47.95,0:29:52.85,英文,,0,0,0,,Because all of these elements have already made their journey and found their home.
Dialogue: 0,0:29:47.95,0:29:52.85,中文,,0,0,0,,因为所有这些元素都已经完成了它们的旅程并找到了自己的家
Dialogue: 0,0:29:52.85,0:29:59.27,英文,,0,0,0,,So if everyone has found their rightful home to the left of 26, I know everyone to the left of 26 is already sorted.
Dialogue: 0,0:29:52.85,0:29:59.27,中文,,0,0,0,,如果每个人都在 26 的左边找到了他们合适的家 我知道 26 左边的每个人都已经排好序了
Dialogue: 0,0:29:59.27,0:30:03.04,英文,,0,0,0,,So that's a nice invariant you can use if you're thinking about insertion sort.
Dialogue: 0,0:29:59.27,0:30:03.04,中文,,0,0,0,,如果你在考虑插入排序 这是一个很好的不变性
Dialogue: 0,0:30:03.04,0:30:11.54,英文,,0,0,0,,So for example, here, when the 2 is about to travel, the 2 knows that everyone to the left is currently sorted, because they've all traveled before and found their rightful place.
Dialogue: 0,0:30:03.04,0:30:11.54,中文,,0,0,0,,例如 在这里 当 2 即将移动时 2 知道左边的每个人都已经排好序了 因为他们之前都移动过并找到了他们合适的位置
Dialogue: 0,0:30:11.54,0:30:17.98,英文,,0,0,0,,But temporarily, as the 2 is moving, it might temporarily break the invariant, like 15, 2, 32.
Dialogue: 0,0:30:11.54,0:30:17.98,中文,,0,0,0,,但是暂时地 当 2 移动时 它可能会暂时破坏不变性 比如 15, 2, 32
Dialogue: 0,0:30:17.98,0:30:19.84,英文,,0,0,0,,That's not sorted.
Dialogue: 0,0:30:17.98,0:30:19.84,中文,,0,0,0,,那没有排序
Dialogue: 0,0:30:19.84,0:30:26.80,英文,,0,0,0,,But once the 2 finishes its journey, then everything to the left of the current item will be sorted again.
Dialogue: 0,0:30:19.84,0:30:26.80,中文,,0,0,0,,但是一旦 2 完成它的旅程 那么当前项目左边的所有内容将再次排序
Dialogue: 0,0:30:26.80,0:30:31.33,英文,,0,0,0,,So if you like, there's an invariant to make thinking about selection sort helpful.
Dialogue: 0,0:30:26.80,0:30:31.33,中文,,0,0,0,,如果你愿意 这里有一个不变性来帮助你思考选择排序
Dialogue: 0,0:30:31.33,0:30:35.25,英文,,0,0,0,,As I consider elements, everyone who's traveled is in the right place.
Dialogue: 0,0:30:31.33,0:30:35.25,中文,,0,0,0,,当我考虑元素时 每个移动过的人都在正确的位置
Dialogue: 0,0:30:35.25,0:30:44.60,英文,,0,0,0,,Although they might have to temporarily shuffle around due to traveling, but once they're done traveling, everyone I've considered so far is in their right place.
Dialogue: 0,0:30:35.25,0:30:44.60,中文,,0,0,0,,虽然他们可能不得不因为旅行而暂时洗牌 但是一旦他们旅行结束 到目前为止我考虑过的每个人都在他们正确的位置
Dialogue: 0,0:30:44.60,0:30:46.08,英文,,0,0,0,,OK.
Dialogue: 0,0:30:44.60,0:30:46.08,中文,,0,0,0,,
Dialogue: 0,0:30:46.08,0:30:46.96,英文,,0,0,0,,Go, 17, go.
Dialogue: 0,0:30:46.08,0:30:46.96,中文,,0,0,0,,走 17 走
Dialogue: 0,0:30:46.96,0:30:48.68,英文,,0,0,0,,OK, you're there.
Dialogue: 0,0:30:46.96,0:30:48.68,中文,,0,0,0,,好的 你到了
Dialogue: 0,0:30:48.68,0:30:50.32,英文,,0,0,0,,That's insertion sort.
Dialogue: 0,0:30:48.68,0:30:50.32,中文,,0,0,0,,这就是插入排序
Dialogue: 0,0:30:50.32,0:30:52.91,英文,,0,0,0,,Thoughts before I tell you about the runtime?
Dialogue: 0,0:30:50.32,0:30:52.91,中文,,0,0,0,,在我告诉你运行时间之前有什么想法吗？
Dialogue: 0,0:30:52.91,0:30:56.37,英文,,0,0,0,,OK, so here are some examples in text.
Dialogue: 0,0:30:52.91,0:30:56.37,中文,,0,0,0,,好的 这里有一些文本示例
Dialogue: 0,0:30:56.37,0:31:00.57,英文,,0,0,0,,If you don't like them, because we have to do alphabetical sorting now, that's OK.
Dialogue: 0,0:30:56.37,0:31:00.57,中文,,0,0,0,,如果你不喜欢它们 因为我们现在必须按字母顺序排序 那没关系
Dialogue: 0,0:31:00.57,0:31:01.71,英文,,0,0,0,,It's the same idea.
Dialogue: 0,0:31:00.57,0:31:01.71,中文,,0,0,0,,这是同样的想法
Dialogue: 0,0:31:01.71,0:31:03.13,英文,,0,0,0,,So I have the word potato.
Dialogue: 0,0:31:01.71,0:31:03.13,中文,,0,0,0,,我有了单词 POTATO
Dialogue: 0,0:31:03.13,0:31:06.63,英文,,0,0,0,,And the way that I sort it is I look at the P. It travels backwards.
Dialogue: 0,0:31:03.13,0:31:06.63,中文,,0,0,0,,我排序的方式是看 P 它向后移动
Dialogue: 0,0:31:06.63,0:31:07.29,英文,,0,0,0,,Good.
Dialogue: 0,0:31:06.63,0:31:07.29,中文,,0,0,0,,
Dialogue: 0,0:31:07.29,0:31:09.35,英文,,0,0,0,,I look at the O. It travels backwards.
Dialogue: 0,0:31:07.29,0:31:09.35,中文,,0,0,0,,我看着 O 它向后移动
Dialogue: 0,0:31:09.35,0:31:12.89,英文,,0,0,0,,And now I have to be like, OK, H-I-J-K-L-M-N-O-P.
Dialogue: 0,0:31:09.35,0:31:12.89,中文,,0,0,0,,现在我必须像这样 好的 H-I-J-K-L-M-N-O-P
Dialogue: 0,0:31:12.89,0:31:13.71,英文,,0,0,0,,OK, good.
Dialogue: 0,0:31:12.89,0:31:13.71,中文,,0,0,0,,好的 很好
Dialogue: 0,0:31:13.71,0:31:16.88,英文,,0,0,0,,So O comes before P. So I have to do a swap.
Dialogue: 0,0:31:13.71,0:31:16.88,中文,,0,0,0,,所以 O 在 P 之前 所以我必须做一个交换
Dialogue: 0,0:31:16.88,0:31:21.26,英文,,0,0,0,,And then the T looks to his left and says, I'm to the right of P. That's OK.
Dialogue: 0,0:31:16.88,0:31:21.26,中文,,0,0,0,,然后 T 看向左边说 我在 P 的右边 没关系
Dialogue: 0,0:31:21.26,0:31:23.52,英文,,0,0,0,,No swaps have to be made.
Dialogue: 0,0:31:21.26,0:31:23.52,中文,,0,0,0,,不需要进行交换
Dialogue: 0,0:31:23.52,0:31:26.16,英文,,0,0,0,,Let's see, the next A.
Dialogue: 0,0:31:23.52,0:31:26.16,中文,,0,0,0,,让我们看看 下一个 A
Dialogue: 0,0:31:26.16,0:31:29.28,英文,,0,0,0,,Well, A is at the very beginning of the alphabet, so it has a long way to go.
Dialogue: 0,0:31:26.16,0:31:29.28,中文,,0,0,0,,嗯 A 在字母表的最开头 所以它还有很长的路要走
Dialogue: 0,0:31:29.28,0:31:31.61,英文,,0,0,0,,It has to travel all the way back to the front.
Dialogue: 0,0:31:29.28,0:31:31.61,中文,,0,0,0,,它必须一直回到最前面
Dialogue: 0,0:31:31.61,0:31:33.61,英文,,0,0,0,,Turns out that's three swaps.
Dialogue: 0,0:31:31.61,0:31:33.61,中文,,0,0,0,,结果是三次交换
Dialogue: 0,0:31:33.61,0:31:36.89,英文,,0,0,0,,Then this T looks to its left and says, no swapping necessary.
Dialogue: 0,0:31:33.61,0:31:36.89,中文,,0,0,0,,然后这个 T 看向左边说 不需要交换
Dialogue: 0,0:31:36.89,0:31:39.03,英文,,0,0,0,,This O has to swap a bit forward.
Dialogue: 0,0:31:36.89,0:31:39.03,中文,,0,0,0,,这个 O 必须向前交换一点
Dialogue: 0,0:31:39.03,0:31:40.35,英文,,0,0,0,,And so there's three swaps.
Dialogue: 0,0:31:39.03,0:31:40.35,中文,,0,0,0,,有三次交换
Dialogue: 0,0:31:40.35,0:31:44.36,英文,,0,0,0,,And so if I sort the word potato, I get a-oo-p-t-t-t.
Dialogue: 0,0:31:40.35,0:31:44.36,中文,,0,0,0,,如果我对单词 POTATO 进行排序 我会得到 A-OO-P-T-T-T
Dialogue: 0,0:31:44.36,0:31:48.33,英文,,0,0,0,,OK, that's the sort of potato.
Dialogue: 0,0:31:44.36,0:31:48.33,中文,,0,0,0,,好的 这就是 POTATO 的排序
Dialogue: 0,0:31:48.33,0:31:54.23,英文,,0,0,0,,This diagram, what I'm showing is, well, every time an element is the traveler, I marked it as purple.
Dialogue: 0,0:31:48.33,0:31:54.23,中文,,0,0,0,,这个图表 我展示的是 嗯 每次一个元素是旅行者时 我都会把它标记为紫色
Dialogue: 0,0:31:54.23,0:31:59.25,英文,,0,0,0,,And every element that's in black is an element that got swapped in the journey of the purple element.
Dialogue: 0,0:31:54.23,0:31:59.25,中文,,0,0,0,,每个黑色元素都是在紫色元素的旅程中被交换的元素
Dialogue: 0,0:31:59.25,0:32:04.86,英文,,0,0,0,,So for example, here, when I took the A and I swapped it all the way to the front
Dialogue: 0,0:31:59.25,0:32:04.86,中文,,0,0,0,,例如 在这里 当我取 A 并将其一直交换到最前面时 我必须将 A 与 T 交换
Dialogue: 0,0:32:04.86,0:32:09.86,英文,,0,0,0,,I had to swap A with T, and then with P, and then with O. So three swaps in total had to be made.
Dialogue: 0,0:32:04.86,0:32:09.86,中文,,0,0,0,,然后与 P 交换 然后与 O 交换 所以总共必须进行三次交换
Dialogue: 0,0:32:09.86,0:32:15.00,英文,,0,0,0,,By contrast, here, when I had the letter T, it looked to its left and said, no swapping necessary.
Dialogue: 0,0:32:09.86,0:32:15.00,中文,,0,0,0,,相反 在这里 当我有字母 T 时 它看向左边说 不需要交换
Dialogue: 0,0:32:15.00,0:32:17.98,英文,,0,0,0,,So at this step, The amount of work done was constant.
Dialogue: 0,0:32:15.00,0:32:17.98,中文,,0,0,0,,所以在这一步  所做的工作量是恒定的
Dialogue: 0,0:32:17.98,0:32:20.24,英文,,0,0,0,,There was no swapping done.
Dialogue: 0,0:32:17.98,0:32:20.24,中文,,0,0,0,,没有进行交换
Dialogue: 0,0:32:20.24,0:32:28.80,英文,,0,0,0,,So in total, if I did a count, I would say that this insertion sort took seven swaps.
Dialogue: 0,0:32:20.24,0:32:28.80,中文,,0,0,0,,总的来说 如果我进行计数 我会说这个插入排序进行了七次交换
Dialogue: 0,0:32:28.80,0:32:31.70,英文,,0,0,0,,Here's a larger example, which I will not say out loud.
Dialogue: 0,0:32:28.80,0:32:31.70,中文,,0,0,0,,这是一个更大的例子 我不会大声说出来
Dialogue: 0,0:32:31.70,0:32:38.36,英文,,0,0,0,,But if I took the word sort example and sorted the letters, every element gets to be the traveler exactly once.
Dialogue: 0,0:32:31.70,0:32:38.36,中文,,0,0,0,,但是如果我以 SORT EXAMPLE 这个词为例并对字母进行排序 每个元素都会成为一次旅行者
Dialogue: 0,0:32:38.36,0:32:47.01,英文,,0,0,0,,So if you look at the purple elements, S-O-R-T-E-X-A-M-P-L-E, every single letter gets to be the traveler exactly once.
Dialogue: 0,0:32:38.36,0:32:47.01,中文,,0,0,0,,如果你看一下紫色的元素 S-O-R-T-E-X-A-M-P-L-E 每个字母都会成为一次旅行者
Dialogue: 0,0:32:47.01,0:32:49.79,英文,,0,0,0,,And that's what each of these rows represents.
Dialogue: 0,0:32:47.01,0:32:49.79,中文,,0,0,0,,这就是每一行的含义
Dialogue: 0,0:32:49.79,0:32:52.01,英文,,0,0,0,,And all the elements in black.
Dialogue: 0,0:32:49.79,0:32:52.01,中文,,0,0,0,,以及所有黑色的元素
Dialogue: 0,0:32:52.01,0:32:56.01,英文,,0,0,0,,represent how long each element took to take its journey.
Dialogue: 0,0:32:52.01,0:32:56.01,中文,,0,0,0,,每一行代表每个元素移动所花费的时间
Dialogue: 0,0:32:56.01,0:33:04.82,英文,,0,0,0,,So for example, the E at the very end, when it was time to consider it, it had to take this long journey and swap all the way back here.
Dialogue: 0,0:32:56.01,0:33:04.82,中文,,0,0,0,,例如 最后的 E 当轮到它时 它必须经过漫长的旅程 一路交换回到这里
Dialogue: 0,0:33:04.82,0:33:11.36,英文,,0,0,0,,By contrast, when I looked at the X at this particular step, it looks to its left and says, well, the T is to my left.
Dialogue: 0,0:33:04.82,0:33:11.36,中文,,0,0,0,,相反 当我查看这一步的 X 时 它向左看 发现 T 在它的左边
Dialogue: 0,0:33:11.36,0:33:12.58,英文,,0,0,0,,I'm in the right place.
Dialogue: 0,0:33:11.36,0:33:12.58,中文,,0,0,0,,我已经在正确的位置了
Dialogue: 0,0:33:12.58,0:33:14.10,英文,,0,0,0,,No swaps have to be made.
Dialogue: 0,0:33:12.58,0:33:14.10,中文,,0,0,0,,不需要进行任何交换
Dialogue: 0,0:33:14.10,0:33:17.86,英文,,0,0,0,,So every row tells me a particular letter being considered.
Dialogue: 0,0:33:14.10,0:33:17.86,中文,,0,0,0,,每一行代表着正在考虑的一个特定字母
Dialogue: 0,0:33:17.86,0:33:21.70,英文,,0,0,0,,And all of the letters that are lit up in black represent
Dialogue: 0,0:33:17.86,0:33:21.70,中文,,0,0,0,,所有黑色高亮的字母代表着
Dialogue: 0,0:33:21.70,0:33:26.11,英文,,0,0,0,,The distance that that particular letter had to travel to find its rightful place.
Dialogue: 0,0:33:21.70,0:33:26.11,中文,,0,0,0,,该特定字母移动到正确位置所经过的距离
Dialogue: 0,0:33:26.11,0:33:31.17,英文,,0,0,0,,Or in other words, all the letters that had to be swapped with the purple element.
Dialogue: 0,0:33:26.11,0:33:31.17,中文,,0,0,0,,换句话说 所有需要与紫色元素交换的字母
Dialogue: 0,0:33:31.17,0:33:32.67,英文,,0,0,0,,So this one took 36 swaps.
Dialogue: 0,0:33:31.17,0:33:32.67,中文,,0,0,0,,这个需要 36 次交换
Dialogue: 0,0:33:32.67,0:33:36.02,英文,,0,0,0,,It's a larger word.
Dialogue: 0,0:33:32.67,0:33:36.02,中文,,0,0,0,,这是一个较长的单词
Dialogue: 0,0:33:36.02,0:33:39.14,英文,,0,0,0,,OK, so now we know how to count swaps.
Dialogue: 0,0:33:36.02,0:33:39.14,中文,,0,0,0,,好的 现在我们知道如何计算交换次数了
Dialogue: 0,0:33:39.14,0:33:44.36,英文,,0,0,0,,So the question for you is, how do we count swaps in terms of n?
Dialogue: 0,0:33:39.14,0:33:44.36,中文,,0,0,0,,那么问题来了 我们如何根据 N 来计算交换次数呢？
Dialogue: 0,0:33:44.36,0:33:49.29,英文,,0,0,0,,If I gave you an arbitrary word, or a list, or an array of size n,
Dialogue: 0,0:33:44.36,0:33:49.29,中文,,0,0,0,,如果我给你一个任意单词、列表或大小为 N 的数组
Dialogue: 0,0:33:49.29,0:33:55.29,英文,,0,0,0,, and I asked you how long insertion sort takes, in the best case, in the worst case, well, that's what I want you to think about.
Dialogue: 0,0:33:49.29,0:33:55.29,中文,,0,0,0,,然后问你插入排序在最好和最坏情况下需要多长时间 这就是我希望你思考的问题
Dialogue: 0,0:33:55.29,0:33:59.09,英文,,0,0,0,,So try and think about the best case.
Dialogue: 0,0:33:55.29,0:33:59.09,中文,,0,0,0,,试着想想最好的情况
Dialogue: 0,0:33:59.09,0:34:01.83,英文,,0,0,0,,And what's the worst case of insertion sort?
Dialogue: 0,0:33:59.09,0:34:01.83,中文,,0,0,0,,插入排序的最坏情况是什么？
Dialogue: 0,0:34:01.83,0:34:07.87,英文,,0,0,0,,What's the fewest number of swaps I would have to do if someone gave me a best case super lucky array?
Dialogue: 0,0:34:01.83,0:34:07.87,中文,,0,0,0,,如果有人给我一个最好的、超级幸运的数组 我最少需要做多少次交换？
Dialogue: 0,0:34:07.87,0:34:20.71,英文,,0,0,0,,And what's the worst number of swaps I'd have to do in terms of n, the length of the input, if someone gives me the worst possible array, where I have to do the most traveling I could possibly ever do?
Dialogue: 0,0:34:07.87,0:34:20.71,中文,,0,0,0,,如果有人给我一个最糟糕的数组 我需要进行尽可能多的移动 那么根据输入的长度 N 我最多需要做多少次交换？
Dialogue: 0,0:34:20.71,0:34:23.79,英文,,0,0,0,,OK, so try to think about it.
Dialogue: 0,0:34:20.71,0:34:23.79,中文,,0,0,0,,好的 试着思考一下
Dialogue: 0,0:34:23.79,0:34:30.14,英文,,0,0,0,,So if I look at this picture, I think about, what's the fewest number of swaps I could do at every layer?
Dialogue: 0,0:34:23.79,0:34:30.14,中文,,0,0,0,,如果我看着这张图 我会思考 在每一层我最少可以做多少次交换？
Dialogue: 0,0:34:30.14,0:34:38.08,英文,,0,0,0,,Well, the fewest number of swaps I could do is, what if I did no swaps at the first step, and then no swaps at the next step, and no swaps, and no swaps?
Dialogue: 0,0:34:30.14,0:34:38.08,中文,,0,0,0,,嗯 最少的交换次数是 如果我在第一步不做任何交换 然后在下一步也不做任何交换 以此类推？
Dialogue: 0,0:34:38.08,0:34:42.31,英文,,0,0,0,,So every element looks to its left and says, oh, there's nothing for me to do.
Dialogue: 0,0:34:38.08,0:34:42.31,中文,,0,0,0,,每个元素都向左看 然后说 哦 我没有需要做的
Dialogue: 0,0:34:42.31,0:34:42.85,英文,,0,0,0,,I would like that.
Dialogue: 0,0:34:42.31,0:34:42.85,中文,,0,0,0,,我希望这样
Dialogue: 0,0:34:42.85,0:34:43.67,英文,,0,0,0,,That would be nice.
Dialogue: 0,0:34:42.85,0:34:43.67,中文,,0,0,0,,那太好了
Dialogue: 0,0:34:43.67,0:34:47.86,英文,,0,0,0,,And in that case, at every single step, I would do constant work.
Dialogue: 0,0:34:43.67,0:34:47.86,中文,,0,0,0,,在这种情况下 在每一步 我都会做恒定的工作量
Dialogue: 0,0:34:47.86,0:34:50.52,英文,,0,0,0,,Every element looks to its left and says, loose swaps.
Dialogue: 0,0:34:47.86,0:34:50.52,中文,,0,0,0,,每个元素都向左看 然后说 没有交换
Dialogue: 0,0:34:50.52,0:34:53.70,英文,,0,0,0,,And so in that case, at every step, I do constant work.
Dialogue: 0,0:34:50.52,0:34:53.70,中文,,0,0,0,,在这种情况下 在每一步 我做的工作量都是恒定的
Dialogue: 0,0:34:53.70,0:34:57.77,英文,,0,0,0,,There are n steps, because I have to consider every letter at least once.
Dialogue: 0,0:34:53.70,0:34:57.77,中文,,0,0,0,,有 N 步 因为我必须至少考虑每个字母一次
Dialogue: 0,0:34:57.77,0:35:03.95,英文,,0,0,0,,So for that reason, I think the best case is n, or theta of n.
Dialogue: 0,0:34:57.77,0:35:03.95,中文,,0,0,0,,因此 我认为最好的情况是 N 或 θ(N)
Dialogue: 0,0:35:03.95,0:35:06.74,英文,,0,0,0,,or sorry, so I could say theta of n in the best case.
Dialogue: 0,0:35:03.95,0:35:06.74,中文,,0,0,0,,或者抱歉 所以我应该说在最好的情况下是 θ(N)
Dialogue: 0,0:35:06.74,0:35:12.68,英文,,0,0,0,,I could also say big omega of n, which is to say insertion sort is always n or worse.
Dialogue: 0,0:35:06.74,0:35:12.68,中文,,0,0,0,,我也可以说 Ω(N) 也就是说插入排序总是 N 或更差
Dialogue: 0,0:35:12.68,0:35:13.98,英文,,0,0,0,,It's up to you.
Dialogue: 0,0:35:12.68,0:35:13.98,中文,,0,0,0,,这取决于你
Dialogue: 0,0:35:13.98,0:35:19.84,英文,,0,0,0,,But I think that n is the lower bound asymptotically of insertion sort.
Dialogue: 0,0:35:13.98,0:35:19.84,中文,,0,0,0,,但我认为 N 是插入排序的渐近下界
Dialogue: 0,0:35:19.84,0:35:22.64,英文,,0,0,0,,And what kind of array would give you n?
Dialogue: 0,0:35:19.84,0:35:22.64,中文,,0,0,0,,什么样的数组会给你 N？
Dialogue: 0,0:35:22.64,0:35:27.23,英文,,0,0,0,,Well, it's if you always look to your left and the item is already in place.
Dialogue: 0,0:35:22.64,0:35:27.23,中文,,0,0,0,,嗯 如果你总是向左看 而项目已经在位了
Dialogue: 0,0:35:27.23,0:35:30.55,英文,,0,0,0,,So if you try it like a sorted array, well, then nobody will do any traveling.
Dialogue: 0,0:35:27.23,0:35:30.55,中文,,0,0,0,,如果你尝试像排序数组一样 那么没有人会做任何移动
Dialogue: 0,0:35:30.55,0:35:31.75,英文,,0,0,0,,You can try it at home.
Dialogue: 0,0:35:30.55,0:35:31.75,中文,,0,0,0,,你可以在家试试
Dialogue: 0,0:35:31.75,0:35:33.75,英文,,0,0,0,,And that will give you n time.
Dialogue: 0,0:35:31.75,0:35:33.75,中文,,0,0,0,,那会给你 N 的时间
Dialogue: 0,0:35:33.75,0:35:37.14,英文,,0,0,0,,Everyone looks to their left and says, there's no traveling for me to do.
Dialogue: 0,0:35:33.75,0:35:37.14,中文,,0,0,0,,每个人都向左看 然后说 我不用移动
Dialogue: 0,0:35:37.14,0:35:39.66,英文,,0,0,0,,So everyone performs zero swaps.
Dialogue: 0,0:35:37.14,0:35:39.66,中文,,0,0,0,,每个人都进行零次交换
Dialogue: 0,0:35:39.66,0:35:40.64,英文,,0,0,0,,So there's n elements.
Dialogue: 0,0:35:39.66,0:35:40.64,中文,,0,0,0,,所以有 N 个元素
Dialogue: 0,0:35:40.64,0:35:42.04,英文,,0,0,0,,I have to consider them all.
Dialogue: 0,0:35:40.64,0:35:42.04,中文,,0,0,0,,我必须全部考虑它们
Dialogue: 0,0:35:42.04,0:35:44.98,英文,,0,0,0,,Everyone checks to their left and says, no swapping for me to do.
Dialogue: 0,0:35:42.04,0:35:44.98,中文,,0,0,0,,每个人都向左检查 然后说 我不用交换
Dialogue: 0,0:35:44.98,0:35:47.11,英文,,0,0,0,,And that's n time.
Dialogue: 0,0:35:44.98,0:35:47.11,中文,,0,0,0,,那就是 N 的时间
Dialogue: 0,0:35:47.11,0:35:48.67,英文,,0,0,0,,What about the worst case?
Dialogue: 0,0:35:47.11,0:35:48.67,中文,,0,0,0,,最坏情况呢？
Dialogue: 0,0:35:48.67,0:35:58.82,英文,,0,0,0,,Well, the worst case is, what if this s had to travel as far as possible, and then the next element had to travel as far as possible, and this element had to travel as far as possible?
Dialogue: 0,0:35:48.67,0:35:58.82,中文,,0,0,0,,嗯 最坏的情况是 如果这个 S 必须尽可能地移动 然后下一个元素也必须尽可能地移动 以此类推？
Dialogue: 0,0:35:58.82,0:36:02.18,英文,,0,0,0,,What's the maximum distance everyone has to travel?
Dialogue: 0,0:35:58.82,0:36:02.18,中文,,0,0,0,,每个人最多要移动多远？
Dialogue: 0,0:36:02.18,0:36:05.43,英文,,0,0,0,,And remember, the distance also tells me how many swaps I have to do.
Dialogue: 0,0:36:02.18,0:36:05.43,中文,,0,0,0,,请记住 距离也告诉我需要做多少次交换
Dialogue: 0,0:36:05.43,0:36:08.07,英文,,0,0,0,,The more swaps I do, the slower the algorithm is.
Dialogue: 0,0:36:05.43,0:36:08.07,中文,,0,0,0,,我做的交换越多 算法就越慢
Dialogue: 0,0:36:08.07,0:36:11.99,英文,,0,0,0,,So this s, it's already at the end of the array, so it can do no swaps.
Dialogue: 0,0:36:08.07,0:36:11.99,中文,,0,0,0,,所以这个 S 它已经在数组的末尾 所以它不能做任何交换
Dialogue: 0,0:36:11.99,0:36:14.15,英文,,0,0,0,,Then this letter could do one swap.
Dialogue: 0,0:36:11.99,0:36:14.15,中文,,0,0,0,,那这个字母可以交换一次
Dialogue: 0,0:36:14.15,0:36:15.81,英文,,0,0,0,,This letter could do two swaps.
Dialogue: 0,0:36:14.15,0:36:15.81,中文,,0,0,0,,这个字母可以交换两次
Dialogue: 0,0:36:15.81,0:36:17.59,英文,,0,0,0,,This letter could do three swaps.
Dialogue: 0,0:36:15.81,0:36:17.59,中文,,0,0,0,,这个字母可以交换三次
Dialogue: 0,0:36:17.59,0:36:26.09,英文,,0,0,0,,This letter could do four, all the way until I get to the last letter, which could potentially, in the worst case, have to travel all the way back to the front of the array.
Dialogue: 0,0:36:17.59,0:36:26.09,中文,,0,0,0,,这个字母可以交换四次 一直到最后一个字母 在最坏的情况下 它可能需要一直回到数组的开头
Dialogue: 0,0:36:26.09,0:36:28.24,英文,,0,0,0,,That would be n swaps.
Dialogue: 0,0:36:26.09,0:36:28.24,中文,,0,0,0,,那将是 N 次交换
Dialogue: 0,0:36:28.24,0:36:37.14,英文,,0,0,0,,So my total sum would be 1 plus 2 plus 3 all the way up to n. And that gives me a theta of n squared bound in the worst case.
Dialogue: 0,0:36:28.24,0:36:37.14,中文,,0,0,0,,我的总和将是 1 加 2 加 3 一直到 N 这给了我在最坏情况下 θ(N^2) 界限
Dialogue: 0,0:36:37.14,0:36:44.80,英文,,0,0,0,,Or you could say big O of n squared to say selection sort is always n squared or better in all cases.
Dialogue: 0,0:36:37.14,0:36:44.80,中文,,0,0,0,,或者你可以说O(N^2)  表示选择排序在所有情况下总是 N^2或更好
Dialogue: 0,0:36:44.80,0:36:46.16,英文,,0,0,0,,So that's selection sort.
Dialogue: 0,0:36:44.80,0:36:46.16,中文,,0,0,0,,这就是选择排序
Dialogue: 0,0:36:46.16,0:36:50.24,英文,,0,0,0,,Best case, worst case, thoughts, questions?
Dialogue: 0,0:36:46.16,0:36:50.24,中文,,0,0,0,,最佳情况、最坏情况 想法、问题？
Dialogue: 0,0:36:50.24,0:36:54.23,英文,,0,0,0,,If I'm lucky, nobody travels, and it's theta of n time.
Dialogue: 0,0:36:50.24,0:36:54.23,中文,,0,0,0,,如果我幸运的话 没有人移动 那就是 θ(N) 时间
Dialogue: 0,0:36:54.23,0:36:58.31,英文,,0,0,0,,If I'm unlucky, everyone travels their maximum distance, and I get n squared.
Dialogue: 0,0:36:54.23,0:36:58.31,中文,,0,0,0,,如果我不走运 每个人都移动他们最大的距离 我得到 N^2
Dialogue: 0,0:36:58.31,0:37:02.81,英文,,0,0,0,,Also, if you like the prettiest geometric arguments, you could also count the number of swaps.
Dialogue: 0,0:36:58.31,0:37:02.81,中文,,0,0,0,,另外 如果你喜欢最漂亮的几何论证 你也可以计算交换的次数
Dialogue: 0,0:37:02.81,0:37:05.74,英文,,0,0,0,,You'll see you get the area of a triangle, which is kind of cool.
Dialogue: 0,0:37:02.81,0:37:05.74,中文,,0,0,0,,你会看到你得到了一个三角形的面积 这很酷
Dialogue: 0,0:37:05.74,0:37:09.26,英文,,0,0,0,,So that's another cool way to get the n squared, if you want.
Dialogue: 0,0:37:05.74,0:37:09.26,中文,,0,0,0,,这是另一种获得 N^2的方法 如果你愿意的话
Dialogue: 0,0:37:09.26,0:37:13.30,英文,,0,0,0,,Question?
Dialogue: 0,0:37:09.26,0:37:13.30,中文,,0,0,0,,问题？
Dialogue: 0,0:37:13.30,0:37:15.12,英文,,0,0,0,,The note at the bottom, yes.
Dialogue: 0,0:37:13.30,0:37:15.12,中文,,0,0,0,,底部的注释 是的
Dialogue: 0,0:37:15.12,0:37:19.30,英文,,0,0,0,,So it says, technically, I could say big omega of 1.
Dialogue: 0,0:37:15.12,0:37:19.30,中文,,0,0,0,,它说 从技术上讲 我可以说 O(1)
Dialogue: 0,0:37:19.30,0:37:24.33,英文,,0,0,0,,Because omega, and this is a good question, by the way, because these symbols always trip people up.
Dialogue: 0,0:37:19.30,0:37:24.33,中文,,0,0,0,,因为 omega 这是一个好问题 顺便说一句 因为这些符号总是让人困惑
Dialogue: 0,0:37:24.33,0:37:34.41,英文,,0,0,0,,So big omega basically says insertion sort is always running in time linear or worse.
Dialogue: 0,0:37:24.33,0:37:34.41,中文,,0,0,0,,所以 big omega 基本上说插入排序总是在线性时间或更糟的时间内运行
Dialogue: 0,0:37:34.41,0:37:35.49,英文,,0,0,0,,That's what big omega means.
Dialogue: 0,0:37:34.41,0:37:35.49,中文,,0,0,0,,这就是 big omega 的意思
Dialogue: 0,0:37:35.49,0:37:37.81,英文,,0,0,0,,You can think of it as greater than or equal to.
Dialogue: 0,0:37:35.49,0:37:37.81,中文,,0,0,0,,你可以把它想象成大于或等于
Dialogue: 0,0:37:37.81,0:37:41.47,英文,,0,0,0,,So the runtime is always n or worse.
Dialogue: 0,0:37:37.81,0:37:41.47,中文,,0,0,0,,运行时间总是 N 或更糟
Dialogue: 0,0:37:41.47,0:37:49.32,英文,,0,0,0,,And the way I can say that is I can say big omega of n. And that represents all of the functions that are bigger than n. So it could be n squared.
Dialogue: 0,0:37:41.47,0:37:49.32,中文,,0,0,0,,我可以这么说 我可以说 O(N) 这代表了所有大于 N 的函数 所以它可能是 N^2
Dialogue: 0,0:37:49.32,0:37:50.34,英文,,0,0,0,,It could be n cubed.
Dialogue: 0,0:37:49.32,0:37:50.34,中文,,0,0,0,,它可能是 N 立方
Dialogue: 0,0:37:50.34,0:37:51.66,英文,,0,0,0,,It could be n to the 100.
Dialogue: 0,0:37:50.34,0:37:51.66,中文,,0,0,0,,它可能是 N 的 100 次方
Dialogue: 0,0:37:51.66,0:37:53.79,英文,,0,0,0,,It could be 2 to the n, whatever.
Dialogue: 0,0:37:51.66,0:37:53.79,中文,,0,0,0,,它可能是 2 的 N 次方 随便什么
Dialogue: 0,0:37:53.79,0:37:58.98,英文,,0,0,0,,All of those functions are encapsulated in the family of omega of n.
Dialogue: 0,0:37:53.79,0:37:58.98,中文,,0,0,0,,所有这些函数都封装在 O(N) 家族中
Dialogue: 0,0:37:58.98,0:38:05.15,英文,,0,0,0,,But I could also say omega of 1, because it's still technically true that insertion sort is constant time or worse.
Dialogue: 0,0:37:58.98,0:38:05.15,中文,,0,0,0,,但我也可以说 O(1) 因为从技术上讲 插入排序是常数时间或更糟仍然是正确的
Dialogue: 0,0:38:05.15,0:38:10.79,英文,,0,0,0,,If I think about all the possible cases of insertion sort, they are all constant time or worse.
Dialogue: 0,0:38:05.15,0:38:10.79,中文,,0,0,0,,如果我考虑插入排序的所有可能情况 它们都是常数时间或更糟
Dialogue: 0,0:38:10.79,0:38:16.30,英文,,0,0,0,,That family of functions, which is larger, also includes all of those insertion sort runtimes.
Dialogue: 0,0:38:10.79,0:38:16.30,中文,,0,0,0,,这个函数族 它更大 也包括所有这些插入排序运行时间
Dialogue: 0,0:38:16.30,0:38:21.90,英文,,0,0,0,,So if you think of asymptotic bounds as like a family of functions, well then,
Dialogue: 0,0:38:16.30,0:38:21.90,中文,,0,0,0,,如果你把渐近界限想象成一个函数族 那么
Dialogue: 0,0:38:21.90,0:38:28.63,英文,,0,0,0,,all the runtimes of insertion sort, they fall into the big omega of n family, and they also fall into the big omega of 1 family.
Dialogue: 0,0:38:21.90,0:38:28.63,中文,,0,0,0,,所有插入排序的运行时间 它们都属于 O(N) 家族 也属于 O(1) 家族
Dialogue: 0,0:38:28.63,0:38:36.06,英文,,0,0,0,,But if you said big omega of 1, it's a little bit of a jerk move, because technically, big omega of n is a tighter bound.
Dialogue: 0,0:38:28.63,0:38:36.06,中文,,0,0,0,,但如果你说 O(1) 那有点像混蛋 因为从技术上讲 O(N) 是一个更紧密的界限
Dialogue: 0,0:38:36.06,0:38:41.00,英文,,0,0,0,,So the way I kind of think about this is, if you think back to numbers, and sorry, I'm digressing a little bit.
Dialogue: 0,0:38:36.06,0:38:41.00,中文,,0,0,0,,我对这个的看法是 如果你回想一下数字 抱歉 我有点跑题了
Dialogue: 0,0:38:41.00,0:38:48.97,英文,,0,0,0,,But let's say I was thinking about a secret number, and I told you the number I'm thinking of is greater than or equal to 7.
Dialogue: 0,0:38:41.00,0:38:48.97,中文,,0,0,0,,但假设我在想一个秘密数字 我告诉你我想到的数字大于或等于 7
Dialogue: 0,0:38:48.97,0:38:52.79,英文,,0,0,0,,Well, if my number was exactly 7, that might be useful to tell you.
Dialogue: 0,0:38:48.97,0:38:52.79,中文,,0,0,0,,嗯 如果我的数字正好是 7 那告诉你可能有用
Dialogue: 0,0:38:52.79,0:39:01.50,英文,,0,0,0,,But if I was thinking of a number like 7, and I said, the number I'm thinking of is at least 7, OK, that's good.
Dialogue: 0,0:38:52.79,0:39:01.50,中文,,0,0,0,,但如果我想到的是像 7 这样的数字 我说 我想到的数字至少是 7 好的 那很好
Dialogue: 0,0:39:01.50,0:39:02.98,英文,,0,0,0,,It's a tight bound.
Dialogue: 0,0:39:01.50,0:39:02.98,中文,,0,0,0,,这是一个紧密的界限
Dialogue: 0,0:39:02.98,0:39:07.14,英文,,0,0,0,,I could also tell you the number I'm thinking of is at least negative infinity.
Dialogue: 0,0:39:02.98,0:39:07.14,中文,,0,0,0,,我也可以告诉你我想到的数字至少是负无穷大
Dialogue: 0,0:39:07.14,0:39:09.54,英文,,0,0,0,,Sure, but that doesn't tell you as much information.
Dialogue: 0,0:39:07.14,0:39:09.54,中文,,0,0,0,,当然 但这并没有告诉你那么多信息
Dialogue: 0,0:39:09.54,0:39:11.17,英文,,0,0,0,,I'm kind of cheating by telling you that.
Dialogue: 0,0:39:09.54,0:39:11.17,中文,,0,0,0,,我告诉你这有点像作弊
Dialogue: 0,0:39:11.17,0:39:14.55,英文,,0,0,0,,So if that helps at all, that's another way of thinking of bounds.
Dialogue: 0,0:39:11.17,0:39:14.55,中文,,0,0,0,,如果这有帮助的话 这是另一种思考界限的方式
Dialogue: 0,0:39:14.55,0:39:19.64,英文,,0,0,0,,I want the bound to be as tight as possible to be the most informative.
Dialogue: 0,0:39:14.55,0:39:19.64,中文,,0,0,0,,我希望界限尽可能紧 以提供最多的信息
Dialogue: 0,0:39:19.64,0:39:22.90,英文,,0,0,0,,Ask me more about it later, but it's a good question.
Dialogue: 0,0:39:19.64,0:39:22.90,中文,,0,0,0,,以后再问我吧 但这是一个好问题
Dialogue: 0,0:39:22.90,0:39:24.28,英文,,0,0,0,,Anything else you want to know?
Dialogue: 0,0:39:22.90,0:39:24.28,中文,,0,0,0,,还有什么你想知道的？
Dialogue: 0,0:39:24.28,0:39:25.40,英文,,0,0,0,,That was a good digression.
Dialogue: 0,0:39:24.28,0:39:25.40,中文,,0,0,0,,那是一次很好的题外话
Dialogue: 0,0:39:25.40,0:39:26.72,英文,,0,0,0,,OK.
Dialogue: 0,0:39:25.40,0:39:26.72,中文,,0,0,0,,
Dialogue: 0,0:39:26.72,0:39:31.41,英文,,0,0,0,,But the important thing on this slide, by the way, is just that insertion sort, in the worst case, is linear time.
Dialogue: 0,0:39:26.72,0:39:31.41,中文,,0,0,0,,顺便说一句 这张幻灯片上的重点是 插入排序在最佳情况下是线性时间
Dialogue: 0,0:39:31.41,0:39:35.35,英文,,0,0,0,,And it's quadratic time, or n squared time, in the worst case.
Dialogue: 0,0:39:31.41,0:39:35.35,中文,,0,0,0,,在最坏情况下 它是二次时间 或者 N^2时间
Dialogue: 0,0:39:35.35,0:39:36.36,英文,,0,0,0,,OK.
Dialogue: 0,0:39:35.35,0:39:36.36,中文,,0,0,0,,
Dialogue: 0,0:39:36.36,0:39:37.06,英文,,0,0,0,,Good.
Dialogue: 0,0:39:36.36,0:39:37.06,中文,,0,0,0,,好
Dialogue: 0,0:39:37.06,0:39:41.92,英文,,0,0,0,,So we have now seen four sorts, and I've told you their worst-case run times right here.
Dialogue: 0,0:39:37.06,0:39:41.92,中文,,0,0,0,,我们已经看了四种排序 我在这边也告诉了你们它们的最坏情况运行时间
Dialogue: 0,0:39:41.92,0:39:48.10,英文,,0,0,0,,Selection sort and insertion sort are n squared time, heap sort and merge sort are n log n time.
Dialogue: 0,0:39:41.92,0:39:48.10,中文,,0,0,0,,选择排序和插入排序是 N^2时间 堆排序和归并排序是 N log N 时间
Dialogue: 0,0:39:48.10,0:39:55.18,英文,,0,0,0,,So here's an interesting puzzle for you then, which is, let's say I have a million integers and I merge sort them.
Dialogue: 0,0:39:48.10,0:39:55.18,中文,,0,0,0,,这里有一个有趣的问题 假设我有一百万个整数 然后我用归并排序对它们进行排序
Dialogue: 0,0:39:55.18,0:39:57.95,英文,,0,0,0,,So I read the integers, I merge sort them.
Dialogue: 0,0:39:55.18,0:39:57.95,中文,,0,0,0,,我读取这些整数 然后用归并排序对它们进行排序
Dialogue: 0,0:39:57.95,0:40:00.80,英文,,0,0,0,,After I merge sort the integers, are they sorted?
Dialogue: 0,0:39:57.95,0:40:00.80,中文,,0,0,0,,在我对这些整数进行归并排序之后 它们是有序的吗？
Dialogue: 0,0:40:00.80,0:40:02.26,英文,,0,0,0,,Yes, because I just sorted them.
Dialogue: 0,0:40:00.80,0:40:02.26,中文,,0,0,0,,是的 因为我刚对它们进行排序
Dialogue: 0,0:40:02.26,0:40:03.18,英文,,0,0,0,,Good.
Dialogue: 0,0:40:02.26,0:40:03.18,中文,,0,0,0,,好
Dialogue: 0,0:40:03.18,0:40:06.74,英文,,0,0,0,,And now, what if I took one number and I changed it?
Dialogue: 0,0:40:03.18,0:40:06.74,中文,,0,0,0,,如果我拿一个数字并改变它会怎么样？
Dialogue: 0,0:40:06.74,0:40:10.62,英文,,0,0,0,,So I have this million-length sorted array.
Dialogue: 0,0:40:06.74,0:40:10.62,中文,,0,0,0,,我有一个长度为一百万的有序数组
Dialogue: 0,0:40:10.62,0:40:12.87,英文,,0,0,0,,And I look through it, and I'm like, there's a number 5.
Dialogue: 0,0:40:10.62,0:40:12.87,中文,,0,0,0,,我浏览它 发现其中有一个数字 5
Dialogue: 0,0:40:12.87,0:40:15.45,英文,,0,0,0,,I'm going to change it to be negative 100.
Dialogue: 0,0:40:12.87,0:40:15.45,中文,,0,0,0,,我要把它改成负 100
Dialogue: 0,0:40:15.45,0:40:19.87,英文,,0,0,0,,Or I'm going to change it to be 20, or something like that.
Dialogue: 0,0:40:15.45,0:40:19.87,中文,,0,0,0,,或者把它改成 20 或者类似的数字
Dialogue: 0,0:40:19.87,0:40:25.30,英文,,0,0,0,,Then I want you to sort the resulting array using any algorithm that you want.
Dialogue: 0,0:40:19.87,0:40:25.30,中文,,0,0,0,,然后我想让你用任何你想要的算法对结果数组进行排序
Dialogue: 0,0:40:25.30,0:40:27.68,英文,,0,0,0,,Which one do you like best?
Dialogue: 0,0:40:25.30,0:40:27.68,中文,,0,0,0,,你最喜欢哪个？
Dialogue: 0,0:40:27.68,0:40:34.45,英文,,0,0,0,,If I guarantee for you that the array is totally sorted, but I took one element and I replaced it with some other number.
Dialogue: 0,0:40:27.68,0:40:34.45,中文,,0,0,0,,如果我向你保证 这个数组是完全有序的 但我取了一个元素 并用另一个数字替换它
Dialogue: 0,0:40:34.45,0:40:39.75,英文,,0,0,0,,So I took a 5 and I replaced it with negative 100 or something.
Dialogue: 0,0:40:34.45,0:40:39.75,中文,,0,0,0,,我取了一个 5 并把它替换成负 100 或者其他的数字
Dialogue: 0,0:40:39.75,0:40:42.08,英文,,0,0,0,,So it's kind of an interesting puzzle.
Dialogue: 0,0:40:39.75,0:40:42.08,中文,,0,0,0,,这是一个很有意思的问题
Dialogue: 0,0:40:42.08,0:40:51.26,英文,,0,0,0,,And maybe you get the answer from the story that I've been telling so far and the section that we're talking about right now, the specific sort.
Dialogue: 0,0:40:42.08,0:40:51.26,中文,,0,0,0,,也许你已经从我到目前为止讲的故事和我现在正在谈论的部分 也就是特定的排序中得到了答案
Dialogue: 0,0:40:51.26,0:40:57.79,英文,,0,0,0,,But if I had an array that was almost sorted in the sense that only one number was in the wrong place, which of these would be fastest?
Dialogue: 0,0:40:51.26,0:40:57.79,中文,,0,0,0,,但是 如果我有一个几乎有序的数组 即只有一个数字在错误的位置 那么哪种排序方法最快？
Dialogue: 0,0:40:57.79,0:41:05.55,英文,,0,0,0,,Well, turns out that if my array is almost sorted, insertion sort is actually really fast.
Dialogue: 0,0:40:57.79,0:41:05.55,中文,,0,0,0,,事实证明 如果我的数组几乎有序 那么插入排序实际上非常快
Dialogue: 0,0:41:05.55,0:41:10.48,英文,,0,0,0,,So for example, here's the array that I was just talking about, where almost everybody is sorted,
Dialogue: 0,0:41:05.55,0:41:10.48,中文,,0,0,0,,例如 这是我刚才提到的数组 几乎所有元素都是有序的
Dialogue: 0,0:41:10.48,0:41:17.48,英文,,0,0,0,,and the only person in the wrong place is this letter, which I've swapped out to be B, and all the other letters are in the right place.
Dialogue: 0,0:41:10.48,0:41:17.48,中文,,0,0,0,,唯一一个在错误位置的字母是我把它换成了 B 所有其他字母都在正确的位置
Dialogue: 0,0:41:17.48,0:41:27.85,英文,,0,0,0,,Well, because everyone's in the right place, if I did insertion sort, every element, A, E, E, L, M, O, everyone would look to their left and say, there's no traveling for me to do.
Dialogue: 0,0:41:17.48,0:41:27.85,中文,,0,0,0,,因为每个人都在正确的位置 如果我进行插入排序 每个元素 A、E、E、L、M、O 都会向左看 然后说 我不需要移动
Dialogue: 0,0:41:27.85,0:41:28.93,英文,,0,0,0,,The arrays are already sorted.
Dialogue: 0,0:41:27.85,0:41:28.93,中文,,0,0,0,,数组已经排序好了
Dialogue: 0,0:41:28.93,0:41:32.17,英文,,0,0,0,,If I look to my left, everyone to my left is less than myself.
Dialogue: 0,0:41:28.93,0:41:32.17,中文,,0,0,0,,如果我向左看 我左边所有的人都比我小
Dialogue: 0,0:41:32.17,0:41:35.19,英文,,0,0,0,,I have no sorting that needs to be done or no swapping.
Dialogue: 0,0:41:32.17,0:41:35.19,中文,,0,0,0,,我不需要做任何排序或交换
Dialogue: 0,0:41:35.19,0:41:45.16,英文,,0,0,0,,So every single letter does a constant amount of work until I get to the incorrect letter that I changed, which is B. That letter has to do a little bit of traveling to find its rightful place.
Dialogue: 0,0:41:35.19,0:41:45.16,中文,,0,0,0,,每个字母都做了一定的工作 直到我找到了我改变的那个错误的字母 也就是 B 这个字母需要移动一点才能找到它正确的位置
Dialogue: 0,0:41:45.16,0:41:49.93,英文,,0,0,0,,And everyone after that just looks to their left and says, there's no traveling for me to do.
Dialogue: 0,0:41:45.16,0:41:49.93,中文,,0,0,0,,在那之后的每个人都只是向左看 然后说 我不需要移动
Dialogue: 0,0:41:49.93,0:41:54.75,英文,,0,0,0,,So it turns out, if I only have arrays that are almost sorted.
Dialogue: 0,0:41:49.93,0:41:54.75,中文,,0,0,0,,事实证明  如果我只有几乎有序的数组
Dialogue: 0,0:41:54.75,0:41:57.45,英文,,0,0,0,,So for example, only one of the elements is wrong.
Dialogue: 0,0:41:54.75,0:41:57.45,中文,,0,0,0,,例如 只有一个元素是错误的
Dialogue: 0,0:41:57.45,0:41:59.61,英文,,0,0,0,,Or I maybe swap two of the elements.
Dialogue: 0,0:41:57.45,0:41:59.61,中文,,0,0,0,,或者我可能交换了两个元素
Dialogue: 0,0:41:59.61,0:42:08.64,英文,,0,0,0,,If I know somehow that my array is almost sorted, it turns out insertion sort is really good, because most of the letters don't have to do any traveling at all.
Dialogue: 0,0:41:59.61,0:42:08.64,中文,,0,0,0,,如果我以某种方式知道我的数组几乎是有序的 那么插入排序非常好 因为大多数字母根本不需要移动
Dialogue: 0,0:42:08.64,0:42:13.30,英文,,0,0,0,,And you just take the one problem, and you just fix it by traveling that one letter.
Dialogue: 0,0:42:08.64,0:42:13.30,中文,,0,0,0,,你只需要处理那个问题 通过移动那个字母来修复它
Dialogue: 0,0:42:13.30,0:42:18.88,英文,,0,0,0,,So I'll have to check all the letters, but most of them, the checking will be fast, because nobody does any traveling.
Dialogue: 0,0:42:13.30,0:42:18.88,中文,,0,0,0,,我必须检查所有字母 但对于大多数字母来说 检查速度很快 因为没有人需要移动
Dialogue: 0,0:42:18.88,0:42:25.25,英文,,0,0,0,,So it's kind of cool that even though, asymptotically, insertion sort chokes and gives you this bad runtime, it turns out it's actually,
Dialogue: 0,0:42:18.88,0:42:25.25,中文,,0,0,0,,即使在渐近情况下 插入排序会阻塞并给你这个糟糕的运行时间 但事实证明
Dialogue: 0,0:42:25.25,0:42:33.25,英文,,0,0,0,, even though it chokes and gives you the bad runtime, turns out that in specific cases like this, insertion sort does pretty well.
Dialogue: 0,0:42:25.25,0:42:33.25,中文,,0,0,0,,即使它阻塞并给你糟糕的运行时间 但在像这样的特定情况下 插入排序的表现相当不错 这很酷
Dialogue: 0,0:42:33.25,0:42:34.35,英文,,0,0,0,,It's kind of cool.
Dialogue: 0,0:42:33.25,0:42:34.35,中文,,0,0,0,,这很酷
Dialogue: 0,0:42:34.35,0:42:36.71,英文,,0,0,0,,And by contrast, you can try something like heap sort.
Dialogue: 0,0:42:34.35,0:42:36.71,中文,,0,0,0,,相比之下 你可以尝试像堆排序这样的方法
Dialogue: 0,0:42:36.71,0:42:39.33,英文,,0,0,0,,What would heap sort do on an almost sorted array?
Dialogue: 0,0:42:36.71,0:42:39.33,中文,,0,0,0,,堆排序对几乎有序的数组会做什么？
Dialogue: 0,0:42:39.33,0:42:42.54,英文,,0,0,0,,The first thing it would do would be turn this into a max heap.
Dialogue: 0,0:42:39.33,0:42:42.54,中文,,0,0,0,,它要做的第一件事就是把它变成一个最大堆
Dialogue: 0,0:42:42.54,0:42:44.22,英文,,0,0,0,,So this array is almost sorted.
Dialogue: 0,0:42:42.54,0:42:44.22,中文,,0,0,0,,这个数组几乎是有序的
Dialogue: 0,0:42:44.22,0:42:51.36,英文,,0,0,0,,Heap sort would like shuffle all the elements around, put the larger elements at the front and the smaller elements at the back to build your max heap.
Dialogue: 0,0:42:44.22,0:42:51.36,中文,,0,0,0,,堆排序会打乱所有元素的顺序 把较大的元素放在前面 较小的元素放在后面 以构建你的最大堆
Dialogue: 0,0:42:51.36,0:42:55.26,英文,,0,0,0,,And then it would delete everything out of the max heap and shuffle everything back in place.
Dialogue: 0,0:42:51.36,0:42:55.26,中文,,0,0,0,,然后它会从最大堆中删除所有内容 并将所有内容重新放置到位
Dialogue: 0,0:42:55.26,0:42:59.16,英文,,0,0,0,,So we can see kind of intuitively that if I used heap sort,
Dialogue: 0,0:42:55.26,0:42:59.16,中文,,0,0,0,,我们可以直观地看到 如果我使用堆排序
Dialogue: 0,0:42:59.16,0:43:02.70,英文,,0,0,0,,Things would be slower, because I have to mess up the whole array and then fix it.
Dialogue: 0,0:42:59.16,0:43:02.70,中文,,0,0,0,,事情会变慢 因为我必须把整个数组弄乱 然后再修复它
Dialogue: 0,0:43:02.70,0:43:05.24,英文,,0,0,0,,Whereas in this case, most of the array stays in place.
Dialogue: 0,0:43:02.70,0:43:05.24,中文,,0,0,0,,而在这种情况下 大部分数组都保持原样
Dialogue: 0,0:43:05.24,0:43:10.61,英文,,0,0,0,,And I just take the one mistake and I travel it backwards until it finds its right place.
Dialogue: 0,0:43:05.24,0:43:10.61,中文,,0,0,0,,我只是把那个错误的东西向后移动 直到它找到正确的位置
Dialogue: 0,0:43:10.61,0:43:15.81,英文,,0,0,0,,So for specific cases, insertion sort might be better.
Dialogue: 0,0:43:10.61,0:43:15.81,中文,,0,0,0,,在特定情况下 插入排序可能更好
Dialogue: 0,0:43:15.81,0:43:21.14,英文,,0,0,0,,So it turns out, for this particular case, I like insertion sort.
Dialogue: 0,0:43:15.81,0:43:21.14,中文,,0,0,0,,事实证明 对于这个特殊情况 我喜欢插入排序
Dialogue: 0,0:43:21.14,0:43:22.26,英文,,0,0,0,,OK.
Dialogue: 0,0:43:21.14,0:43:22.26,中文,,0,0,0,,
Dialogue: 0,0:43:22.26,0:43:24.42,英文,,0,0,0,,Here's another case where insertion sort does better.
Dialogue: 0,0:43:22.26,0:43:24.42,中文,,0,0,0,,再来看看插入排序表现更好的情况
Dialogue: 0,0:43:24.42,0:43:30.35,英文,,0,0,0,,And this one is not as obvious as the example I just showed to you, but I will describe it anyway.
Dialogue: 0,0:43:24.42,0:43:30.35,中文,,0,0,0,,这个例子不如我刚才展示的那么明显 但我还是会解释一下
Dialogue: 0,0:43:30.35,0:43:42.60,英文,,0,0,0,,It turns out that if arrays are very small, and by small, it's something you have to run experiments to find the exact number for, but it turns out around 15 or so is small for the purposes of this slide.
Dialogue: 0,0:43:30.35,0:43:42.60,中文,,0,0,0,,如果数组非常小 而这个“小”的具体数值需要通过实验来确定 但在这张幻灯片里 15左右就可以算是小的了
Dialogue: 0,0:43:42.60,0:43:46.16,英文,,0,0,0,,It turns out if I have a very small array, say 10 elements,
Dialogue: 0,0:43:42.60,0:43:46.16,中文,,0,0,0,,如果我有一个非常小的数组 比如10个元素
Dialogue: 0,0:43:46.16,0:43:47.93,英文,,0,0,0,,or seven elements.
Dialogue: 0,0:43:46.16,0:43:47.93,中文,,0,0,0,,或者7个元素
Dialogue: 0,0:43:47.93,0:43:53.45,英文,,0,0,0,,Turns out, if you just run experiments in real life, insertion sort turns out to just be faster than the others.
Dialogue: 0,0:43:47.93,0:43:53.45,中文,,0,0,0,,结果是 如果你在现实生活中进行实验 插入排序的速度会比其他排序快
Dialogue: 0,0:43:53.45,0:43:58.13,英文,,0,0,0,,This is one of those things that's hard to prove, necessarily, because the array is so small.
Dialogue: 0,0:43:53.45,0:43:58.13,中文,,0,0,0,,这是很难证明的事情之一 因为数组太小了
Dialogue: 0,0:43:58.13,0:44:03.24,英文,,0,0,0,,And remember, in asymptotic analysis, I care about n blowing up to infinity.
Dialogue: 0,0:43:58.13,0:44:03.24,中文,,0,0,0,,记住 在渐近分析中 我关心的是 N 趋近于无穷大
Dialogue: 0,0:44:03.24,0:44:06.74,英文,,0,0,0,,But in this case, I'm specifically concerned about arrays that are small.
Dialogue: 0,0:44:03.24,0:44:06.74,中文,,0,0,0,,但在这种情况下 我特别关注的是那些小的数组
Dialogue: 0,0:44:06.74,0:44:09.08,英文,,0,0,0,,So the analysis is a little bit different.
Dialogue: 0,0:44:06.74,0:44:09.08,中文,,0,0,0,,分析方法有点不同
Dialogue: 0,0:44:09.08,0:44:11.30,英文,,0,0,0,,It requires doing some real-life experiments.
Dialogue: 0,0:44:09.08,0:44:11.30,中文,,0,0,0,,它需要做一些现实生活中的实验
Dialogue: 0,0:44:11.30,0:44:16.81,英文,,0,0,0,,But it turns out that insertion sort is actually the fastest sort if your array is very small.
Dialogue: 0,0:44:11.30,0:44:16.81,中文,,0,0,0,,但事实证明 如果你的数组非常小 插入排序实际上是最快的排序
Dialogue: 0,0:44:16.81,0:44:23.23,英文,,0,0,0,,And the best picture that I can give to you is that, well, think about how you would merge sort an array of size 7.
Dialogue: 0,0:44:16.81,0:44:23.23,中文,,0,0,0,,我能给你的最好的图景是 想想你如何对一个大小为7的数组进行归并排序
Dialogue: 0,0:44:23.23,0:44:25.06,英文,,0,0,0,,Well, what would merge sort do?
Dialogue: 0,0:44:23.23,0:44:25.06,中文,,0,0,0,,那么 归并排序会做什么呢？
Dialogue: 0,0:44:25.06,0:44:27.54,英文,,0,0,0,,Merge sort does the thing where it's like, the array is size 7.
Dialogue: 0,0:44:25.06,0:44:27.54,中文,,0,0,0,,归并排序会说 这个数组的大小是7
Dialogue: 0,0:44:27.54,0:44:31.14,英文,,0,0,0,,So I'm going to give you half of the array, and I'll give you half of the array.
Dialogue: 0,0:44:27.54,0:44:31.14,中文,,0,0,0,,我要把一半的数组给你 把另一半的数组给你
Dialogue: 0,0:44:31.14,0:44:34.91,英文,,0,0,0,,We'll sort each half, and then we'll come back together and organize our results.
Dialogue: 0,0:44:31.14,0:44:34.91,中文,,0,0,0,,我们会对每一半进行排序 然后我们再一起回来组织我们的结果
Dialogue: 0,0:44:34.91,0:44:40.23,英文,,0,0,0,,So MergeSort is doing something like dividing and conquering, where it says, this array is big.
Dialogue: 0,0:44:34.91,0:44:40.23,中文,,0,0,0,,归并排序做的是类似分而治之的事情 它说 这个数组很大
Dialogue: 0,0:44:40.23,0:44:41.35,英文,,0,0,0,,You can take half of it.
Dialogue: 0,0:44:40.23,0:44:41.35,中文,,0,0,0,,你可以取它的一半
Dialogue: 0,0:44:41.35,0:44:42.57,英文,,0,0,0,,Then you take half of it.
Dialogue: 0,0:44:41.35,0:44:42.57,中文,,0,0,0,,然后你再取它的一半
Dialogue: 0,0:44:42.57,0:44:43.69,英文,,0,0,0,,And then afterwards, you finish.
Dialogue: 0,0:44:42.57,0:44:43.69,中文,,0,0,0,,然后 你就完成了
Dialogue: 0,0:44:43.69,0:44:45.77,英文,,0,0,0,,And we come back together, and we organize it.
Dialogue: 0,0:44:43.69,0:44:45.77,中文,,0,0,0,,我们再一起回来 把它组织起来
Dialogue: 0,0:44:45.77,0:44:48.20,英文,,0,0,0,,And then each of those halves says, OK, you get half.
Dialogue: 0,0:44:45.77,0:44:48.20,中文,,0,0,0,,然后每一半都说 好的 你拿一半
Dialogue: 0,0:44:48.20,0:44:49.00,英文,,0,0,0,,You get half.
Dialogue: 0,0:44:48.20,0:44:49.00,中文,,0,0,0,,你拿一半
Dialogue: 0,0:44:49.00,0:44:51.48,英文,,0,0,0,,We'll come back and organize our results with a merge.
Dialogue: 0,0:44:49.00,0:44:51.48,中文,,0,0,0,,我们会回来 用合并来组织我们的结果
Dialogue: 0,0:44:51.48,0:44:53.74,英文,,0,0,0,,And then on the right subarray, you take half.
Dialogue: 0,0:44:51.48,0:44:53.74,中文,,0,0,0,,然后在右边的子数组上 你拿一半
Dialogue: 0,0:44:53.74,0:44:54.30,英文,,0,0,0,,You take half.
Dialogue: 0,0:44:53.74,0:44:54.30,中文,,0,0,0,,你拿一半
Dialogue: 0,0:44:54.30,0:44:56.50,英文,,0,0,0,,And you come back and organize your results.
Dialogue: 0,0:44:54.30,0:44:56.50,中文,,0,0,0,,你回来 组织你的结果
Dialogue: 0,0:44:56.50,0:45:00.44,英文,,0,0,0,,So MergeSort is doing all this hard thinking of, OK, let's see.
Dialogue: 0,0:44:56.50,0:45:00.44,中文,,0,0,0,,归并排序做了所有这些费劲的思考 好的 让我们看看
Dialogue: 0,0:45:00.44,0:45:01.21,英文,,0,0,0,,Here's a subarray.
Dialogue: 0,0:45:00.44,0:45:01.21,中文,,0,0,0,,这是一个子数组
Dialogue: 0,0:45:01.21,0:45:01.91,英文,,0,0,0,,Here's a subarray.
Dialogue: 0,0:45:01.21,0:45:01.91,中文,,0,0,0,,这是一个子数组
Dialogue: 0,0:45:01.91,0:45:02.65,英文,,0,0,0,,Here's a subarray.
Dialogue: 0,0:45:01.91,0:45:02.65,中文,,0,0,0,,这是一个子数组
Dialogue: 0,0:45:02.65,0:45:04.72,英文,,0,0,0,,It's dividing up the work.
Dialogue: 0,0:45:02.65,0:45:04.72,中文,,0,0,0,,它在分割工作
Dialogue: 0,0:45:04.72,0:45:06.20,英文,,0,0,0,,But what does InsertionSort do?
Dialogue: 0,0:45:04.72,0:45:06.20,中文,,0,0,0,,但是插入排序做什么呢？
Dialogue: 0,0:45:06.20,0:45:07.62,英文,,0,0,0,,It says, well, forget all that.
Dialogue: 0,0:45:06.20,0:45:07.62,中文,,0,0,0,,它说 好吧 忘记这一切吧
Dialogue: 0,0:45:07.62,0:45:10.22,英文,,0,0,0,,I'll just swap every element into its right place.
Dialogue: 0,0:45:07.62,0:45:10.22,中文,,0,0,0,,我只是把每个元素都交换到正确的位置
Dialogue: 0,0:45:10.22,0:45:18.46,英文,,0,0,0,,So while MergeSort is sitting there delegating all the work and saying, OK, you do this half, and you do this half, and then you do this quarter,
Dialogue: 0,0:45:10.22,0:45:18.46,中文,,0,0,0,,当归并排序在那里分配所有工作 说 你做这一半 你做这一半 然后你做这一部分 你做这一部分
Dialogue: 0,0:45:18.46,0:45:25.46,英文,,0,0,0,,you do this quarter, well, by the time MergeSort is done doing all the splitting, InsertionSort has probably already finished sorting the array.
Dialogue: 0,0:45:18.46,0:45:25.46,中文,,0,0,0,,那么 当归并排序完成所有分割的时候 插入排序可能已经完成了对数组的排序
Dialogue: 0,0:45:25.46,0:45:27.06,英文,,0,0,0,,So that's my rough intuitive picture.
Dialogue: 0,0:45:25.46,0:45:27.06,中文,,0,0,0,,这就是我粗略的直观图景
Dialogue: 0,0:45:27.06,0:45:28.53,英文,,0,0,0,,It's not a proof.
Dialogue: 0,0:45:27.06,0:45:28.53,中文,,0,0,0,,这不是一个证明
Dialogue: 0,0:45:28.53,0:45:38.38,英文,,0,0,0,,But it kind of gets to the idea that merge sort is very concerned with organizing its sort, whereas for a very small array like this, you might as well just get it done using insertion sort.
Dialogue: 0,0:45:28.53,0:45:38.38,中文,,0,0,0,,但它有点说明了归并排序非常关心组织它的排序 而对于像这样非常小的数组 你不如直接用插入排序来完成它
Dialogue: 0,0:45:38.38,0:45:39.46,英文,,0,0,0,,OK.
Dialogue: 0,0:45:38.38,0:45:39.46,中文,,0,0,0,,
Dialogue: 0,0:45:39.46,0:45:46.90,英文,,0,0,0,,By the way, kind of cool fact is that if you look inside Java, which has implementations for things like merge sort, it turns out
Dialogue: 0,0:45:39.46,0:45:46.90,中文,,0,0,0,,顺便说一下 一个很酷的事实是 如果你查看Java内部 它有像归并排序这样的实现
Dialogue: 0,0:45:46.90,0:45:53.90,英文,,0,0,0,,that if you go into Java and you check the implementation of merge sort, which I won't click on, it actually does this, which is if the array is very small,
Dialogue: 0,0:45:46.90,0:45:53.90,中文,,0,0,0,,如果你进入Java并检查归并排序的实现 我不会点击它 它实际上是这样做的 如果数组非常小
Dialogue: 0,0:45:53.90,0:46:00.90,英文,,0,0,0,,you split and split and split, and the array gets to a small size, it doesn't actually split all the way until the arrays are of size one.
Dialogue: 0,0:45:53.90,0:46:00.90,中文,,0,0,0,,你分割分割再分割 数组达到一个小的尺寸 它实际上不会一直分割到数组的尺寸为1
Dialogue: 0,0:46:00.90,0:46:05.10,英文,,0,0,0,,It just splits until the arrays are small enough and then does insertion sort.
Dialogue: 0,0:46:00.90,0:46:05.10,中文,,0,0,0,,它只是分割到数组足够小 然后做插入排序
Dialogue: 0,0:46:05.10,0:46:07.00,英文,,0,0,0,,So it doesn't merge sort all the way to the bottom.
Dialogue: 0,0:46:05.10,0:46:07.00,中文,,0,0,0,,它不会一直归并排序到底
Dialogue: 0,0:46:07.00,0:46:09.40,英文,,0,0,0,,It calls it quits once the array is small enough.
Dialogue: 0,0:46:07.00,0:46:09.40,中文,,0,0,0,,一旦数组足够小 它就停止了
Dialogue: 0,0:46:09.40,0:46:10.66,英文,,0,0,0,,It does insertion sort.
Dialogue: 0,0:46:09.40,0:46:10.66,中文,,0,0,0,,它做插入排序
Dialogue: 0,0:46:10.66,0:46:14.34,英文,,0,0,0,,It turns out to be faster in real life.
Dialogue: 0,0:46:10.66,0:46:14.34,中文,,0,0,0,,结果证明 在现实生活中 它更快
Dialogue: 0,0:46:14.34,0:46:14.94,英文,,0,0,0,,OK.
Dialogue: 0,0:46:14.34,0:46:14.94,中文,,0,0,0,,
Dialogue: 0,0:46:14.94,0:46:17.36,英文,,0,0,0,,At this point, you've seen four sorts.
Dialogue: 0,0:46:14.94,0:46:17.36,中文,,0,0,0,,至此 你已经看到了四种排序
Dialogue: 0,0:46:17.36,0:46:18.42,英文,,0,0,0,,And there's actually more out there.
Dialogue: 0,0:46:17.36,0:46:18.42,中文,,0,0,0,,实际上还有更多
Dialogue: 0,0:46:18.42,0:46:20.03,英文,,0,0,0,,And we'll see one more probably next time.
Dialogue: 0,0:46:18.42,0:46:20.03,中文,,0,0,0,,下次我们可能会再看一个
Dialogue: 0,0:46:20.03,0:46:22.07,英文,,0,0,0,,But there are four sorts.
Dialogue: 0,0:46:20.03,0:46:22.07,中文,,0,0,0,,但总共有四种排序算法
Dialogue: 0,0:46:22.07,0:46:23.63,英文,,0,0,0,,And by the way, this is the point.
Dialogue: 0,0:46:22.07,0:46:23.63,中文,,0,0,0,,顺便说一下 这就是重点
Dialogue: 0,0:46:23.63,0:46:26.07,英文,,0,0,0,,And I think I'll have a slide for this, hopefully.
Dialogue: 0,0:46:23.63,0:46:26.07,中文,,0,0,0,,我希望我有一张幻灯片来解释这一点
Dialogue: 0,0:46:26.07,0:46:26.85,英文,,0,0,0,,OK.
Dialogue: 0,0:46:26.07,0:46:26.85,中文,,0,0,0,,
Dialogue: 0,0:46:26.85,0:46:35.01,英文,,0,0,0,,This is the point where you're probably sitting here and you're thinking, I feel like I have just seen the same algorithm four times.
Dialogue: 0,0:46:26.85,0:46:35.01,中文,,0,0,0,,在这一点上 你可能坐在那里想 我觉得我好像已经四次看到相同的算法了
Dialogue: 0,0:46:35.01,0:46:39.85,英文,,0,0,0,,And the reason why you're thinking that is, you have basically seen the same algorithm four times.
Dialogue: 0,0:46:35.01,0:46:39.85,中文,,0,0,0,,你之所以这么想 是因为你基本上已经四次看到相同的算法了
Dialogue: 0,0:46:39.85,0:46:49.06,英文,,0,0,0,,So this is the point where it's very easy to get lost in all the sorts and the operations and say, what's the real difference between selection sort and insertion sort?
Dialogue: 0,0:46:39.85,0:46:49.06,中文,,0,0,0,,很容易在各种排序和操作中迷失 然后说 选择排序和插入排序之间有什么真正的区别？
Dialogue: 0,0:46:49.06,0:46:51.52,英文,,0,0,0,,Or what's the difference between heap sort and merge sort?
Dialogue: 0,0:46:49.06,0:46:51.52,中文,,0,0,0,,或者堆排序和归并排序之间有什么区别？
Dialogue: 0,0:46:51.52,0:46:53.32,英文,,0,0,0,,They're both n log n runtime.
Dialogue: 0,0:46:51.52,0:46:53.32,中文,,0,0,0,,它们都是 N log N 运行时间
Dialogue: 0,0:46:53.32,0:46:59.89,英文,,0,0,0,,So to me, The way to separate out the sorts, because it's very tricky to confuse them
Dialogue: 0,0:46:53.32,0:46:59.89,中文,,0,0,0,,对我来说  区分排序的方法 因为很容易混淆它们
Dialogue: 0,0:46:59.89,0:47:07.89,英文,,0,0,0,,and feel like you just saw the same thing over and over again, is I try to think about what's the operation that makes the sort work.
Dialogue: 0,0:46:59.89,0:47:07.89,中文,,0,0,0,,感觉你只是看到了相同的事情一遍又一遍 我是尝试思考使排序起作用的操作是什么
Dialogue: 0,0:47:07.89,0:47:14.73,英文,,0,0,0,,So for example, in selection sort, what was the operation I was doing over and over and over again to make the sort work?
Dialogue: 0,0:47:07.89,0:47:14.73,中文,,0,0,0,,例如 在选择排序中 我一遍又一遍地做的是什么操作来使排序起作用？
Dialogue: 0,0:47:14.73,0:47:17.34,英文,,0,0,0,,It was find the smallest item.
Dialogue: 0,0:47:14.73,0:47:17.34,中文,,0,0,0,,找到最小的项
Dialogue: 0,0:47:17.34,0:47:26.86,英文,,0,0,0,,So the key operation that made selection sort work, and also heap sort by extension, is you find the smallest item over and over and over again.
Dialogue: 0,0:47:17.34,0:47:26.86,中文,,0,0,0,,使选择排序起作用的关键操作 以及扩展的堆排序 就是一遍又一遍地找到最小的项
Dialogue: 0,0:47:26.86,0:47:31.68,英文,,0,0,0,,So I can maybe even call it something like find the smallest item sort.
Dialogue: 0,0:47:26.86,0:47:31.68,中文,,0,0,0,,我甚至可以称它为“找到最小项排序”之类的东西
Dialogue: 0,0:47:31.68,0:47:36.36,英文,,0,0,0,,That's not what they call it, but that's the key idea that makes selection sort work.
Dialogue: 0,0:47:31.68,0:47:36.36,中文,,0,0,0,,这不是他们所说的 但这是使选择排序起作用的关键思想
Dialogue: 0,0:47:36.36,0:47:42.87,英文,,0,0,0,,By contrast, InsertionSort, which might have felt really similar, it uses an- another core operation that's different.
Dialogue: 0,0:47:36.36,0:47:42.87,中文,,0,0,0,,相比之下 Insertion sort(插入排序)可能感觉非常相似 它使用另一个不同的核心操作
Dialogue: 0,0:47:42.87,0:47:44.51,英文,,0,0,0,,It does not find the smallest element.
Dialogue: 0,0:47:42.87,0:47:44.51,中文,,0,0,0,,它没有找到最小的元素
Dialogue: 0,0:47:44.51,0:47:48.49,英文,,0,0,0,,You go back and look at InsertionSort, we never bothered finding the smallest element.
Dialogue: 0,0:47:44.51,0:47:48.49,中文,,0,0,0,,你回去看看 插入排序 我们从来没有费心找到最小的元素
Dialogue: 0,0:47:48.49,0:47:51.86,英文,,0,0,0,,Instead, we figured out where to put the current item.
Dialogue: 0,0:47:48.49,0:47:51.86,中文,,0,0,0,,相反 我们弄清楚了当前项应该放在哪里
Dialogue: 0,0:47:51.86,0:48:02.81,英文,,0,0,0,,So the key idea that makes InsertionSort work, the operation you do over and over again, is that traveling operation where you find out where the item needs to go.
Dialogue: 0,0:47:51.86,0:48:02.81,中文,,0,0,0,,所以使插入排序起作用的关键思想 你一遍又一遍地做的操作 就是那个旅行操作 在那里你找出项目需要去哪里
Dialogue: 0,0:48:02.81,0:48:04.07,英文,,0,0,0,,And what about merge sort?
Dialogue: 0,0:48:02.81,0:48:04.07,中文,,0,0,0,,那归并排序呢？
Dialogue: 0,0:48:04.07,0:48:05.89,英文,,0,0,0,,It didn't do either of these ideas.
Dialogue: 0,0:48:04.07,0:48:05.89,中文,,0,0,0,,它没有做这两个想法中的任何一个
Dialogue: 0,0:48:05.89,0:48:12.37,英文,,0,0,0,,The core idea that made merge sort work, the operation you do over and over and over again, is I have two sorted arrays.
Dialogue: 0,0:48:05.89,0:48:12.37,中文,,0,0,0,,使归并排序起作用的核心思想 你一遍又一遍地做的操作 是我有两个已排序的数组
Dialogue: 0,0:48:12.37,0:48:16.43,英文,,0,0,0,,How do I combine them into one larger sorted array?
Dialogue: 0,0:48:12.37,0:48:16.43,中文,,0,0,0,,如何将它们组合成一个更大的已排序数组？
Dialogue: 0,0:48:16.43,0:48:22.97,英文,,0,0,0,,So every flavor of sort that you've seen so far is backed by a specific core idea.
Dialogue: 0,0:48:16.43,0:48:22.97,中文,,0,0,0,,你到目前为止看到的每一种排序算法都以一个特定的核心思想为基础
Dialogue: 0,0:48:22.97,0:48:29.56,英文,,0,0,0,,And if you're ever feeling like, I feel like I've seen the same sort of five times at this point, these are the ideas that I think of to tease them apart.
Dialogue: 0,0:48:22.97,0:48:29.56,中文,,0,0,0,,如果你曾经觉得 我觉得我已经看到过五次相同的排序了 这些是我想到的用来区分它们的想法
Dialogue: 0,0:48:29.56,0:48:33.16,英文,,0,0,0,,So I'll give you a quick a quick sort preview.
Dialogue: 0,0:48:29.56,0:48:33.16,中文,,0,0,0,,我会给你一个快速的快速排序预览
Dialogue: 0,0:48:33.16,0:48:38.72,英文,,0,0,0,,I was going to say a quick quick sort preview, which also works, and then we'll come back next time and talk about it.
Dialogue: 0,0:48:33.16,0:48:38.72,中文,,0,0,0,,我本来想说一个快速的快速排序预览 这也行 然后我们下次再回来讨论它
Dialogue: 0,0:48:38.72,0:48:41.18,英文,,0,0,0,,So it turns out quick sort also has an idea.
Dialogue: 0,0:48:38.72,0:48:41.18,中文,,0,0,0,,事实证明 快速排序也有一个想法
Dialogue: 0,0:48:41.18,0:48:46.17,英文,,0,0,0,,But the idea is going to take me one whole lecture to explain, which I will do next time.
Dialogue: 0,0:48:41.18,0:48:46.17,中文,,0,0,0,,但是这个想法需要我用整整一节课来解释 我下次会这样做
Dialogue: 0,0:48:46.17,0:48:55.59,英文,,0,0,0,,And basically, it also has this extremely weird backstory, which I'll briefly mention, which is that the person who invented QuickSort was Tony Hoare.
Dialogue: 0,0:48:46.17,0:48:55.59,中文,,0,0,0,,基本上 它也有一个非常奇怪的背景故事 我将简要提及 那就是发明 QuickSort(快速排序)的人是 ToNy Hoare
Dialogue: 0,0:48:55.59,0:48:58.59,英文,,0,0,0,,He was trying to work on this machine translation algorithm.
Dialogue: 0,0:48:55.59,0:48:58.59,中文,,0,0,0,,他当时正在研究这个机器翻译算法
Dialogue: 0,0:48:58.59,0:49:01.89,英文,,0,0,0,,And this is 1960, so the algorithm wasn't sophisticated at all.
Dialogue: 0,0:48:58.59,0:49:01.89,中文,,0,0,0,,这是 1960 年 所以这个算法一点也不复杂
Dialogue: 0,0:49:01.89,0:49:03.05,英文,,0,0,0,,Here are some details.
Dialogue: 0,0:49:01.89,0:49:03.05,中文,,0,0,0,,以下是一些细节
Dialogue: 0,0:49:03.05,0:49:10.96,英文,,0,0,0,,But basically, somewhere in his algorithm, because it's 1960 and hardware was really bad, he had to sort a sentence.
Dialogue: 0,0:49:03.05,0:49:10.96,中文,,0,0,0,,但基本上 在他的算法中的某个地方 因为那是 1960 年 硬件真的很糟糕 他必须对一个句子进行排序
Dialogue: 0,0:49:10.96,0:49:13.04,英文,,0,0,0,,And this is 1960. There's no Google.
Dialogue: 0,0:49:10.96,0:49:13.04,中文,,0,0,0,,这是 1960 年  没有 Google
Dialogue: 0,0:49:13.04,0:49:16.32,英文,,0,0,0,,There's no ChatGPT to ask, how do you sort something?
Dialogue: 0,0:49:13.04,0:49:16.32,中文,,0,0,0,,也没有 ChatGPT 可以问 你如何排序？
Dialogue: 0,0:49:16.32,0:49:18.20,英文,,0,0,0,,So he had to come up with the sort himself.
Dialogue: 0,0:49:16.32,0:49:18.20,中文,,0,0,0,,他必须自己想出排序方法
Dialogue: 0,0:49:18.20,0:49:26.35,英文,,0,0,0,,And what you're about to see next time, which will take me basically one hour to explain, will be Tony Hoare's first idea from 1960.
Dialogue: 0,0:49:18.20,0:49:26.35,中文,,0,0,0,,下次你将看到的内容 我基本上需要一个小时来解释 将是 ToNy Hoare 在 1960 年的第一个想法
Dialogue: 0,0:49:26.35,0:49:31.87,英文,,0,0,0,,So how a novice programmer came up with something that you and I will take an hour to explain is beyond me.
Dialogue: 0,0:49:26.35,0:49:31.87,中文,,0,0,0,,一个新手程序员如何想出一些你我需要一个小时才能解释的东西 我无法理解
Dialogue: 0,0:49:31.87,0:49:33.83,英文,,0,0,0,,But that's going to happen next time.
Dialogue: 0,0:49:31.87,0:49:33.83,中文,,0,0,0,,但这将在下次发生
Dialogue: 0,0:49:33.83,0:49:39.78,英文,,0,0,0,,Do you have any final thoughts or questions before I leave you on this quicksort cliffhanger?
Dialogue: 0,0:49:33.83,0:49:39.78,中文,,0,0,0,,在我让你带着这个快速排序的悬念离开之前 你还有什么想法或问题吗？
Dialogue: 0,0:49:39.78,0:49:42.21,英文,,0,0,0,,Did I actually finish early today?
Dialogue: 0,0:49:39.78,0:49:42.21,中文,,0,0,0,,我今天真的提前结束了吗？
Dialogue: 0,0:49:42.21,0:49:43.57,英文,,0,0,0,,I finished like 10 seconds early.
Dialogue: 0,0:49:42.21,0:49:43.57,中文,,0,0,0,,我提前了 10 秒钟结束
Dialogue: 0,0:49:43.57,0:49:46.19,英文,,0,0,0,,OK, go enjoy your extra 10 seconds of freedom.
Dialogue: 0,0:49:43.57,0:49:46.19,中文,,0,0,0,,好的 去享受你额外的 10 秒钟的自由吧
Dialogue: 0,0:49:46.19,0:49:47.28,英文,,0,0,0,,I'll see you next time.
Dialogue: 0,0:49:46.19,0:49:47.28,中文,,0,0,0,,下次见
