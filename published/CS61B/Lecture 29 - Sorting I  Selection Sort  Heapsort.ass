[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 3
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Export Encoding: Unicode (UTF-8)
Audio File: D:/python_code/video_tool/video_tool/result/Lecture 02.1 - Number Representation Intro, Bits can be anything.mp4
Video File: D:/python_code/video_tool/video_tool/result/Lecture 02.1 - Number Representation Intro, Bits can be anything.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.375000
Scroll Position: 920
Active Line: 923
Video Position: 8466

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,14,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.33333,1.33333,2,6,6,8,1
Style: 英文,Arial,24,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1.33333,1.33333,2,2,2,6,1
Style: 中文,微软雅黑,38,&H0029EEF1,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1.33333,1.33333,2,2,2,20,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,
Dialogue: 0,0:00:04.24,0:00:06.79,英文,,0,0,0,,OK, hi.
Dialogue: 0,0:00:04.24,0:00:06.79,中文,,0,0,0,,好 大家好
Dialogue: 0,0:00:06.79,0:00:08.78,英文,,0,0,0,,Hope your spring break went well.
Dialogue: 0,0:00:06.79,0:00:08.78,中文,,0,0,0,,希望你们的春假过得愉快
Dialogue: 0,0:00:08.78,0:00:12.34,英文,,0,0,0,,So today starts the last part of the class, which I'm excited about.
Dialogue: 0,0:00:08.78,0:00:12.34,中文,,0,0,0,,今天开始课程的最后一部分 我很期待
Dialogue: 0,0:00:12.34,0:00:14.68,英文,,0,0,0,,So we're done with spring break.
Dialogue: 0,0:00:12.34,0:00:14.68,中文,,0,0,0,,春假结束了
Dialogue: 0,0:00:14.68,0:00:16.27,英文,,0,0,0,,We only have one more topic left.
Dialogue: 0,0:00:14.68,0:00:16.27,中文,,0,0,0,,我们只剩下一个主题了
Dialogue: 0,0:00:16.27,0:00:19.39,英文,,0,0,0,,So the rest of all the lectures will be mostly about sorting.
Dialogue: 0,0:00:16.27,0:00:19.39,中文,,0,0,0,,剩下的所有课程主要都是关于排序的
Dialogue: 0,0:00:19.39,0:00:23.73,英文,,0,0,0,,There will be a couple of optional software engineering lectures, which are kind of fun, so stop by.
Dialogue: 0,0:00:19.39,0:00:23.73,中文,,0,0,0,,还会有几节可选的软件工程课 很有意思 所以请来参加
Dialogue: 0,0:00:23.73,0:00:26.97,英文,,0,0,0,,But sorting is the last major topic we have to do.
Dialogue: 0,0:00:23.73,0:00:26.97,中文,,0,0,0,,但排序是我们最后一个主要议题
Dialogue: 0,0:00:26.97,0:00:33.92,英文,,0,0,0,,We're done with all the data structures, which is great, I guess, except these topics, which I forgot to cover before spring break.
Dialogue: 0,0:00:26.97,0:00:33.92,中文,,0,0,0,,我们已经完成了所有的数据结构 这很好 我想 除了这些主题 我忘了在春假前讲
Dialogue: 0,0:00:33.92,0:00:38.76,英文,,0,0,0,,So I'll do these, and then we'll be fully into the sorting unit of the class.
Dialogue: 0,0:00:33.92,0:00:38.76,中文,,0,0,0,,我先讲这些 然后我们就正式进入课程的排序单元
Dialogue: 0,0:00:38.76,0:00:39.60,英文,,0,0,0,,Fun.
Dialogue: 0,0:00:38.76,0:00:39.60,中文,,0,0,0,,有趣
Dialogue: 0,0:00:39.60,0:00:51.66,英文,,0,0,0,,OK, so before spring break, I told you all about the try, which was this character-by-character data structure, which is used to source sets or maps of strings.
Dialogue: 0,0:00:39.60,0:00:51.66,中文,,0,0,0,,在春假前 我给大家讲了 trie 这是一个逐字符的数据结构 用于存储字符串的集合或映射
Dialogue: 0,0:00:51.66,0:00:55.24,英文,,0,0,0,,So this is being used to represent a set of strings.
Dialogue: 0,0:00:51.66,0:00:55.24,中文,,0,0,0,,它被用来表示一个字符串集合
Dialogue: 0,0:00:55.24,0:00:58.43,英文,,0,0,0,,I could also use it to represent a map of strings.
Dialogue: 0,0:00:55.24,0:00:58.43,中文,,0,0,0,,我也可以用它来表示字符串的映射
Dialogue: 0,0:00:58.43,0:01:02.97,英文,,0,0,0,,And we said that tries have really good performance, constant-time performance.
Dialogue: 0,0:00:58.43,0:01:02.97,中文,,0,0,0,,我们说过 trie 的性能非常好 是常数级的
Dialogue: 0,0:01:02.97,0:01:13.40,英文,,0,0,0,,But maybe that's not so impressive because binary search trees also had logarithmic performance, which is pretty good, and hash tables had basically constant time performance.
Dialogue: 0,0:01:02.97,0:01:13.40,中文,,0,0,0,,但这也许不那么令人印象深刻 因为二叉搜索树也有对数级的性能 这已经很好了 而哈希表基本上是常数级的性能
Dialogue: 0,0:01:13.40,0:01:23.19,英文,,0,0,0,,So what was the point of showing you this special purpose data structure if the runtime isn't that much better than the other set of maps that we've seen?
Dialogue: 0,0:01:13.40,0:01:23.19,中文,,0,0,0,,如果运行时间与我们见过的其他集合和映射没有太大差别 那么向你们展示这种特殊用途的数据结构的意义何在呢？
Dialogue: 0,0:01:23.19,0:01:28.98,英文,,0,0,0,,And so what we said, and the cliffhanger that I left you on before break,
Dialogue: 0,0:01:23.19,0:01:28.98,中文,,0,0,0,,我说的 以及我在放假前留给你们的悬念是
Dialogue: 0,0:01:28.98,0:01:36.98,英文,,0,0,0,, is that tries are often really good at specific string operations that binary search trees and hash tables are not very good at.
Dialogue: 0,0:01:28.98,0:01:36.98,中文,,0,0,0,,trie 通常在特定的字符串操作方面非常出色 而二叉搜索树和哈希表在这方面并不擅长
Dialogue: 0,0:01:36.98,0:01:38.97,英文,,0,0,0,,So just looking at the pictures.
Dialogue: 0,0:01:36.98,0:01:38.97,中文,,0,0,0,,所以只看图
Dialogue: 0,0:01:38.97,0:01:41.57,英文,,0,0,0,,Hopefully, the pictures can kind of convince you that.
Dialogue: 0,0:01:38.97,0:01:41.57,中文,,0,0,0,,希望这些图能让你信服
Dialogue: 0,0:01:41.57,0:01:46.73,英文,,0,0,0,,Let's say I wanted to do something like, please tell me all of the words that start with saw.
Dialogue: 0,0:01:41.57,0:01:46.73,中文,,0,0,0,,假设我想做这样的事情 请告诉我所有以 saw 开头的单词
Dialogue: 0,0:01:46.73,0:01:49.69,英文,,0,0,0,,So in my set of words, there are lots of words.
Dialogue: 0,0:01:46.73,0:01:49.69,中文,,0,0,0,,在我的单词集合中 有很多单词
Dialogue: 0,0:01:49.69,0:01:53.68,英文,,0,0,0,,Some of them start with S-A, followed by other letters.
Dialogue: 0,0:01:49.69,0:01:53.68,中文,,0,0,0,,其中一些以 s-a 开头 后面跟着其他字母
Dialogue: 0,0:01:53.68,0:01:56.12,英文,,0,0,0,,So try doing that in a hash set.
Dialogue: 0,0:01:53.68,0:01:56.12,中文,,0,0,0,,试着用哈希集合来做这件事
Dialogue: 0,0:01:56.12,0:01:58.14,英文,,0,0,0,,I have this hash set. It's got all these buckets.
Dialogue: 0,0:01:56.12,0:01:58.14,中文,,0,0,0,,我有一个哈希集合  它有很多桶
Dialogue: 0,0:01:58.14,0:02:00.52,英文,,0,0,0,,Where are all the words that start with saw?
Dialogue: 0,0:01:58.14,0:02:00.52,中文,,0,0,0,,所有以 saw 开头的单词在哪里？
Dialogue: 0,0:02:00.52,0:02:02.78,英文,,0,0,0,,Well, they're not necessarily in the same bucket.
Dialogue: 0,0:02:00.52,0:02:02.78,中文,,0,0,0,,嗯 它们不一定在同一个桶里
Dialogue: 0,0:02:02.78,0:02:08.83,英文,,0,0,0,,Who knows what hash code I used to spread these items among the buckets?
Dialogue: 0,0:02:02.78,0:02:08.83,中文,,0,0,0,,谁知道我用什么哈希码把这些项分散到各个桶里呢？
Dialogue: 0,0:02:08.83,0:02:10.29,英文,,0,0,0,,There's a word with saw.
Dialogue: 0,0:02:08.83,0:02:10.29,中文,,0,0,0,,有一个以 saw 开头的单词
Dialogue: 0,0:02:10.29,0:02:11.05,英文,,0,0,0,,It's like in bucket 0.
Dialogue: 0,0:02:10.29,0:02:11.05,中文,,0,0,0,,它在第 0 个桶里
Dialogue: 0,0:02:11.05,0:02:14.63,英文,,0,0,0,,And then there's another one in bucket 3 and another one in bucket 2.
Dialogue: 0,0:02:11.05,0:02:14.63,中文,,0,0,0,,然后第 3 个桶里还有一个 第 2 个桶里还有一个
Dialogue: 0,0:02:14.63,0:02:15.93,英文,,0,0,0,,So it's all over the place.
Dialogue: 0,0:02:14.63,0:02:15.93,中文,,0,0,0,,它们到处都是
Dialogue: 0,0:02:15.93,0:02:20.61,英文,,0,0,0,,To find all the keys that start with saw, I'd have to scan through all of the buckets.
Dialogue: 0,0:02:15.93,0:02:20.61,中文,,0,0,0,,要找到所有以 saw 开头的键 我必须扫描所有的桶
Dialogue: 0,0:02:20.61,0:02:25.85,英文,,0,0,0,,And so it turns out the hash table, it's kind of a piece of garbage for this particular operation.
Dialogue: 0,0:02:20.61,0:02:25.85,中文,,0,0,0,,事实证明 哈希表对于这个特定的操作来说有点像垃圾
Dialogue: 0,0:02:25.85,0:02:27.84,英文,,0,0,0,,And same thing with the binary search tree.
Dialogue: 0,0:02:25.85,0:02:27.84,中文,,0,0,0,,二叉搜索树也是一样
Dialogue: 0,0:02:27.84,0:02:31.68,英文,,0,0,0,,Well, OK, well, the first, the root is sad.
Dialogue: 0,0:02:27.84,0:02:31.68,中文,,0,0,0,,好吧 好吧 首先 根节点是 sad
Dialogue: 0,0:02:31.68,0:02:35.60,英文,,0,0,0,,I don't know why the video keeps going up, but I guess complain at me if it does.
Dialogue: 0,0:02:31.68,0:02:35.60,中文,,0,0,0,,我不知道为什么视频一直往上跑 如果这样的话 我想你们可以向我抱怨
Dialogue: 0,0:02:35.60,0:02:36.85,英文,,0,0,0,,OK.
Dialogue: 0,0:02:35.60,0:02:36.85,中文,,0,0,0,,
Dialogue: 0,0:02:36.85,0:02:42.51,英文,,0,0,0,,So the root is sad, and yeah, maybe there's some other words that start with SA elsewhere in the tree.
Dialogue: 0,0:02:36.85,0:02:42.51,中文,,0,0,0,,根节点是 sad 是的 也许树中其他地方还有一些以 sa 开头的单词
Dialogue: 0,0:02:42.51,0:02:48.24,英文,,0,0,0,,But it's not immediately obvious to me how I find all of the words that start with SA.
Dialogue: 0,0:02:42.51,0:02:48.24,中文,,0,0,0,,但我不知道如何找到所有以 sa 开头的单词
Dialogue: 0,0:02:48.24,0:02:50.32,英文,,0,0,0,,By contrast, this is the punchline.
Dialogue: 0,0:02:48.24,0:02:50.32,中文,,0,0,0,,相比之下 这就是关键
Dialogue: 0,0:02:50.32,0:02:57.30,英文,,0,0,0,,If I look at the trie, well, here, if I'm looking for all the words that start with SA, I know they have to be,
Dialogue: 0,0:02:50.32,0:02:57.30,中文,,0,0,0,,如果我查看 trie 那么 在这里 如果我正在寻找所有以 sa 开头的单词 我知道它们必须是
Dialogue: 0,0:02:57.30,0:03:04.30,英文,,0,0,0,,I can start at the root, and I can spell S, and I can spell A, and I know that everything else in this subtree has to start with SA.
Dialogue: 0,0:02:57.30,0:03:04.30,中文,,0,0,0,,我可以从根节点开始 我可以拼写 s 我可以拼写 a 我知道这个子树中的所有其他内容都必须以 sa 开头
Dialogue: 0,0:03:04.30,0:03:09.75,英文,,0,0,0,,So the trie gives me a very natural way to complete this operation, where the binary search tree and the hash table,
Dialogue: 0,0:03:04.30,0:03:09.75,中文,,0,0,0,,所以 trie 为我提供了一种非常自然的方式来完成这个操作
Dialogue: 0,0:03:09.75,0:03:15.75,英文,,0,0,0,, they have implementations that would be slower for this operation and probably more complicated for you to write.
Dialogue: 0,0:03:09.75,0:03:15.75,中文,,0,0,0,,而二叉搜索树和哈希表 它们实现这个操作的速度会更慢 而且可能更复杂
Dialogue: 0,0:03:15.75,0:03:17.45,英文,,0,0,0,,So that's why I like tries.
Dialogue: 0,0:03:15.75,0:03:17.45,中文,,0,0,0,,这就是我喜欢 trie 的原因
Dialogue: 0,0:03:17.45,0:03:21.61,英文,,0,0,0,,They're good for specific string operations.
Dialogue: 0,0:03:17.45,0:03:21.61,中文,,0,0,0,,它们适合特定的字符串操作
Dialogue: 0,0:03:21.61,0:03:25.48,英文,,0,0,0,,OK, so I kind of hinted at what we have to do.
Dialogue: 0,0:03:21.61,0:03:25.48,中文,,0,0,0,,我 提示了我们必须做什么
Dialogue: 0,0:03:25.48,0:03:28.43,英文,,0,0,0,,For example, I want to find all the words that start with saw.
Dialogue: 0,0:03:25.48,0:03:28.43,中文,,0,0,0,,例如 我想找到所有以 saw 开头的单词
Dialogue: 0,0:03:28.43,0:03:31.43,英文,,0,0,0,,And in this particular set happens to be those words.
Dialogue: 0,0:03:28.43,0:03:31.43,中文,,0,0,0,,在这个特定的集合中 碰巧就是这些单词
Dialogue: 0,0:03:31.43,0:03:35.85,英文,,0,0,0,,And so I will not walk through the entire implementation of this.
Dialogue: 0,0:03:31.43,0:03:35.85,中文,,0,0,0,,我不会详细介绍这个实现的全部内容
Dialogue: 0,0:03:35.85,0:03:37.85,英文,,0,0,0,,All the slides are there for your reference if you want.
Dialogue: 0,0:03:35.85,0:03:37.85,中文,,0,0,0,,所有的幻灯片都在那里供你们参考 如果你们需要的话
Dialogue: 0,0:03:37.85,0:03:44.26,英文,,0,0,0,,But I just think this is one of those things where if you step through it slide by slide, I think you'd get the hang of it pretty quickly.
Dialogue: 0,0:03:37.85,0:03:44.26,中文,,0,0,0,,但我只是认为这是一件如果你一步一步地看幻灯片 我认为你很快就能掌握的事情
Dialogue: 0,0:03:44.26,0:03:47.40,英文,,0,0,0,,So I won't belabor the point in lecture.
Dialogue: 0,0:03:44.26,0:03:47.40,中文,,0,0,0,,我不会在课堂上过分强调这一点
Dialogue: 0,0:03:47.40,0:03:54.82,英文,,0,0,0,,But the high-level idea is somehow I can do a traversal to get all of the keys in this set.
Dialogue: 0,0:03:47.40,0:03:54.82,中文,,0,0,0,,但总的思路是 我可以用某种遍历来获取这个集合中的所有键
Dialogue: 0,0:03:54.82,0:03:58.34,英文,,0,0,0,,And I can also use a traversal to get all of the keys to start with SA.
Dialogue: 0,0:03:54.82,0:03:58.34,中文,,0,0,0,,我也可以用遍历来获取所有以 sa 开头的键
Dialogue: 0,0:03:58.34,0:04:04.56,英文,,0,0,0,,So I guess as a bit of a warm-up, what kind of traversal should I do to get all of the keys?
Dialogue: 0,0:03:58.34,0:04:04.56,中文,,0,0,0,,我想作为一个热身 我应该做什么样的遍历来获取所有的键？
Dialogue: 0,0:04:04.56,0:04:08.17,英文,,0,0,0,,So here's my try, and I want all of the words that are in the try.
Dialogue: 0,0:04:04.56,0:04:08.17,中文,,0,0,0,,这是我的 trie 我想要 trie 中的所有单词
Dialogue: 0,0:04:08.17,0:04:10.51,英文,,0,0,0,,So what kind of traversal could I do?
Dialogue: 0,0:04:08.17,0:04:10.51,中文,,0,0,0,,那我能做什么样的遍历呢？
Dialogue: 0,0:04:10.51,0:04:16.79,英文,,0,0,0,,Well, maybe consider something like, and I know there's a lot of words, but it's kind of like a depth-first traversal.
Dialogue: 0,0:04:10.51,0:04:16.79,中文,,0,0,0,,嗯 也许可以考虑类似深度优先遍历的东西 我知道有很多单词 但它有点像深度优先遍历
Dialogue: 0,0:04:16.79,0:04:20.35,英文,,0,0,0,,So I start at the root and just kind of watch where this call help
Dialogue: 0,0:04:16.79,0:04:20.35,中文,,0,0,0,,我从根节点开始 然后观察这个调用辅助函数的去向
Dialogue: 0,0:04:20.35,0:04:22.43,英文,,0,0,0,,Step-first search helper is going.
Dialogue: 0,0:04:20.35,0:04:22.43,中文,,0,0,0,,深度优先搜索辅助函数的去向
Dialogue: 0,0:04:22.43,0:04:23.23,英文,,0,0,0,,So it starts here.
Dialogue: 0,0:04:22.43,0:04:23.23,中文,,0,0,0,,从这里开始
Dialogue: 0,0:04:23.23,0:04:28.31,英文,,0,0,0,,It goes A, which then calls W, and then calls L, and then calls S. OK, great.
Dialogue: 0,0:04:23.23,0:04:28.31,中文,,0,0,0,,它会先调用 a 然后调用 w 再调用 l 最后调用 s 好 很好
Dialogue: 0,0:04:28.31,0:04:31.62,英文,,0,0,0,,And now I found a word, alls, because this node is blue.
Dialogue: 0,0:04:28.31,0:04:31.62,中文,,0,0,0,,现在我找到了一个单词 "alls" 因为这个节点是蓝色的
Dialogue: 0,0:04:31.62,0:04:33.84,英文,,0,0,0,,And then I return.
Dialogue: 0,0:04:31.62,0:04:33.84,中文,,0,0,0,,返回
Dialogue: 0,0:04:33.84,0:04:36.02,英文,,0,0,0,,And then I return all the way back up.
Dialogue: 0,0:04:33.84,0:04:36.02,中文,,0,0,0,,然后一路返回到最上面
Dialogue: 0,0:04:36.02,0:04:37.21,英文,,0,0,0,,I get A.
Dialogue: 0,0:04:36.02,0:04:37.21,中文,,0,0,0,,得到 a
Dialogue: 0,0:04:37.21,0:04:37.87,英文,,0,0,0,,Great.
Dialogue: 0,0:04:37.21,0:04:37.87,中文,,0,0,0,,很好
Dialogue: 0,0:04:37.87,0:04:40.35,英文,,0,0,0,,I go over here and I do another depth-first search.
Dialogue: 0,0:04:37.87,0:04:40.35,中文,,0,0,0,,我过来这边 再做一次深度优先搜索
Dialogue: 0,0:04:40.35,0:04:43.61,英文,,0,0,0,,So S calls A and then and so on.
Dialogue: 0,0:04:40.35,0:04:43.61,中文,,0,0,0,,所以 s 调用 a 然后等等
Dialogue: 0,0:04:43.61,0:04:45.79,英文,,0,0,0,,And so it's kind of a depth-first search.
Dialogue: 0,0:04:43.61,0:04:45.79,中文,,0,0,0,,这是一种深度优先搜索
Dialogue: 0,0:04:45.79,0:04:48.10,英文,,0,0,0,,You have to do a little bit of extra bookkeeping.
Dialogue: 0,0:04:45.79,0:04:48.10,中文,,0,0,0,,你需要做一些额外的记录工作
Dialogue: 0,0:04:48.10,0:04:49.84,英文,,0,0,0,,That's what all this other stuff is.
Dialogue: 0,0:04:48.10,0:04:49.84,中文,,0,0,0,,这就是所有这些其他东西的作用
Dialogue: 0,0:04:49.84,0:04:53.38,英文,,0,0,0,,So you have to keep track of things like what are all the letters I've seen so far?
Dialogue: 0,0:04:49.84,0:04:53.38,中文,,0,0,0,,你必须跟踪一些事情 比如我到目前为止看到了哪些字母？
Dialogue: 0,0:04:53.38,0:04:56.94,英文,,0,0,0,,And I can use an extra argument to help me keep track of that.
Dialogue: 0,0:04:53.38,0:04:56.94,中文,,0,0,0,,我可以使用一个额外的参数来帮助我跟踪这些内容
Dialogue: 0,0:04:56.94,0:05:05.45,英文,,0,0,0,,But at a very high level, hopefully it feels OK that doing a depth-first traversal will give me all of the keys in my triangle.
Dialogue: 0,0:04:56.94,0:05:05.45,中文,,0,0,0,,但在非常高的层面上 希望你觉得做深度优先遍历会给我三角形中的所有键 这感觉还可以
Dialogue: 0,0:05:05.45,0:05:12.17,英文,,0,0,0,,So I start here, I go depth-first, I see A is blue, so I spell the word A, WLS,
Dialogue: 0,0:05:05.45,0:05:12.17,中文,,0,0,0,,我从这里开始 进行深度优先搜索 我看到 a 是蓝色的 所以我拼出单词 a wls
Dialogue: 0,0:05:12.17,0:05:17.17,英文,,0,0,0,,I spell alls, and then I return back up, and then I do the same thing on the right branch of the tree.
Dialogue: 0,0:05:12.17,0:05:17.17,中文,,0,0,0,,我拼出 "alls" 然后返回到上面 然后我在树的右分支上做同样的事情
Dialogue: 0,0:05:17.17,0:05:26.22,英文,,0,0,0,,So basically a depth-first reversal, but with a bit of extra bookkeeping to remind myself the letters that I've seen so far.
Dialogue: 0,0:05:17.17,0:05:26.22,中文,,0,0,0,,基本上是深度优先遍历 但需要一些额外的记录来提醒我自己到目前为止看到的字母
Dialogue: 0,0:05:26.22,0:05:27.90,英文,,0,0,0,,And that lets me get all the words.
Dialogue: 0,0:05:26.22,0:05:27.90,中文,,0,0,0,,这样我就能得到所有的单词
Dialogue: 0,0:05:27.90,0:05:30.98,英文,,0,0,0,,OK, so that's how you would get all of the keys.
Dialogue: 0,0:05:27.90,0:05:30.98,中文,,0,0,0,,这就是你如何获得所有键的方法
Dialogue: 0,0:05:30.98,0:05:34.10,英文,,0,0,0,,But what if I only want the keys that start with S, A?
Dialogue: 0,0:05:30.98,0:05:34.10,中文,,0,0,0,,但是如果我只想要以 s-a 开头的键怎么办？
Dialogue: 0,0:05:34.10,0:05:38.65,英文,,0,0,0,,Remember, if I do a depth-first traversal starting at the root, I get all of the keys.
Dialogue: 0,0:05:34.10,0:05:38.65,中文,,0,0,0,,记住 如果我从根节点开始进行深度优先遍历 我就会得到所有的键
Dialogue: 0,0:05:38.65,0:05:44.89,英文,,0,0,0,,If I just want some of them, well, then what I can do is I can say, well, I only want the thing starting with S, A.
Dialogue: 0,0:05:38.65,0:05:44.89,中文,,0,0,0,,如果我只想要其中的一部分 那么我可以说 我只想要以 s-a 开头的那些
Dialogue: 0,0:05:44.89,0:05:51.89,英文,,0,0,0,,So I'll go S, A, and then I'll do a depth-first traversal starting at this A node and looking at everything underneath the A.
Dialogue: 0,0:05:44.89,0:05:51.89,中文,,0,0,0,,我先找到 s-a 然后从这个 a 节点开始进行深度优先遍历 查看 a 下面的所有内容
Dialogue: 0,0:05:51.89,0:06:05.78,英文,,0,0,0,,So again, it's a little bit high level, but hopefully it feels convincing that this is an operation that the try would be very good at, while the binary search tree or the hash table would kind of struggle at doing this.
Dialogue: 0,0:05:51.89,0:06:05.78,中文,,0,0,0,,再说一次 这有点高层次 但希望你觉得这种操作是 trie 非常擅长的 而二叉搜索树或哈希表在这种操作上会比较困难
Dialogue: 0,0:06:05.78,0:06:06.91,英文,,0,0,0,,OK.
Dialogue: 0,0:06:05.78,0:06:06.91,中文,,0,0,0,,
Dialogue: 0,0:06:06.91,0:06:08.13,英文,,0,0,0,,Questions?
Dialogue: 0,0:06:06.91,0:06:08.13,中文,,0,0,0,,有问题吗？
Dialogue: 0,0:06:08.13,0:06:11.89,英文,,0,0,0,,I just realized I should probably check Zoom periodically today.
Dialogue: 0,0:06:08.13,0:06:11.89,中文,,0,0,0,,我刚刚意识到我今天应该定期检查一下 Zoom
Dialogue: 0,0:06:11.89,0:06:15.83,英文,,0,0,0,,The white node, I'm assuming maybe you mean the one at the top, that's the root.
Dialogue: 0,0:06:11.89,0:06:15.83,中文,,0,0,0,,白色节点 我假设你指的是顶部的那个 那是根节点
Dialogue: 0,0:06:15.83,0:06:19.28,英文,,0,0,0,,Use that to indicate that nothing has been spelled yet.
Dialogue: 0,0:06:15.83,0:06:19.28,中文,,0,0,0,,用它来表示还没有拼写任何东西
Dialogue: 0,0:06:19.28,0:06:20.14,英文,,0,0,0,,Good question.
Dialogue: 0,0:06:19.28,0:06:20.14,中文,,0,0,0,,好问题
Dialogue: 0,0:06:20.14,0:06:21.68,英文,,0,0,0,,OK.
Dialogue: 0,0:06:20.14,0:06:21.68,中文,,0,0,0,,
Dialogue: 0,0:06:21.68,0:06:25.64,英文,,0,0,0,,So I will briefly tell you about some applications of this.
Dialogue: 0,0:06:21.68,0:06:25.64,中文,,0,0,0,,我将简要地告诉你一些这方面的应用
Dialogue: 0,0:06:25.64,0:06:29.66,英文,,0,0,0,,I don't expect you to know this in a lot of detail, but might as well.
Dialogue: 0,0:06:25.64,0:06:29.66,中文,,0,0,0,,我不指望你对此了解很多细节 但不妨了解一下
Dialogue: 0,0:06:29.66,0:06:35.57,英文,,0,0,0,,So we saw that I can use keys with prefix to find all of the words that start with some prefix.
Dialogue: 0,0:06:29.66,0:06:35.57,中文,,0,0,0,,我们看到 我可以用带前缀的键来查找所有以某个前缀开头的单词
Dialogue: 0,0:06:35.57,0:06:39.29,英文,,0,0,0,,And you might be like, well, that's great, but when would I ever use this in real life?
Dialogue: 0,0:06:35.57,0:06:39.29,中文,,0,0,0,,你可能会想 这很好 但在现实生活中我什么时候会用到它呢？
Dialogue: 0,0:06:39.29,0:06:47.43,英文,,0,0,0,,So it turns out this is very useful in real life, because if you ever go to Google and you start typing in words, you know how it gives you a bunch of suggested searches?
Dialogue: 0,0:06:39.29,0:06:47.43,中文,,0,0,0,,事实证明 这在现实生活中非常有用 因为如果你去 Google 开始输入单词 你知道它会给你很多建议的搜索吗？
Dialogue: 0,0:06:47.43,0:06:48.97,英文,,0,0,0,,Well, how do you think it's doing that?
Dialogue: 0,0:06:47.43,0:06:48.97,中文,,0,0,0,,好吧 你觉得它是怎么做到的？
Dialogue: 0,0:06:48.97,0:06:57.17,英文,,0,0,0,,It must be using some form of keys with prefix, where it says, what are all of the search terms that start with how are?
Dialogue: 0,0:06:48.97,0:06:57.17,中文,,0,0,0,,它一定是使用了某种形式的带前缀的键 它会说 所有以 "how are" 开头的搜索词是什么？
Dialogue: 0,0:06:57.17,0:06:59.13,英文,,0,0,0,,And it gives you all of these common ones.
Dialogue: 0,0:06:57.17,0:06:59.13,中文,,0,0,0,,然后它会给你所有这些常见的词
Dialogue: 0,0:06:59.13,0:07:02.95,英文,,0,0,0,,So that might be an application of keys with prefix.
Dialogue: 0,0:06:59.13,0:07:02.95,中文,,0,0,0,,这可能是带前缀的键的应用
Dialogue: 0,0:07:02.95,0:07:04.05,英文,,0,0,0,,And this would be a use case.
Dialogue: 0,0:07:02.95,0:07:04.05,中文,,0,0,0,,这将是一个用例
Dialogue: 0,0:07:04.05,0:07:12.55,英文,,0,0,0,,If you were building a Google-style search engine, that'd be a great case to use a trie instead of one of those other data structures that we saw.
Dialogue: 0,0:07:04.05,0:07:12.55,中文,,0,0,0,,如果你正在构建一个 Google 风格的搜索引擎 那么使用 trie 而不是我们看到的其他数据结构将是一个很好的例子
Dialogue: 0,0:07:12.55,0:07:14.71,英文,,0,0,0,,So I actually won't go through these slides in too much detail.
Dialogue: 0,0:07:12.55,0:07:14.71,中文,,0,0,0,,我实际上不会详细介绍这些幻灯片
Dialogue: 0,0:07:14.71,0:07:16.59,英文,,0,0,0,,There is a video if you're interested.
Dialogue: 0,0:07:14.71,0:07:16.59,中文,,0,0,0,,如果你有兴趣 这里有一个视频
Dialogue: 0,0:07:16.59,0:07:19.74,英文,,0,0,0,,One of those things where I think if you just went through the slides, you'd be OK with it.
Dialogue: 0,0:07:16.59,0:07:19.74,中文,,0,0,0,,我认为如果你只是浏览一下幻灯片 你就会明白的
Dialogue: 0,0:07:19.74,0:07:22.54,英文,,0,0,0,,I also don't think we'd test you on this in a lot of detail anyway.
Dialogue: 0,0:07:19.74,0:07:22.54,中文,,0,0,0,,我也不认为我们会在这方面对你进行很多细节的测试
Dialogue: 0,0:07:22.54,0:07:30.73,英文,,0,0,0,,But basically, the idea is if you want to keep track of the most common words with prefix, you can add some extra bookkeeping to say, I don't want just any of the things that start with B,
Dialogue: 0,0:07:22.54,0:07:30.73,中文,,0,0,0,,基本上 如果你想跟踪最常见的带前缀的单词 你可以添加一些额外的记录 我不要任何以 b 开头的单词
Dialogue: 0,0:07:30.73,0:07:38.73,英文,,0,0,0,,but I want the most common words that start with B. And I can use some extra bookkeeping to keep track of that.
Dialogue: 0,0:07:30.73,0:07:38.73,中文,,0,0,0,,但我想要最常见的以 b 开头的单词 我可以使用一些额外的记录来跟踪这些内容
Dialogue: 0,0:07:38.73,0:07:41.75,英文,,0,0,0,,But again, not something I'll talk about in too much detail.
Dialogue: 0,0:07:38.73,0:07:41.75,中文,,0,0,0,,但同样 我不会详细讨论这个问题
Dialogue: 0,0:07:41.75,0:07:45.58,英文,,0,0,0,,There's also some fancy tricks you can see to make the try even faster.
Dialogue: 0,0:07:41.75,0:07:45.58,中文,,0,0,0,,你还可以看到一些让 trie 更快的奇特技巧
Dialogue: 0,0:07:45.58,0:07:48.88,英文,,0,0,0,,But we won't discuss, as the slide says.
Dialogue: 0,0:07:45.58,0:07:48.88,中文,,0,0,0,,但我们不会讨论 正如幻灯片所说
Dialogue: 0,0:07:48.88,0:07:51.60,英文,,0,0,0,,Are people OK with my autocomplete speedrun?
Dialogue: 0,0:07:48.88,0:07:51.60,中文,,0,0,0,,大家对我的自动完成速度竞赛还满意吗？
Dialogue: 0,0:07:51.60,0:07:55.31,英文,,0,0,0,,Are we convinced that this is probably useful for autocomplete?
Dialogue: 0,0:07:51.60,0:07:55.31,中文,,0,0,0,,我们是否确信这对自动完成可能有用？
Dialogue: 0,0:07:55.31,0:07:56.82,英文,,0,0,0,,OK.
Dialogue: 0,0:07:55.31,0:07:56.82,中文,,0,0,0,,
Dialogue: 0,0:07:56.82,0:08:00.94,英文,,0,0,0,,So to quickly summarize, why did we talk about tries in the first place?
Dialogue: 0,0:07:56.82,0:08:00.94,中文,,0,0,0,,简单总结一下 我们为什么要讨论trie？
Dialogue: 0,0:08:00.94,0:08:04.28,英文,,0,0,0,,Well, theoretically, the performance is a little bit better.
Dialogue: 0,0:08:00.94,0:08:04.28,中文,,0,0,0,,理论上 它的性能会更好一些
Dialogue: 0,0:08:04.28,0:08:10.00,英文,,0,0,0,,I went from theta of 1 with some asterisks to theta of 1 all of the time, which is good.
Dialogue: 0,0:08:04.28,0:08:10.00,中文,,0,0,0,,时间复杂度从带星号的Θ(1)变成了始终是Θ(1) 这很好
Dialogue: 0,0:08:10.00,0:08:12.18,英文,,0,0,0,,Then I had to think about how to implement the try.
Dialogue: 0,0:08:10.00,0:08:12.18,中文,,0,0,0,,然后我需要考虑如何实现trie
Dialogue: 0,0:08:12.18,0:08:14.60,英文,,0,0,0,,And remember, there were a lot of different choices.
Dialogue: 0,0:08:12.18,0:08:14.60,中文,,0,0,0,,还记得 我们有很多不同的选择
Dialogue: 0,0:08:14.60,0:08:20.94,英文,,0,0,0,,And if you trusted the abstraction, you believed that whatever was in the box was a way to map characters to nodes,
Dialogue: 0,0:08:14.60,0:08:20.94,中文,,0,0,0,,如果你相信抽象  你相信盒子里的东西是一种将字符映射到节点的方法
Dialogue: 0,0:08:20.94,0:08:27.94,英文,,0,0,0,,and how the mapping happened was not our concern, then you can swap out implementations and say, maybe I'll use one of those data-indexed character maps,
Dialogue: 0,0:08:20.94,0:08:27.94,中文,,0,0,0,,并且映射如何发生不是我们关心的问题 那么你可以替换实现并说 也许我会使用数据索引字符映射
Dialogue: 0,0:08:27.94,0:08:32.94,英文,,0,0,0,,a big array, maybe I'll use a binary search tree, maybe I'll use a hash table.
Dialogue: 0,0:08:27.94,0:08:32.94,中文,,0,0,0,,一个大数组 也许我会使用二叉搜索树 也许我会使用哈希表
Dialogue: 0,0:08:32.94,0:08:40.37,英文,,0,0,0,,They're all good choices, although I think the data-indexed character map is a little bit more memory inefficient than the other two.
Dialogue: 0,0:08:32.94,0:08:40.37,中文,,0,0,0,,它们都是不错的选择 尽管我认为数据索引字符映射比其他两个更浪费内存
Dialogue: 0,0:08:40.37,0:08:49.07,英文,,0,0,0,,And then we talked about just today that tries to support very good string operations, or they're very good at supporting certain string operations
Dialogue: 0,0:08:40.37,0:08:49.07,中文,,0,0,0,,然后我们今天讨论了trie支持非常好的字符串操作 或者它们非常擅长支持某些字符串操作
Dialogue: 0,0:08:49.07,0:08:56.07,英文,,0,0,0,,like keys with prefix that other implementations of a set or a map would not be great at implementing.
Dialogue: 0,0:08:49.07,0:08:56.07,中文,,0,0,0,,例如带有前缀的键 而其他集合或映射的实现很难做到这一点
Dialogue: 0,0:08:56.07,0:09:00.99,英文,,0,0,0,,So I think this is cool because it shows you that data structures can interact in beautiful ways.
Dialogue: 0,0:08:56.07,0:09:00.99,中文,,0,0,0,,我认为这很酷 因为它向你展示了数据结构可以以漂亮的方式交互
Dialogue: 0,0:09:00.99,0:09:06.98,英文,,0,0,0,,We used a binary search tree inside another tree, and we got this beautiful data structure out of it.
Dialogue: 0,0:09:00.99,0:09:06.98,中文,,0,0,0,,我们在另一棵树中使用了二叉搜索树 并从中得到了这个漂亮的数据结构
Dialogue: 0,0:09:06.98,0:09:08.34,英文,,0,0,0,,I think that's nice.
Dialogue: 0,0:09:06.98,0:09:08.34,中文,,0,0,0,,我觉得这很棒
Dialogue: 0,0:09:08.34,0:09:11.18,英文,,0,0,0,,OK, and so although we won't talk about it, you can go look up.
Dialogue: 0,0:09:08.34,0:09:11.18,中文,,0,0,0,,虽然我们不会讨论它 但你可以去查一下
Dialogue: 0,0:09:11.18,0:09:14.72,英文,,0,0,0,,There are other types of special purpose sets and maps.
Dialogue: 0,0:09:11.18,0:09:14.72,中文,,0,0,0,,还有其他类型的专用集合和映射
Dialogue: 0,0:09:14.72,0:09:18.98,英文,,0,0,0,,If you know that your data type is something special, like a string or a character,
Dialogue: 0,0:09:14.72,0:09:18.98,中文,,0,0,0,,如果你知道你的数据类型是特殊的 例如字符串或字符
Dialogue: 0,0:09:18.98,0:09:19.95,英文,,0,0,0,,Or a number.
Dialogue: 0,0:09:18.98,0:09:19.95,中文,,0,0,0,,或者数字
Dialogue: 0,0:09:19.95,0:09:27.51,英文,,0,0,0,,Well, there are some other data structures out there that are cool, like suffix trees or DOG, which is Directed Acyclic Word Graph.
Dialogue: 0,0:09:19.95,0:09:27.51,中文,,0,0,0,,那么 还有一些其他很酷的数据结构 例如后缀树或dog 即有向无环词图
Dialogue: 0,0:09:27.51,0:09:31.87,英文,,0,0,0,,I just wanted to say dog, but I'm actually not too familiar with what it is.
Dialogue: 0,0:09:27.51,0:09:31.87,中文,,0,0,0,,我只是想说dog 但我实际上不太熟悉它是什么
Dialogue: 0,0:09:31.87,0:09:32.57,英文,,0,0,0,,OK.
Dialogue: 0,0:09:31.87,0:09:32.57,中文,,0,0,0,,
Dialogue: 0,0:09:32.57,0:09:44.50,英文,,0,0,0,,Anything else you want to know about tries, data structures, the entire second unit of this class before we move on to the final unit, which is all about sorting and algorithms?
Dialogue: 0,0:09:32.57,0:09:44.50,中文,,0,0,0,,在进入最后一单元（关于排序和算法）之前 你还想知道关于trie、数据结构、这门课的整个第二单元的任何内容吗？
Dialogue: 0,0:09:44.50,0:09:46.20,英文,,0,0,0,,OK.
Dialogue: 0,0:09:44.50,0:09:46.20,中文,,0,0,0,,
Dialogue: 0,0:09:46.20,0:09:50.97,英文,,0,0,0,,Great, so I'm switching over to the lecture 29 slides for those of you following at home.
Dialogue: 0,0:09:46.20,0:09:50.97,中文,,0,0,0,,很好 所以我切换到第 29 讲的幻灯片 供那些在家学习的人参考
Dialogue: 0,0:09:50.97,0:09:53.33,英文,,0,0,0,,Let's start talking about sorting.
Dialogue: 0,0:09:50.97,0:09:53.33,中文,,0,0,0,,我们开始讨论排序
Dialogue: 0,0:09:53.33,0:09:54.99,英文,,0,0,0,,OK, I hope you're excited.
Dialogue: 0,0:09:53.33,0:09:54.99,中文,,0,0,0,,我希望你很兴奋
Dialogue: 0,0:09:54.99,0:09:58.08,英文,,0,0,0,,So as I said, we are done with phase 2.
Dialogue: 0,0:09:54.99,0:09:58.08,中文,,0,0,0,,正如我所说 我们已经完成了第二阶段
Dialogue: 0,0:09:58.08,0:10:00.40,英文,,0,0,0,,Here we are in phase 3.
Dialogue: 0,0:09:58.08,0:10:00.40,中文,,0,0,0,,现在我们进入了第三阶段
Dialogue: 0,0:10:00.40,0:10:01.40,英文,,0,0,0,,So here we go.
Dialogue: 0,0:10:00.40,0:10:01.40,中文,,0,0,0,,我们开始吧
Dialogue: 0,0:10:01.40,0:10:04.39,英文,,0,0,0,,OK, so. Sorting.
Dialogue: 0,0:10:01.40,0:10:04.39,中文,,0,0,0,,好的 那么排序
Dialogue: 0,0:10:04.39,0:10:04.91,英文,,0,0,0,,What is it?
Dialogue: 0,0:10:04.39,0:10:04.91,中文,,0,0,0,,它是什么？
Dialogue: 0,0:10:04.91,0:10:09.35,英文,,0,0,0,,Well, hopefully we've all sorted things before, and so I'll try to make it formal.
Dialogue: 0,0:10:04.91,0:10:09.35,中文,,0,0,0,,希望我们以前都实现过排序 所以我会试着形式化地讲解它
Dialogue: 0,0:10:09.35,0:10:12.29,英文,,0,0,0,,But roughly speaking, I have a bunch of items.
Dialogue: 0,0:10:09.35,0:10:12.29,中文,,0,0,0,,粗略地说 我有一堆项目
Dialogue: 0,0:10:12.29,0:10:14.47,英文,,0,0,0,,I need to put them in order.
Dialogue: 0,0:10:12.29,0:10:14.47,中文,,0,0,0,,我需要把它们按顺序排列
Dialogue: 0,0:10:14.47,0:10:16.94,英文,,0,0,0,,And there's lots of different reasons why this would be useful.
Dialogue: 0,0:10:14.47,0:10:16.94,中文,,0,0,0,,这样做有很多不同的原因
Dialogue: 0,0:10:16.94,0:10:21.42,英文,,0,0,0,,So I'll try to convince you that sorting is useful, although maybe you already believe it.
Dialogue: 0,0:10:16.94,0:10:21.42,中文,,0,0,0,,我会尽量让你相信排序是有用的 尽管你可能已经相信了
Dialogue: 0,0:10:21.42,0:10:26.30,英文,,0,0,0,,So remember in the asymptotics lecture, the very first one, we talked about DUP1.
Dialogue: 0,0:10:21.42,0:10:26.30,中文,,0,0,0,,还记得在渐进分析的课程中 第一节课 我们讨论了 DUP1
Dialogue: 0,0:10:26.30,0:10:34.38,英文,,0,0,0,,versus Duke 2, and we said, well, if the items are sorted, I can just compare all the adjacent elements to see if there are any duplicates.
Dialogue: 0,0:10:26.30,0:10:34.38,中文,,0,0,0,,和 Duke 2 我们说 如果项目是排序的 我可以直接比较所有相邻的元素 看看是否有重复的
Dialogue: 0,0:10:34.38,0:10:38.52,英文,,0,0,0,,Well, that would be an algorithm that's a lot faster if the array was sorted.
Dialogue: 0,0:10:34.38,0:10:38.52,中文,,0,0,0,,如果数组是排序的 那么这个算法会快很多
Dialogue: 0,0:10:38.52,0:10:44.57,英文,,0,0,0,,And if the array was not sorted, then Duke 1 and Duke 2 would be a lot slower asymptotically.
Dialogue: 0,0:10:38.52,0:10:44.57,中文,,0,0,0,,如果数组没有排序 那么 Duke 1 和 Duke 2 在渐进分析上会慢很多
Dialogue: 0,0:10:44.57,0:10:47.75,英文,,0,0,0,,So sometimes by sorting, you get better algorithms.
Dialogue: 0,0:10:44.57,0:10:47.75,中文,,0,0,0,,有时通过排序 你可以得到更好的算法
Dialogue: 0,0:10:47.75,0:10:51.05,英文,,0,0,0,,And if you sort things, you can also build nice data structures.
Dialogue: 0,0:10:47.75,0:10:51.05,中文,,0,0,0,,如果你对事物进行排序 你也可以构建漂亮的数据结构
Dialogue: 0,0:10:51.05,0:10:54.82,英文,,0,0,0,,All of this is just to say, sorting is a pretty important problem.
Dialogue: 0,0:10:51.05,0:10:54.82,中文,,0,0,0,,所有这些只是为了说明 排序是一个非常重要的问题
Dialogue: 0,0:10:54.82,0:10:58.22,英文,,0,0,0,,And so let's go explore different ways to solve it.
Dialogue: 0,0:10:54.82,0:10:58.22,中文,,0,0,0,,让我们去探索解决它的不同方法
Dialogue: 0,0:10:58.22,0:10:59.50,英文,,0,0,0,,OK.
Dialogue: 0,0:10:58.22,0:10:59.50,中文,,0,0,0,,
Dialogue: 0,0:10:59.50,0:11:02.00,英文,,0,0,0,,So I'm going to formally define it.
Dialogue: 0,0:10:59.50,0:11:02.00,中文,,0,0,0,,我要正式定义它
Dialogue: 0,0:11:02.00,0:11:03.76,英文,,0,0,0,,This is kind of pedantic.
Dialogue: 0,0:11:02.00,0:11:03.76,中文,,0,0,0,,这有点迂腐
Dialogue: 0,0:11:03.76,0:11:05.08,英文,,0,0,0,,I'm not going to lie.
Dialogue: 0,0:11:03.76,0:11:05.08,中文,,0,0,0,,我不撒谎
Dialogue: 0,0:11:05.08,0:11:09.42,英文,,0,0,0,,But it's good to all be on the same page about what sorting is.
Dialogue: 0,0:11:05.08,0:11:09.42,中文,,0,0,0,,不过 我们最好先统一一下对排序的理解
Dialogue: 0,0:11:09.42,0:11:13.55,英文,,0,0,0,,So I know it's a little bit boring, but let's go through some definitions.
Dialogue: 0,0:11:09.42,0:11:13.55,中文,,0,0,0,,我知道这有点无聊 但我们还是来过一遍定义吧
Dialogue: 0,0:11:13.55,0:11:26.41,英文,,0,0,0,,So if I have two keys, like A and B, two items of any sort, it has to be the case that A is less than B, A is equal to B, or A is greater than B. It has to be one of those.
Dialogue: 0,0:11:13.55,0:11:26.41,中文,,0,0,0,,如果有两个键 比如 a 和 b 或者任何类型的两个元素 那么 a 必须小于 b 等于 b 或者大于 b 三者之一
Dialogue: 0,0:11:26.41,0:11:29.38,英文,,0,0,0,,You cannot have two of these true at the same time.
Dialogue: 0,0:11:26.41,0:11:29.38,中文,,0,0,0,,这三种情况不可能同时成立
Dialogue: 0,0:11:29.38,0:11:34.86,英文,,0,0,0,,Again, hopefully it's stuff that we're all kind of convinced of, but good to be very clear about it.
Dialogue: 0,0:11:29.38,0:11:34.86,中文,,0,0,0,,希望这些都是大家认同的 但还是要明确一下
Dialogue: 0,0:11:34.86,0:11:41.96,英文,,0,0,0,,Hopefully it doesn't seem too wild to suggest that if A is less than B, B is less than C, then hopefully A should also be less than C.
Dialogue: 0,0:11:34.86,0:11:41.96,中文,,0,0,0,,如果 a < b b < c 那么 a 应该也小于c 这个应该没问题吧
Dialogue: 0,0:11:41.96,0:11:49.96,英文,,0,0,0,,So if both of these are true, it means that there is a way to put all of my items in order.
Dialogue: 0,0:11:41.96,0:11:49.96,中文,,0,0,0,,如果这两个条件都成立 就意味着有一种方法可以把我所有的元素按顺序排列
Dialogue: 0,0:11:49.96,0:11:52.83,英文,,0,0,0,,And I want my items in non-decreasing order.
Dialogue: 0,0:11:49.96,0:11:52.83,中文,,0,0,0,,我希望我的元素按非递减顺序排列
Dialogue: 0,0:11:52.83,0:12:03.28,英文,,0,0,0,,That is, each item has to be less than or possibly equal to, if I have duplicates, the next item relative to some ordering relation that someone gives me.
Dialogue: 0,0:11:52.83,0:12:03.28,中文,,0,0,0,,也就是说 每个元素都必须小于或等于（如果有重复元素的话）下一个元素 根据别人给我的排序关系
Dialogue: 0,0:12:03.28,0:12:10.80,英文,,0,0,0,,And again, I know it's kind of pedantic, but just to make sure we all know how to sort things in the same way, that's how we're going to talk about them.
Dialogue: 0,0:12:03.28,0:12:10.80,中文,,0,0,0,,我知道这有点迂腐 但为了确保我们都知道如何以相同的方式对事物进行排序 我们会这样来讨论它们
Dialogue: 0,0:12:10.80,0:12:12.60,英文,,0,0,0,,OK, here are some examples.
Dialogue: 0,0:12:10.80,0:12:12.60,中文,,0,0,0,,好的 这里有一些例子
Dialogue: 0,0:12:12.60,0:12:15.06,英文,,0,0,0,,And I think, again, some of it's kind of pedantic.
Dialogue: 0,0:12:12.60,0:12:15.06,中文,,0,0,0,,我觉得 还是有点迂腐
Dialogue: 0,0:12:15.06,0:12:21.53,英文,,0,0,0,,But the important thing, I think, on this slide is that sometimes there are different ordering relations you can use to sort something.
Dialogue: 0,0:12:15.06,0:12:21.53,中文,,0,0,0,,但我觉得 这张幻灯片上重要的是 有时可以使用不同的排序关系来对某些东西进行排序
Dialogue: 0,0:12:21.53,0:12:27.22,英文,,0,0,0,,So suppose I give you this array, cows, get, going, the.
Dialogue: 0,0:12:21.53,0:12:27.22,中文,,0,0,0,,假设我给你这个数组cows、get、going、the
Dialogue: 0,0:12:27.22,0:12:29.84,英文,,0,0,0,,You could say, maybe I'll sort this alphabetically.
Dialogue: 0,0:12:27.22,0:12:29.84,中文,,0,0,0,,你可以说 也许我会按字母顺序排序
Dialogue: 0,0:12:29.84,0:12:35.55,英文,,0,0,0,,So cows is first, and then get is next, because G comes after C in the alphabet.
Dialogue: 0,0:12:29.84,0:12:35.55,中文,,0,0,0,,所以 cows 排在第一位 然后是 get 因为字母表中 g 排在 c 后面
Dialogue: 0,0:12:35.55,0:12:38.03,英文,,0,0,0,,But there are other ordering relations out there.
Dialogue: 0,0:12:35.55,0:12:38.03,中文,,0,0,0,,但是还有其他的排序关系
Dialogue: 0,0:12:38.03,0:12:41.82,英文,,0,0,0,,So maybe I don't want to sort this by alphabetical order of the words.
Dialogue: 0,0:12:38.03,0:12:41.82,中文,,0,0,0,,也许我不想按单词的字母顺序排序
Dialogue: 0,0:12:41.82,0:12:44.18,英文,,0,0,0,,I want to sort it by the length of the words.
Dialogue: 0,0:12:41.82,0:12:44.18,中文,,0,0,0,,我想按单词的长度排序
Dialogue: 0,0:12:44.18,0:12:46.96,英文,,0,0,0,,So that would be a different ordering relation I can use.
Dialogue: 0,0:12:44.18,0:12:46.96,中文,,0,0,0,,这将是我可以使用的另一种排序关系
Dialogue: 0,0:12:46.96,0:12:55.29,英文,,0,0,0,,And if I want to sort by the length of the words, so the shortest words are first, longest words are last, turns out there's actually two valid orderings.
Dialogue: 0,0:12:46.96,0:12:55.29,中文,,0,0,0,,如果我想按单词的长度排序 最短的单词排在最前面 最长的单词排在最后面 结果发现实际上有两种有效的排序方式
Dialogue: 0,0:12:55.29,0:13:00.79,英文,,0,0,0,,I could say the get cows going, or I could say get the cows going.
Dialogue: 0,0:12:55.29,0:13:00.79,中文,,0,0,0,,我可以说、the、get、cows、going 或者我可以说get、the、cows、going
Dialogue: 0,0:13:00.79,0:13:01.65,英文,,0,0,0,,Why are there two?
Dialogue: 0,0:13:00.79,0:13:01.65,中文,,0,0,0,,为什么会有两种？
Dialogue: 0,0:13:01.65,0:13:02.47,英文,,0,0,0,,Because there's a tie.
Dialogue: 0,0:13:01.65,0:13:02.47,中文,,0,0,0,,因为它们长度相同
Dialogue: 0,0:13:02.47,0:13:05.65,英文,,0,0,0,,Both of these have the same length.
Dialogue: 0,0:13:02.47,0:13:05.65,中文,,0,0,0,,这两个单词的长度相同
Dialogue: 0,0:13:05.65,0:13:06.45,英文,,0,0,0,,OK.
Dialogue: 0,0:13:05.65,0:13:06.45,中文,,0,0,0,,
Dialogue: 0,0:13:06.45,0:13:11.20,英文,,0,0,0,,And so not to get too much in the weeds, I'm just trying to define sorting here.
Dialogue: 0,0:13:06.45,0:13:11.20,中文,,0,0,0,,为了不跑题 我只是想在这里定义一下排序
Dialogue: 0,0:13:11.20,0:13:16.38,英文,,0,0,0,,But here's a case where these two words, they're not really equal in the sense that they're not the same word.
Dialogue: 0,0:13:11.20,0:13:16.38,中文,,0,0,0,,但这里有一个例子 这两个词 它们并不是真正的相等 因为它们不是同一个词
Dialogue: 0,0:13:16.38,0:13:23.63,英文,,0,0,0,,But under this particular ordering relation, for the sort that I'm doing right now, they're equal in the sense that they have the same length.
Dialogue: 0,0:13:16.38,0:13:23.63,中文,,0,0,0,,但在这种特定的排序关系下 对于我现在正在进行的排序 它们是相等的 因为它们的长度相同
Dialogue: 0,0:13:23.63,0:13:32.32,英文,,0,0,0,,Sometimes we say two things are equal for a particular sort, even if they are not equal if you think about the java.equals method.
Dialogue: 0,0:13:23.63,0:13:32.32,中文,,0,0,0,,有时我们会说两个东西对于特定的排序是相等的 即使它们在 java.equals 方法中并不相等
Dialogue: 0,0:13:32.32,0:13:42.44,英文,,0,0,0,,These two things are not dot equals, but if I use a dot compare or something, they would be considered equal for my particular sort that I want to do.
Dialogue: 0,0:13:32.32,0:13:42.44,中文,,0,0,0,,这两样东西不是点等于 但如果我使用点比较或其他方法 它们在我想要进行的特定排序中将被视为相等
Dialogue: 0,0:13:42.44,0:13:50.56,英文,,0,0,0,,But kind of a pedantic point, the important thing is, and I guess here's more pedantic points, the important thing is that we want to sort things,
Dialogue: 0,0:13:42.44,0:13:50.56,中文,,0,0,0,,这是一个比较迂腐的观点 重要的是我想这里还有更多迂腐的观点 重要的是我们想要对事物进行排序
Dialogue: 0,0:13:50.56,0:13:57.56,英文,,0,0,0,, we want to put them in non-decreasing order, and sometimes there are multiple ordering relations to do it.
Dialogue: 0,0:13:50.56,0:13:57.56,中文,,0,0,0,,我们想要把它们按非递减顺序排列 有时有多种排序关系可以做到这一点
Dialogue: 0,0:13:57.56,0:14:03.85,英文,,0,0,0,,Are we all somewhat agreed on the definition of sort before I show you something a little bit more important?
Dialogue: 0,0:13:57.56,0:14:03.85,中文,,0,0,0,,在我展示一些更重要的东西之前 我们是否都对排序的定义达成了一致？
Dialogue: 0,0:14:03.85,0:14:05.55,英文,,0,0,0,,Oops, sorry, I missed the try question.
Dialogue: 0,0:14:03.85,0:14:05.55,中文,,0,0,0,,哦 抱歉 我错过了尝试问题
Dialogue: 0,0:14:05.55,0:14:07.42,英文,,0,0,0,,I'll answer it afterwards.
Dialogue: 0,0:14:05.55,0:14:07.42,中文,,0,0,0,,我稍后会回答它
Dialogue: 0,0:14:07.42,0:14:08.61,英文,,0,0,0,,OK.
Dialogue: 0,0:14:07.42,0:14:08.61,中文,,0,0,0,,
Dialogue: 0,0:14:08.61,0:14:11.27,英文,,0,0,0,,Good, so we all know what sorting is and how it works.
Dialogue: 0,0:14:08.61,0:14:11.27,中文,,0,0,0,,很好 所以我们都知道排序是什么以及它是如何工作的
Dialogue: 0,0:14:11.27,0:14:15.46,英文,,0,0,0,,So now I'll tell you an idea that is more important, which is an inversion.
Dialogue: 0,0:14:11.27,0:14:15.46,中文,,0,0,0,,现在我将告诉你一个更重要的概念 那就是逆序
Dialogue: 0,0:14:15.46,0:14:20.46,英文,,0,0,0,,So take a look at this array and say I want to sort it from small numbers to big numbers.
Dialogue: 0,0:14:15.46,0:14:20.46,中文,,0,0,0,,看看这个数组 假设我想把它从小到大排序
Dialogue: 0,0:14:20.46,0:14:29.13,英文,,0,0,0,,So I have 0, 1, 1, 2, 3, 4, 8, 6, 9, 5, 7. Is this array sorted?
Dialogue: 0,0:14:20.46,0:14:29.13,中文,,0,0,0,,我有 0, 1, 1, 2, 3, 4, 8, 6, 9, 5, 7  这个数组排序了吗？
Dialogue: 0,0:14:29.13,0:14:31.35,英文,,0,0,0,,No, because there are some items that are out of order.
Dialogue: 0,0:14:29.13,0:14:31.35,中文,,0,0,0,,没有 因为有些元素是乱序的
Dialogue: 0,0:14:31.35,0:14:34.40,英文,,0,0,0,,So this 9 should not come before this 5.
Dialogue: 0,0:14:31.35,0:14:34.40,中文,,0,0,0,,这个 9 不应该在这个 5 之前
Dialogue: 0,0:14:34.40,0:14:37.88,英文,,0,0,0,,But is this array kind of sorted?
Dialogue: 0,0:14:34.40,0:14:37.88,中文,,0,0,0,,但是这个数组算是排序了吗？
Dialogue: 0,0:14:37.88,0:14:40.98,英文,,0,0,0,,I think it is, because a lot of the items do seem in the right place.
Dialogue: 0,0:14:37.88,0:14:40.98,中文,,0,0,0,,我觉得是 因为很多元素看起来都在正确的位置上
Dialogue: 0,0:14:40.98,0:14:44.08,英文,,0,0,0,,The 0, 1, 1, 2, 3, 4, that was pretty good.
Dialogue: 0,0:14:40.98,0:14:44.08,中文,,0,0,0,,0, 1, 1, 2, 3, 4 这部分很好
Dialogue: 0,0:14:44.08,0:14:47.14,英文,,0,0,0,,And yeah, we kind of messed up with the 8.
Dialogue: 0,0:14:44.08,0:14:47.14,中文,,0,0,0,,是的 我们在 8 那里有点搞砸了
Dialogue: 0,0:14:47.14,0:14:48.40,英文,,0,0,0,,It's close.
Dialogue: 0,0:14:47.14,0:14:48.40,中文,,0,0,0,,它接近排序了
Dialogue: 0,0:14:48.40,0:15:00.83,英文,,0,0,0,,And so if I want to represent the fact that this array isn't sorted, but it's almost sorted, one way that I can say that is I can count the number of inversions in this list or this array.
Dialogue: 0,0:14:48.40,0:15:00.83,中文,,0,0,0,,如果我想表示这个数组没有排序 但几乎排序了 一种方法就是计算这个列表或数组中的逆序数
Dialogue: 0,0:15:00.83,0:15:02.47,英文,,0,0,0,,And an inversion is any two elements.
Dialogue: 0,0:15:00.83,0:15:02.47,中文,,0,0,0,,逆序就是任何两个元素...
Dialogue: 0,0:15:02.47,0:15:03.93,英文,,0,0,0,,So I pick any two elements.
Dialogue: 0,0:15:02.47,0:15:03.93,中文,,0,0,0,,我选择任意两个元素
Dialogue: 0,0:15:03.93,0:15:05.36,英文,,0,0,0,,They don't have to be adjacent.
Dialogue: 0,0:15:03.93,0:15:05.36,中文,,0,0,0,,它们不必是相邻的
Dialogue: 0,0:15:05.36,0:15:08.06,英文,,0,0,0,,So I could pick 8 and 7.
Dialogue: 0,0:15:05.36,0:15:08.06,中文,,0,0,0,,我可以选择 8 和 7
Dialogue: 0,0:15:08.06,0:15:09.86,英文,,0,0,0,,Well, these two are out of order.
Dialogue: 0,0:15:08.06,0:15:09.86,中文,,0,0,0,,嗯 这两个是乱序的
Dialogue: 0,0:15:09.86,0:15:11.82,英文,,0,0,0,,The 8 and the 7 are out of order.
Dialogue: 0,0:15:09.86,0:15:11.82,中文,,0,0,0,,8 和 7 的顺序反了
Dialogue: 0,0:15:11.82,0:15:13.42,英文,,0,0,0,,The 7 should have come first.
Dialogue: 0,0:15:11.82,0:15:13.42,中文,,0,0,0,,7 应该在前面
Dialogue: 0,0:15:13.42,0:15:16.30,英文,,0,0,0,,So that pair forms an inversion.
Dialogue: 0,0:15:13.42,0:15:16.30,中文,,0,0,0,,这对数字形成了一个逆序
Dialogue: 0,0:15:16.30,0:15:21.17,英文,,0,0,0,,And I can check all of the pairs in this array to see how many inversions there are.
Dialogue: 0,0:15:16.30,0:15:21.17,中文,,0,0,0,,我可以检查数组中所有的数字对 看看有多少个逆序
Dialogue: 0,0:15:21.17,0:15:24.51,英文,,0,0,0,,And that gives me a rough sense of how sorted this array is.
Dialogue: 0,0:15:21.17,0:15:24.51,中文,,0,0,0,,这让我大致了解这个数组的排序程度
Dialogue: 0,0:15:24.51,0:15:30.75,英文,,0,0,0,,So in this case, there are 55 inversions, or 55 possible inversions, that could exist.
Dialogue: 0,0:15:24.51,0:15:30.75,中文,,0,0,0,,在这种情况下 存在 55 个逆序 或者说 55 个可能的逆序
Dialogue: 0,0:15:30.75,0:15:34.19,英文,,0,0,0,,Because I could check the 0 against any of these elements.
Dialogue: 0,0:15:30.75,0:15:34.19,中文,,0,0,0,,因为我可以将 0 与这些元素中的任何一个进行比较
Dialogue: 0,0:15:34.19,0:15:36.99,英文,,0,0,0,,And I could check the 1 against any of these elements.
Dialogue: 0,0:15:34.19,0:15:36.99,中文,,0,0,0,,我可以将 1 与这些元素中的任何一个进行比较
Dialogue: 0,0:15:36.99,0:15:40.24,英文,,0,0,0,,And I can check the 2 against any of these elements, so on.
Dialogue: 0,0:15:36.99,0:15:40.24,中文,,0,0,0,,我可以将 2 与这些元素中的任何一个进行比较 以此类推
Dialogue: 0,0:15:40.24,0:15:45.24,英文,,0,0,0,,So if you list out all the pairs, 0, 1, 0, 2, 0, 3, 0, 4,
Dialogue: 0,0:15:40.24,0:15:45.24,中文,,0,0,0,,如果你列出所有的数字对 0, 1, 0, 2, 0, 3, 0, 4,
Dialogue: 0,0:15:45.24,0:15:47.70,英文,,0,0,0,,I list out 3, 4, 3, 8, 3, 6.
Dialogue: 0,0:15:45.24,0:15:47.70,中文,,0,0,0,,我列出 3, 4, 3, 8, 3, 6
Dialogue: 0,0:15:47.70,0:15:51.10,英文,,0,0,0,,If I list out all of the pairs, there are 55 of them.
Dialogue: 0,0:15:47.70,0:15:51.10,中文,,0,0,0,,如果我列出所有的数字对 会有 55 对
Dialogue: 0,0:15:51.10,0:15:55.10,英文,,0,0,0,,And it turns out in this particular array, six of them are inversions.
Dialogue: 0,0:15:51.10,0:15:55.10,中文,,0,0,0,,结果在这个特定的数组中 其中有 6 对是逆序的
Dialogue: 0,0:15:55.10,0:15:57.25,英文,,0,0,0,,That is, they are out of order.
Dialogue: 0,0:15:55.10,0:15:57.25,中文,,0,0,0,,也就是说 它们的顺序是反的
Dialogue: 0,0:15:57.25,0:15:59.99,英文,,0,0,0,,So for example, we saw 8 and 5.
Dialogue: 0,0:15:57.25,0:15:59.99,中文,,0,0,0,,例如 我们看到了 8 和 5
Dialogue: 0,0:15:59.99,0:16:03.73,英文,,0,0,0,,That's an inversion because the 8 should not come before the 5.
Dialogue: 0,0:15:59.99,0:16:03.73,中文,,0,0,0,,这是一个逆序 因为 8 不应该在 5 之前
Dialogue: 0,0:16:03.73,0:16:06.83,英文,,0,0,0,,But out of 55 possible, there are only six.
Dialogue: 0,0:16:03.73,0:16:06.83,中文,,0,0,0,,但是在 55 个可能的逆序中 只有 6 个是真正的逆序
Dialogue: 0,0:16:06.83,0:16:13.15,英文,,0,0,0,,And that somehow captures the notion that this array is pretty close, but not all the way there.
Dialogue: 0,0:16:06.83,0:16:13.15,中文,,0,0,0,,这在某种程度上说明了这个数组已经非常接近有序状态 但还没有完全排好序
Dialogue: 0,0:16:13.15,0:16:17.91,英文,,0,0,0,,So if I have a definition like inversion, then there's another way to talk about sorting.
Dialogue: 0,0:16:13.15,0:16:17.91,中文,,0,0,0,,如果我有一个像“逆序”这样的定义 那么就有另一种方法来谈论排序
Dialogue: 0,0:16:17.91,0:16:21.07,英文,,0,0,0,,So I could say, put all the items in non-decreasing order.
Dialogue: 0,0:16:17.91,0:16:21.07,中文,,0,0,0,,我可以说 把所有的项目按非递减顺序排列
Dialogue: 0,0:16:21.07,0:16:23.01,英文,,0,0,0,,Or I could say, I have this sequence.
Dialogue: 0,0:16:21.07,0:16:23.01,中文,,0,0,0,,或者我可以说 我有这个序列
Dialogue: 0,0:16:23.01,0:16:25.34,英文,,0,0,0,,It has some number of inversions, like 6.
Dialogue: 0,0:16:23.01,0:16:25.34,中文,,0,0,0,,它有一些逆序 比如 6 个
Dialogue: 0,0:16:25.34,0:16:27.96,英文,,0,0,0,,And I want this number to go down to 0.
Dialogue: 0,0:16:25.34,0:16:27.96,中文,,0,0,0,,我想让这个数字降到 0
Dialogue: 0,0:16:27.96,0:16:35.46,英文,,0,0,0,,So take the items, shuffle them around, move them around, put them in order, such that the number of inversions is 0.
Dialogue: 0,0:16:27.96,0:16:35.46,中文,,0,0,0,,把这些项目打乱 移动它们 把它们按顺序排列 使逆序的数量为 0
Dialogue: 0,0:16:35.46,0:16:37.32,英文,,0,0,0,,It's another way to talk about sorting.
Dialogue: 0,0:16:35.46,0:16:37.32,中文,,0,0,0,,这是另一种谈论排序的方式
Dialogue: 0,0:16:37.32,0:16:43.08,英文,,0,0,0,,But inversions will be pretty useful when we talk about different algorithms, try to convince ourselves that they work.
Dialogue: 0,0:16:37.32,0:16:43.08,中文,,0,0,0,,但是当我们讨论不同的算法 试图说服自己它们有效的时候 逆序将非常有用
Dialogue: 0,0:16:43.08,0:16:52.23,英文,,0,0,0,,By the way, I will mention now, before we start seeing the actual algorithms, some of our algorithms will take this number 6 and slowly chip away at it.
Dialogue: 0,0:16:43.08,0:16:52.23,中文,,0,0,0,,顺便说一下 在我们开始看实际的算法之前 我想说的是 我们的一些算法会取这个数字 6 然后慢慢地减少它
Dialogue: 0,0:16:52.23,0:16:54.77,英文,,0,0,0,,And we'll swap something, and now there's only five inversions.
Dialogue: 0,0:16:52.23,0:16:54.77,中文,,0,0,0,,我们会交换一些东西 现在只剩下 5 个逆序
Dialogue: 0,0:16:54.77,0:16:57.31,英文,,0,0,0,,And then we'll do another swap, and now there's four inversions.
Dialogue: 0,0:16:54.77,0:16:57.31,中文,,0,0,0,,然后我们会再进行一次交换 现在就只剩下 4 个逆序了
Dialogue: 0,0:16:57.31,0:17:02.01,英文,,0,0,0,,So we'll slowly always decrease the number of inversions until we hit 0.
Dialogue: 0,0:16:57.31,0:17:02.01,中文,,0,0,0,,我们会慢慢地减少逆序的数量 直到达到 0
Dialogue: 0,0:17:02.01,0:17:03.97,英文,,0,0,0,,That's a valid strategy.
Dialogue: 0,0:17:02.01,0:17:03.97,中文,,0,0,0,,这是一个有效的策略
Dialogue: 0,0:17:03.97,0:17:06.21,英文,,0,0,0,,Some other sorting algorithms are a bit more wild.
Dialogue: 0,0:17:03.97,0:17:06.21,中文,,0,0,0,,其他一些排序算法就比较狂野了
Dialogue: 0,0:17:06.21,0:17:08.96,英文,,0,0,0,,They actually shuffle things out of order first.
Dialogue: 0,0:17:06.21,0:17:08.96,中文,,0,0,0,,它们实际上先把东西打乱顺序
Dialogue: 0,0:17:08.96,0:17:11.78,英文,,0,0,0,,And so the number of inversions will increase at first.
Dialogue: 0,0:17:08.96,0:17:11.78,中文,,0,0,0,,逆序的数量一开始会增加
Dialogue: 0,0:17:11.78,0:17:15.16,英文,,0,0,0,,You'll actually make things worse when the algorithm starts out.
Dialogue: 0,0:17:11.78,0:17:15.16,中文,,0,0,0,,当算法开始运行时 实际上会把事情弄得更糟
Dialogue: 0,0:17:15.16,0:17:18.54,英文,,0,0,0,,But it's OK, because when the algorithm ends, everything will fall in place.
Dialogue: 0,0:17:15.16,0:17:18.54,中文,,0,0,0,,但没关系 因为当算法结束时 一切都会井然有序
Dialogue: 0,0:17:18.54,0:17:21.95,英文,,0,0,0,,And the number of inversions will go all the way back down to 0.
Dialogue: 0,0:17:18.54,0:17:21.95,中文,,0,0,0,,逆序的数量会一路降到 0
Dialogue: 0,0:17:21.95,0:17:26.57,英文,,0,0,0,,So sometimes algorithms slowly decrease the number of inversions.
Dialogue: 0,0:17:21.95,0:17:26.57,中文,,0,0,0,,有时候算法会慢慢减少逆序的数量
Dialogue: 0,0:17:26.57,0:17:28.09,英文,,0,0,0,,Other ones are a bit more wild.
Dialogue: 0,0:17:26.57,0:17:28.09,中文,,0,0,0,,其他的算法就比较狂野了
Dialogue: 0,0:17:28.09,0:17:32.20,英文,,0,0,0,,They'll increase before decreasing the number of inversions.
Dialogue: 0,0:17:28.09,0:17:32.20,中文,,0,0,0,,它们会在减少逆序数量之前先增加逆序数量
Dialogue: 0,0:17:32.20,0:17:36.64,英文,,0,0,0,,All of those are good algorithms that we'll see soon.
Dialogue: 0,0:17:32.20,0:17:36.64,中文,,0,0,0,,所有这些都是我们将很快看到的好的算法
Dialogue: 0,0:17:36.64,0:17:42.47,英文,,0,0,0,,OK, so as we talk about algorithms, we should also talk about how good they are.
Dialogue: 0,0:17:36.64,0:17:42.47,中文,,0,0,0,,当我们谈论算法的时候 我们也应该谈谈它们有多好
Dialogue: 0,0:17:42.47,0:17:44.41,英文,,0,0,0,,So hopefully, this slide, mostly review.
Dialogue: 0,0:17:42.47,0:17:44.41,中文,,0,0,0,,希望这张幻灯片大部分都是复习
Dialogue: 0,0:17:44.41,0:17:49.63,英文,,0,0,0,,But in case Spring Break has got you hung over or something, well, let's talk about the time complexity.
Dialogue: 0,0:17:44.41,0:17:49.63,中文,,0,0,0,,但是以防万一春假让你宿醉或者什么的 好吧 让我们来谈谈时间复杂度
Dialogue: 0,0:17:49.63,0:17:50.77,英文,,0,0,0,,We've seen that before.
Dialogue: 0,0:17:49.63,0:17:50.77,中文,,0,0,0,,我们以前见过这个
Dialogue: 0,0:17:50.77,0:17:55.07,英文,,0,0,0,,It tells us, asymptotically, how long the algorithm takes to run.
Dialogue: 0,0:17:50.77,0:17:55.07,中文,,0,0,0,,它告诉我们 算法运行需要多长时间 渐近地
Dialogue: 0,0:17:55.07,0:18:04.86,英文,,0,0,0,,And although we haven't analyzed it too much yet, there's also something called space complexity, which tells me how much space the algorithm needs to run.
Dialogue: 0,0:17:55.07,0:18:04.86,中文,,0,0,0,,虽然我们还没有太多地分析它 但还有一种叫做空间复杂度的东西 它告诉我算法运行需要多少空间
Dialogue: 0,0:18:04.86,0:18:12.88,英文,,0,0,0,,And one thing I'll note that I don't think I've noted yet is that space complexity is usually measured in terms of how much extra space you need.
Dialogue: 0,0:18:04.86,0:18:12.88,中文,,0,0,0,,我要注意的一件事 我认为我还没有注意到 那就是空间复杂度通常是根据你需要多少额外的空间来衡量的
Dialogue: 0,0:18:12.88,0:18:16.90,英文,,0,0,0,,So we don't count the space it takes to store the original array.
Dialogue: 0,0:18:12.88,0:18:16.90,中文,,0,0,0,,我们不计算存储原始数组所需的空间
Dialogue: 0,0:18:16.90,0:18:20.82,英文,,0,0,0,,We only count the amount of extra space that someone would need.
Dialogue: 0,0:18:16.90,0:18:20.82,中文,,0,0,0,,我们只计算某人需要的额外空间量
Dialogue: 0,0:18:20.82,0:18:25.01,英文,,0,0,0,,Otherwise, every algorithm would have to store the initial problem.
Dialogue: 0,0:18:20.82,0:18:25.01,中文,,0,0,0,,否则 每个算法都必须存储初始问题
Dialogue: 0,0:18:25.01,0:18:27.15,英文,,0,0,0,,So that's a little bit weird.
Dialogue: 0,0:18:25.01,0:18:27.15,中文,,0,0,0,,这有点奇怪
Dialogue: 0,0:18:27.15,0:18:32.27,英文,,0,0,0,,So instead, every time we talk about space complexity, we're not going to count the size of the initial problem.
Dialogue: 0,0:18:27.15,0:18:32.27,中文,,0,0,0,,相反 每次我们谈论空间复杂度时 我们都不会计算初始问题的大小
Dialogue: 0,0:18:32.27,0:18:37.13,英文,,0,0,0,,We'll just talk about how much extra space did it cost you to finish running the algorithm?
Dialogue: 0,0:18:32.27,0:18:37.13,中文,,0,0,0,,我们只会讨论完成算法运行需要花费多少额外的空间？
Dialogue: 0,0:18:37.13,0:18:43.50,英文,,0,0,0,,What are the extra temporary arrays or instance variables you had to make to solve the problem?
Dialogue: 0,0:18:37.13,0:18:43.50,中文,,0,0,0,,为了解决这个问题 你必须创建哪些额外的临时数组或实例变量？
Dialogue: 0,0:18:43.50,0:18:47.56,英文,,0,0,0,,That's time complexity, space complexity, all set.
Dialogue: 0,0:18:43.50,0:18:47.56,中文,,0,0,0,,时间复杂度 空间复杂度 都设置好了
Dialogue: 0,0:18:47.56,0:18:49.16,英文,,0,0,0,,OK, here come sorts.
Dialogue: 0,0:18:47.56,0:18:49.16,中文,,0,0,0,,好的 排序来了
Dialogue: 0,0:18:49.16,0:18:53.18,英文,,0,0,0,,I will tell you about two, maybe three, if I have time.
Dialogue: 0,0:18:49.16,0:18:53.18,中文,,0,0,0,,我会告诉你两种 如果我有时间的话 也许是三种
Dialogue: 0,0:18:53.18,0:18:54.79,英文,,0,0,0,,So here we go.
Dialogue: 0,0:18:53.18,0:18:54.79,中文,,0,0,0,,我们开始吧
Dialogue: 0,0:18:54.79,0:18:57.05,英文,,0,0,0,,I will start with selection sort.
Dialogue: 0,0:18:54.79,0:18:57.05,中文,,0,0,0,,我将从选择排序开始
Dialogue: 0,0:18:57.05,0:18:58.11,英文,,0,0,0,,Here we go.
Dialogue: 0,0:18:57.05,0:18:58.11,中文,,0,0,0,,我们开始吧
Dialogue: 0,0:18:58.11,0:18:58.97,英文,,0,0,0,,Here is an array.
Dialogue: 0,0:18:58.11,0:18:58.97,中文,,0,0,0,,这是一个数组
Dialogue: 0,0:18:58.97,0:19:01.45,英文,,0,0,0,,Do we all agree it's not really sorted?
Dialogue: 0,0:18:58.97,0:19:01.45,中文,,0,0,0,,我们都同意它没有真正排序吗？
Dialogue: 0,0:19:01.45,0:19:03.19,英文,,0,0,0,,OK, here's what I'll do.
Dialogue: 0,0:19:01.45,0:19:03.19,中文,,0,0,0,,好的 我要做的是：
Dialogue: 0,0:19:03.19,0:19:07.70,英文,,0,0,0,,I'm going to go through the array, find the smallest item, and dump it at the front.
Dialogue: 0,0:19:03.19,0:19:07.70,中文,,0,0,0,,我要遍历数组 找到最小的项目 然后把它放到前面
Dialogue: 0,0:19:07.70,0:19:11.20,英文,,0,0,0,,And I will do that over and over again until it's sorted.
Dialogue: 0,0:19:07.70,0:19:11.20,中文,,0,0,0,,我会一遍又一遍地这样做 直到它被排序
Dialogue: 0,0:19:11.20,0:19:12.20,英文,,0,0,0,,That's it.
Dialogue: 0,0:19:11.20,0:19:12.20,中文,,0,0,0,,就是这样
Dialogue: 0,0:19:12.20,0:19:17.39,英文,,0,0,0,,Find the smallest item, put it at the front, do it over and over again till everything is sorted.
Dialogue: 0,0:19:12.20,0:19:17.39,中文,,0,0,0,,找到最小的项目 把它放在前面 一遍又一遍地做 直到所有东西都被排序
Dialogue: 0,0:19:17.39,0:19:18.95,英文,,0,0,0,,So let's scan through this array.
Dialogue: 0,0:19:17.39,0:19:18.95,中文,,0,0,0,,让我们扫描这个数组
Dialogue: 0,0:19:18.95,0:19:20.15,英文,,0,0,0,,Scan.
Dialogue: 0,0:19:18.95,0:19:20.15,中文,,0,0,0,,扫描
Dialogue: 0,0:19:20.15,0:19:23.18,英文,,0,0,0,,What is the smallest item? 2.
Dialogue: 0,0:19:20.15,0:19:23.18,中文,,0,0,0,,最小项是什么？ 2.
Dialogue: 0,0:19:23.18,0:19:23.60,英文,,0,0,0,,Thank you.
Dialogue: 0,0:19:23.18,0:19:23.60,中文,,0,0,0,,谢谢
Dialogue: 0,0:19:23.60,0:19:24.14,英文,,0,0,0,,OK.
Dialogue: 0,0:19:23.60,0:19:24.14,中文,,0,0,0,,
Dialogue: 0,0:19:24.14,0:19:25.56,英文,,0,0,0,,So there it is. It's 2.
Dialogue: 0,0:19:24.14,0:19:25.56,中文,,0,0,0,,就是它了  是 2.
Dialogue: 0,0:19:25.56,0:19:28.22,英文,,0,0,0,,And so I want to move this to the front of the array.
Dialogue: 0,0:19:25.56,0:19:28.22,中文,,0,0,0,,我想把它移到数组的前面
Dialogue: 0,0:19:28.22,0:19:34.80,英文,,0,0,0,,Well, at first it might be tempting to say, well, let's take 32 and 15 and let's like shift them over and then let's move the 2 to the front.
Dialogue: 0,0:19:28.22,0:19:34.80,中文,,0,0,0,,一开始 你可能会想 好吧 我们把 32 和 15 向后移 然后把 2 移到前面
Dialogue: 0,0:19:34.80,0:19:38.80,英文,,0,0,0,,But that might be kind of slow because then I have a lot of these items to shift over.
Dialogue: 0,0:19:34.80,0:19:38.80,中文,,0,0,0,,但这可能有点慢 因为我有很多项目要移动
Dialogue: 0,0:19:38.80,0:19:46.03,英文,,0,0,0,,So I will do a clever trick where instead of shifting all the items over, I will just take the 2, I'll just swap it with the 32.
Dialogue: 0,0:19:38.80,0:19:46.03,中文,,0,0,0,,我将使用一个巧妙的技巧 不是把所有项目都向后移 而是直接把 2 和 32 交换位置
Dialogue: 0,0:19:46.03,0:19:49.01,英文,,0,0,0,,So look, 2 was here, 32 was here.
Dialogue: 0,0:19:46.03,0:19:49.01,中文,,0,0,0,,看 2 在这里 32 在这里
Dialogue: 0,0:19:49.01,0:19:53.53,英文,,0,0,0,,They swapped places and that caused the 2 to appear at the front.
Dialogue: 0,0:19:49.01,0:19:53.53,中文,,0,0,0,,它们交换了位置 这使得 2 出现在前面
Dialogue: 0,0:19:53.53,0:19:55.23,英文,,0,0,0,,That's great.
Dialogue: 0,0:19:53.53,0:19:55.23,中文,,0,0,0,,太棒了
Dialogue: 0,0:19:55.23,0:20:01.35,英文,,0,0,0,,So now if you look at the two, I'm coloring it gray to indicate the fact that this too has found its rightful home.
Dialogue: 0,0:19:55.23,0:20:01.35,中文,,0,0,0,,现在如果你看一下这个 2 我把它涂成灰色 表示它已经找到了正确的位置
Dialogue: 0,0:20:01.35,0:20:03.02,英文,,0,0,0,,It will never move again.
Dialogue: 0,0:20:01.35,0:20:03.02,中文,,0,0,0,,它不会再移动了
Dialogue: 0,0:20:03.02,0:20:04.26,英文,,0,0,0,,It was the smallest item.
Dialogue: 0,0:20:03.02,0:20:04.26,中文,,0,0,0,,它是最小项
Dialogue: 0,0:20:04.26,0:20:05.40,英文,,0,0,0,,We put it at the front.
Dialogue: 0,0:20:04.26,0:20:05.40,中文,,0,0,0,,我们把它放在前面
Dialogue: 0,0:20:05.40,0:20:08.04,英文,,0,0,0,,There's no need to look at it a second time.
Dialogue: 0,0:20:05.40,0:20:08.04,中文,,0,0,0,,不需要再看它第二次了
Dialogue: 0,0:20:08.04,0:20:10.52,英文,,0,0,0,,So here's all the stuff that we do have to look at.
Dialogue: 0,0:20:08.04,0:20:10.52,中文,,0,0,0,,这些都是我们必须看的
Dialogue: 0,0:20:10.52,0:20:11.76,英文,,0,0,0,,I scan through it.
Dialogue: 0,0:20:10.52,0:20:11.76,中文,,0,0,0,,我扫描它
Dialogue: 0,0:20:11.76,0:20:13.89,英文,,0,0,0,,I find the next smallest items.
Dialogue: 0,0:20:11.76,0:20:13.89,中文,,0,0,0,,我找到下一个最小项
Dialogue: 0,0:20:13.89,0:20:15.09,英文,,0,0,0,,I don't look at the two.
Dialogue: 0,0:20:13.89,0:20:15.09,中文,,0,0,0,,我不看 2.
Dialogue: 0,0:20:15.09,0:20:15.87,英文,,0,0,0,,I've already looked at it.
Dialogue: 0,0:20:15.09,0:20:15.87,中文,,0,0,0,,我已经看过了
Dialogue: 0,0:20:15.87,0:20:17.05,英文,,0,0,0,,It's in the right place.
Dialogue: 0,0:20:15.87,0:20:17.05,中文,,0,0,0,,它在正确的位置
Dialogue: 0,0:20:17.05,0:20:20.87,英文,,0,0,0,,I scan through smallest item is
Dialogue: 0,0:20:17.05,0:20:20.87,中文,,0,0,0,,我扫描一遍 最小项是
Dialogue: 0,0:20:20.87,0:20:22.95,英文,,0,0,0,,15, check my work, 15.
Dialogue: 0,0:20:20.87,0:20:22.95,中文,,0,0,0,,15, 检查我的工作 15
Dialogue: 0,0:20:22.95,0:20:23.83,英文,,0,0,0,,OK.
Dialogue: 0,0:20:22.95,0:20:23.83,中文,,0,0,0,,
Dialogue: 0,0:20:23.83,0:20:28.05,英文,,0,0,0,,And again, I have to swap it to the front of the unsorted array.
Dialogue: 0,0:20:23.83,0:20:28.05,中文,,0,0,0,,再次 我必须把它交换到未排序数组的前面
Dialogue: 0,0:20:28.05,0:20:29.55,英文,,0,0,0,,So in this case, it's already at the front.
Dialogue: 0,0:20:28.05,0:20:29.55,中文,,0,0,0,,在这种情况下 它已经在前面了
Dialogue: 0,0:20:29.55,0:20:33.44,英文,,0,0,0,,So I swap the 15 with itself, or I don't move it.
Dialogue: 0,0:20:29.55,0:20:33.44,中文,,0,0,0,,我把 15 和它自己交换 或者我不移动它
Dialogue: 0,0:20:33.44,0:20:34.58,英文,,0,0,0,,And it's good.
Dialogue: 0,0:20:33.44,0:20:34.58,中文,,0,0,0,,它很好
Dialogue: 0,0:20:34.58,0:20:35.74,英文,,0,0,0,,It's locked in place.
Dialogue: 0,0:20:34.58,0:20:35.74,中文,,0,0,0,,它被锁定在原地
Dialogue: 0,0:20:35.74,0:20:37.34,英文,,0,0,0,,We'll never move again.
Dialogue: 0,0:20:35.74,0:20:37.34,中文,,0,0,0,,我们将永远不会再移动
Dialogue: 0,0:20:37.34,0:20:41.56,英文,,0,0,0,,And now I look at the rest of the array, scan through, what's the smallest item?
Dialogue: 0,0:20:37.34,0:20:41.56,中文,,0,0,0,,现在我查看数组的其余部分 扫描一遍 最小项是什么？
Dialogue: 0,0:20:41.56,0:20:43.04,英文,,0,0,0,,17. Which 17?
Dialogue: 0,0:20:41.56,0:20:43.04,中文,,0,0,0,,17. 哪个 17？
Dialogue: 0,0:20:43.04,0:20:43.90,英文,,0,0,0,,It's up to you.
Dialogue: 0,0:20:43.04,0:20:43.90,中文,,0,0,0,,由你决定
Dialogue: 0,0:20:43.90,0:20:46.86,英文,,0,0,0,,I chose this one for now, and I will swap it to the front.
Dialogue: 0,0:20:43.90,0:20:46.86,中文,,0,0,0,,我现在选择这个 我会把它交换到前面
Dialogue: 0,0:20:46.86,0:20:49.84,英文,,0,0,0,,So the 17 and the 32, they change places.
Dialogue: 0,0:20:46.86,0:20:49.84,中文,,0,0,0,,所以 17 和 32 它们交换了位置
Dialogue: 0,0:20:49.84,0:20:55.41,英文,,0,0,0,,And if I swap to the front, by the way, I mean the front of the unsorted array, I don't want to swap the 17 with the 2.
Dialogue: 0,0:20:49.84,0:20:55.41,中文,,0,0,0,,顺便说一句 如果我交换到前面 我的意思是未排序数组的前面 我不想把 17 和 2 交换
Dialogue: 0,0:20:55.41,0:20:57.61,英文,,0,0,0,,That would not be correct.
Dialogue: 0,0:20:55.41,0:20:57.61,中文,,0,0,0,,那是不正确的
Dialogue: 0,0:20:57.61,0:20:58.85,英文,,0,0,0,,And I can swap it with the 32.
Dialogue: 0,0:20:57.61,0:20:58.85,中文,,0,0,0,,我可以把它和 32 交换
Dialogue: 0,0:20:58.85,0:21:00.01,英文,,0,0,0,,OK, great.
Dialogue: 0,0:20:58.85,0:21:00.01,中文,,0,0,0,,好的 太棒了
Dialogue: 0,0:21:00.01,0:21:01.13,英文,,0,0,0,,Now it's in place.
Dialogue: 0,0:21:00.01,0:21:01.13,中文,,0,0,0,,现在它就位了
Dialogue: 0,0:21:01.13,0:21:05.39,英文,,0,0,0,,So I won't bore you with all of the steps, but we'll just keep going.
Dialogue: 0,0:21:01.13,0:21:05.39,中文,,0,0,0,,我不会让你厌烦所有的步骤 但我们会继续下去
Dialogue: 0,0:21:05.39,0:21:07.41,英文,,0,0,0,,17 swaps to the front.
Dialogue: 0,0:21:05.39,0:21:07.41,中文,,0,0,0,,17 交换到前面
Dialogue: 0,0:21:07.41,0:21:09.11,英文,,0,0,0,,17 swaps to the front.
Dialogue: 0,0:21:07.41,0:21:09.11,中文,,0,0,0,,17 交换到前面
Dialogue: 0,0:21:09.11,0:21:10.37,英文,,0,0,0,,19 swaps.
Dialogue: 0,0:21:09.11,0:21:10.37,中文,,0,0,0,,19 交换
Dialogue: 0,0:21:10.37,0:21:12.21,英文,,0,0,0,,26 swaps.
Dialogue: 0,0:21:10.37,0:21:12.21,中文,,0,0,0,,26 交换
Dialogue: 0,0:21:12.21,0:21:14.01,英文,,0,0,0,,32 swaps with itself.
Dialogue: 0,0:21:12.21,0:21:14.01,中文,,0,0,0,,32 和它自己交换
Dialogue: 0,0:21:14.01,0:21:15.81,英文,,0,0,0,,41 swaps with itself.
Dialogue: 0,0:21:14.01,0:21:15.81,中文,,0,0,0,,41 和它自己交换
Dialogue: 0,0:21:15.81,0:21:19.09,英文,,0,0,0,,Look, everything is sorted and beautiful.
Dialogue: 0,0:21:15.81,0:21:19.09,中文,,0,0,0,,看 一切都排序好了 很漂亮
Dialogue: 0,0:21:19.09,0:21:20.17,英文,,0,0,0,,OK, so that's it.
Dialogue: 0,0:21:19.09,0:21:20.17,中文,,0,0,0,,好的 就是这样
Dialogue: 0,0:21:20.17,0:21:21.15,英文,,0,0,0,,That's selection sort.
Dialogue: 0,0:21:20.17,0:21:21.15,中文,,0,0,0,,这就是选择排序
Dialogue: 0,0:21:21.15,0:21:24.69,英文,,0,0,0,,It's basically two steps.
Dialogue: 0,0:21:21.15,0:21:24.69,中文,,0,0,0,,它基本上是两个步骤
Dialogue: 0,0:21:24.69,0:21:25.23,英文,,0,0,0,,Do you like it?
Dialogue: 0,0:21:24.69,0:21:25.23,中文,,0,0,0,,你喜欢吗？
Dialogue: 0,0:21:25.23,0:21:26.57,英文,,0,0,0,,Do you have a bad feeling about it?
Dialogue: 0,0:21:25.23,0:21:26.57,中文,,0,0,0,,你对此有不好的感觉吗？
Dialogue: 0,0:21:26.57,0:21:29.85,英文,,0,0,0,,Well, I have a little bit of a bad feeling about it.
Dialogue: 0,0:21:26.57,0:21:29.85,中文,,0,0,0,,嗯 我对此有点不好的感觉
Dialogue: 0,0:21:29.85,0:21:31.15,英文,,0,0,0,,I don't know if you did.
Dialogue: 0,0:21:29.85,0:21:31.15,中文,,0,0,0,,我不知道你是否有
Dialogue: 0,0:21:31.15,0:21:36.71,英文,,0,0,0,,And so here is where I started to sense a bit of dread with SelectionSort.
Dialogue: 0,0:21:31.15,0:21:36.71,中文,,0,0,0,,在这里我开始对选择排序感到有点恐惧
Dialogue: 0,0:21:36.71,0:21:39.45,英文,,0,0,0,,So I started here, and I said, what's the smallest item?
Dialogue: 0,0:21:36.71,0:21:39.45,中文,,0,0,0,,我从这里开始 我说 最小项是什么？
Dialogue: 0,0:21:39.45,0:21:43.83,英文,,0,0,0,,And I scanned the entire array to find two, and then I swapped it.
Dialogue: 0,0:21:39.45,0:21:43.83,中文,,0,0,0,,我扫描了整个数组来找到 2 然后我交换了它
Dialogue: 0,0:21:43.83,0:21:46.29,英文,,0,0,0,,And then I asked, what's the next smallest item?
Dialogue: 0,0:21:43.83,0:21:46.29,中文,,0,0,0,,然后我问 下一个最小项是什么？
Dialogue: 0,0:21:46.29,0:21:47.49,英文,,0,0,0,,So what did I do?
Dialogue: 0,0:21:46.29,0:21:47.49,中文,,0,0,0,,我做了什么？
Dialogue: 0,0:21:47.49,0:21:50.77,英文,,0,0,0,,I scanned the entire array again to find the 15.
Dialogue: 0,0:21:47.49,0:21:50.77,中文,,0,0,0,,我再次扫描了整个数组来找到 15
Dialogue: 0,0:21:50.77,0:21:53.05,英文,,0,0,0,,Then I swapped it to the front.
Dialogue: 0,0:21:50.77,0:21:53.05,中文,,0,0,0,,然后我把它交换到前面
Dialogue: 0,0:21:53.05,0:21:54.15,英文,,0,0,0,,What's the next smallest item?
Dialogue: 0,0:21:53.05,0:21:54.15,中文,,0,0,0,,下一个最小项是什么？
Dialogue: 0,0:21:54.15,0:21:56.51,英文,,0,0,0,,I scanned everything again to find the 17.
Dialogue: 0,0:21:54.15,0:21:56.51,中文,,0,0,0,,我再次扫描了所有内容来找到 17
Dialogue: 0,0:21:56.51,0:21:58.39,英文,,0,0,0,,Then I swapped it.
Dialogue: 0,0:21:56.51,0:21:58.39,中文,,0,0,0,,然后我交换了它
Dialogue: 0,0:21:58.39,0:22:00.95,英文,,0,0,0,,So that doesn't feel so efficient.
Dialogue: 0,0:21:58.39,0:22:00.95,中文,,0,0,0,,这感觉不太有效率
Dialogue: 0,0:22:00.95,0:22:06.39,英文,,0,0,0,,And in fact, you can do some asymptotic analysis and think about, how many operations am I doing?
Dialogue: 0,0:22:00.95,0:22:06.39,中文,,0,0,0,,事实上 你可以做一些渐近分析 想想我做了多少次操作？
Dialogue: 0,0:22:06.39,0:22:09.62,英文,,0,0,0,,How many elements of the array do I have to look at
Dialogue: 0,0:22:06.39,0:22:09.62,中文,,0,0,0,,我必须查看数组中有多少个元素
Dialogue: 0,0:22:09.62,0:22:10.94,英文,,0,0,0,,in order to finish this algorithm.
Dialogue: 0,0:22:09.62,0:22:10.94,中文,,0,0,0,,才能完成这个算法
Dialogue: 0,0:22:10.94,0:22:15.28,英文,,0,0,0,,So here, I had to look at all n items to find the smallest one.
Dialogue: 0,0:22:10.94,0:22:15.28,中文,,0,0,0,,在这里 我必须查看所有 N 个项目才能找到最小的那个
Dialogue: 0,0:22:15.28,0:22:16.34,英文,,0,0,0,,I swapped it.
Dialogue: 0,0:22:15.28,0:22:16.34,中文,,0,0,0,,我交换了它
Dialogue: 0,0:22:16.34,0:22:22.04,英文,,0,0,0,,Then I had to look at n minus 1 items, because I don't have to look at the first one again to find the smallest item.
Dialogue: 0,0:22:16.34,0:22:22.04,中文,,0,0,0,,然后我必须查看 N-1 个项目 因为我不必再查看第一个项目来找到最小的项目
Dialogue: 0,0:22:22.04,0:22:22.70,英文,,0,0,0,,Then I swapped it.
Dialogue: 0,0:22:22.04,0:22:22.70,中文,,0,0,0,,然后我交换了它
Dialogue: 0,0:22:22.70,0:22:23.91,英文,,0,0,0,,OK, great.
Dialogue: 0,0:22:22.70,0:22:23.91,中文,,0,0,0,,好的 太棒了
Dialogue: 0,0:22:23.91,0:22:26.75,英文,,0,0,0,,Then I look at n minus 2 items to find the smallest one.
Dialogue: 0,0:22:23.91,0:22:26.75,中文,,0,0,0,,然后我查看 N-2 个项目来找到最小的那个
Dialogue: 0,0:22:26.75,0:22:27.73,英文,,0,0,0,,Then I swap it.
Dialogue: 0,0:22:26.75,0:22:27.73,中文,,0,0,0,,然后我交换了它
Dialogue: 0,0:22:27.73,0:22:29.81,英文,,0,0,0,,Then I look at n minus 3 items.
Dialogue: 0,0:22:27.73,0:22:29.81,中文,,0,0,0,,然后我查看 N-3 个项目
Dialogue: 0,0:22:29.81,0:22:31.41,英文,,0,0,0,,And maybe you see where this is going.
Dialogue: 0,0:22:29.81,0:22:31.41,中文,,0,0,0,,也许你看到了这是怎么回事
Dialogue: 0,0:22:31.41,0:22:35.03,英文,,0,0,0,,n minus 4, n minus 5, sum that all the way down to 1.
Dialogue: 0,0:22:31.41,0:22:35.03,中文,,0,0,0,,N-4, N-5, 一直到 1
Dialogue: 0,0:22:35.03,0:22:40.32,英文,,0,0,0,,and the sum of n plus n minus 1 plus n minus 2 all the way down to 1.
Dialogue: 0,0:22:35.03,0:22:40.32,中文,,0,0,0,,N + N-1 + N-2 一直到 1 的总和
Dialogue: 0,0:22:40.32,0:22:43.74,英文,,0,0,0,,Well, we know that's theta of n squared.
Dialogue: 0,0:22:40.32,0:22:43.74,中文,,0,0,0,,嗯 我们知道那是 Θ(N^2).
Dialogue: 0,0:22:43.74,0:22:47.64,英文,,0,0,0,,So selection sort, it works, but it's an n squared algorithm.
Dialogue: 0,0:22:43.74,0:22:47.64,中文,,0,0,0,,选择排序 它可以工作 但它是一个 N^2 算法
Dialogue: 0,0:22:47.64,0:22:50.92,英文,,0,0,0,,Hopefully, Kind of feels like we can do better.
Dialogue: 0,0:22:47.64,0:22:50.92,中文,,0,0,0,,希望  感觉我们可以做得更好
Dialogue: 0,0:22:50.92,0:22:57.40,英文,,0,0,0,,Why were we wasting all the time looking at the same elements of the array over and over and over again to find the smallest item?
Dialogue: 0,0:22:50.92,0:22:57.40,中文,,0,0,0,,为什么我们要浪费所有时间一遍又一遍地查看数组的相同元素来找到最小的项目？
Dialogue: 0,0:22:57.40,0:22:59.44,英文,,0,0,0,,Imagine if the array had a billion items.
Dialogue: 0,0:22:57.40,0:22:59.44,中文,,0,0,0,,想象一下 如果数组有十亿个项目
Dialogue: 0,0:22:59.44,0:23:02.40,英文,,0,0,0,,You'd have to scan through all of them to find the smallest item.
Dialogue: 0,0:22:59.44,0:23:02.40,中文,,0,0,0,,你必须扫描所有项目才能找到最小的项目
Dialogue: 0,0:23:02.40,0:23:08.87,英文,,0,0,0,,And then on the next step, you'd scan through all of the items again, minus one item, to find the next smallest item.
Dialogue: 0,0:23:02.40,0:23:08.87,中文,,0,0,0,,然后在下一步 你将再次扫描所有项目 减去一个项目 以找到下一个最小的项目
Dialogue: 0,0:23:08.87,0:23:10.41,英文,,0,0,0,,Seems kind of a waste of time.
Dialogue: 0,0:23:08.87,0:23:10.41,中文,,0,0,0,,这似乎有点浪费时间
Dialogue: 0,0:23:10.41,0:23:15.41,英文,,0,0,0,,So that selection sort, it's simple, but maybe we can do better.
Dialogue: 0,0:23:10.41,0:23:15.41,中文,,0,0,0,,选择排序 它很简单 但也许我们可以做得更好
Dialogue: 0,0:23:15.41,0:23:20.83,英文,,0,0,0,,Thoughts, opinions, questions about selection sort, where I pile onwards.
Dialogue: 0,0:23:15.41,0:23:20.83,中文,,0,0,0,,关于选择排序的想法、意见、问题 在我继续前进的地方
Dialogue: 0,0:23:20.83,0:23:26.14,英文,,0,0,0,,When counting inversions, do inversions you decide to do carry out the whole time?
Dialogue: 0,0:23:20.83,0:23:26.14,中文,,0,0,0,,在计算逆序数时 你决定做的逆序数会一直执行吗？
Dialogue: 0,0:23:26.14,0:23:27.38,英文,,0,0,0,,That's a good question.
Dialogue: 0,0:23:26.14,0:23:27.38,中文,,0,0,0,,这是个好问题
Dialogue: 0,0:23:27.38,0:23:30.82,英文,,0,0,0,,I would say for an inversion, someone just hands you an array.
Dialogue: 0,0:23:27.38,0:23:30.82,中文,,0,0,0,,我想说对于逆序数 有人只是给你一个数组
Dialogue: 0,0:23:30.82,0:23:31.62,英文,,0,0,0,,It could be sorted.
Dialogue: 0,0:23:30.82,0:23:31.62,中文,,0,0,0,,它可以是排序的
Dialogue: 0,0:23:31.62,0:23:32.68,英文,,0,0,0,,It could be partially sorted.
Dialogue: 0,0:23:31.62,0:23:32.68,中文,,0,0,0,,它可以是部分排序的
Dialogue: 0,0:23:32.68,0:23:33.80,英文,,0,0,0,,It could be unsorted.
Dialogue: 0,0:23:32.68,0:23:33.80,中文,,0,0,0,,它可以是未排序的
Dialogue: 0,0:23:33.80,0:23:37.78,英文,,0,0,0,,And you just count the number of inversions for a specific array.
Dialogue: 0,0:23:33.80,0:23:37.78,中文,,0,0,0,,你只需要计算特定数组的逆序数
Dialogue: 0,0:23:37.78,0:23:39.87,英文,,0,0,0,,That's kind of how I think about it.
Dialogue: 0,0:23:37.78,0:23:39.87,中文,,0,0,0,,我就是这样想的
Dialogue: 0,0:23:39.87,0:23:41.13,英文,,0,0,0,,So input is an array.
Dialogue: 0,0:23:39.87,0:23:41.13,中文,,0,0,0,,输入是一个数组
Dialogue: 0,0:23:41.13,0:23:46.51,英文,,0,0,0,,Output is a number of inversions.
Dialogue: 0,0:23:41.13,0:23:46.51,中文,,0,0,0,,输出是逆序数
Dialogue: 0,0:23:46.51,0:23:47.45,英文,,0,0,0,,OK, good question, though.
Dialogue: 0,0:23:46.51,0:23:47.45,中文,,0,0,0,,好的 不过这是个好问题
Dialogue: 0,0:23:47.45,0:23:49.13,英文,,0,0,0,,Sorry for not getting to it earlier.
Dialogue: 0,0:23:47.45,0:23:49.13,中文,,0,0,0,,很抱歉没有早点回答你
Dialogue: 0,0:23:49.13,0:23:51.39,英文,,0,0,0,,OK, that was SelectionSort.
Dialogue: 0,0:23:49.13,0:23:51.39,中文,,0,0,0,,好的 这就是选择排序
Dialogue: 0,0:23:51.39,0:23:52.01,英文,,0,0,0,,We saw it.
Dialogue: 0,0:23:51.39,0:23:52.01,中文,,0,0,0,,我们看到了
Dialogue: 0,0:23:52.01,0:23:54.14,英文,,0,0,0,,It works, but it's kind of slow.
Dialogue: 0,0:23:52.01,0:23:54.14,中文,,0,0,0,,它有效 但有点慢
Dialogue: 0,0:23:54.14,0:23:57.36,英文,,0,0,0,,So let's go find something better.
Dialogue: 0,0:23:54.14,0:23:57.36,中文,,0,0,0,,我们去找更好的东西吧
Dialogue: 0,0:23:57.36,0:24:01.68,英文,,0,0,0,,So I go back and I think about all of those data structures that I spent all that time learning.
Dialogue: 0,0:23:57.36,0:24:01.68,中文,,0,0,0,,我回去思考我花那么多时间学习的所有那些数据结构
Dialogue: 0,0:24:01.68,0:24:05.32,英文,,0,0,0,,And I realized, well, what was I doing in SelectionSort?
Dialogue: 0,0:24:01.68,0:24:05.32,中文,,0,0,0,,我意识到 嗯 我在选择排序中做了什么？
Dialogue: 0,0:24:05.32,0:24:07.44,英文,,0,0,0,,I kept trying to find the smallest item.
Dialogue: 0,0:24:05.32,0:24:07.44,中文,,0,0,0,,我一直试图找到最小的项目
Dialogue: 0,0:24:07.44,0:24:08.36,英文,,0,0,0,,I scanned through the array.
Dialogue: 0,0:24:07.44,0:24:08.36,中文,,0,0,0,,我扫描了数组
Dialogue: 0,0:24:08.36,0:24:09.68,英文,,0,0,0,,What's the smallest item?
Dialogue: 0,0:24:08.36,0:24:09.68,中文,,0,0,0,,最小的项目是什么？
Dialogue: 0,0:24:09.68,0:24:10.58,英文,,0,0,0,,I scanned through the array.
Dialogue: 0,0:24:09.68,0:24:10.58,中文,,0,0,0,,我扫描了数组
Dialogue: 0,0:24:10.58,0:24:12.99,英文,,0,0,0,,What's the smallest item?
Dialogue: 0,0:24:10.58,0:24:12.99,中文,,0,0,0,,最小的项目是什么？
Dialogue: 0,0:24:12.99,0:24:18.51,英文,,0,0,0,,And I go back and I think, do I have a data structure that's very good at finding smallest items?
Dialogue: 0,0:24:12.99,0:24:18.51,中文,,0,0,0,,然后我回去思考 我是否有数据结构非常擅长查找最小项目？
Dialogue: 0,0:24:18.51,0:24:21.45,英文,,0,0,0,,Like I give it a pile of data and I say, what's the smallest?
Dialogue: 0,0:24:18.51,0:24:21.45,中文,,0,0,0,,比如我给它一堆数据 我说 最小的项目是什么？
Dialogue: 0,0:24:21.45,0:24:23.17,英文,,0,0,0,,Well, yeah, it turns out I do.
Dialogue: 0,0:24:21.45,0:24:23.17,中文,,0,0,0,,嗯 是的 事实证明我有
Dialogue: 0,0:24:23.17,0:24:25.57,英文,,0,0,0,,You remember the heap or the priority queue?
Dialogue: 0,0:24:23.17,0:24:25.57,中文,,0,0,0,,你记得堆或优先队列吗？
Dialogue: 0,0:24:25.57,0:24:27.12,英文,,0,0,0,,What was a heap really good at?
Dialogue: 0,0:24:25.57,0:24:27.12,中文,,0,0,0,,堆擅长什么？
Dialogue: 0,0:24:27.12,0:24:30.74,英文,,0,0,0,,A heap was good at telling you what the smallest item is.
Dialogue: 0,0:24:27.12,0:24:30.74,中文,,0,0,0,,堆擅长告诉你最小的项目是什么
Dialogue: 0,0:24:30.74,0:24:32.16,英文,,0,0,0,,That's what the heap was good at.
Dialogue: 0,0:24:30.74,0:24:32.16,中文,,0,0,0,,这就是堆擅长的
Dialogue: 0,0:24:32.16,0:24:41.92,英文,,0,0,0,,So what if, instead of spending all that time scanning over and over again to find the smallest item, I use the heap to help me find the smallest item quickly?
Dialogue: 0,0:24:32.16,0:24:41.92,中文,,0,0,0,,那么 如果我不是花那么多时间一遍又一遍地扫描来找到最小的项目 而是使用堆来帮助我快速找到最小的项目呢？
Dialogue: 0,0:24:41.92,0:24:43.64,英文,,0,0,0,,So let's try and do that.
Dialogue: 0,0:24:41.92,0:24:43.64,中文,,0,0,0,,让我们试试这样做
Dialogue: 0,0:24:43.64,0:24:49.49,英文,,0,0,0,,So I'll show you a naive version, which hopefully is more intuitive, and then we'll try to make it more efficient.
Dialogue: 0,0:24:43.64,0:24:49.49,中文,,0,0,0,,我将向你展示一个天真的版本 希望它更直观 然后我们将尝试使其更有效
Dialogue: 0,0:24:49.49,0:24:52.81,英文,,0,0,0,,So here's the algorithm, and it's like one sentence.
Dialogue: 0,0:24:49.49,0:24:52.81,中文,,0,0,0,,这是算法 它就像一句话
Dialogue: 0,0:24:52.81,0:24:59.58,英文,,0,0,0,,I'll take all my items, I'll shove them in a heap, and then I'll delete the items over and over again, and they'll come out in order.
Dialogue: 0,0:24:52.81,0:24:59.58,中文,,0,0,0,,我将把我所有的项目都塞进一个堆里 然后我将一遍又一遍地删除这些项目 它们会按顺序出来
Dialogue: 0,0:24:59.58,0:25:00.96,英文,,0,0,0,,That's basically it.
Dialogue: 0,0:24:59.58,0:25:00.96,中文,,0,0,0,,基本上就是这样
Dialogue: 0,0:25:00.96,0:25:04.44,英文,,0,0,0,,We know that the heap will always give me the next smallest item.
Dialogue: 0,0:25:00.96,0:25:04.44,中文,,0,0,0,,我们知道堆总是会给我下一个最小的项目
Dialogue: 0,0:25:04.44,0:25:09.38,英文,,0,0,0,,So if I shove everything in a heap and I pull all the items out one by one, they'll come out in order.
Dialogue: 0,0:25:04.44,0:25:09.38,中文,,0,0,0,,如果我把所有东西都堆在一起 然后一个一个地拿出来 它们就会按顺序出来
Dialogue: 0,0:25:09.38,0:25:10.46,英文,,0,0,0,,That's it.
Dialogue: 0,0:25:09.38,0:25:10.46,中文,,0,0,0,,就是这样
Dialogue: 0,0:25:10.46,0:25:12.84,英文,,0,0,0,,Okay, now I'll try to make it more formal.
Dialogue: 0,0:25:10.46,0:25:12.84,中文,,0,0,0,,好的 现在我试着把它写得更正式些
Dialogue: 0,0:25:12.84,0:25:22.06,英文,,0,0,0,,So, while this would work with the min-heap, which is kind of how I described it, I will actually use a max-heap for reasons that will become more clear in a couple minutes.
Dialogue: 0,0:25:12.84,0:25:22.06,中文,,0,0,0,,虽然这可以用最小堆来实现 就像我之前描述的那样 但我实际上会使用最大堆 原因几分钟后就会更清楚
Dialogue: 0,0:25:22.06,0:25:25.89,英文,,0,0,0,,So trust me on this one, I know how the lecture ends, the max-heap will be good.
Dialogue: 0,0:25:22.06,0:25:25.89,中文,,0,0,0,,相信我 我知道这节课的结局 最大堆会很棒的
Dialogue: 0,0:25:25.89,0:25:28.31,英文,,0,0,0,,But if you use the min-heap, that would be fine.
Dialogue: 0,0:25:25.89,0:25:28.31,中文,,0,0,0,,但如果你用最小堆 那也没问题
Dialogue: 0,0:25:28.31,0:25:32.25,英文,,0,0,0,,You would just shove all the items in a min-heap, pull them out one by one.
Dialogue: 0,0:25:28.31,0:25:32.25,中文,,0,0,0,,你只需要把所有东西都放进一个最小堆里 然后一个一个地取出来
Dialogue: 0,0:25:32.25,0:25:34.77,英文,,0,0,0,,That works perfectly fine too.
Dialogue: 0,0:25:32.25,0:25:34.77,中文,,0,0,0,,这也能完美地工作
Dialogue: 0,0:25:34.77,0:25:35.95,英文,,0,0,0,,Okay.
Dialogue: 0,0:25:34.77,0:25:35.95,中文,,0,0,0,,
Dialogue: 0,0:25:35.95,0:25:37.19,英文,,0,0,0,,But I'll use a max-heap.
Dialogue: 0,0:25:35.95,0:25:37.19,中文,,0,0,0,,但我会用最大堆
Dialogue: 0,0:25:37.19,0:25:43.04,英文,,0,0,0,,And hopefully, max-heap is also OK, because I put everything in the max-heap, and I pull the items out one by one.
Dialogue: 0,0:25:37.19,0:25:43.04,中文,,0,0,0,,希望最大堆也没问题 因为我把所有东西都放进最大堆里 然后一个一个地取出来
Dialogue: 0,0:25:43.04,0:25:46.56,英文,,0,0,0,,And in this case, I would get the items from largest to smallest.
Dialogue: 0,0:25:43.04,0:25:46.56,中文,,0,0,0,,在这种情况下 我会得到从大到小的元素
Dialogue: 0,0:25:46.56,0:25:47.48,英文,,0,0,0,,But that's OK.
Dialogue: 0,0:25:46.56,0:25:47.48,中文,,0,0,0,,但没关系
Dialogue: 0,0:25:47.48,0:25:50.02,英文,,0,0,0,,I can just reverse that, and I'll get a sort.
Dialogue: 0,0:25:47.48,0:25:50.02,中文,,0,0,0,,我只需要把它反过来 就能得到一个排序
Dialogue: 0,0:25:50.02,0:25:51.25,英文,,0,0,0,,OK, so here I go.
Dialogue: 0,0:25:50.02,0:25:51.25,中文,,0,0,0,,好 开始吧
Dialogue: 0,0:25:51.25,0:25:52.39,英文,,0,0,0,,Here's my input array.
Dialogue: 0,0:25:51.25,0:25:52.39,中文,,0,0,0,,这是我的输入数组
Dialogue: 0,0:25:52.39,0:25:54.33,英文,,0,0,0,,It's our old favorite array.
Dialogue: 0,0:25:52.39,0:25:54.33,中文,,0,0,0,,这是我们最喜欢的旧数组
Dialogue: 0,0:25:54.33,0:25:58.39,英文,,0,0,0,,This is our favorite, despite the fact that we've only seen it once, but it's our favorite array.
Dialogue: 0,0:25:54.33,0:25:58.39,中文,,0,0,0,,这是我们最喜欢的 尽管我们只见过它一次 但它就是我们最喜欢的数组
Dialogue: 0,0:25:58.39,0:26:03.12,英文,,0,0,0,,We're going to put all the items in a max heap and then pull the items out one by one.
Dialogue: 0,0:25:58.39,0:26:03.12,中文,,0,0,0,,我们要把所有元素都放进一个最大堆里 然后一个一个地取出来
Dialogue: 0,0:26:03.12,0:26:04.10,英文,,0,0,0,,So here we go.
Dialogue: 0,0:26:03.12,0:26:04.10,中文,,0,0,0,,开始吧
Dialogue: 0,0:26:04.10,0:26:05.12,英文,,0,0,0,,Here's the items.
Dialogue: 0,0:26:04.10,0:26:05.12,中文,,0,0,0,,这些是元素
Dialogue: 0,0:26:05.12,0:26:07.38,英文,,0,0,0,,I will shove them into a max heap.
Dialogue: 0,0:26:05.12,0:26:07.38,中文,,0,0,0,,我会把它们放进一个最大堆里
Dialogue: 0,0:26:07.38,0:26:09.06,英文,,0,0,0,,So here are the items.
Dialogue: 0,0:26:07.38,0:26:09.06,中文,,0,0,0,,这些是元素
Dialogue: 0,0:26:09.06,0:26:12.87,英文,,0,0,0,,After adding them into a max heap, you get a picture that looks like this.
Dialogue: 0,0:26:09.06,0:26:12.87,中文,,0,0,0,,把它们加入最大堆后 你会得到这样一张图
Dialogue: 0,0:26:12.87,0:26:20.03,英文,,0,0,0,,And just to be clear, I don't expect you to instantly see that this is the correct max heap after I add all these items.
Dialogue: 0,0:26:12.87,0:26:20.03,中文,,0,0,0,,需要说明的是 我并不期望你立即就能看出 在我添加所有这些元素后 这就是正确的最大堆
Dialogue: 0,0:26:20.03,0:26:27.49,英文,,0,0,0,,You'd have to actually run all the steps one by one, syncing some nodes or swimming some nodes as they enter the heap.
Dialogue: 0,0:26:20.03,0:26:27.49,中文,,0,0,0,,你必须一步一步地运行所有步骤 在元素进入堆时同步一些节点或上浮一些节点
Dialogue: 0,0:26:27.49,0:26:38.68,英文,,0,0,0,,But I think with enough time and some pencil and paper, you will be able to take this input array, add the items into the heap one by one, and get this resulting picture.
Dialogue: 0,0:26:27.49,0:26:38.68,中文,,0,0,0,,但我相信 只要有足够的时间和一些纸笔 你就能将这个输入数组 一个一个地将元素加入堆中 并得到这张最终的图
Dialogue: 0,0:26:38.68,0:26:39.55,英文,,0,0,0,,OK.
Dialogue: 0,0:26:38.68,0:26:39.55,中文,,0,0,0,,
Dialogue: 0,0:26:39.55,0:26:43.77,英文,,0,0,0,,Great. And by the way, do you remember how we represented a heap in memory?
Dialogue: 0,0:26:39.55,0:26:43.77,中文,,0,0,0,,很好  顺便问一下 你还记得我们是如何在内存中表示堆的吗?
Dialogue: 0,0:26:43.77,0:26:48.39,英文,,0,0,0,,Because this cartoon picture is great, but what was the actual implementation of a heap?
Dialogue: 0,0:26:43.77,0:26:48.39,中文,,0,0,0,,因为这张卡通图很棒 但堆的实际实现是什么?
Dialogue: 0,0:26:48.39,0:26:52.09,英文,,0,0,0,,Remember, we could have used all these different tree representations.
Dialogue: 0,0:26:48.39,0:26:52.09,中文,,0,0,0,,记住 我们可以使用所有这些不同的树表示形式
Dialogue: 0,0:26:52.09,0:26:56.70,英文,,0,0,0,,But do you remember in a heap, we actually used an array to represent the heap?
Dialogue: 0,0:26:52.09,0:26:56.70,中文,,0,0,0,,但你记得在堆中 我们实际上是用数组来表示堆的吗?
Dialogue: 0,0:26:56.70,0:26:58.54,英文,,0,0,0,,So that's what I'm showing here.
Dialogue: 0,0:26:56.70,0:26:58.54,中文,,0,0,0,,这就是我在这里展示的
Dialogue: 0,0:26:58.54,0:27:02.50,英文,,0,0,0,,This is the underlying representation of the heap.
Dialogue: 0,0:26:58.54,0:27:02.50,中文,,0,0,0,,这是堆的底层表示
Dialogue: 0,0:27:02.50,0:27:04.00,英文,,0,0,0,,This is the cartoon picture.
Dialogue: 0,0:27:02.50,0:27:04.00,中文,,0,0,0,,这是卡通图
Dialogue: 0,0:27:04.00,0:27:05.08,英文,,0,0,0,,This is what Java sees.
Dialogue: 0,0:27:04.00,0:27:05.08,中文,,0,0,0,,这是 Java 看到的
Dialogue: 0,0:27:05.08,0:27:08.60,英文,,0,0,0,,It sees an array, and the array represents the heap.
Dialogue: 0,0:27:05.08,0:27:08.60,中文,,0,0,0,,它看到的是一个数组 这个数组代表堆
Dialogue: 0,0:27:08.60,0:27:12.03,英文,,0,0,0,,That's why I'm going from one input array to another input array.
Dialogue: 0,0:27:08.60,0:27:12.03,中文,,0,0,0,,这就是为什么我从一个输入数组到另一个输入数组
Dialogue: 0,0:27:12.03,0:27:13.89,英文,,0,0,0,,That's because I threw everything in a heap.
Dialogue: 0,0:27:12.03,0:27:13.89,中文,,0,0,0,,那是因为我把所有东西都放进了一个堆里
Dialogue: 0,0:27:13.89,0:27:15.85,英文,,0,0,0,,And how do I represent the heap in memory?
Dialogue: 0,0:27:13.89,0:27:15.85,中文,,0,0,0,,我如何在内存中表示堆?
Dialogue: 0,0:27:15.85,0:27:17.17,英文,,0,0,0,,It's an array.
Dialogue: 0,0:27:15.85,0:27:17.17,中文,,0,0,0,,它是一个数组
Dialogue: 0,0:27:17.17,0:27:18.03,英文,,0,0,0,,OK.
Dialogue: 0,0:27:17.17,0:27:18.03,中文,,0,0,0,,
Dialogue: 0,0:27:18.03,0:27:19.07,英文,,0,0,0,,So there it is.
Dialogue: 0,0:27:18.03,0:27:19.07,中文,,0,0,0,,就是这样
Dialogue: 0,0:27:19.07,0:27:22.82,英文,,0,0,0,,I have a heap, and the max item is at the front.
Dialogue: 0,0:27:19.07,0:27:22.82,中文,,0,0,0,,我有一个堆 最大的元素在最前面
Dialogue: 0,0:27:22.82,0:27:24.10,英文,,0,0,0,,There is the 41.
Dialogue: 0,0:27:22.82,0:27:24.10,中文,,0,0,0,,那是 41
Dialogue: 0,0:27:24.10,0:27:26.92,英文,,0,0,0,,And then items below it are smaller.
Dialogue: 0,0:27:24.10,0:27:26.92,中文,,0,0,0,,然后它下面的元素更小
Dialogue: 0,0:27:26.92,0:27:28.44,英文,,0,0,0,,That's the heap.
Dialogue: 0,0:27:26.92,0:27:28.44,中文,,0,0,0,,这就是堆
Dialogue: 0,0:27:28.44,0:27:32.08,英文,,0,0,0,,OK, now it's time to take all of the items and delete them out.
Dialogue: 0,0:27:28.44,0:27:32.08,中文,,0,0,0,,好 现在是时候把所有的元素都删除了
Dialogue: 0,0:27:32.08,0:27:37.00,英文,,0,0,0,,But I guess before I do that, I want you to tell me the runtime of just this step.
Dialogue: 0,0:27:32.08,0:27:37.00,中文,,0,0,0,,但我想在我这样做之前 我希望你告诉我这一步的运行时间
Dialogue: 0,0:27:37.00,0:27:40.07,英文,,0,0,0,,So we haven't finished heap sort yet, but I'm kind of halfway there.
Dialogue: 0,0:27:37.00,0:27:40.07,中文,,0,0,0,,我们还没有完成堆排序 但我已经进行了一半了
Dialogue: 0,0:27:40.07,0:27:41.61,英文,,0,0,0,,I put all the things in the heap.
Dialogue: 0,0:27:40.07,0:27:41.61,中文,,0,0,0,,我把所有东西都放进了堆里
Dialogue: 0,0:27:41.61,0:27:44.17,英文,,0,0,0,,So how long did this take?
Dialogue: 0,0:27:41.61,0:27:44.17,中文,,0,0,0,,那么这花了多长时间?
Dialogue: 0,0:27:44.17,0:27:49.07,英文,,0,0,0,,How many operations did I have to do with the heap, and how long did each one take?
Dialogue: 0,0:27:44.17,0:27:49.07,中文,,0,0,0,,我必须对堆进行多少次操作 每一次操作花费多长时间?
Dialogue: 0,0:27:49.07,0:27:51.57,英文,,0,0,0,,Remember your heap runtimes?
Dialogue: 0,0:27:49.07,0:27:51.57,中文,,0,0,0,,还记得你的堆运行时间吗?
Dialogue: 0,0:27:51.57,0:27:54.16,英文,,0,0,0,,So there are n things that I had to add.
Dialogue: 0,0:27:51.57,0:27:54.16,中文,,0,0,0,,我必须添加 N 个元素
Dialogue: 0,0:27:54.16,0:27:59.82,英文,,0,0,0,,And how long does it take, roughly, to add an item into a heap with n items?
Dialogue: 0,0:27:54.16,0:27:59.82,中文,,0,0,0,,在有 N 个元素的堆中添加一个元素大约需要多长时间?
Dialogue: 0,0:27:59.82,0:28:01.06,英文,,0,0,0,,Just give me a big old bound.
Dialogue: 0,0:27:59.82,0:28:01.06,中文,,0,0,0,,给我一个大致的范围
Dialogue: 0,0:28:01.06,0:28:02.54,英文,,0,0,0,,Be lazy.
Dialogue: 0,0:28:01.06,0:28:02.54,中文,,0,0,0,,偷个懒
Dialogue: 0,0:28:02.54,0:28:04.44,英文,,0,0,0,,What do you like?
Dialogue: 0,0:28:02.54,0:28:04.44,中文,,0,0,0,,你喜欢什么?
Dialogue: 0,0:28:04.44,0:28:06.42,英文,,0,0,0,,How long does it take?
Dialogue: 0,0:28:04.44,0:28:06.42,中文,,0,0,0,,需要多长时间?
Dialogue: 0,0:28:06.42,0:28:07.40,英文,,0,0,0,,No takers.
Dialogue: 0,0:28:06.42,0:28:07.40,中文,,0,0,0,,没人回答
Dialogue: 0,0:28:07.40,0:28:08.46,英文,,0,0,0,,Yeah, I like nLogN.
Dialogue: 0,0:28:07.40,0:28:08.46,中文,,0,0,0,,是的 我喜欢 N log N
Dialogue: 0,0:28:08.46,0:28:15.54,英文,,0,0,0,,So there's n items, and it takes log n time to insert each element into the heap.
Dialogue: 0,0:28:08.46,0:28:15.54,中文,,0,0,0,,有 N 个元素 将每个元素插入堆中需要 log N 的时间
Dialogue: 0,0:28:15.54,0:28:18.89,英文,,0,0,0,,So I have a total runtime of this step of nLogN.
Dialogue: 0,0:28:15.54,0:28:18.89,中文,,0,0,0,,这一步的总运行时间为 N log N
Dialogue: 0,0:28:18.89,0:28:19.99,英文,,0,0,0,,There's n items.
Dialogue: 0,0:28:18.89,0:28:19.99,中文,,0,0,0,,有 N 个元素
Dialogue: 0,0:28:19.99,0:28:22.29,英文,,0,0,0,,Each one takes log n time to insert.
Dialogue: 0,0:28:19.99,0:28:22.29,中文,,0,0,0,,每个元素插入需要 log N 的时间
Dialogue: 0,0:28:22.29,0:28:24.03,英文,,0,0,0,,nLogN so far.
Dialogue: 0,0:28:22.29,0:28:24.03,中文,,0,0,0,,到目前为止是 N log N
Dialogue: 0,0:28:24.03,0:28:28.32,英文,,0,0,0,,I'll probably have to add some other stuff, but for now, nLogN.
Dialogue: 0,0:28:24.03,0:28:28.32,中文,,0,0,0,,我可能需要添加一些其他的东西 但现在 是 N log N
Dialogue: 0,0:28:28.32,0:28:29.79,英文,,0,0,0,,OK.
Dialogue: 0,0:28:28.32,0:28:29.79,中文,,0,0,0,,
Dialogue: 0,0:28:29.79,0:28:37.53,英文,,0,0,0,,Now it's time to delete all of the items out of the heap one by one, and I know that they'll come out in order, because that's the property of the heap.
Dialogue: 0,0:28:29.79,0:28:37.53,中文,,0,0,0,,现在是时候把所有元素都从堆中一个一个地删除了 我知道它们会按顺序出来 因为这是堆的性质
Dialogue: 0,0:28:37.53,0:28:41.63,英文,,0,0,0,,You always delete and get the largest item, since it's a max heap.
Dialogue: 0,0:28:37.53,0:28:41.63,中文,,0,0,0,,由于它是一个最大堆 你总是删除并获得最大的元素
Dialogue: 0,0:28:41.63,0:28:45.73,英文,,0,0,0,,By the way, at this point, I no longer need the input array, so I'll throw it away.
Dialogue: 0,0:28:41.63,0:28:45.73,中文,,0,0,0,,顺便说一下 在这一点上 我不再需要输入数组了 所以我要把它扔掉
Dialogue: 0,0:28:45.73,0:28:47.09,英文,,0,0,0,,You'll never see it again.
Dialogue: 0,0:28:45.73,0:28:47.09,中文,,0,0,0,,你再也见不到它了
Dialogue: 0,0:28:47.09,0:28:53.76,英文,,0,0,0,,I'll just use this representation of the heap, and I'll pull out items one by one, and I'll stick them in my output array.
Dialogue: 0,0:28:47.09,0:28:53.76,中文,,0,0,0,,我将只使用堆的这种表示形式 并将元素一个一个地取出 并把它们粘贴到我的输出数组中
Dialogue: 0,0:28:53.76,0:28:56.58,英文,,0,0,0,,Since I'm using a max heap, I'm going to fill the array backwards.
Dialogue: 0,0:28:53.76,0:28:56.58,中文,,0,0,0,,由于我使用的是最大堆 我将从后往前填充数组
Dialogue: 0,0:28:56.58,0:28:59.48,英文,,0,0,0,,Because remember, I get the largest items out first.
Dialogue: 0,0:28:56.58,0:28:59.48,中文,,0,0,0,,因为记住 我先取出了最大的元素
Dialogue: 0,0:28:59.48,0:29:08.11,英文,,0,0,0,,So I'll put the largest item here, and then the next largest item here, all the way down to the smallest item in the first box or element.
Dialogue: 0,0:28:59.48,0:29:08.11,中文,,0,0,0,,我会把最大的元素放在这里 然后是下一个最大的元素放在这里 一直到第一个框或元素中最小的元素
Dialogue: 0,0:29:08.11,0:29:08.86,英文,,0,0,0,,OK.
Dialogue: 0,0:29:08.11,0:29:08.86,中文,,0,0,0,,
Dialogue: 0,0:29:08.86,0:29:09.44,英文,,0,0,0,,So here I go.
Dialogue: 0,0:29:08.86,0:29:09.44,中文,,0,0,0,,开始吧
Dialogue: 0,0:29:09.44,0:29:10.58,英文,,0,0,0,,I'm going to take this heap.
Dialogue: 0,0:29:09.44,0:29:10.58,中文,,0,0,0,,我要取这个堆
Dialogue: 0,0:29:10.58,0:29:12.56,英文,,0,0,0,,I'm going to pull the smallest item out.
Dialogue: 0,0:29:10.58,0:29:12.56,中文,,0,0,0,,我要把最小的元素取出来
Dialogue: 0,0:29:12.56,0:29:16.78,英文,,0,0,0,,And remember, when you pull the smallest item out, a bunch of stuff happens in the heap.
Dialogue: 0,0:29:12.56,0:29:16.78,中文,,0,0,0,,记住 当你取出最小的元素时 堆里会发生很多事情
Dialogue: 0,0:29:16.78,0:29:18.50,英文,,0,0,0,,Some stuff shuffles up and down.
Dialogue: 0,0:29:16.78,0:29:18.50,中文,,0,0,0,,一些东西会上下移动
Dialogue: 0,0:29:18.50,0:29:19.96,英文,,0,0,0,,I don't really care what happens.
Dialogue: 0,0:29:18.50,0:29:19.96,中文,,0,0,0,,我不在乎发生了什么
Dialogue: 0,0:29:19.96,0:29:23.32,英文,,0,0,0,,But somehow, things in the heap shuffled up and down.
Dialogue: 0,0:29:19.96,0:29:23.32,中文,,0,0,0,,但不知何故 堆里的东西上下移动了
Dialogue: 0,0:29:23.32,0:29:26.67,英文,,0,0,0,,I got the 41 out, and I put it at the end of the array.
Dialogue: 0,0:29:23.32,0:29:26.67,中文,,0,0,0,,我取出了 41 并把它放在数组的末尾
Dialogue: 0,0:29:26.67,0:29:33.85,英文,,0,0,0,,And again, I don't expect you to instantly see that this is how the array changes, and this is how the cartoon picture changes.
Dialogue: 0,0:29:26.67,0:29:33.85,中文,,0,0,0,,再说一次 我并不期望你立即就能看出数组是如何变化的 以及卡通图是如何变化的
Dialogue: 0,0:29:33.85,0:29:38.63,英文,,0,0,0,,But I think if you just wrote it out, you'd be able to perform this heap operation.
Dialogue: 0,0:29:33.85,0:29:38.63,中文,,0,0,0,,但我认为 如果你把它写出来 你就能执行这个堆操作
Dialogue: 0,0:29:38.63,0:29:40.43,英文,,0,0,0,,It's just a heap delete.
Dialogue: 0,0:29:38.63,0:29:40.43,中文,,0,0,0,,这只是一个堆删除操作
Dialogue: 0,0:29:40.43,0:29:44.73,英文,,0,0,0,,I delete an item, some items sync or float, and I get the 41 out.
Dialogue: 0,0:29:40.43,0:29:44.73,中文,,0,0,0,,我删除了一个元素 一些元素下沉或上浮 我取出了 41
Dialogue: 0,0:29:44.73,0:29:47.28,英文,,0,0,0,,And now the heap is smaller, see?
Dialogue: 0,0:29:44.73,0:29:47.28,中文,,0,0,0,,现在堆变小了 看到了吗?
Dialogue: 0,0:29:47.28,0:29:48.58,英文,,0,0,0,,The heap used to have nine items.
Dialogue: 0,0:29:47.28,0:29:48.58,中文,,0,0,0,,这个堆以前有 9 个元素
Dialogue: 0,0:29:48.58,0:29:49.70,英文,,0,0,0,,Now it has eight.
Dialogue: 0,0:29:48.58,0:29:49.70,中文,,0,0,0,,现在它有 8 个了
Dialogue: 0,0:29:49.70,0:29:51.56,英文,,0,0,0,,So that's good, too.
Dialogue: 0,0:29:49.70,0:29:51.56,中文,,0,0,0,,那也很好
Dialogue: 0,0:29:51.56,0:29:52.68,英文,,0,0,0,,OK.
Dialogue: 0,0:29:51.56,0:29:52.68,中文,,0,0,0,,
Dialogue: 0,0:29:52.68,0:29:53.76,英文,,0,0,0,,Let's keep going.
Dialogue: 0,0:29:52.68,0:29:53.76,中文,,0,0,0,,继续
Dialogue: 0,0:29:53.76,0:29:58.96,英文,,0,0,0,,So again, I go to the heap, I pull the largest thing out of the heap, happens to be 32.
Dialogue: 0,0:29:53.76,0:29:58.96,中文,,0,0,0,,再一次 我到堆里 从堆里取出最大的东西 正好是 32
Dialogue: 0,0:29:58.96,0:30:08.70,英文,,0,0,0,,The items are going to shuffle around because I deleted something from the heap, and I put the 32 in the next position in the output array.
Dialogue: 0,0:29:58.96,0:30:08.70,中文,,0,0,0,,元素会四处移动 因为我从堆中删除了一些东西 我把 32 放在输出数组的下一个位置
Dialogue: 0,0:30:08.70,0:30:09.96,英文,,0,0,0,,And I keep going.
Dialogue: 0,0:30:08.70,0:30:09.96,中文,,0,0,0,,我继续
Dialogue: 0,0:30:09.96,0:30:11.06,英文,,0,0,0,,I pull out the next thing.
Dialogue: 0,0:30:09.96,0:30:11.06,中文,,0,0,0,,我取出下一个元素
Dialogue: 0,0:30:11.06,0:30:12.26,英文,,0,0,0,,I pull out the next thing.
Dialogue: 0,0:30:11.06,0:30:12.26,中文,,0,0,0,,我拿出下一个元素
Dialogue: 0,0:30:12.26,0:30:18.13,英文,,0,0,0,,And again, the exact way in which these numbers are shuffling is something that I think you could do with enough time.
Dialogue: 0,0:30:12.26,0:30:18.13,中文,,0,0,0,,同样 这些数字的具体洗牌方式 我认为只要有足够的时间 你也能做到
Dialogue: 0,0:30:18.13,0:30:20.59,英文,,0,0,0,,But it's just not interesting enough to do now.
Dialogue: 0,0:30:18.13,0:30:20.59,中文,,0,0,0,,但现在做这个没什么意思
Dialogue: 0,0:30:20.59,0:30:22.77,英文,,0,0,0,,I trust that you can do the heap operations.
Dialogue: 0,0:30:20.59,0:30:22.77,中文,,0,0,0,,我相信你能够进行堆操作
Dialogue: 0,0:30:22.77,0:30:24.59,英文,,0,0,0,,So there we go.
Dialogue: 0,0:30:22.77,0:30:24.59,中文,,0,0,0,,所以 就是这样
Dialogue: 0,0:30:24.59,0:30:26.15,英文,,0,0,0,,We pull items out one by one.
Dialogue: 0,0:30:24.59,0:30:26.15,中文,,0,0,0,,我们逐个取出元素
Dialogue: 0,0:30:26.15,0:30:32.59,英文,,0,0,0,,And we fill them into the output array until everything is gone in the heap.
Dialogue: 0,0:30:26.15,0:30:32.59,中文,,0,0,0,,并将它们填入输出数组 直到堆中所有元素都取出
Dialogue: 0,0:30:32.59,0:30:34.07,英文,,0,0,0,,OK, that's the cartoon.
Dialogue: 0,0:30:32.59,0:30:34.07,中文,,0,0,0,,好的 这就是示意图
Dialogue: 0,0:30:34.07,0:30:34.69,英文,,0,0,0,,I like it.
Dialogue: 0,0:30:34.07,0:30:34.69,中文,,0,0,0,,我喜欢
Dialogue: 0,0:30:34.69,0:30:35.99,英文,,0,0,0,,Any thoughts?
Dialogue: 0,0:30:34.69,0:30:35.99,中文,,0,0,0,,有什么想法吗？
Dialogue: 0,0:30:35.99,0:30:39.11,英文,,0,0,0,,So again, I pull something out, and I don't care how these items shuffle.
Dialogue: 0,0:30:35.99,0:30:39.11,中文,,0,0,0,,再说一次 我取出一个元素 我不关心这些元素如何洗牌
Dialogue: 0,0:30:39.11,0:30:40.13,英文,,0,0,0,,It's not my concern.
Dialogue: 0,0:30:39.11,0:30:40.13,中文,,0,0,0,,这不是我关心的问题
Dialogue: 0,0:30:40.13,0:30:41.64,英文,,0,0,0,,That's the heaps problem.
Dialogue: 0,0:30:40.13,0:30:41.64,中文,,0,0,0,,那是堆的问题
Dialogue: 0,0:30:41.64,0:30:47.82,英文,,0,0,0,,And I put the items one by one into the sorted array from the back to the front.
Dialogue: 0,0:30:41.64,0:30:47.82,中文,,0,0,0,,我把元素一个接一个地从后往前放入已排序的数组中
Dialogue: 0,0:30:47.82,0:30:50.52,英文,,0,0,0,,OK, thoughts, questions?
Dialogue: 0,0:30:47.82,0:30:50.52,中文,,0,0,0,,好的 有什么想法或问题吗？
Dialogue: 0,0:30:50.52,0:31:01.73,英文,,0,0,0,,Yeah, sorry.
Dialogue: 0,0:30:50.52,0:31:01.73,中文,,0,0,0,,是的 抱歉
Dialogue: 0,0:31:01.73,0:31:03.12,英文,,0,0,0,,The question was,
Dialogue: 0,0:31:01.73,0:31:03.12,中文,,0,0,0,,问题是
Dialogue: 0,0:31:03.12,0:31:04.06,英文,,0,0,0,,Oh, sorry.
Dialogue: 0,0:31:03.12,0:31:04.06,中文,,0,0,0,,哦 抱歉
Dialogue: 0,0:31:04.06,0:31:07.66,英文,,0,0,0,,Yeah, the question was, could I not start with the items at the end of the heap?
Dialogue: 0,0:31:04.06,0:31:07.66,中文,,0,0,0,,是的 问题是 我能不能从堆末尾的元素开始？
Dialogue: 0,0:31:07.66,0:31:10.50,英文,,0,0,0,,So like start here and just add backwards, I guess?
Dialogue: 0,0:31:07.66,0:31:10.50,中文,,0,0,0,,就是说从这里开始 然后倒着添加 我猜？
Dialogue: 0,0:31:10.50,0:31:16.39,英文,,0,0,0,,Well, the problem is that if you remember the heap property, the items in the heap are not necessarily all sorted.
Dialogue: 0,0:31:10.50,0:31:16.39,中文,,0,0,0,,问题是 如果你还记得堆的性质 堆中的元素不一定是全部有序的
Dialogue: 0,0:31:16.39,0:31:21.37,英文,,0,0,0,,The property in the heap is that this item is going to be greater than both of its children.
Dialogue: 0,0:31:16.39,0:31:21.37,中文,,0,0,0,,堆的性质是 这个元素将大于它的两个子节点
Dialogue: 0,0:31:21.37,0:31:24.16,英文,,0,0,0,,That does not necessarily mean the heap itself is sorted.
Dialogue: 0,0:31:21.37,0:31:24.16,中文,,0,0,0,,这并不一定意味着堆本身是有序的
Dialogue: 0,0:31:24.16,0:31:27.82,英文,,0,0,0,,And in fact, if you look at this heap, it's not actually sorted.
Dialogue: 0,0:31:24.16,0:31:27.82,中文,,0,0,0,,事实上 如果你看一下这个堆 它实际上并没有排序
Dialogue: 0,0:31:27.82,0:31:33.28,英文,,0,0,0,,It just has the heap property that every item is less than, or in this case, greater than its two children.
Dialogue: 0,0:31:27.82,0:31:33.28,中文,,0,0,0,,它只是具有堆的性质 即每个元素都小于 或者在本例中 大于它的两个子节点
Dialogue: 0,0:31:33.28,0:31:36.08,英文,,0,0,0,,And that's what makes deleting the largest item fast.
Dialogue: 0,0:31:33.28,0:31:36.08,中文,,0,0,0,,这就是删除最大元素速度快的原因
Dialogue: 0,0:31:36.08,0:31:37.32,英文,,0,0,0,,That's a great question, though.
Dialogue: 0,0:31:36.08,0:31:37.32,中文,,0,0,0,,不过 这是一个很好的问题
Dialogue: 0,0:31:37.32,0:31:45.19,英文,,0,0,0,,So you might be tempted to just read the heap in backwards order, but you will not get a valid sort because heaps don't have to keep things in sorted order.
Dialogue: 0,0:31:37.32,0:31:45.19,中文,,0,0,0,,你可能会想直接以相反的顺序读取堆 但这不会得到有效的排序 因为堆不必保持元素的有序性
Dialogue: 0,0:31:45.19,0:31:50.13,英文,,0,0,0,,They just have to organize things enough to make deleting largest items fast.
Dialogue: 0,0:31:45.19,0:31:50.13,中文,,0,0,0,,它们只需要组织好元素 以便快速删除最大的元素
Dialogue: 0,0:31:50.13,0:31:51.53,英文,,0,0,0,,That's a great question, though.
Dialogue: 0,0:31:50.13,0:31:51.53,中文,,0,0,0,,不过 这是一个很好的问题
Dialogue: 0,0:31:51.53,0:31:53.05,英文,,0,0,0,,I've never seen someone ask that before.
Dialogue: 0,0:31:51.53,0:31:53.05,中文,,0,0,0,,我以前从未见过有人问过这个问题
Dialogue: 0,0:31:53.05,0:31:53.89,英文,,0,0,0,,It's really cool.
Dialogue: 0,0:31:53.05,0:31:53.89,中文,,0,0,0,,这真的很酷
Dialogue: 0,0:31:53.89,0:31:55.51,英文,,0,0,0,,OK.
Dialogue: 0,0:31:53.89,0:31:55.51,中文,,0,0,0,,
Dialogue: 0,0:31:55.51,0:31:59.82,英文,,0,0,0,,So you've now seen phase one, which was shove everything in a heap.
Dialogue: 0,0:31:55.51,0:31:59.82,中文,,0,0,0,,你现在已经看到了第一阶段 即把所有东西都塞进一个堆里
Dialogue: 0,0:31:59.82,0:32:05.44,英文,,0,0,0,,You now saw phase two, which was delete an item from the heap over and over until it's empty.
Dialogue: 0,0:31:59.82,0:32:05.44,中文,,0,0,0,,你现在看到了第二阶段 即从堆中反复删除元素 直到它为空
Dialogue: 0,0:32:05.44,0:32:07.12,英文,,0,0,0,,So what is the total runtime?
Dialogue: 0,0:32:05.44,0:32:07.12,中文,,0,0,0,,那么总运行时间是多少？
Dialogue: 0,0:32:07.12,0:32:08.42,英文,,0,0,0,,There were two steps.
Dialogue: 0,0:32:07.12,0:32:08.42,中文,,0,0,0,,有两个步骤
Dialogue: 0,0:32:08.42,0:32:13.21,英文,,0,0,0,,We figured out the first step is theta n log n. What about the second step?
Dialogue: 0,0:32:08.42,0:32:13.21,中文,,0,0,0,,我们已经算出第一步是 Θ(N log N) 第二步呢？
Dialogue: 0,0:32:13.21,0:32:15.71,英文,,0,0,0,,How many things did I have to delete?
Dialogue: 0,0:32:13.21,0:32:15.71,中文,,0,0,0,,我需要删除多少个元素？
Dialogue: 0,0:32:15.71,0:32:16.71,英文,,0,0,0,,N of them.
Dialogue: 0,0:32:15.71,0:32:16.71,中文,,0,0,0,,N 个
Dialogue: 0,0:32:16.71,0:32:18.71,英文,,0,0,0,,How long did each delete take?
Dialogue: 0,0:32:16.71,0:32:18.71,中文,,0,0,0,,每次删除需要多长时间？
Dialogue: 0,0:32:18.71,0:32:20.87,英文,,0,0,0,,How long does it take to delete something from the heap?
Dialogue: 0,0:32:18.71,0:32:20.87,中文,,0,0,0,,从堆中删除一个元素需要多长时间？
Dialogue: 0,0:32:20.87,0:32:28.14,英文,,0,0,0,,Remember, if I want to delete something, I have to take the next item, put it at the root, and do some syncing.
Dialogue: 0,0:32:20.87,0:32:28.14,中文,,0,0,0,,记住 如果我想删除一个元素 我必须取下一个元素 把它放在根节点 然后做一些同步操作
Dialogue: 0,0:32:28.14,0:32:31.28,英文,,0,0,0,,So each delete takes log n time.
Dialogue: 0,0:32:28.14,0:32:31.28,中文,,0,0,0,,每次删除都需要 log N 时间
Dialogue: 0,0:32:31.28,0:32:38.13,英文,,0,0,0,,So I have one step that's n log n. Then, completely separately, I have another step that's n log n.
Dialogue: 0,0:32:31.28,0:32:38.13,中文,,0,0,0,,我有一个步骤是 N log N 然后 完全分开地 我还有另一个步骤也是 N log N
Dialogue: 0,0:32:38.13,0:32:43.13,英文,,0,0,0,,So in total, I have to do one n log n step plus another n log n step.
Dialogue: 0,0:32:38.13,0:32:43.13,中文,,0,0,0,,所以总的来说 我必须做一次 N log N 步骤加上另一次 N log N 步骤
Dialogue: 0,0:32:43.13,0:32:51.68,英文,,0,0,0,,Then I sum them up, and I get a bound of n log n, which is, you'll notice, better than SelectionSort.
Dialogue: 0,0:32:43.13,0:32:51.68,中文,,0,0,0,,然后我把它们加起来 我得到了 N log N 的界限 你会注意到 这比选择排序要好
Dialogue: 0,0:32:51.68,0:32:53.50,英文,,0,0,0,,So SelectionSort was n squared.
Dialogue: 0,0:32:51.68,0:32:53.50,中文,,0,0,0,,所以选择排序是 N²
Dialogue: 0,0:32:53.50,0:32:58.02,英文,,0,0,0,,I have now gotten it down to n log n. Pretty cool.
Dialogue: 0,0:32:53.50,0:32:58.02,中文,,0,0,0,,我现在已经把它降低到 N log N 了 相当酷
Dialogue: 0,0:32:58.02,0:33:00.10,英文,,0,0,0,,And it was all thanks to the heap.
Dialogue: 0,0:32:58.02,0:33:00.10,中文,,0,0,0,,这都要归功于堆
Dialogue: 0,0:33:00.10,0:33:01.58,英文,,0,0,0,,OK, what about memory usage?
Dialogue: 0,0:33:00.10,0:33:01.58,中文,,0,0,0,,好的 内存使用情况如何？
Dialogue: 0,0:33:01.58,0:33:04.36,英文,,0,0,0,,And again, we don't want to count the initial input array.
Dialogue: 0,0:33:01.58,0:33:04.36,中文,,0,0,0,,同样 我们不想计算初始输入数组
Dialogue: 0,0:33:04.36,0:33:05.56,英文,,0,0,0,,That's kind of cheating.
Dialogue: 0,0:33:04.36,0:33:05.56,中文,,0,0,0,,那有点像作弊
Dialogue: 0,0:33:05.56,0:33:11.08,英文,,0,0,0,,The input array is always going to be theta of n. But how much extra space did I have to use?
Dialogue: 0,0:33:05.56,0:33:11.08,中文,,0,0,0,,输入数组始终是 Θ(N) 的 但我需要使用多少额外的空间？
Dialogue: 0,0:33:11.08,0:33:16.10,英文,,0,0,0,,So if I go back and I watch the entire algorithm in action, well, here was the input array.
Dialogue: 0,0:33:11.08,0:33:16.10,中文,,0,0,0,,如果我回去看看整个算法的运行情况 嗯 这是输入数组
Dialogue: 0,0:33:16.10,0:33:18.31,英文,,0,0,0,,We don't count it in the extra memory.
Dialogue: 0,0:33:16.10,0:33:18.31,中文,,0,0,0,,我们不把它算在额外内存中
Dialogue: 0,0:33:18.31,0:33:19.29,英文,,0,0,0,,It's OK.
Dialogue: 0,0:33:18.31,0:33:19.29,中文,,0,0,0,,没关系
Dialogue: 0,0:33:19.29,0:33:24.35,英文,,0,0,0,,But then I had to create this extra auxiliary array to store the heap.
Dialogue: 0,0:33:19.29,0:33:24.35,中文,,0,0,0,,但是然后我不得不创建这个额外的辅助数组来存储堆
Dialogue: 0,0:33:24.35,0:33:27.55,英文,,0,0,0,,So I had to create another array of size n.
Dialogue: 0,0:33:24.35,0:33:27.55,中文,,0,0,0,,我不得不创建另一个大小为 N 的数组
Dialogue: 0,0:33:27.55,0:33:36.20,英文,,0,0,0,,And then I had to create another output array, third one, of size n. So in total, my extra space that I use is roughly n plus n,
Dialogue: 0,0:33:27.55,0:33:36.20,中文,,0,0,0,,然后我不得不创建另一个输出数组 第三个大小也是 N 总的来说 我使用的额外空间大约是 N 加 N
Dialogue: 0,0:33:36.20,0:33:45.20,英文,,0,0,0,,which is 2n, which is still theta of n. So I had a theta of n factor in terms of extra memory.
Dialogue: 0,0:33:36.20,0:33:45.20,中文,,0,0,0,,也就是 2N 仍然是 Θ(N) 的 在额外内存方面 我有一个 Θ(N) 的因子
Dialogue: 0,0:33:45.20,0:33:50.85,英文,,0,0,0,,It wasn't the initial array, but it was those extra two to store the heap and the output.
Dialogue: 0,0:33:45.20,0:33:50.85,中文,,0,0,0,,它不是初始数组 而是那两个额外的数组 用来存储堆和输出
Dialogue: 0,0:33:50.85,0:33:51.97,英文,,0,0,0,,So that's Heapsort.
Dialogue: 0,0:33:50.85,0:33:51.97,中文,,0,0,0,,这就是堆排序
Dialogue: 0,0:33:51.97,0:33:52.73,英文,,0,0,0,,It works.
Dialogue: 0,0:33:51.97,0:33:52.73,中文,,0,0,0,,它有效
Dialogue: 0,0:33:52.73,0:33:56.32,英文,,0,0,0,,It's nlogn, but there's a bit of extra memory usage.
Dialogue: 0,0:33:52.73,0:33:56.32,中文,,0,0,0,,它是 N log N 的 但会有一些额外的内存使用量
Dialogue: 0,0:33:56.32,0:34:02.11,英文,,0,0,0,,So we're going to get rid of this extra memory usage with some fancy trickery coming up next.
Dialogue: 0,0:33:56.32,0:34:02.11,中文,,0,0,0,,接下来我们将通过一些奇特的技巧来消除这种额外的内存使用量
Dialogue: 0,0:34:02.11,0:34:03.97,英文,,0,0,0,,Unless you have questions.
Dialogue: 0,0:34:02.11,0:34:03.97,中文,,0,0,0,,除非你有问题
Dialogue: 0,0:34:03.97,0:34:05.78,英文,,0,0,0,,OK.
Dialogue: 0,0:34:03.97,0:34:05.78,中文,,0,0,0,,
Dialogue: 0,0:34:05.78,0:34:07.20,英文,,0,0,0,,So that was naive heap sort.
Dialogue: 0,0:34:05.78,0:34:07.20,中文,,0,0,0,,这就是朴素的堆排序
Dialogue: 0,0:34:07.20,0:34:09.72,英文,,0,0,0,,Hopefully, it didn't feel too bad.
Dialogue: 0,0:34:07.20,0:34:09.72,中文,,0,0,0,,希望它不会让你觉得太糟糕
Dialogue: 0,0:34:09.72,0:34:13.98,英文,,0,0,0,,And again, I almost think that this slide's complicated a little bit more than it has to be.
Dialogue: 0,0:34:09.72,0:34:13.98,中文,,0,0,0,,再说一次 我几乎认为这张幻灯片比它应有的复杂程度还要复杂一点
Dialogue: 0,0:34:13.98,0:34:17.97,英文,,0,0,0,,It really is just shove everything in a heap and delete it all back out.
Dialogue: 0,0:34:13.98,0:34:17.97,中文,,0,0,0,,它实际上只是把所有东西都塞进一个堆里 然后再全部删除出来
Dialogue: 0,0:34:17.97,0:34:20.53,英文,,0,0,0,,Things will pop out in order, thanks to the heap.
Dialogue: 0,0:34:17.97,0:34:20.53,中文,,0,0,0,,由于堆的特性 元素会按顺序弹出
Dialogue: 0,0:34:20.53,0:34:23.53,英文,,0,0,0,,But now, let's do in-place heap sort.
Dialogue: 0,0:34:20.53,0:34:23.53,中文,,0,0,0,,但是现在 让我们来做原地堆排序
Dialogue: 0,0:34:23.53,0:34:29.21,英文,,0,0,0,,And here, what I want to do is I want to avoid having to create all of those extra arrays.
Dialogue: 0,0:34:23.53,0:34:29.21,中文,,0,0,0,,在这里 我想做的是避免创建所有那些额外的数组
Dialogue: 0,0:34:29.21,0:34:32.02,英文,,0,0,0,,I don't want to make another array and then put
Dialogue: 0,0:34:29.21,0:34:32.02,中文,,0,0,0,,我不想创建另一个数组 然后把
Dialogue: 0,0:34:32.02,0:34:33.74,英文,,0,0,0,,The heap and the other array.
Dialogue: 0,0:34:32.02,0:34:33.74,中文,,0,0,0,,堆放在另一个数组里
Dialogue: 0,0:34:33.74,0:34:37.92,英文,,0,0,0,,I want to do everything in the original array just by swapping items around.
Dialogue: 0,0:34:33.74,0:34:37.92,中文,,0,0,0,,我想在原来的数组中完成所有操作 只需交换元素的位置
Dialogue: 0,0:34:37.92,0:34:39.20,英文,,0,0,0,,So can I do that?
Dialogue: 0,0:34:37.92,0:34:39.20,中文,,0,0,0,,那么我能做到吗？
Dialogue: 0,0:34:39.20,0:34:40.67,英文,,0,0,0,,Well, yeah, it turns out I can.
Dialogue: 0,0:34:39.20,0:34:40.67,中文,,0,0,0,,嗯 是的 事实证明我可以
Dialogue: 0,0:34:40.67,0:34:42.47,英文,,0,0,0,,So here's what I'll do.
Dialogue: 0,0:34:40.67,0:34:42.47,中文,,0,0,0,,我会这样做
Dialogue: 0,0:34:42.47,0:34:45.55,英文,,0,0,0,,I'm going to take the original array.
Dialogue: 0,0:34:42.47,0:34:45.55,中文,,0,0,0,,我要取原始数组
Dialogue: 0,0:34:45.55,0:34:46.95,英文,,0,0,0,,Here's the original array.
Dialogue: 0,0:34:45.55,0:34:46.95,中文,,0,0,0,,这是原始数组
Dialogue: 0,0:34:46.95,0:34:48.72,英文,,0,0,0,,So first of all, is it sorted?
Dialogue: 0,0:34:46.95,0:34:48.72,中文,,0,0,0,,首先 它排序了吗？
Dialogue: 0,0:34:48.72,0:34:49.81,英文,,0,0,0,,No.
Dialogue: 0,0:34:48.72,0:34:49.81,中文,,0,0,0,,没有
Dialogue: 0,0:34:49.81,0:34:51.73,英文,,0,0,0,,Was this array a heap?
Dialogue: 0,0:34:49.81,0:34:51.73,中文,,0,0,0,,这个数组是堆吗？
Dialogue: 0,0:34:51.73,0:34:52.39,英文,,0,0,0,,No.
Dialogue: 0,0:34:51.73,0:34:52.39,中文,,0,0,0,,不是
Dialogue: 0,0:34:52.39,0:34:53.51,英文,,0,0,0,,Who knows what this array was?
Dialogue: 0,0:34:52.39,0:34:53.51,中文,,0,0,0,,谁知道这个数组是什么？
Dialogue: 0,0:34:53.51,0:34:55.77,英文,,0,0,0,,Someone just handed me a bunch of numbers.
Dialogue: 0,0:34:53.51,0:34:55.77,中文,,0,0,0,,有人只是给了我一堆数字
Dialogue: 0,0:34:55.77,0:34:56.73,英文,,0,0,0,,Is this a heap?
Dialogue: 0,0:34:55.77,0:34:56.73,中文,,0,0,0,,这是一个堆吗？
Dialogue: 0,0:34:56.73,0:34:58.33,英文,,0,0,0,,It's probably not a heap.
Dialogue: 0,0:34:56.73,0:34:58.33,中文,,0,0,0,,它可能不是一个堆
Dialogue: 0,0:34:58.33,0:35:01.76,英文,,0,0,0,,But what if I really wanted it to be a heap?
Dialogue: 0,0:34:58.33,0:35:01.76,中文,,0,0,0,,但如果我真的很想让它成为一个堆呢？
Dialogue: 0,0:35:01.76,0:35:06.52,英文,,0,0,0,,Remember, in naive heap sort, I would make a second array, and then I'd make it into a heap.
Dialogue: 0,0:35:01.76,0:35:06.52,中文,,0,0,0,,记住 在朴素的堆排序中 我会创建一个第二个数组 然后把它变成一个堆
Dialogue: 0,0:35:06.52,0:35:12.22,英文,,0,0,0,,I'd add all these items into the second array, and the items would shuffle around, and I'd get a heap.
Dialogue: 0,0:35:06.52,0:35:12.22,中文,,0,0,0,,我会把所有这些元素都添加到第二个数组中 这些元素会四处移动 然后我就会得到一个堆
Dialogue: 0,0:35:12.22,0:35:14.54,英文,,0,0,0,,And so I look at this first array.
Dialogue: 0,0:35:12.22,0:35:14.54,中文,,0,0,0,,我看着第一个数组
Dialogue: 0,0:35:14.54,0:35:17.92,英文,,0,0,0,,You're not a heap, but I really wish it was a heap.
Dialogue: 0,0:35:14.54,0:35:17.92,中文,,0,0,0,,你不是一个堆 但我真的很希望它是一个堆
Dialogue: 0,0:35:17.92,0:35:23.36,英文,,0,0,0,,So what if I made my wish come true and I said, you are a heap?
Dialogue: 0,0:35:17.92,0:35:23.36,中文,,0,0,0,,那么 如果我让我的愿望成真 我说 你是一个堆呢？
Dialogue: 0,0:35:23.36,0:35:26.66,英文,,0,0,0,,Well, if this is a heap, I can draw it out in cartoon format.
Dialogue: 0,0:35:23.36,0:35:26.66,中文,,0,0,0,,嗯 如果这是一个堆 我可以用卡通形式把它画出来
Dialogue: 0,0:35:26.66,0:35:28.01,英文,,0,0,0,,And remember,
Dialogue: 0,0:35:26.66,0:35:28.01,中文,,0,0,0,,记住
Dialogue: 0,0:35:28.01,0:35:33.21,英文,,0,0,0,,This array is just a heap implemented in Java.
Dialogue: 0,0:35:28.01,0:35:33.21,中文,,0,0,0,,这个数组只是一个用 Java 实现的堆
Dialogue: 0,0:35:33.21,0:35:34.35,英文,,0,0,0,,So it's not really a heap.
Dialogue: 0,0:35:33.21,0:35:34.35,中文,,0,0,0,,它并不是真正的堆
Dialogue: 0,0:35:34.35,0:35:37.19,英文,,0,0,0,,I don't know what the user gave to me.
Dialogue: 0,0:35:34.35,0:35:37.19,中文,,0,0,0,,我不知道用户给了我什么
Dialogue: 0,0:35:37.19,0:35:44.02,英文,,0,0,0,,But if I really wished and I wished, and my wish came true, and this was actually a heap, it would look like this.
Dialogue: 0,0:35:37.19,0:35:44.02,中文,,0,0,0,,但如果我真的希望 而且我的愿望成真了 而这实际上是一个堆 它就会像这样
Dialogue: 0,0:35:44.02,0:35:45.16,英文,,0,0,0,,32, 15, 2.
Dialogue: 0,0:35:44.02,0:35:45.16,中文,,0,0,0,,32, 15, 2.
Dialogue: 0,0:35:45.16,0:35:47.24,英文,,0,0,0,,I'm reading off the items in level order.
Dialogue: 0,0:35:45.16,0:35:47.24,中文,,0,0,0,,我按层级顺序读出元素
Dialogue: 0,0:35:47.24,0:35:48.71,英文,,0,0,0,,That's my heap.
Dialogue: 0,0:35:47.24,0:35:48.71,中文,,0,0,0,,这是我的堆
Dialogue: 0,0:35:48.71,0:35:52.43,英文,,0,0,0,,Except, is this actually a valid max heap?
Dialogue: 0,0:35:48.71,0:35:52.43,中文,,0,0,0,,但是 这真的是一个有效的最大堆吗？
Dialogue: 0,0:35:52.43,0:35:53.31,英文,,0,0,0,,And no.
Dialogue: 0,0:35:52.43,0:35:53.31,中文,,0,0,0,,并不是
Dialogue: 0,0:35:53.31,0:35:55.19,英文,,0,0,0,,And in fact, that's not that surprising.
Dialogue: 0,0:35:53.31,0:35:55.19,中文,,0,0,0,,事实上 这并不奇怪
Dialogue: 0,0:35:55.19,0:35:56.73,英文,,0,0,0,,The user didn't give me a heap.
Dialogue: 0,0:35:55.19,0:35:56.73,中文,,0,0,0,,用户没有给我一个堆
Dialogue: 0,0:35:56.73,0:36:00.83,英文,,0,0,0,,So if I pretended it was a heap, why would it be a valid max heap?
Dialogue: 0,0:35:56.73,0:36:00.83,中文,,0,0,0,,如果我假装它是一个堆 为什么它会是一个有效的最大堆呢？
Dialogue: 0,0:36:00.83,0:36:02.63,英文,,0,0,0,,In general, it's not going to be.
Dialogue: 0,0:36:00.83,0:36:02.63,中文,,0,0,0,,一般来说 它不会是
Dialogue: 0,0:36:02.63,0:36:08.17,英文,,0,0,0,,For example, this 15 should be greater than both of its children, but it's not.
Dialogue: 0,0:36:02.63,0:36:08.17,中文,,0,0,0,,例如 这个15应该大于它的两个子节点 但它不是
Dialogue: 0,0:36:08.17,0:36:11.41,英文,,0,0,0,,15 is less than both of its children, which is wrong.
Dialogue: 0,0:36:08.17,0:36:11.41,中文,,0,0,0,,15小于它的两个子节点 这是错误的
Dialogue: 0,0:36:11.41,0:36:15.31,英文,,0,0,0,,So while I wished for this array to be a heap,
Dialogue: 0,0:36:11.41,0:36:15.31,中文,,0,0,0,,虽然我希望这个数组是一个堆
Dialogue: 0,0:36:15.31,0:36:17.24,英文,,0,0,0,,It's not actually a valid heap.
Dialogue: 0,0:36:15.31,0:36:17.24,中文,,0,0,0,,但它实际上不是一个有效的堆
Dialogue: 0,0:36:17.24,0:36:20.04,英文,,0,0,0,,So I want to make it a valid heap.
Dialogue: 0,0:36:17.24,0:36:20.04,中文,,0,0,0,,我想把它变成一个有效的堆
Dialogue: 0,0:36:20.04,0:36:27.30,英文,,0,0,0,,I want to take these items and shuffle them around and do some swaps so that this array becomes a valid max heap.
Dialogue: 0,0:36:20.04,0:36:27.30,中文,,0,0,0,,我想把这些元素进行一些交换 让这个数组成为一个有效的最大堆
Dialogue: 0,0:36:27.30,0:36:33.49,英文,,0,0,0,,And it turns out the way to do it, I'll tell you how to do it, and then we'll convince ourselves that it works, is
Dialogue: 0,0:36:27.30,0:36:33.49,中文,,0,0,0,,事实证明 方法是 我会告诉你如何做 然后我们会让自己相信它是有效的 那就是
Dialogue: 0,0:36:33.49,0:36:40.17,英文,,0,0,0,,I will start at the bottom, and I will scan my way up in reverse level order, and I'll sync every single node.
Dialogue: 0,0:36:33.49,0:36:40.17,中文,,0,0,0,,我将从底部开始 以相反的层次顺序向上扫描 并同步每一个节点
Dialogue: 0,0:36:40.17,0:36:43.65,英文,,0,0,0,,So every single node will get sunk as far down as it can go.
Dialogue: 0,0:36:40.17,0:36:43.65,中文,,0,0,0,,每个节点都会尽可能地向下沉
Dialogue: 0,0:36:43.65,0:36:47.58,英文,,0,0,0,,And if I do that, I will get a max heap after I'm done.
Dialogue: 0,0:36:43.65,0:36:47.58,中文,,0,0,0,,如果我这样做 完成后我将得到一个最大堆
Dialogue: 0,0:36:47.58,0:36:51.02,英文,,0,0,0,,So I'll do it, and then we'll convince ourselves that it works.
Dialogue: 0,0:36:47.58,0:36:51.02,中文,,0,0,0,,我会这样做 然后我们会让自己相信它是有效的
Dialogue: 0,0:36:51.02,0:36:55.96,英文,,0,0,0,,But is everyone OK with the first step, which is that I get some random old array from someone else?
Dialogue: 0,0:36:51.02,0:36:55.96,中文,,0,0,0,,但是 第一步大家都同意吗 那就是我从别人那里得到一个随机的旧数组？
Dialogue: 0,0:36:55.96,0:37:02.01,英文,,0,0,0,,It's not a heap, but I pretended it's a heap, and now I'm going to fix it so that it's actually a valid heap.
Dialogue: 0,0:36:55.96,0:37:02.01,中文,,0,0,0,,它不是一个堆 但我假装它是一个堆 现在我要修复它 让它成为一个有效的堆
Dialogue: 0,0:37:02.01,0:37:03.66,英文,,0,0,0,,Okay, so here we go.
Dialogue: 0,0:37:02.01,0:37:03.66,中文,,0,0,0,,好的 我们开始吧
Dialogue: 0,0:37:03.66,0:37:05.44,英文,,0,0,0,,I start at the bottom 17.
Dialogue: 0,0:37:03.66,0:37:05.44,中文,,0,0,0,,我从底部的17开始
Dialogue: 0,0:37:05.44,0:37:06.40,英文,,0,0,0,,I sink it.
Dialogue: 0,0:37:05.44,0:37:06.40,中文,,0,0,0,,我把它下沉
Dialogue: 0,0:37:06.40,0:37:09.97,英文,,0,0,0,,I want it to go down to its rightful place.
Dialogue: 0,0:37:06.40,0:37:09.97,中文,,0,0,0,,我希望它下降到它应该在的位置
Dialogue: 0,0:37:09.97,0:37:13.21,英文,,0,0,0,,There's nothing below it, so if I sync it, nothing happens.
Dialogue: 0,0:37:09.97,0:37:13.21,中文,,0,0,0,,它下面什么都没有 所以如果我同步它 什么都不会发生
Dialogue: 0,0:37:13.21,0:37:14.12,英文,,0,0,0,,OK.
Dialogue: 0,0:37:13.21,0:37:14.12,中文,,0,0,0,,
Dialogue: 0,0:37:14.12,0:37:16.44,英文,,0,0,0,,Then I sync the next 17.
Dialogue: 0,0:37:14.12,0:37:16.44,中文,,0,0,0,,然后我同步下一个17
Dialogue: 0,0:37:16.44,0:37:17.58,英文,,0,0,0,,What does it do?
Dialogue: 0,0:37:16.44,0:37:17.58,中文,,0,0,0,,它做什么？
Dialogue: 0,0:37:17.58,0:37:18.20,英文,,0,0,0,,Nothing.
Dialogue: 0,0:37:17.58,0:37:18.20,中文,,0,0,0,,什么都没有
Dialogue: 0,0:37:18.20,0:37:18.68,英文,,0,0,0,,OK.
Dialogue: 0,0:37:18.20,0:37:18.68,中文,,0,0,0,,
Dialogue: 0,0:37:18.68,0:37:19.64,英文,,0,0,0,,That's fine.
Dialogue: 0,0:37:18.68,0:37:19.64,中文,,0,0,0,,没关系
Dialogue: 0,0:37:19.64,0:37:21.68,英文,,0,0,0,,Now we sync the 41.
Dialogue: 0,0:37:19.64,0:37:21.68,中文,,0,0,0,,现在我们同步41
Dialogue: 0,0:37:21.68,0:37:22.72,英文,,0,0,0,,Nothing happens.
Dialogue: 0,0:37:21.68,0:37:22.72,中文,,0,0,0,,什么都没发生
Dialogue: 0,0:37:22.72,0:37:23.86,英文,,0,0,0,,I sync the 26.
Dialogue: 0,0:37:22.72,0:37:23.86,中文,,0,0,0,,我同步26
Dialogue: 0,0:37:23.86,0:37:24.76,英文,,0,0,0,,Nothing happens.
Dialogue: 0,0:37:23.86,0:37:24.76,中文,,0,0,0,,什么都没发生
Dialogue: 0,0:37:24.76,0:37:25.92,英文,,0,0,0,,I hope you're having fun.
Dialogue: 0,0:37:24.76,0:37:25.92,中文,,0,0,0,,希望你们玩得开心
Dialogue: 0,0:37:25.92,0:37:27.41,英文,,0,0,0,,I sync the 19.
Dialogue: 0,0:37:25.92,0:37:27.41,中文,,0,0,0,,我同步19
Dialogue: 0,0:37:27.41,0:37:28.49,英文,,0,0,0,,Nothing happens.
Dialogue: 0,0:37:27.41,0:37:28.49,中文,,0,0,0,,什么都没发生
Dialogue: 0,0:37:28.49,0:37:29.57,英文,,0,0,0,,Nothing happens.
Dialogue: 0,0:37:28.49,0:37:29.57,中文,,0,0,0,,什么都没发生
Dialogue: 0,0:37:29.57,0:37:30.19,英文,,0,0,0,,OK.
Dialogue: 0,0:37:29.57,0:37:30.19,中文,,0,0,0,,
Dialogue: 0,0:37:30.19,0:37:33.39,英文,,0,0,0,,Here is where something interesting happens.
Dialogue: 0,0:37:30.19,0:37:33.39,中文,,0,0,0,,这里发生了一些有趣的事情
Dialogue: 0,0:37:33.39,0:37:34.01,英文,,0,0,0,,I get to the 2.
Dialogue: 0,0:37:33.39,0:37:34.01,中文,,0,0,0,,我到了2
Dialogue: 0,0:37:34.01,0:37:36.63,英文,,0,0,0,,I'm going in reverse level order.
Dialogue: 0,0:37:34.01,0:37:36.63,中文,,0,0,0,,我以相反的层次顺序进行
Dialogue: 0,0:37:36.63,0:37:39.55,英文,,0,0,0,,I get to the 2, and I want it to sink.
Dialogue: 0,0:37:36.63,0:37:39.55,中文,,0,0,0,,我到了2 我想让它下沉
Dialogue: 0,0:37:39.55,0:37:43.07,英文,,0,0,0,,Something's going to happen, because this 2 is in the wrong place.
Dialogue: 0,0:37:39.55,0:37:43.07,中文,,0,0,0,,有些事情会发生 因为这个2的位置不对
Dialogue: 0,0:37:43.07,0:37:49.40,英文,,0,0,0,,This item here should be greater than both of its children, but the 2 is not greater than both of its children.
Dialogue: 0,0:37:43.07,0:37:49.40,中文,,0,0,0,,这里的元素应该大于它的两个子节点 但是2并不大于它的两个子节点
Dialogue: 0,0:37:49.40,0:37:51.10,英文,,0,0,0,,The 2's like, I'm not cut out for this.
Dialogue: 0,0:37:49.40,0:37:51.10,中文,,0,0,0,,2就像 我不适合这个位置
Dialogue: 0,0:37:51.10,0:37:55.68,英文,,0,0,0,,This is too high of a position for me, so I'm going to sink to my rightful place.
Dialogue: 0,0:37:51.10,0:37:55.68,中文,,0,0,0,,这个位置对我来说太高了 我要沉到我应该在的位置
Dialogue: 0,0:37:55.68,0:37:57.94,英文,,0,0,0,,And it looks below itself and says, 26, 41.
Dialogue: 0,0:37:55.68,0:37:57.94,中文,,0,0,0,,它向下看 发现26和41
Dialogue: 0,0:37:57.94,0:38:00.28,英文,,0,0,0,,Who would be the better boss?
Dialogue: 0,0:37:57.94,0:38:00.28,中文,,0,0,0,,谁会是更好的老板？
Dialogue: 0,0:38:00.28,0:38:01.86,英文,,0,0,0,,Well, 41's larger.
Dialogue: 0,0:38:00.28,0:38:01.86,中文,,0,0,0,,嗯 41更大
Dialogue: 0,0:38:01.86,0:38:04.34,英文,,0,0,0,,So we will swap the 41 and the 2.
Dialogue: 0,0:38:01.86,0:38:04.34,中文,,0,0,0,,我们将交换41和2
Dialogue: 0,0:38:04.34,0:38:11.91,英文,,0,0,0,,So if you ignore the colors for a moment and just look at the picture, 2 and the 41, they swapped places in the picture.
Dialogue: 0,0:38:04.34,0:38:11.91,中文,,0,0,0,,如果你暂时忽略颜色 只看图片 2和41 它们在图片中交换了位置
Dialogue: 0,0:38:11.91,0:38:16.26,英文,,0,0,0,,They also swapped places in the array, which is representing this picture.
Dialogue: 0,0:38:11.91,0:38:16.26,中文,,0,0,0,,它们在数组中也交换了位置 数组代表着这张图片
Dialogue: 0,0:38:16.26,0:38:20.43,英文,,0,0,0,,So the 2 is now sunk into its proper place.
Dialogue: 0,0:38:16.26,0:38:20.43,中文,,0,0,0,,所以2现在已经下沉到它正确的位置
Dialogue: 0,0:38:20.43,0:38:22.23,英文,,0,0,0,,Okay, let's keep going.
Dialogue: 0,0:38:20.43,0:38:22.23,中文,,0,0,0,,好的 让我们继续
Dialogue: 0,0:38:22.23,0:38:24.07,英文,,0,0,0,,So, what do I sync next?
Dialogue: 0,0:38:22.23,0:38:24.07,中文,,0,0,0,,那么 我接下来同步什么？
Dialogue: 0,0:38:24.07,0:38:25.25,英文,,0,0,0,,I sync the 15 next.
Dialogue: 0,0:38:24.07,0:38:25.25,中文,,0,0,0,,我接下来同步15
Dialogue: 0,0:38:25.25,0:38:27.83,英文,,0,0,0,,I'm just going in reverse level order.
Dialogue: 0,0:38:25.25,0:38:27.83,中文,,0,0,0,,我只是以相反的层次顺序进行
Dialogue: 0,0:38:27.83,0:38:29.12,英文,,0,0,0,,So I sync the 15 next.
Dialogue: 0,0:38:27.83,0:38:29.12,中文,,0,0,0,,所以接下来我同步15
Dialogue: 0,0:38:29.12,0:38:30.46,英文,,0,0,0,,Remember, I just synced the 2.
Dialogue: 0,0:38:29.12,0:38:30.46,中文,,0,0,0,,记住 我刚刚同步了2
Dialogue: 0,0:38:30.46,0:38:31.90,英文,,0,0,0,,Now I sync the 15.
Dialogue: 0,0:38:30.46,0:38:31.90,中文,,0,0,0,,现在我同步15
Dialogue: 0,0:38:31.90,0:38:34.50,英文,,0,0,0,,And so, I think this does do something, right?
Dialogue: 0,0:38:31.90,0:38:34.50,中文,,0,0,0,,我认为这确实会做一些事情 对吧？
Dialogue: 0,0:38:34.50,0:38:35.84,英文,,0,0,0,,Because I look below,
Dialogue: 0,0:38:34.50,0:38:35.84,中文,,0,0,0,,因为我向下看
Dialogue: 0,0:38:35.84,0:38:39.55,英文,,0,0,0,,And I need to be greater than both of my children, but I'm not.
Dialogue: 0,0:38:35.84,0:38:39.55,中文,,0,0,0,,我需要大于我的两个子节点 但我不是
Dialogue: 0,0:38:39.55,0:38:42.17,英文,,0,0,0,,So the 15's like, nope, I'm not cut out for this position.
Dialogue: 0,0:38:39.55,0:38:42.17,中文,,0,0,0,,所以15就像 不 我不适合这个位置
Dialogue: 0,0:38:42.17,0:38:44.87,英文,,0,0,0,,I'm going to go down, find my rightful place.
Dialogue: 0,0:38:42.17,0:38:44.87,中文,,0,0,0,,我要下去 找到我应该在的位置
Dialogue: 0,0:38:44.87,0:38:47.63,英文,,0,0,0,,And the 19 is bigger, so I'll swap myself with the 19.
Dialogue: 0,0:38:44.87,0:38:47.63,中文,,0,0,0,,19更大 所以我会和19交换位置
Dialogue: 0,0:38:47.63,0:38:50.99,英文,,0,0,0,,So the 15 and the 19, they swap.
Dialogue: 0,0:38:47.63,0:38:50.99,中文,,0,0,0,,所以15和19 它们交换了位置
Dialogue: 0,0:38:50.99,0:38:52.45,英文,,0,0,0,,15 and 19, they swap.
Dialogue: 0,0:38:50.99,0:38:52.45,中文,,0,0,0,,15和19 它们交换了位置
Dialogue: 0,0:38:52.45,0:38:53.21,英文,,0,0,0,,Good.
Dialogue: 0,0:38:52.45,0:38:53.21,中文,,0,0,0,,很好
Dialogue: 0,0:38:53.21,0:38:55.11,英文,,0,0,0,,And finally, I get to the 32.
Dialogue: 0,0:38:53.21,0:38:55.11,中文,,0,0,0,,最后 我到了32
Dialogue: 0,0:38:55.11,0:38:57.43,英文,,0,0,0,,And the 32, I want it to sync.
Dialogue: 0,0:38:55.11,0:38:57.43,中文,,0,0,0,,32 我想让它同步
Dialogue: 0,0:38:57.43,0:39:00.22,英文,,0,0,0,,And it looks below itself and says, ah, 19, that's fine.
Dialogue: 0,0:38:57.43,0:39:00.22,中文,,0,0,0,,它向下看 发现19 没关系
Dialogue: 0,0:39:00.22,0:39:02.24,英文,,0,0,0,,But 41 is not OK.
Dialogue: 0,0:39:00.22,0:39:02.24,中文,,0,0,0,,但是41不行
Dialogue: 0,0:39:02.24,0:39:04.52,英文,,0,0,0,,So I'll swap myself with the 41.
Dialogue: 0,0:39:02.24,0:39:04.52,中文,,0,0,0,,我会和41交换位置
Dialogue: 0,0:39:04.52,0:39:07.48,英文,,0,0,0,,I will look below again to see if I have to sync any further.
Dialogue: 0,0:39:04.52,0:39:07.48,中文,,0,0,0,,我会再向下看 看看是否需要进一步同步
Dialogue: 0,0:39:07.48,0:39:10.43,英文,,0,0,0,,And while I'm greater than the 26, I'm greater than the 2.
Dialogue: 0,0:39:07.48,0:39:10.43,中文,,0,0,0,,虽然我大于26 也大于2
Dialogue: 0,0:39:10.43,0:39:11.83,英文,,0,0,0,,So I'm happy here.
Dialogue: 0,0:39:10.43,0:39:11.83,中文,,0,0,0,,我在这里很开心
Dialogue: 0,0:39:11.83,0:39:14.91,英文,,0,0,0,,And after syncing everybody, if I look,
Dialogue: 0,0:39:11.83,0:39:14.91,中文,,0,0,0,,在同步了所有人之后 如果我看看
Dialogue: 0,0:39:14.91,0:39:17.49,英文,,0,0,0,,Everything is in its proper place.
Dialogue: 0,0:39:14.91,0:39:17.49,中文,,0,0,0,,一切都在它应该在的位置
Dialogue: 0,0:39:17.49,0:39:18.79,英文,,0,0,0,,This is a valid heap.
Dialogue: 0,0:39:17.49,0:39:18.79,中文,,0,0,0,,这是一个有效的堆
Dialogue: 0,0:39:18.79,0:39:21.89,英文,,0,0,0,,Every item is greater than both of its children.
Dialogue: 0,0:39:18.79,0:39:21.89,中文,,0,0,0,,每个元素都大于它的两个子节点
Dialogue: 0,0:39:21.89,0:39:25.83,英文,,0,0,0,,So, are we at least okay with the mechanics of how to do it?
Dialogue: 0,0:39:21.89,0:39:25.83,中文,,0,0,0,,那么 我们至少对如何操作的机制感到满意吗？
Dialogue: 0,0:39:25.83,0:39:34.62,英文,,0,0,0,,You read the items, right to left, bottom to top, you sync every item, and when you're done, I promise you, you will get a heap.
Dialogue: 0,0:39:25.83,0:39:34.62,中文,,0,0,0,,你从右到左 从下到上读取元素 同步每个元素 当你完成后 我保证 你将得到一个堆
Dialogue: 0,0:39:34.62,0:39:35.96,英文,,0,0,0,,It's okay?
Dialogue: 0,0:39:34.62,0:39:35.96,中文,,0,0,0,,可以吗？
Dialogue: 0,0:39:35.96,0:39:38.76,英文,,0,0,0,,If so, I'll tell you how it works.
Dialogue: 0,0:39:35.96,0:39:38.76,中文,,0,0,0,,如果是这样 我会告诉你它是如何工作的
Dialogue: 0,0:39:38.76,0:39:42.55,英文,,0,0,0,,Question so far, why not use a min-heap?
Dialogue: 0,0:39:38.76,0:39:42.55,中文,,0,0,0,,到目前为止的问题是 为什么不使用最小堆？
Dialogue: 0,0:39:42.55,0:39:46.57,英文,,0,0,0,,Stay tuned, I promise you, you will see why the max-heap is useful.
Dialogue: 0,0:39:42.55,0:39:46.57,中文,,0,0,0,,请继续关注 我保证 你将看到为什么最大堆是有用的
Dialogue: 0,0:39:46.57,0:39:50.42,英文,,0,0,0,,Although if you wanted to, naive heap sort could have used the min-heap.
Dialogue: 0,0:39:46.57,0:39:50.42,中文,,0,0,0,,虽然如果你愿意 朴素的堆排序可以使用最小堆
Dialogue: 0,0:39:50.42,0:39:52.30,英文,,0,0,0,,OK, so here we go.
Dialogue: 0,0:39:50.42,0:39:52.30,中文,,0,0,0,,好的 我们开始吧
Dialogue: 0,0:39:52.30,0:39:53.78,英文,,0,0,0,,Let me tell you why this works.
Dialogue: 0,0:39:52.30,0:39:53.78,中文,,0,0,0,,让我告诉你为什么它有效
Dialogue: 0,0:39:53.78,0:39:56.66,英文,,0,0,0,,So as I sync, let's see.
Dialogue: 0,0:39:53.78,0:39:56.66,中文,,0,0,0,,当我同步时 让我们看看
Dialogue: 0,0:39:56.66,0:39:59.96,英文,,0,0,0,,Let me go find a place where I think this is informative.
Dialogue: 0,0:39:56.66,0:39:59.96,中文,,0,0,0,,让我去找一个我认为有信息量的地方
Dialogue: 0,0:39:59.96,0:40:06.30,英文,,0,0,0,,OK, so maybe let me stop at, I want to stop at the 32, actually, at the very end.
Dialogue: 0,0:39:59.96,0:40:06.30,中文,,0,0,0,,好的 也许让我在 我想在32处停下来 实际上 在最后
Dialogue: 0,0:40:06.30,0:40:10.77,英文,,0,0,0,,So I pause the demo right here, and I'm looking at this 32.
Dialogue: 0,0:40:06.30,0:40:10.77,中文,,0,0,0,,我在这里暂停演示 我正在看这个32
Dialogue: 0,0:40:10.77,0:40:17.40,英文,,0,0,0,,So at this point, do you agree that the left side is a max heap?
Dialogue: 0,0:40:10.77,0:40:17.40,中文,,0,0,0,,那么 在这一点上 你同意左边是一个最大堆吗？
Dialogue: 0,0:40:17.40,0:40:20.51,英文,,0,0,0,,Yes, because we sunk all the items in reverse level order.
Dialogue: 0,0:40:17.40,0:40:20.51,中文,,0,0,0,,是的 因为我们以相反的层次顺序沉没了所有元素
Dialogue: 0,0:40:20.51,0:40:22.71,英文,,0,0,0,,So we know it's a MaxHeap.
Dialogue: 0,0:40:20.51,0:40:22.71,中文,,0,0,0,,我们知道它是一个最大堆
Dialogue: 0,0:40:22.71,0:40:24.99,英文,,0,0,0,,That's the property that I want you to believe in.
Dialogue: 0,0:40:22.71,0:40:24.99,中文,,0,0,0,,这是我希望你相信的属性
Dialogue: 0,0:40:24.99,0:40:26.73,英文,,0,0,0,,And what about this right subtree?
Dialogue: 0,0:40:24.99,0:40:26.73,中文,,0,0,0,,这个右子树怎么样？
Dialogue: 0,0:40:26.73,0:40:28.81,英文,,0,0,0,,Is this also a MaxHeap?
Dialogue: 0,0:40:26.73,0:40:28.81,中文,,0,0,0,,这也是一个最大堆吗？
Dialogue: 0,0:40:28.81,0:40:32.19,英文,,0,0,0,,Yes, because I sunk all of the items in reverse level order.
Dialogue: 0,0:40:28.81,0:40:32.19,中文,,0,0,0,,是的 因为我以相反的层次顺序沉没了所有元素
Dialogue: 0,0:40:32.19,0:40:36.05,英文,,0,0,0,,So this red subtree is also a MaxHeap.
Dialogue: 0,0:40:32.19,0:40:36.05,中文,,0,0,0,,这个红色的子树也是一个最大堆
Dialogue: 0,0:40:36.05,0:40:42.54,英文,,0,0,0,,So if you trust me that the left subtree is a max heap and the right subtree is a max heap,
Dialogue: 0,0:40:36.05,0:40:42.54,中文,,0,0,0,,如果你相信我 左子树是一个最大堆 右子树也是一个最大堆
Dialogue: 0,0:40:42.54,0:40:49.54,英文,,0,0,0,, well then, if I take this extra item up here and I sync it, I will promise to you that the result is a max heap.
Dialogue: 0,0:40:42.54,0:40:49.54,中文,,0,0,0,,那么 如果我把这个额外的元素放在这里 并同步它 我向你保证 结果是一个最大堆
Dialogue: 0,0:40:49.54,0:40:54.13,英文,,0,0,0,,And the way that I'm going to convince you is, how did I delete something from a heap?
Dialogue: 0,0:40:49.54,0:40:54.13,中文,,0,0,0,,我要说服你的方式是 我是如何从堆中删除东西的？
Dialogue: 0,0:40:54.13,0:40:58.29,英文,,0,0,0,,Way back, like 20 lectures ago, how did I delete something from a heap?
Dialogue: 0,0:40:54.13,0:40:58.29,中文,,0,0,0,,很久以前 大约20节课前 我是如何从堆中删除东西的？
Dialogue: 0,0:40:58.29,0:41:01.78,英文,,0,0,0,,Well, remember, when I deleted something, I took the root.
Dialogue: 0,0:40:58.29,0:41:01.78,中文,,0,0,0,,嗯 记得 当我删除东西时 我拿走了根
Dialogue: 0,0:41:01.78,0:41:02.96,英文,,0,0,0,,I took the root.
Dialogue: 0,0:41:01.78,0:41:02.96,中文,,0,0,0,,我拿走了根
Dialogue: 0,0:41:02.96,0:41:04.00,英文,,0,0,0,,I deleted it.
Dialogue: 0,0:41:02.96,0:41:04.00,中文,,0,0,0,,我删除了它
Dialogue: 0,0:41:04.00,0:41:07.69,英文,,0,0,0,,I took some random item at the end, and I stuck it in the root.
Dialogue: 0,0:41:04.00,0:41:07.69,中文,,0,0,0,,我随便拿了末尾的一个元素 把它放到根节点
Dialogue: 0,0:41:07.69,0:41:10.15,英文,,0,0,0,,And I said, you need to sync to your rightful place.
Dialogue: 0,0:41:07.69,0:41:10.15,中文,,0,0,0,,然后我说 你需要同步到你应该在的位置
Dialogue: 0,0:41:10.15,0:41:13.81,英文,,0,0,0,,And after you sync, the resulting data structure will still be a heap.
Dialogue: 0,0:41:10.15,0:41:13.81,中文,,0,0,0,,同步之后 得到的数据结构仍然是一个堆
Dialogue: 0,0:41:13.81,0:41:16.78,英文,,0,0,0,,That's kind of the same flavor as what I'm doing here.
Dialogue: 0,0:41:13.81,0:41:16.78,中文,,0,0,0,,这和我在这里做的事情有点类似
Dialogue: 0,0:41:16.78,0:41:24.34,英文,,0,0,0,,I'm not really deleting items, but if you trust from the priority queues lecture that I can just stick any old item at the top,
Dialogue: 0,0:41:16.78,0:41:24.34,中文,,0,0,0,,我并没有真正删除元素 但如果你相信优先队列课程中所说的 我可以把任何旧的元素放在顶部
Dialogue: 0,0:41:24.34,0:41:31.34,英文,,0,0,0,,so I take the next item, whatever, and I say, you're the new boss, and then that boss sinks to its rightful place,
Dialogue: 0,0:41:24.34,0:41:31.34,中文,,0,0,0,,我拿下一个元素 随便哪个 然后我说 你是新的老大 然后这个老大沉到它应该在的位置
Dialogue: 0,0:41:31.34,0:41:37.34,英文,,0,0,0,,and the result is a heap, well then, that's basically all that I'm doing in my heapification process.
Dialogue: 0,0:41:31.34,0:41:37.34,中文,,0,0,0,,结果就是一个堆 那么 这就是我在堆化过程中所做的一切
Dialogue: 0,0:41:37.34,0:41:41.31,英文,,0,0,0,,If I have a left subtree that's good, a right subtree that's good, I can stick any item up here.
Dialogue: 0,0:41:37.34,0:41:41.31,中文,,0,0,0,,如果我有一个好的左子树 一个好的右子树 我可以在上面放任何元素
Dialogue: 0,0:41:41.31,0:41:47.01,英文,,0,0,0,,It could be 32, it could be 45, it could be a billion, it could be negative 10, whatever item I want up here.
Dialogue: 0,0:41:41.31,0:41:47.01,中文,,0,0,0,,它可以是 32 可以是 45 可以是十亿 可以是负 10 任何我想要的元素都可以放在这里
Dialogue: 0,0:41:47.01,0:41:55.88,英文,,0,0,0,,It could be anything, as long as the left and right subtrees are heaps, and I sync this item, and the resulting data structure will be a valid heap.
Dialogue: 0,0:41:47.01,0:41:55.88,中文,,0,0,0,,它可以是任何东西 只要左右子树都是堆 我同步这个元素 结果的数据结构就会是一个有效的堆
Dialogue: 0,0:41:55.88,0:41:56.84,英文,,0,0,0,,That's the idea.
Dialogue: 0,0:41:55.88,0:41:56.84,中文,,0,0,0,,这就是思路
Dialogue: 0,0:41:56.84,0:42:04.76,英文,,0,0,0,,And if I apply the idea inductively from the bottom all the way up, then I will see that this works fine.
Dialogue: 0,0:41:56.84,0:42:04.76,中文,,0,0,0,,如果我把这个想法从底部一直向上归纳应用 那么我就会看到这很好用
Dialogue: 0,0:42:04.76,0:42:09.72,英文,,0,0,0,,So kind of the base case, if you're curious, is like a zero or a one-item heap.
Dialogue: 0,0:42:04.76,0:42:09.72,中文,,0,0,0,,如果你好奇的话 基本情况就像一个零或一个元素的堆
Dialogue: 0,0:42:09.72,0:42:12.33,英文,,0,0,0,,The item 26 all by itself, that's a heap.
Dialogue: 0,0:42:09.72,0:42:12.33,中文,,0,0,0,,元素 26 自己就是一个堆
Dialogue: 0,0:42:12.33,0:42:14.40,英文,,0,0,0,,And then I induct my way up.
Dialogue: 0,0:42:12.33,0:42:14.40,中文,,0,0,0,,然后我向上归纳
Dialogue: 0,0:42:14.40,0:42:19.09,英文,,0,0,0,,using larger and larger heaps until eventually I get to the entire thing being a heap.
Dialogue: 0,0:42:14.40,0:42:19.09,中文,,0,0,0,,使用越来越大的堆 直到最终我得到整个东西是一个堆
Dialogue: 0,0:42:19.09,0:42:21.17,英文,,0,0,0,,But that's kind of the rough idea.
Dialogue: 0,0:42:19.09,0:42:21.17,中文,,0,0,0,,但这只是大概的思路
Dialogue: 0,0:42:21.17,0:42:28.03,英文,,0,0,0,,If I sync every item, I know that my resulting data structure will be a heap because I'm going in reverse level order.
Dialogue: 0,0:42:21.17,0:42:28.03,中文,,0,0,0,,如果我同步每个元素 我知道我得到的数据结构将是一个堆 因为我按反向层级顺序进行
Dialogue: 0,0:42:28.03,0:42:28.59,英文,,0,0,0,,OK.
Dialogue: 0,0:42:28.03,0:42:28.59,中文,,0,0,0,,
Dialogue: 0,0:42:28.59,0:42:34.51,英文,,0,0,0,,So again, I think even if you didn't totally wrap your head around the proof, you would be able to do this mechanically.
Dialogue: 0,0:42:28.59,0:42:34.51,中文,,0,0,0,,再说一次 我认为即使你没有完全理解证明 你也可以机械地做到这一点
Dialogue: 0,0:42:34.51,0:42:39.93,英文,,0,0,0,,But are there any thoughts or opinions about the proof before I go onwards?
Dialogue: 0,0:42:34.51,0:42:39.93,中文,,0,0,0,,但在继续之前 你对这个证明有什么想法或意见吗？
Dialogue: 0,0:42:39.93,0:42:42.11,英文,,0,0,0,,This is probably the most annoying part of today, by the way.
Dialogue: 0,0:42:39.93,0:42:42.11,中文,,0,0,0,,顺便说一下 这可能是今天最烦人的部分
Dialogue: 0,0:42:42.11,0:42:45.01,英文,,0,0,0,,So OK.
Dialogue: 0,0:42:42.11,0:42:45.01,中文,,0,0,0,,
Dialogue: 0,0:42:45.01,0:42:45.81,英文,,0,0,0,,Great.
Dialogue: 0,0:42:45.01,0:42:45.81,中文,,0,0,0,,太好了
Dialogue: 0,0:42:45.81,0:42:52.33,英文,,0,0,0,,So we saw that syncing every item will give me, in reverse level order, will give me a heap.
Dialogue: 0,0:42:45.81,0:42:52.33,中文,,0,0,0,,我们看到 同步每个元素 按反向层级顺序 会给我一个堆
Dialogue: 0,0:42:52.33,0:42:54.33,英文,,0,0,0,,And I didn't have to create a new output array.
Dialogue: 0,0:42:52.33,0:42:54.33,中文,,0,0,0,,而且我不必创建一个新的输出数组
Dialogue: 0,0:42:54.33,0:42:56.45,英文,,0,0,0,,That was the trick that made this so cool.
Dialogue: 0,0:42:54.33,0:42:56.45,中文,,0,0,0,,这就是让它如此酷炫的技巧
Dialogue: 0,0:42:56.45,0:43:01.19,英文,,0,0,0,,I didn't have to go and create a second output array and put all the items into a new heap.
Dialogue: 0,0:42:56.45,0:43:01.19,中文,,0,0,0,,我不必去创建第二个输出数组 然后把所有元素都放到一个新的堆中
Dialogue: 0,0:43:01.19,0:43:08.02,英文,,0,0,0,,I just took the original input array, pretended it was a heap, I wished it was a heap, and the items are not in the right place.
Dialogue: 0,0:43:01.19,0:43:08.02,中文,,0,0,0,,我只是拿了原来的输入数组 假装它是一个堆 我希望它是一个堆 但元素不在正确的位置
Dialogue: 0,0:43:08.02,0:43:12.86,英文,,0,0,0,,And I did some syncing to swap all the items until the resulting data structure was a heap.
Dialogue: 0,0:43:08.02,0:43:12.86,中文,,0,0,0,,我做了一些同步操作来交换所有的元素 直到得到的数据结构是一个堆
Dialogue: 0,0:43:12.86,0:43:16.08,英文,,0,0,0,,And it is now.
Dialogue: 0,0:43:12.86,0:43:16.08,中文,,0,0,0,,现在就是这样了
Dialogue: 0,0:43:16.08,0:43:19.82,英文,,0,0,0,,Great, so everything is heapified.
Dialogue: 0,0:43:16.08,0:43:19.82,中文,,0,0,0,,太好了 现在一切都堆化了
Dialogue: 0,0:43:19.82,0:43:22.44,英文,,0,0,0,,And I didn't have to use extra space, which is cool.
Dialogue: 0,0:43:19.82,0:43:22.44,中文,,0,0,0,,而且我没有使用额外的空间 这很酷
Dialogue: 0,0:43:22.44,0:43:27.62,英文,,0,0,0,,So now it's time to do the same process as before, which is delete items from the heap.
Dialogue: 0,0:43:22.44,0:43:27.62,中文,,0,0,0,,现在是时候像以前一样进行同样的过程了 那就是从堆中删除元素
Dialogue: 0,0:43:27.62,0:43:31.07,英文,,0,0,0,,Every time I delete, some things will shuffle around, and that's OK.
Dialogue: 0,0:43:27.62,0:43:31.07,中文,,0,0,0,,每次我删除 一些东西就会重新排列 这没关系
Dialogue: 0,0:43:31.07,0:43:34.49,英文,,0,0,0,,And I will shove the result into my output array.
Dialogue: 0,0:43:31.07,0:43:34.49,中文,,0,0,0,,我会把结果推送到我的输出数组中
Dialogue: 0,0:43:34.49,0:43:36.01,英文,,0,0,0,,So I could do that.
Dialogue: 0,0:43:34.49,0:43:36.01,中文,,0,0,0,,我可以这样做
Dialogue: 0,0:43:36.01,0:43:38.05,英文,,0,0,0,,And I'll go back and show you.
Dialogue: 0,0:43:36.01,0:43:38.05,中文,,0,0,0,,我会回去给你看
Dialogue: 0,0:43:38.05,0:43:39.11,英文,,0,0,0,,Let's go find it.
Dialogue: 0,0:43:38.05,0:43:39.11,中文,,0,0,0,,我们去找找
Dialogue: 0,0:43:39.11,0:43:42.05,英文,,0,0,0,,Sorry, this lecture has so many slides.
Dialogue: 0,0:43:39.11,0:43:42.05,中文,,0,0,0,,抱歉 这节课的幻灯片太多了
Dialogue: 0,0:43:42.05,0:43:42.93,英文,,0,0,0,,Let's see.
Dialogue: 0,0:43:42.05,0:43:42.93,中文,,0,0,0,,让我们看看
Dialogue: 0,0:43:42.93,0:43:45.33,英文,,0,0,0,,OK, heap deletion.
Dialogue: 0,0:43:42.93,0:43:45.33,中文,,0,0,0,,好的 堆删除
Dialogue: 0,0:43:45.33,0:43:45.89,英文,,0,0,0,,Where are you?
Dialogue: 0,0:43:45.33,0:43:45.89,中文,,0,0,0,,你在哪里？
Dialogue: 0,0:43:45.89,0:43:46.69,英文,,0,0,0,,Here.
Dialogue: 0,0:43:45.89,0:43:46.69,中文,,0,0,0,,这里
Dialogue: 0,0:43:46.69,0:43:52.82,英文,,0,0,0,,So I could do what I did from before, which is I had my valid heap, and I deleted the items, and I put them in the output array.
Dialogue: 0,0:43:46.69,0:43:52.82,中文,,0,0,0,,我以前做的事情我可以再做一次 那就是我有一个有效的堆 我删除了这些元素 我把它们放到了输出数组中
Dialogue: 0,0:43:52.82,0:43:57.68,英文,,0,0,0,,But that would require creating an extra output array, which is extra space.
Dialogue: 0,0:43:52.82,0:43:57.68,中文,,0,0,0,,但这需要创建一个额外的输出数组 这是额外的空间
Dialogue: 0,0:43:57.68,0:43:59.36,英文,,0,0,0,,And I don't like extra space.
Dialogue: 0,0:43:57.68,0:43:59.36,中文,,0,0,0,,我不喜欢额外的空间
Dialogue: 0,0:43:59.36,0:44:08.28,英文,,0,0,0,,So while I could do that, and this is the place, by the way, where the max heap is finally going to be useful, I could have done all this with the min heap until this point.
Dialogue: 0,0:43:59.36,0:44:08.28,中文,,0,0,0,,虽然我可以这样做 顺便说一下 这是最大堆最终会有用的地方 我到目前为止可以用最小堆来做所有这些
Dialogue: 0,0:44:08.28,0:44:11.77,英文,,0,0,0,,Now the max heap trick is going to come in handy.
Dialogue: 0,0:44:08.28,0:44:11.77,中文,,0,0,0,,现在最大堆的技巧就要派上用场了
Dialogue: 0,0:44:11.77,0:44:16.03,英文,,0,0,0,,Watch just the green elements of the heap.
Dialogue: 0,0:44:11.77,0:44:16.03,中文,,0,0,0,,只看堆的绿色元素
Dialogue: 0,0:44:16.03,0:44:19.64,英文,,0,0,0,,As I delete things, the green is draining out.
Dialogue: 0,0:44:16.03,0:44:19.64,中文,,0,0,0,,当我删除东西时 绿色就会消失
Dialogue: 0,0:44:19.64,0:44:23.00,英文,,0,0,0,,So look, everything was being used in the heap.
Dialogue: 0,0:44:19.64,0:44:23.00,中文,,0,0,0,,你看 所有东西都被用在了堆里
Dialogue: 0,0:44:23.00,0:44:27.16,英文,,0,0,0,,And as I deleted items, just focus on the green, it's draining away.
Dialogue: 0,0:44:23.00,0:44:27.16,中文,,0,0,0,,当我删除元素时 只关注绿色 它正在消失
Dialogue: 0,0:44:27.16,0:44:31.45,英文,,0,0,0,,And then the array is starting to get less and less used.
Dialogue: 0,0:44:27.16,0:44:31.45,中文,,0,0,0,,然后数组开始越来越少被使用
Dialogue: 0,0:44:31.45,0:44:34.11,英文,,0,0,0,,Now, watch the output array.
Dialogue: 0,0:44:31.45,0:44:34.11,中文,,0,0,0,,现在 看输出数组
Dialogue: 0,0:44:34.11,0:44:35.71,英文,,0,0,0,,Maybe you see where this is going.
Dialogue: 0,0:44:34.11,0:44:35.71,中文,,0,0,0,,也许你已经看到我要做什么了
Dialogue: 0,0:44:35.71,0:44:38.21,英文,,0,0,0,,Right now, the output array is totally unused.
Dialogue: 0,0:44:35.71,0:44:38.21,中文,,0,0,0,,现在 输出数组完全没有被使用
Dialogue: 0,0:44:38.21,0:44:39.91,英文,,0,0,0,,But I start to fill items.
Dialogue: 0,0:44:38.21,0:44:39.91,中文,,0,0,0,,但我开始填充元素
Dialogue: 0,0:44:39.91,0:44:40.73,英文,,0,0,0,,Watch the gray.
Dialogue: 0,0:44:39.91,0:44:40.73,中文,,0,0,0,,看灰色的
Dialogue: 0,0:44:40.73,0:44:44.17,英文,,0,0,0,,It's filling in from right to left.
Dialogue: 0,0:44:40.73,0:44:44.17,中文,,0,0,0,,它从右到左填充
Dialogue: 0,0:44:44.17,0:44:47.19,英文,,0,0,0,,So maybe you see the trick that I'm about to play.
Dialogue: 0,0:44:44.17,0:44:47.19,中文,,0,0,0,,也许你看到了我要玩的把戏
Dialogue: 0,0:44:47.19,0:44:59.74,英文,,0,0,0,,If the heap is draining items such that its back elements are starting to become unused, and the output array is filling in items from the back such that they're starting to get used,
Dialogue: 0,0:44:47.19,0:44:59.74,中文,,0,0,0,,如果堆正在消耗元素 以至于它的后面的元素开始变得未使用 而输出数组正在从后面填充元素 以至于它们开始被使用
Dialogue: 0,0:44:59.74,0:45:00.94,英文,,0,0,0,,Well, maybe you see the trick now.
Dialogue: 0,0:44:59.74,0:45:00.94,中文,,0,0,0,,那么 也许你现在看到了这个技巧
Dialogue: 0,0:45:00.94,0:45:04.14,英文,,0,0,0,,Maybe I don't need two arrays after all.
Dialogue: 0,0:45:00.94,0:45:04.14,中文,,0,0,0,,也许我根本不需要两个数组
Dialogue: 0,0:45:04.14,0:45:09.70,英文,,0,0,0,,And that's the trick that's going to make in-place heap sort not use extra memory.
Dialogue: 0,0:45:04.14,0:45:09.70,中文,,0,0,0,,这就是可以让原地堆排序不使用额外内存的技巧
Dialogue: 0,0:45:09.70,0:45:10.74,英文,,0,0,0,,So here we go.
Dialogue: 0,0:45:09.70,0:45:10.74,中文,,0,0,0,,我们开始吧
Dialogue: 0,0:45:10.74,0:45:13.05,英文,,0,0,0,,This 41, I'm going to delete it.
Dialogue: 0,0:45:10.74,0:45:13.05,中文,,0,0,0,,这个 41 我要把它删除
Dialogue: 0,0:45:13.05,0:45:20.43,英文,,0,0,0,,But instead of putting it in a brand new output array, which would be extra space, I'm just going to shove it at the end of the array.
Dialogue: 0,0:45:13.05,0:45:20.43,中文,,0,0,0,,但我不会把它放在一个全新的输出数组中 那会占用额外的空间 我只会把它塞到数组的末尾
Dialogue: 0,0:45:20.43,0:45:24.38,英文,,0,0,0,,And that's OK, because the heap has vacated this element of the array.
Dialogue: 0,0:45:20.43,0:45:24.38,中文,,0,0,0,,这没关系 因为堆已经腾出了数组的这个元素
Dialogue: 0,0:45:24.38,0:45:26.64,英文,,0,0,0,,It's no longer using this part of the array.
Dialogue: 0,0:45:24.38,0:45:26.64,中文,,0,0,0,,它不再使用数组的这一部分了
Dialogue: 0,0:45:26.64,0:45:28.95,英文,,0,0,0,,So I'm safe to put the output here.
Dialogue: 0,0:45:26.64,0:45:28.95,中文,,0,0,0,,我可以把输出放在这里
Dialogue: 0,0:45:28.95,0:45:32.43,英文,,0,0,0,,Then I take the next element, 32, and I delete it.
Dialogue: 0,0:45:28.95,0:45:32.43,中文,,0,0,0,,然后我取下一个元素 32 我把它删除
Dialogue: 0,0:45:32.43,0:45:34.76,英文,,0,0,0,,And when I delete it, the heap's going to shuffle around.
Dialogue: 0,0:45:32.43,0:45:34.76,中文,,0,0,0,,当我删除它的时候 堆会重新排列
Dialogue: 0,0:45:34.76,0:45:40.24,英文,,0,0,0,,But this last box is going to no longer be used by the heap, because I deleted something out.
Dialogue: 0,0:45:34.76,0:45:40.24,中文,,0,0,0,,但是最后一个框将不再被堆使用 因为我删除了一些东西
Dialogue: 0,0:45:40.24,0:45:42.38,英文,,0,0,0,,So I can put the 32 in there.
Dialogue: 0,0:45:40.24,0:45:42.38,中文,,0,0,0,,我可以把 32 放在那里
Dialogue: 0,0:45:42.38,0:45:47.28,英文,,0,0,0,,Then I take the 26, I delete it, and I put it where?
Dialogue: 0,0:45:42.38,0:45:47.28,中文,,0,0,0,,然后我取 26 我把它删除 我把它放在哪里？
Dialogue: 0,0:45:47.28,0:46:01.94,英文,,0,0,0,,It's a little bit harder to stare at, and it's not as simple as swapping, so don't get tempted to just swap the 41 and the 17, that will not work.
Dialogue: 0,0:45:47.28,0:46:01.94,中文,,0,0,0,,盯着它看有点难 它不像交换那么简单 所以不要试图简单地交换 41 和 17 那行不通
Dialogue: 0,0:46:01.94,0:46:06.40,英文,,0,0,0,,You have to delete the item, let the heap shuffle and sync its items around,
Dialogue: 0,0:46:01.94,0:46:06.40,中文,,0,0,0,,你必须删除这个元素 让堆重新排列并同步它的元素
Dialogue: 0,0:46:06.40,0:46:11.35,英文,,0,0,0,,And then put the 41 in the spot vacated by the heap.
Dialogue: 0,0:46:06.40,0:46:11.35,中文,,0,0,0,,然后把 41 放在堆腾出的位置
Dialogue: 0,0:46:11.35,0:46:17.07,英文,,0,0,0,,And I almost think the in-place animation is kind of helpful to see what's going on here.
Dialogue: 0,0:46:11.35,0:46:17.07,中文,,0,0,0,,我几乎认为原地动画有助于了解这里发生的事情
Dialogue: 0,0:46:17.07,0:46:22.18,英文,,0,0,0,,So again, you watch the heap at the top drain, and then watch the output at the bottom fill up.
Dialogue: 0,0:46:17.07,0:46:22.18,中文,,0,0,0,,再说一次 你看着顶部的堆消耗掉 然后看着底部的输出填满
Dialogue: 0,0:46:22.18,0:46:26.06,英文,,0,0,0,,That's what makes in-place heapification work.
Dialogue: 0,0:46:22.18,0:46:26.06,中文,,0,0,0,,这就是原地堆化的工作原理
Dialogue: 0,0:46:26.06,0:46:28.41,英文,,0,0,0,,And it avoids having to create a second output array.
Dialogue: 0,0:46:26.06,0:46:28.41,中文,,0,0,0,,它避免了创建第二个输出数组
Dialogue: 0,0:46:28.41,0:46:29.89,英文,,0,0,0,,It's pretty cool.
Dialogue: 0,0:46:28.41,0:46:29.89,中文,,0,0,0,,这很酷
Dialogue: 0,0:46:29.89,0:46:33.27,英文,,0,0,0,,You could try doing this with a min-heap, but it would be more annoying.
Dialogue: 0,0:46:29.89,0:46:33.27,中文,,0,0,0,,你可以尝试用最小堆来做这件事 但这会更麻烦
Dialogue: 0,0:46:33.27,0:46:38.28,英文,,0,0,0,,That's why I like using a max-heap, because the items fill in from the back instead of the front.
Dialogue: 0,0:46:33.27,0:46:38.28,中文,,0,0,0,,这就是为什么我喜欢使用最大堆 因为元素是从后面而不是前面填充的
Dialogue: 0,0:46:38.28,0:46:42.28,英文,,0,0,0,,That's the one place where the max-heap is useful.
Dialogue: 0,0:46:38.28,0:46:42.28,中文,,0,0,0,,这是最大堆有用的地方
Dialogue: 0,0:46:42.28,0:46:42.78,英文,,0,0,0,,Thoughts?
Dialogue: 0,0:46:42.28,0:46:42.78,中文,,0,0,0,,想法？
Dialogue: 0,0:46:42.78,0:46:43.34,英文,,0,0,0,,Questions?
Dialogue: 0,0:46:42.78,0:46:43.34,中文,,0,0,0,,问题？
Dialogue: 0,0:46:43.34,0:46:44.87,英文,,0,0,0,,Are your minds blown by this?
Dialogue: 0,0:46:43.34,0:46:44.87,中文,,0,0,0,,这把你们都惊呆了吧？
Dialogue: 0,0:46:44.87,0:46:46.45,英文,,0,0,0,,OK.
Dialogue: 0,0:46:44.87,0:46:46.45,中文,,0,0,0,,好
Dialogue: 0,0:46:46.45,0:46:47.03,英文,,0,0,0,,Good.
Dialogue: 0,0:46:46.45,0:46:47.03,中文,,0,0,0,,不错
Dialogue: 0,0:46:47.03,0:46:48.13,英文,,0,0,0,,That's heap sort.
Dialogue: 0,0:46:47.03,0:46:48.13,中文,,0,0,0,,这就是堆排序
Dialogue: 0,0:46:48.13,0:46:52.05,英文,,0,0,0,,Let's think about runtime, and then we probably have to go.
Dialogue: 0,0:46:48.13,0:46:52.05,中文,,0,0,0,,我们来考虑一下运行时间 然后可能就要结束了
Dialogue: 0,0:46:52.05,0:46:54.13,英文,,0,0,0,,So. Runtime.
Dialogue: 0,0:46:52.05,0:46:54.13,中文,,0,0,0,,所以运行时间
Dialogue: 0,0:46:54.13,0:46:56.35,英文,,0,0,0,,Well, here are the things we had to do.
Dialogue: 0,0:46:54.13,0:46:56.35,中文,,0,0,0,,那么 我们要做的事情如下
Dialogue: 0,0:46:56.35,0:47:02.59,英文,,0,0,0,,We had to do that bottom-up heapification thing, which was sync all the items in reverse level order.
Dialogue: 0,0:46:56.35,0:47:02.59,中文,,0,0,0,,我们必须进行自底向上的堆化操作 也就是按反向层级顺序同步所有元素
Dialogue: 0,0:47:02.59,0:47:09.16,英文,,0,0,0,,And then I had to remove the largest item over and over again, just like in regular naive heap sort.
Dialogue: 0,0:47:02.59,0:47:09.16,中文,,0,0,0,,然后我必须像常规的朴素堆排序一样 反复删除最大的元素
Dialogue: 0,0:47:09.16,0:47:11.24,英文,,0,0,0,,So let's think about both of these steps.
Dialogue: 0,0:47:09.16,0:47:11.24,中文,,0,0,0,,我们来考虑一下这两个步骤
Dialogue: 0,0:47:11.24,0:47:15.48,英文,,0,0,0,,And then we'll add them together, because I did both steps separately.
Dialogue: 0,0:47:11.24,0:47:15.48,中文,,0,0,0,,然后我们将它们加起来 因为我分别执行了这两个步骤
Dialogue: 0,0:47:15.48,0:47:18.68,英文,,0,0,0,,So how long did it take to do bottom-up heapification?
Dialogue: 0,0:47:15.48,0:47:18.68,中文,,0,0,0,,那么自底向上的堆化操作需要多长时间？
Dialogue: 0,0:47:18.68,0:47:19.50,英文,,0,0,0,,And be lazy.
Dialogue: 0,0:47:18.68,0:47:19.50,中文,,0,0,0,,偷个懒
Dialogue: 0,0:47:19.50,0:47:21.11,英文,,0,0,0,,Give me a big old bound.
Dialogue: 0,0:47:19.50,0:47:21.11,中文,,0,0,0,,给我一个粗略的界限
Dialogue: 0,0:47:21.11,0:47:22.89,英文,,0,0,0,,that you think feels right.
Dialogue: 0,0:47:21.11,0:47:22.89,中文,,0,0,0,,你觉得合适的就行
Dialogue: 0,0:47:22.89,0:47:29.47,英文,,0,0,0,,And it might not be tight, might not be the best bound that you can give, but be lazy, give me something that you think makes sense.
Dialogue: 0,0:47:22.89,0:47:29.47,中文,,0,0,0,,它可能并不精确 可能不是你能给出的最佳界限 但偷个懒 给我一个你觉得合理的答案
Dialogue: 0,0:47:29.47,0:47:33.69,英文,,0,0,0,,So, if I want to sync every item, that's not what I want.
Dialogue: 0,0:47:29.47,0:47:33.69,中文,,0,0,0,,如果我想同步每个元素 那不是我想要的
Dialogue: 0,0:47:33.69,0:47:37.77,英文,,0,0,0,,If I want to sync every item, how many items do I have to sync?
Dialogue: 0,0:47:33.69,0:47:37.77,中文,,0,0,0,,如果我想同步每个元素 我需要同步多少个元素？
Dialogue: 0,0:47:37.77,0:47:43.04,英文,,0,0,0,,And in the worst case, give me an upper bound of how long each sync takes.
Dialogue: 0,0:47:37.77,0:47:43.04,中文,,0,0,0,,在最坏的情况下 给我一个每个同步操作所需时间的上限
Dialogue: 0,0:47:43.04,0:47:44.62,英文,,0,0,0,,So I have to sync everything, right?
Dialogue: 0,0:47:43.04,0:47:44.62,中文,,0,0,0,,我必须同步所有元素 对吧？
Dialogue: 0,0:47:44.62,0:47:46.86,英文,,0,0,0,,I have to sync everything one by one.
Dialogue: 0,0:47:44.62,0:47:46.86,中文,,0,0,0,,我必须逐个同步所有元素
Dialogue: 0,0:47:46.86,0:47:49.00,英文,,0,0,0,,And in the worst case,
Dialogue: 0,0:47:46.86,0:47:49.00,中文,,0,0,0,,在最坏的情况下
Dialogue: 0,0:47:49.00,0:47:52.48,英文,,0,0,0,,Give me an upper bound for how long each sync takes.
Dialogue: 0,0:47:49.00,0:47:52.48,中文,,0,0,0,,给我一个每个同步操作所需时间上限
Dialogue: 0,0:47:52.48,0:47:57.46,英文,,0,0,0,,If I start at the top and I sync all the way down, log n. So I have n things to sync.
Dialogue: 0,0:47:52.48,0:47:57.46,中文,,0,0,0,,如果我从顶部开始同步到底部 那就是 log N 我有 N 个元素需要同步
Dialogue: 0,0:47:57.46,0:48:06.33,英文,,0,0,0,,Everything takes log n. So I at least have an upper bound of big O of n log n for the bottom-up heapification step.
Dialogue: 0,0:47:57.46,0:48:06.33,中文,,0,0,0,,每个操作都需要 log N 的时间 所以自底向上的堆化步骤至少有一个 O(N log N) 的上限
Dialogue: 0,0:48:06.33,0:48:07.85,英文,,0,0,0,,And then what about that second step?
Dialogue: 0,0:48:06.33,0:48:07.85,中文,,0,0,0,,那么第二个步骤呢？
Dialogue: 0,0:48:07.85,0:48:11.85,英文,,0,0,0,,It was the same thing as before, which was I take every item and I remove it.
Dialogue: 0,0:48:07.85,0:48:11.85,中文,,0,0,0,,它和之前一样 也就是我取出每个元素并删除它
Dialogue: 0,0:48:11.85,0:48:13.87,英文,,0,0,0,,There are n items to remove.
Dialogue: 0,0:48:11.85,0:48:13.87,中文,,0,0,0,,有 N 个元素需要删除
Dialogue: 0,0:48:13.87,0:48:20.19,英文,,0,0,0,,Every removal costs me log n. So in total, the removal is n log n.
Dialogue: 0,0:48:13.87,0:48:20.19,中文,,0,0,0,,每次删除都需要 log N 的时间 所以总的来说 删除操作需要 N log N 的时间
Dialogue: 0,0:48:20.19,0:48:25.91,英文,,0,0,0,,So I have one step that's n log n. I have another step that's n log n.
Dialogue: 0,0:48:20.19,0:48:25.91,中文,,0,0,0,,我有一个步骤需要 N log N 的时间 另一个步骤也需要 N log N 的时间
Dialogue: 0,0:48:25.91,0:48:29.91,英文,,0,0,0,, I add them together, and the time complexity is still n log n. But I got rid of all that extra memory.
Dialogue: 0,0:48:25.91,0:48:29.91,中文,,0,0,0,,我把它们加起来 时间复杂度仍然是 N log N 但我摆脱了所有额外的内存
Dialogue: 0,0:48:29.91,0:48:37.02,英文,,0,0,0,,So the space complexity would be theta of 1, because it did not have to create any extra array.
Dialogue: 0,0:48:29.91,0:48:37.02,中文,,0,0,0,,空间复杂度是 Θ(1) 因为它不需要创建任何额外的数组
Dialogue: 0,0:48:37.02,0:48:42.06,英文,,0,0,0,,The extra space that I need was not scaling with the size of my input.
Dialogue: 0,0:48:37.02,0:48:42.06,中文,,0,0,0,,我需要的额外空间不会随着输入的大小而扩展
Dialogue: 0,0:48:42.06,0:48:43.17,英文,,0,0,0,,OK.
Dialogue: 0,0:48:42.06,0:48:43.17,中文,,0,0,0,,好
Dialogue: 0,0:48:43.17,0:48:44.27,英文,,0,0,0,,So that was Heapsort.
Dialogue: 0,0:48:43.17,0:48:44.27,中文,,0,0,0,,这就是堆排序
Dialogue: 0,0:48:44.27,0:48:48.91,英文,,0,0,0,,And I guess before I let you go, I want to show you something that I think people always ask me about.
Dialogue: 0,0:48:44.27,0:48:48.91,中文,,0,0,0,,我想在结束之前 向你们展示一些人们经常问我的东西
Dialogue: 0,0:48:48.91,0:48:51.70,英文,,0,0,0,,And I realize that this is a nice place to show it to you.
Dialogue: 0,0:48:48.91,0:48:51.70,中文,,0,0,0,,我意识到这是一个向你们展示的好地方
Dialogue: 0,0:48:51.70,0:48:57.04,英文,,0,0,0,,So people always ask, what is the difference between big O and worst case?
Dialogue: 0,0:48:51.70,0:48:57.04,中文,,0,0,0,,人们总是问 大 O 和最坏情况有什么区别？
Dialogue: 0,0:48:57.04,0:48:58.44,英文,,0,0,0,,I know you've had this question.
Dialogue: 0,0:48:57.04,0:48:58.44,中文,,0,0,0,,我知道你们有过这样的疑问
Dialogue: 0,0:48:58.44,0:49:00.54,英文,,0,0,0,,I'm going to try and finally answer it for you.
Dialogue: 0,0:48:58.44,0:49:00.54,中文,,0,0,0,,我会尽量最终为你们解答
Dialogue: 0,0:49:00.54,0:49:03.92,英文,,0,0,0,,So what if I told you that
Dialogue: 0,0:49:00.54,0:49:03.92,中文,,0,0,0,,如果我告诉你们
Dialogue: 0,0:49:03.92,0:49:09.91,英文,,0,0,0,,Our analysis that bottom-up heapification was n log n was actually pretty lazy.
Dialogue: 0,0:49:03.92,0:49:09.91,中文,,0,0,0,,我们对自底向上堆化的分析结果是 N log N 实际上是相当粗略的
Dialogue: 0,0:49:09.91,0:49:16.81,英文,,0,0,0,,So we just said there's n things to sink, and each sink takes log n in the worst case.
Dialogue: 0,0:49:09.91,0:49:16.81,中文,,0,0,0,,我们只是说有 N 个元素需要下沉 每个下沉操作在最坏情况下需要 log N 的时间
Dialogue: 0,0:49:16.81,0:49:19.64,英文,,0,0,0,,And I multiply them together and I get n log n.
Dialogue: 0,0:49:16.81,0:49:19.64,中文,,0,0,0,,我把它们相乘 就得到了 N log N
Dialogue: 0,0:49:19.64,0:49:21.74,英文,,0,0,0,,And I used big O. Why did I use big O?
Dialogue: 0,0:49:19.64,0:49:21.74,中文,,0,0,0,,我使用了大 O 表示法 为什么我使用大 O？
Dialogue: 0,0:49:21.74,0:49:27.82,英文,,0,0,0,,Because I said, well, I know it's n log n or better, but I actually don't know if it's exactly n log n.
Dialogue: 0,0:49:21.74,0:49:27.82,中文,,0,0,0,,因为我说 嗯 我知道它最多是 N log N 但我实际上不知道它是否恰好是 N log N
Dialogue: 0,0:49:27.82,0:49:33.82,英文,,0,0,0,,If I knew that it was exactly n log n to sync all the items, I'd put a theta here.
Dialogue: 0,0:49:27.82,0:49:33.82,中文,,0,0,0,,如果我知道同步所有元素的确切时间是 N log N 我会在这里写一个 Θ
Dialogue: 0,0:49:33.82,0:49:39.52,英文,,0,0,0,,But I put an O here because I'm lazy, and I actually don't know if this is the exact best runtime.
Dialogue: 0,0:49:33.82,0:49:39.52,中文,,0,0,0,,但我在这里写了一个 O 因为我偷懒了 我实际上不知道这是否是确切的最佳运行时间
Dialogue: 0,0:49:39.52,0:49:42.18,英文,,0,0,0,,In other words, I don't know if this bound is tight.
Dialogue: 0,0:49:39.52,0:49:42.18,中文,,0,0,0,,换句话说 我不知道这个界限是否精确
Dialogue: 0,0:49:42.18,0:49:47.81,英文,,0,0,0,,And it turns out, if you really go and play with the math, and you get a really funky summation,
Dialogue: 0,0:49:42.18,0:49:47.81,中文,,0,0,0,,事实证明 如果你真的去研究数学 你会得到一个非常奇怪的求和式
Dialogue: 0,0:49:47.81,0:49:53.81,英文,,0,0,0,,and you sum it out, it turns out that bottom-up heap implication is actually not n log n exactly.
Dialogue: 0,0:49:47.81,0:49:53.81,中文,,0,0,0,,然后你把它求和 结果发现自底向上的堆化操作实际上并不是 N log N
Dialogue: 0,0:49:53.81,0:49:58.21,英文,,0,0,0,,It's actually theta of n. And it's not something that I expect you to see right away.
Dialogue: 0,0:49:53.81,0:49:58.21,中文,,0,0,0,,它实际上是 Θ(N) 这不是我希望你们马上就能看出来的
Dialogue: 0,0:49:58.21,0:50:06.06,英文,,0,0,0,,But it turns out, if you do the analysis, it's theta of n. Does that mean that our analysis was totally busted?
Dialogue: 0,0:49:58.21,0:50:06.06,中文,,0,0,0,,但事实证明 如果你进行分析 它就是 Θ(N) 这是否意味着我们的分析完全失败了？
Dialogue: 0,0:50:06.06,0:50:12.22,英文,,0,0,0,,Well, not really, because here I said bottom-up heapification is big O of n log n.
Dialogue: 0,0:50:06.06,0:50:12.22,中文,,0,0,0,,嗯 也不尽然 因为我在这里说自底向上的堆化操作是大 O(N log N)
Dialogue: 0,0:50:12.22,0:50:20.22,英文,,0,0,0,,And what I was really saying was bottom-up heapification, the thing where I sync all the elements, it's n log n or better.
Dialogue: 0,0:50:12.22,0:50:20.22,中文,,0,0,0,,我真正想说的是 自底向上的堆化操作 也就是同步所有元素的操作 它最多是 N log N
Dialogue: 0,0:50:20.22,0:50:21.80,英文,,0,0,0,,Is it exactly n log n?
Dialogue: 0,0:50:20.22,0:50:21.80,中文,,0,0,0,,它恰好是 N log N 吗？
Dialogue: 0,0:50:21.80,0:50:22.62,英文,,0,0,0,,I don't know.
Dialogue: 0,0:50:21.80,0:50:22.62,中文,,0,0,0,,我不知道
Dialogue: 0,0:50:22.62,0:50:24.16,英文,,0,0,0,,Is it better than n log n?
Dialogue: 0,0:50:22.62,0:50:24.16,中文,,0,0,0,,它比 N log N 更好吗？
Dialogue: 0,0:50:24.16,0:50:24.94,英文,,0,0,0,,Maybe.
Dialogue: 0,0:50:24.16,0:50:24.94,中文,,0,0,0,,也许吧
Dialogue: 0,0:50:24.94,0:50:30.74,英文,,0,0,0,,But I know that it's not going to be worse than n log n. That's where I use the big O notation.
Dialogue: 0,0:50:24.94,0:50:30.74,中文,,0,0,0,,但我知道它不会比 N log N 更差 这就是我使用大 O 表示法的地方
Dialogue: 0,0:50:30.74,0:50:33.35,英文,,0,0,0,,But it's not the same thing as saying it's n log n in the worst case.
Dialogue: 0,0:50:30.74,0:50:33.35,中文,,0,0,0,,但这与说它在最坏情况下是 N log N 不一样
Dialogue: 0,0:50:33.35,0:50:36.51,英文,,0,0,0,,It turns out it's actually not n log n in the worst case.
Dialogue: 0,0:50:33.35,0:50:36.51,中文,,0,0,0,,事实证明 它在最坏情况下实际上不是 N log N
Dialogue: 0,0:50:36.51,0:50:42.07,英文,,0,0,0,,It's actually theta of n in the worst case, if you do really careful analysis.
Dialogue: 0,0:50:36.51,0:50:42.07,中文,,0,0,0,,如果你仔细分析 它在最坏情况下实际上是 Θ(N)
Dialogue: 0,0:50:42.07,0:50:46.63,英文,,0,0,0,,So here is a case where I used big O to be lazy in my analysis.
Dialogue: 0,0:50:42.07,0:50:46.63,中文,,0,0,0,,这里有一个例子 我使用大 O 来偷懒进行分析
Dialogue: 0,0:50:46.63,0:50:49.90,英文,,0,0,0,,And it turns out it is not the same thing as worst case.
Dialogue: 0,0:50:46.63,0:50:49.90,中文,,0,0,0,,事实证明 它与最坏情况不一样
Dialogue: 0,0:50:49.90,0:50:53.12,英文,,0,0,0,,The worst case was really theta of n.
Dialogue: 0,0:50:49.90,0:50:53.12,中文,,0,0,0,,最坏情况实际上是 Θ(N)
Dialogue: 0,0:50:53.12,0:50:57.72,英文,,0,0,0,,But I was lazy, and I bounded it by saying, it's n log n. Maybe it's better.
Dialogue: 0,0:50:53.12,0:50:57.72,中文,,0,0,0,,但我偷懒了 我把它限制在 N log N 也许它更好
Dialogue: 0,0:50:57.72,0:50:58.48,英文,,0,0,0,,Who knows?
Dialogue: 0,0:50:57.72,0:50:58.48,中文,,0,0,0,,谁知道呢？
Dialogue: 0,0:50:58.48,0:51:02.87,英文,,0,0,0,,But here's a case where it's not, where big O and worst case are not the same thing.
Dialogue: 0,0:50:58.48,0:51:02.87,中文,,0,0,0,,但这里有一个例子 大 O 和最坏情况不一样
Dialogue: 0,0:51:02.87,0:51:04.15,英文,,0,0,0,,So now you know.
Dialogue: 0,0:51:02.87,0:51:04.15,中文,,0,0,0,,现在你们知道了
Dialogue: 0,0:51:04.15,0:51:07.90,英文,,0,0,0,,And by the way, why was I OK by using this lazy analysis?
Dialogue: 0,0:51:04.15,0:51:07.90,中文,,0,0,0,,顺便说一下 为什么我可以用这种偷懒的分析方法？
Dialogue: 0,0:51:07.90,0:51:13.48,英文,,0,0,0,,Because let's say I really did find out, oh, shoot, this is actually theta of n time.
Dialogue: 0,0:51:07.90,0:51:13.48,中文,,0,0,0,,因为假设我真的发现 哦 糟糕 这实际上是 Θ(N) 的时间
Dialogue: 0,0:51:13.48,0:51:16.60,英文,,0,0,0,,Would that change the runtime of in-place heap sort?
Dialogue: 0,0:51:13.48,0:51:16.60,中文,,0,0,0,,这会改变原地堆排序的运行时间吗？
Dialogue: 0,0:51:16.60,0:51:19.55,英文,,0,0,0,,Well, not really, because I have a theta of n step.
Dialogue: 0,0:51:16.60,0:51:19.55,中文,,0,0,0,,嗯 不会 因为我有一个 Θ(N) 的步骤
Dialogue: 0,0:51:19.55,0:51:21.91,英文,,0,0,0,,Then I have a theta of n log n step.
Dialogue: 0,0:51:19.55,0:51:21.91,中文,,0,0,0,,然后我有一个 Θ(N log N) 的步骤
Dialogue: 0,0:51:21.91,0:51:28.30,英文,,0,0,0,,And if I add them together, the resulting time complexity is still n log n.
Dialogue: 0,0:51:21.91,0:51:28.30,中文,,0,0,0,,如果我把它们加起来 最终的时间复杂度仍然是 N log N
Dialogue: 0,0:51:28.30,0:51:30.72,英文,,0,0,0,,That's why being a little bit lazy here turned out to pay off.
Dialogue: 0,0:51:28.30,0:51:30.72,中文,,0,0,0,,这就是为什么在这里偷懒一点 terNyata 有回报
Dialogue: 0,0:51:30.72,0:51:33.86,英文,,0,0,0,,It doesn't always pay off, but in this case, it did.
Dialogue: 0,0:51:30.72,0:51:33.86,中文,,0,0,0,,这并不总是有效 但在这种情况下 它有效了
Dialogue: 0,0:51:33.86,0:51:36.18,英文,,0,0,0,,And I used a bound that was not totally tight.
Dialogue: 0,0:51:33.86,0:51:36.18,中文,,0,0,0,,我使用了一个不完全精确的界限
Dialogue: 0,0:51:36.18,0:51:39.48,英文,,0,0,0,,So now you know all about big O and worst case.
Dialogue: 0,0:51:36.18,0:51:39.48,中文,,0,0,0,,现在你们都了解了大 O 和最坏情况
Dialogue: 0,0:51:39.48,0:51:40.78,英文,,0,0,0,,So I snuck that in there.
Dialogue: 0,0:51:39.48,0:51:40.78,中文,,0,0,0,,我就偷偷地把它塞进去了
Dialogue: 0,0:51:40.78,0:51:43.88,英文,,0,0,0,,So you saw two sorts, but I know you're not satisfied.
Dialogue: 0,0:51:40.78,0:51:43.88,中文,,0,0,0,,你们看到了两种排序方式 但我知道你们还不满意
Dialogue: 0,0:51:43.88,0:51:45.02,英文,,0,0,0,,So come back next time.
Dialogue: 0,0:51:43.88,0:51:45.02,中文,,0,0,0,,下次再来吧
Dialogue: 0,0:51:45.02,0:51:48.30,英文,,0,0,0,,You will get more sorts.
Dialogue: 0,0:51:45.02,0:51:48.30,中文,,0,0,0,,你们会看到更多排序方式的
Dialogue: 0,0:51:48.30,0:51:54.24,英文,,0,0,0,,Let's answer some questions on Zoom while you all squeak in your chairs and head out.
Dialogue: 0,0:51:48.30,0:51:54.24,中文,,0,0,0,,在我们都吱吱呀呀地坐到椅子上离开的时候 让我们在 Zoom 上回答一些问题吧
Dialogue: 0,0:51:54.24,0:51:57.24,英文,,0,0,0,,So questions.
Dialogue: 0,0:51:54.24,0:51:57.24,中文,,0,0,0,,所以 提问吧
Dialogue: 0,0:51:57.24,0:51:58.82,英文,,0,0,0,,Let's see.
Dialogue: 0,0:51:57.24,0:51:58.82,中文,,0,0,0,,让我们看看
Dialogue: 0,0:51:58.82,0:52:00.54,英文,,0,0,0,,Why is the max-heap better than the min-heap?
Dialogue: 0,0:51:58.82,0:52:00.54,中文,,0,0,0,,为什么最大堆比最小堆更好？
Dialogue: 0,0:52:00.54,0:52:04.72,英文,,0,0,0,,It's because I wanted to do that in-place operation.
Dialogue: 0,0:52:00.54,0:52:04.72,中文,,0,0,0,,这是因为我想进行原地操作
Dialogue: 0,0:52:04.72,0:52:12.01,英文,,0,0,0,,So the max-heap is better because it allows me to do this thing where I can delete something and fill it into the back.
Dialogue: 0,0:52:04.72,0:52:12.01,中文,,0,0,0,,最大堆更好 因为它允许我做这样的事情：我可以删除一个元素并把它填到后面
Dialogue: 0,0:52:12.01,0:52:13.95,英文,,0,0,0,,That's why the max-heap was better.
Dialogue: 0,0:52:12.01,0:52:13.95,中文,,0,0,0,,这就是为什么最大堆更好
Dialogue: 0,0:52:13.95,0:52:16.94,英文,,0,0,0,,For in-place heap sort,
Dialogue: 0,0:52:13.95,0:52:16.94,中文,,0,0,0,,对于原地堆排序
Dialogue: 0,0:52:16.94,0:52:22.04,英文,,0,0,0,,The textbook says that bottom-up construction is theta of n. Shouldn't it be n log n?
Dialogue: 0,0:52:16.94,0:52:22.04,中文,,0,0,0,,教科书上说自底向上的构建是 Θ(N) 它不应该是 N log N 吗？
Dialogue: 0,0:52:22.04,0:52:29.61,英文,,0,0,0,,That was the thing that we just talked about, which is that I set n log n as a big O bound to say it's n log n or better,
Dialogue: 0,0:52:22.04,0:52:29.61,中文,,0,0,0,,这就是我们刚才讨论的内容 也就是我设定 N log N 作为大 O 界限 表示它最多是 N log N
Dialogue: 0,0:52:29.61,0:52:38.61,英文,,0,0,0,,but it turns out I can actually get it all the way down to theta of n, but I just upper bounded it lazily with big O of n log n. And the question of why is it n log n?
Dialogue: 0,0:52:29.61,0:52:38.61,中文,,0,0,0,,但事实证明我实际上可以把它一直降低到 Θ(N) 但我只是懒惰地用大 O(N log N) 作为上限 为什么它是 N log N？
Dialogue: 0,0:52:38.61,0:52:46.79,英文,,0,0,0,,It's because I have n items to sync, and in the worst case, every sync could take log n. If I have to sync all the way from the top to the bottom,
Dialogue: 0,0:52:38.61,0:52:46.79,中文,,0,0,0,,这是因为我有 N 个元素需要同步 在最坏的情况下 每个同步操作可能需要 log N 的时间 如果我必须从顶部到底部进行同步
Dialogue: 0,0:52:46.79,0:52:47.75,英文,,0,0,0,,There are n items.
Dialogue: 0,0:52:46.79,0:52:47.75,中文,,0,0,0,,有 N 个元素
Dialogue: 0,0:52:47.75,0:52:49.94,英文,,0,0,0,,Every sink takes log n time.
Dialogue: 0,0:52:47.75,0:52:49.94,中文,,0,0,0,,每个下沉操作都需要 log N 的时间
Dialogue: 0,0:52:49.94,0:52:58.13,英文,,0,0,0,,So my upper bound, which turned out not to be exact, but was a good upper estimate, was n log n. OK, those are all the questions on Zoom.
Dialogue: 0,0:52:49.94,0:52:58.13,中文,,0,0,0,,我的上限 虽然结果不精确 但是一个很好的上限估计 是 N log N 好的 Zoom 上的问题都回答完了
Dialogue: 0,0:52:58.13,0:53:00.13,英文,,0,0,0,,So goodbye, Zoom.
Dialogue: 0,0:52:58.13,0:53:00.13,中文,,0,0,0,,那么 再见 Zoom
