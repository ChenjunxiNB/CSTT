[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 3
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1152
PlayResY: 720

[Aegisub Project Garbage]
Export Encoding: Unicode (UTF-8)
Audio File: D:/python_code/video_tool/video_tool/result/[61B SP24] Lecture 17 - B-Trees (2-3, 2-3-4 Trees).mp4
Video File: D:/python_code/video_tool/video_tool/result/[61B SP24] Lecture 17 - B-Trees (2-3, 2-3-4 Trees).mp4
Video AR Mode: 4
Video AR Value: 1.600000
Video Zoom Percent: 0.750000
Scroll Position: 793
Active Line: 803
Video Position: 11471

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,13,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,90,100,0,0,1,1.33333,1.33333,2,6,6,7,1
Style: 英文,Arial,24,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1.33333,1.33333,2,1,1,5,1
Style: 中文,微软雅黑,38,&H0029EEF1,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1.33333,1.33333,2,2,2,30,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,
Dialogue: 0,0:00:00.33,0:00:04.84,英文,,0,0,0,,I'm going to record this.
Dialogue: 0,0:00:00.33,0:00:04.84,中文,,0,0,0,,我要记录这个
Dialogue: 0,0:00:04.84,0:00:08.92,英文,,0,0,0,,Okay, I hope you're ready for more graphs.
Dialogue: 0,0:00:04.84,0:00:08.92,中文,,0,0,0,,希望你准备好看更多的图表
Dialogue: 0,0:00:08.92,0:00:15.03,英文,,0,0,0,,We have seen two algorithms for finding paths in a graph so far.
Dialogue: 0,0:00:08.92,0:00:15.03,中文,,0,0,0,,到目前为止我们已经看到了两种在图中寻找路径的算法
Dialogue: 0,0:00:15.03,0:00:22.56,英文,,0,0,0,,We saw depth-first paths, which was a way to find a path from a starting vertex at x, sorry, starting vertex s.
Dialogue: 0,0:00:15.03,0:00:22.56,中文,,0,0,0,,我们看到了深度优先路径这是一种从起始顶点 x抱歉起始顶点 s 开始寻找路径的方式
Dialogue: 0,0:00:22.56,0:00:28.96,英文,,0,0,0,,So someone specifies, I want to know how to get from this vertex to every other vertex that's reachable.
Dialogue: 0,0:00:22.56,0:00:28.96,中文,,0,0,0,,有人指定我想知道如何从这个顶点到达每一个可到达的顶点
Dialogue: 0,0:00:28.96,0:00:31.38,英文,,0,0,0,,Depth-first paths gave that to you.
Dialogue: 0,0:00:28.96,0:00:31.38,中文,,0,0,0,,深度优先路径给了你这个
Dialogue: 0,0:00:31.38,0:00:38.22,英文,,0,0,0,,But there was another algorithm called breadth-first paths that used the Q that also gave you a path.
Dialogue: 0,0:00:31.38,0:00:38.22,中文,,0,0,0,,但是还有另一种叫做广度优先路径的算法它使用了队列也给了你一条路径
Dialogue: 0,0:00:38.22,0:00:41.94,英文,,0,0,0,,from starting vertex S to every other reachable vertex.
Dialogue: 0,0:00:38.22,0:00:41.94,中文,,0,0,0,,从起始顶点 S 到每一个其他可到达的顶点
Dialogue: 0,0:00:41.94,0:00:43.97,英文,,0,0,0,,So I showed you two algorithms.
Dialogue: 0,0:00:41.94,0:00:43.97,中文,,0,0,0,,我给你展示了两种算法
Dialogue: 0,0:00:43.97,0:00:48.05,英文,,0,0,0,,So a natural question you might ask is, which do you like better?
Dialogue: 0,0:00:43.97,0:00:48.05,中文,,0,0,0,,那么你可能会问的一个自然问题是你更喜欢哪一个
Dialogue: 0,0:00:48.05,0:00:53.33,英文,,0,0,0,,So we'll do some quick comparisons, and then we'll talk about a third algorithm.
Dialogue: 0,0:00:48.05,0:00:53.33,中文,,0,0,0,,接下来我们将进行一些快速比较然后我们会讨论第三种算法
Dialogue: 0,0:00:53.33,0:00:56.86,英文,,0,0,0,,So one question is, do both of these algorithms work?
Dialogue: 0,0:00:53.33,0:00:56.86,中文,,0,0,0,,一个问题是这两种算法都有效吗
Dialogue: 0,0:00:56.86,0:00:58.80,英文,,0,0,0,,So I will say, yes, they both work.
Dialogue: 0,0:00:56.86,0:00:58.80,中文,,0,0,0,,我要说是的它们都有效
Dialogue: 0,0:00:58.80,0:01:00.18,英文,,0,0,0,,We saw them in action.
Dialogue: 0,0:00:58.80,0:01:00.18,中文,,0,0,0,,我们看到它们的实际效果
Dialogue: 0,0:01:00.18,0:01:05.45,英文,,0,0,0,,They will give you a path to all the vertices if that's what you're concerned about.
Dialogue: 0,0:01:00.18,0:01:05.45,中文,,0,0,0,,如果这是你关心的问题它们将为你提供到所有顶点的路径
Dialogue: 0,0:01:05.45,0:01:11.35,英文,,0,0,0,,So if I'm just looking for a path to every vertex, either algorithm is great.
Dialogue: 0,0:01:05.45,0:01:11.35,中文,,0,0,0,,如果我只是在找每个顶点的路径那么任一算法都很棒
Dialogue: 0,0:01:11.35,0:01:15.71,英文,,0,0,0,,Now, another question you might ask is, does one of them give you a better answer?
Dialogue: 0,0:01:11.35,0:01:15.71,中文,,0,0,0,,现在你可能会问的另一个问题是它们中的一个会给你更好的答案吗
Dialogue: 0,0:01:15.71,0:01:19.03,英文,,0,0,0,,I guess that depends on what you mean by better.
Dialogue: 0,0:01:15.71,0:01:19.03,中文,,0,0,0,,我想这取决于你对更好的定义是什么
Dialogue: 0,0:01:19.03,0:01:31.06,英文,,0,0,0,,So if by better, you mean you want a path that has fewer edges, well, in that case, breadth-first search is going to give you the paths that have fewer edges compared to depth-first search.
Dialogue: 0,0:01:19.03,0:01:31.06,中文,,0,0,0,,如果你说的更好是指你想要边更少的路径那么在这种情况下广度优先搜索会给你比深度优先搜索更少边的路径
Dialogue: 0,0:01:31.06,0:01:34.72,英文,,0,0,0,,So I'll show you an example, maybe in one or two slides.
Dialogue: 0,0:01:31.06,0:01:34.72,中文,,0,0,0,,我会给你展示一个例子可能会用一两张幻灯片
Dialogue: 0,0:01:34.72,0:01:41.47,英文,,0,0,0,,But remember, the character of BFS was that it explored closer things before it explored further things.
Dialogue: 0,0:01:34.72,0:01:41.47,中文,,0,0,0,,但请记住BFS 的特点是在探索更远的事物之前会先探索更接近的事物
Dialogue: 0,0:01:41.47,0:01:42.11,英文,,0,0,0,,That was the idea.
Dialogue: 0,0:01:41.47,0:01:42.11,中文,,0,0,0,,这就是它的理念
Dialogue: 0,0:01:42.11,0:01:48.63,英文,,0,0,0,,We looked at all the things that are one away, and then all the things that are two away, and then all the things that are three away.
Dialogue: 0,0:01:42.11,0:01:48.63,中文,,0,0,0,,我们首先看了所有距离为1的事物然后是所有距离为2的事物然后是所有距离为3的事物
Dialogue: 0,0:01:48.63,0:01:53.15,英文,,0,0,0,,And we use the Q to enforce that we're looking at closer vertices before further ones.
Dialogue: 0,0:01:48.63,0:01:53.15,中文,,0,0,0,,然后我们使用 Q 来强制执行确保我们先看距离较近的顶点再看距离较远的顶点
Dialogue: 0,0:01:53.15,0:02:02.60,英文,,0,0,0,,So because BFS has that rule that you have to explore closer vertices first, you're guaranteed to get paths that use the fewest edges.
Dialogue: 0,0:01:53.15,0:02:02.60,中文,,0,0,0,,因此由于 BFS 有这样的规则你必须首先探索距离较近的顶点你保证获得使用最少边的路径
Dialogue: 0,0:02:02.60,0:02:07.04,英文,,0,0,0,,So if that is something that you care about, then BFS gives you a two-for-one deal.
Dialogue: 0,0:02:02.60,0:02:07.04,中文,,0,0,0,,如果这是你关心的事情那么 BFS 就给了你一个两全其美的选择
Dialogue: 0,0:02:07.04,0:02:10.52,英文,,0,0,0,,You get paths, and you get the shortest paths.
Dialogue: 0,0:02:07.04,0:02:10.52,中文,,0,0,0,,你得到了路径你也得到了最短路径
Dialogue: 0,0:02:10.52,0:02:12.26,英文,,0,0,0,,Okay, more questions.
Dialogue: 0,0:02:10.52,0:02:12.26,中文,,0,0,0,,还有更多问题
Dialogue: 0,0:02:12.26,0:02:14.68,英文,,0,0,0,,Time efficiency is one better than the other.
Dialogue: 0,0:02:12.26,0:02:14.68,中文,,0,0,0,,时间效率哪一个更好一些
Dialogue: 0,0:02:14.68,0:02:19.03,英文,,0,0,0,,It turns out both of them have the same rough asymptotic runtime.
Dialogue: 0,0:02:14.68,0:02:19.03,中文,,0,0,0,,原来他们俩的渐近运行时间差不多
Dialogue: 0,0:02:19.03,0:02:26.21,英文,,0,0,0,,It was this very annoying V plus E that we talked about, C, last lecture, if you don't like it, but...
Dialogue: 0,0:02:19.03,0:02:26.21,中文,,0,0,0,,就是我们上次讲课时提到的那个非常烦人的V+E如果你不喜欢的话
Dialogue: 0,0:02:26.21,0:02:28.65,英文,,0,0,0,,I'd say asymptotically, they're pretty close.
Dialogue: 0,0:02:26.21,0:02:28.65,中文,,0,0,0,,我会说从渐近的角度看它们非常接近
Dialogue: 0,0:02:28.65,0:02:32.37,英文,,0,0,0,,You might have to run some experiments to see which is better.
Dialogue: 0,0:02:28.65,0:02:32.37,中文,,0,0,0,,你可能需要做一些实验来看哪个更好
Dialogue: 0,0:02:32.37,0:02:33.77,英文,,0,0,0,,And then there's space efficiency.
Dialogue: 0,0:02:32.37,0:02:33.77,中文,,0,0,0,,还有空间效率的问题
Dialogue: 0,0:02:33.77,0:02:37.80,英文,,0,0,0,,I won't talk about this in too much detail, but you can read it if you're curious.
Dialogue: 0,0:02:33.77,0:02:37.80,中文,,0,0,0,,我不会详细讲这个但如果你感兴趣的话可以去读读
Dialogue: 0,0:02:37.80,0:02:47.60,英文,,0,0,0,,Basically, I will just quickly mention that DFS is bad if the graph is spindly, because then you have to dive all the way down into a very, very tall,
Dialogue: 0,0:02:37.80,0:02:47.60,中文,,0,0,0,,基本上我只是想快速提一下如果图很细长那么DFS就不好因为这样你必须深入到一个非常非常高的位置
Dialogue: 0,0:02:47.60,0:02:56.67,英文,,0,0,0,,spindly structure, whereas BFS is bad if your graph is bushy because then you have to put tons and tons of stuff on the queue every single time.
Dialogue: 0,0:02:47.60,0:02:56.67,中文,,0,0,0,,如果你的图形是纤细的结构那么 BFS 就不好因为如果你的图形是茂密的那么每次你都必须把大量的东西放在队列上
Dialogue: 0,0:02:56.67,0:03:05.05,英文,,0,0,0,,So roughly speaking, space efficiency depends on what the graph looks like, but I'll leave it to you to read through the words.
Dialogue: 0,0:02:56.67,0:03:05.05,中文,,0,0,0,,大致来说空间效率取决于图的形状但我会让你自己去读一下这些词
Dialogue: 0,0:03:05.05,0:03:08.01,英文,,0,0,0,,Okay, so we did a little bit of comparison between the two.
Dialogue: 0,0:03:05.05,0:03:08.01,中文,,0,0,0,,我们对这两种方法进行了一点比较
Dialogue: 0,0:03:08.01,0:03:15.05,英文,,0,0,0,,Any thoughts on the two of them before I show you a third way to find paths in a graph?
Dialogue: 0,0:03:08.01,0:03:15.05,中文,,0,0,0,,在我向你展示第三种在图中找路径的方法之前你对这两种方法有什么想法吗
Dialogue: 0,0:03:15.05,0:03:16.89,英文,,0,0,0,,OK, we've seen two.
Dialogue: 0,0:03:15.05,0:03:16.89,中文,,0,0,0,,我们已经看过两种了
Dialogue: 0,0:03:16.89,0:03:17.97,英文,,0,0,0,,We compared them.
Dialogue: 0,0:03:16.89,0:03:17.97,中文,,0,0,0,,我们对它们进行了比较
Dialogue: 0,0:03:17.97,0:03:26.72,英文,,0,0,0,,So now a question for you is, would breadth-first search be a good idea for a driving directions app like Google Maps?
Dialogue: 0,0:03:17.97,0:03:26.72,中文,,0,0,0,,现在问你一个问题广度优先搜索是否适合用于像谷歌地图这样的驾驶导航应用程序
Dialogue: 0,0:03:26.72,0:03:31.13,英文,,0,0,0,,I want to find the best way to get from here to somewhere else.
Dialogue: 0,0:03:26.72,0:03:31.13,中文,,0,0,0,,我想找到从这里到别的地方的最佳方式
Dialogue: 0,0:03:31.13,0:03:34.40,英文,,0,0,0,,Would BFS be a good idea for Google Maps?
Dialogue: 0,0:03:31.13,0:03:34.40,中文,,0,0,0,,BFS对谷歌地图来说是个好主意吗
Dialogue: 0,0:03:34.40,0:03:38.26,英文,,0,0,0,,Well, let's see an example to see if BFS would be good.
Dialogue: 0,0:03:34.40,0:03:38.26,中文,,0,0,0,,我们来看一个例子看看BFS是否合适
Dialogue: 0,0:03:38.26,0:03:39.50,英文,,0,0,0,,So here's a place.
Dialogue: 0,0:03:38.26,0:03:39.50,中文,,0,0,0,,这里是一个地方
Dialogue: 0,0:03:39.50,0:03:42.12,英文,,0,0,0,,I guess it's somewhere in, I don't know, on campus.
Dialogue: 0,0:03:39.50,0:03:42.12,中文,,0,0,0,,我想它应该在某个地方我不知道在校园里
Dialogue: 0,0:03:42.12,0:03:46.05,英文,,0,0,0,,It's a little pond outside Hearst Mining Building or whatever.
Dialogue: 0,0:03:42.12,0:03:46.05,中文,,0,0,0,,它是在赫斯特矿业大楼外面的一个小池塘或者别的什么地方
Dialogue: 0,0:03:46.05,0:03:48.05,英文,,0,0,0,,OK, so I'm here at S.
Dialogue: 0,0:03:46.05,0:03:48.05,中文,,0,0,0,,我现在在 s 这里
Dialogue: 0,0:03:48.05,0:03:54.17,英文,,0,0,0,,And I would like to get to T. Maybe I represent the Hearst Mining Building place as a graph.
Dialogue: 0,0:03:48.05,0:03:54.17,中文,,0,0,0,,我想把 t 图拿到手也许我可以把赫斯特矿业大厦的位置表示成一个图
Dialogue: 0,0:03:54.17,0:03:55.07,英文,,0,0,0,,Here are the vertices.
Dialogue: 0,0:03:54.17,0:03:55.07,中文,,0,0,0,,这些是顶点
Dialogue: 0,0:03:55.07,0:03:56.56,英文,,0,0,0,,They're the intersections.
Dialogue: 0,0:03:55.07,0:03:56.56,中文,,0,0,0,,它们就是交叉点
Dialogue: 0,0:03:56.56,0:04:02.68,英文,,0,0,0,,Here are the distances between the vertices, which I think you carefully measured this one day, right?
Dialogue: 0,0:03:56.56,0:04:02.68,中文,,0,0,0,,这些是顶点之间的距离我觉得你有一天很仔细地测量过对吧
Dialogue: 0,0:04:02.68,0:04:06.15,英文,,0,0,0,,You went out with a ruler, and you measured these, so they're very accurate.
Dialogue: 0,0:04:02.68,0:04:06.15,中文,,0,0,0,,你拿着尺子出去测量过所以它们非常准确
Dialogue: 0,0:04:06.15,0:04:07.57,英文,,0,0,0,,OK, you used Google Maps to do it.
Dialogue: 0,0:04:06.15,0:04:07.57,中文,,0,0,0,,你用Google地图做的
Dialogue: 0,0:04:07.57,0:04:08.19,英文,,0,0,0,,It's cheating.
Dialogue: 0,0:04:07.57,0:04:08.19,中文,,0,0,0,,这太作弊了
Dialogue: 0,0:04:08.19,0:04:09.43,英文,,0,0,0,,OK, so.
Dialogue: 0,0:04:09.43,0:04:10.45,英文,,0,0,0,,You're lazy.
Dialogue: 0,0:04:09.43,0:04:10.45,中文,,0,0,0,,你懒惰
Dialogue: 0,0:04:10.45,0:04:11.77,英文,,0,0,0,,So here's the graph.
Dialogue: 0,0:04:10.45,0:04:11.77,中文,,0,0,0,,这就是图表
Dialogue: 0,0:04:11.77,0:04:13.69,英文,,0,0,0,,Here are all the distances.
Dialogue: 0,0:04:11.77,0:04:13.69,中文,,0,0,0,,这些是所有的距离
Dialogue: 0,0:04:13.69,0:04:20.02,英文,,0,0,0,,So for example, this edge right here that walks all the way around has distance 260.
Dialogue: 0,0:04:13.69,0:04:20.02,中文,,0,0,0,,例如这条边绕一圈走了260的距离
Dialogue: 0,0:04:20.02,0:04:22.60,英文,,0,0,0,,So we put an edge weight on the graph of 260.
Dialogue: 0,0:04:20.02,0:04:22.60,中文,,0,0,0,,我们在图上标注了260的边权重
Dialogue: 0,0:04:22.60,0:04:25.06,英文,,0,0,0,,OK, great.
Dialogue: 0,0:04:22.60,0:04:25.06,中文,,0,0,0,,好的太棒了
Dialogue: 0,0:04:25.06,0:04:34.09,英文,,0,0,0,,So let's use BFS to try and find the path from S to T that is the fastest, or that is the shortest, according to BFS.
Dialogue: 0,0:04:25.06,0:04:34.09,中文,,0,0,0,,那么让我们使用BFS尝试找到从 s 到 t 的最快路径或者根据BFS找到的最短路径
Dialogue: 0,0:04:34.09,0:04:36.27,英文,,0,0,0,,So here's what BFS finds.
Dialogue: 0,0:04:34.09,0:04:36.27,中文,,0,0,0,,那么这就是BFS找到的内容
Dialogue: 0,0:04:36.27,0:04:45.57,英文,,0,0,0,,It says, to get from S to T, you should walk all the way around and then go to T. Does this look like the shortest path to you?
Dialogue: 0,0:04:36.27,0:04:45.57,中文,,0,0,0,,它说要从 s 到 t 你应该绕着走然后去 t 这看起来像是你想走的最短路径吗
Dialogue: 0,0:04:45.57,0:04:48.25,英文,,0,0,0,,Is this the path you want to take if you're lazy?
Dialogue: 0,0:04:45.57,0:04:48.25,中文,,0,0,0,,如果你很懒你想选择这条路吗
Dialogue: 0,0:04:48.25,0:04:49.03,英文,,0,0,0,,I don't.
Dialogue: 0,0:04:48.25,0:04:49.03,中文,,0,0,0,,我不想
Dialogue: 0,0:04:49.03,0:04:51.33,英文,,0,0,0,,So why did BFS give such a weird answer?
Dialogue: 0,0:04:49.03,0:04:51.33,中文,,0,0,0,,那么为什么BFS给出了这样奇怪的答案呢
Dialogue: 0,0:04:51.33,0:04:54.86,英文,,0,0,0,,Well, remember, BFS does not consider the edge weights.
Dialogue: 0,0:04:51.33,0:04:54.86,中文,,0,0,0,,记住BFS不考虑边的权重
Dialogue: 0,0:04:54.86,0:04:59.20,英文,,0,0,0,,That is, it totally ignores the numbers associated with every edge.
Dialogue: 0,0:04:54.86,0:04:59.20,中文,,0,0,0,,也就是说它完全忽略了与每条边相关的数字
Dialogue: 0,0:04:59.20,0:05:02.54,英文,,0,0,0,,And it says, let me find the path with the fewest number of edges.
Dialogue: 0,0:04:59.20,0:05:02.54,中文,,0,0,0,,而且它说让我找到边数最少的路径
Dialogue: 0,0:05:02.54,0:05:08.47,英文,,0,0,0,,So BFS likes this path because, look, it has one, two edges to get to t.
Dialogue: 0,0:05:02.54,0:05:08.47,中文,,0,0,0,,所以 BFS 喜欢这条路径因为看它只需要一、两条边就能到达 t
Dialogue: 0,0:05:08.47,0:05:22.24,英文,,0,0,0,,But if we had just been a little bit more patient and we had taken this path with one, two, three, four edges, the total weight along this path, that is the total distance using this path, is actually better.
Dialogue: 0,0:05:08.47,0:05:22.24,中文,,0,0,0,,但如果我们稍微再耐心一点选择这条有一、两、三、四条边的路径沿着这条路径的总权重也就是使用这条路径的总距离实际上更好
Dialogue: 0,0:05:22.24,0:05:28.00,英文,,0,0,0,,So this one is 130, this one is 330, which is worse.
Dialogue: 0,0:05:22.24,0:05:28.00,中文,,0,0,0,,这个是 130这个是 330后者更糟糕
Dialogue: 0,0:05:28.00,0:05:34.85,英文,,0,0,0,,So hopefully we're all convinced that while BFS will give you the path with the fewest number of edges, because it looks at all the nodes that are one edge away,
Dialogue: 0,0:05:28.00,0:05:34.85,中文,,0,0,0,,希望我们都相信虽然 BFS 会给出边数最少的路径因为它查看所有距离1条边远的节点
Dialogue: 0,0:05:34.85,0:05:39.85,英文,,0,0,0,,and then all the nodes that are two edges away, then all the nodes that are three edges away,
Dialogue: 0,0:05:34.85,0:05:39.85,中文,,0,0,0,,然后查看所有距离两条边远的节点再查看所有距离3条边远的节点
Dialogue: 0,0:05:39.85,0:05:45.32,英文,,0,0,0,,it would not be good for something like Google Maps, where not all edges are built the same.
Dialogue: 0,0:05:39.85,0:05:45.32,中文,,0,0,0,,但对于像谷歌地图这样的东西并不适用因为不是所有的边都是相同的
Dialogue: 0,0:05:45.32,0:05:48.92,英文,,0,0,0,,Some edges are very long, some edges are very short.
Dialogue: 0,0:05:45.32,0:05:48.92,中文,,0,0,0,,有些边非常长有些边非常短
Dialogue: 0,0:05:48.92,0:05:55.04,英文,,0,0,0,,So I want an algorithm that gives me this path, not this weird one on the right.
Dialogue: 0,0:05:48.92,0:05:55.04,中文,,0,0,0,,我想要一个算法给我这条路径而不是右边这条奇怪的
Dialogue: 0,0:05:55.04,0:05:55.86,英文,,0,0,0,,So is everyone clear?
Dialogue: 0,0:05:55.04,0:05:55.86,中文,,0,0,0,,那么大家清楚了吗
Dialogue: 0,0:05:55.86,0:06:03.16,英文,,0,0,0,,Are we good on the goal for today, which is build an algorithm that does this, takes me from s to t?
Dialogue: 0,0:05:55.86,0:06:03.16,中文,,0,0,0,,今天的目标是什么是构建一个能做到这一点的算法把我从 s 到 t
Dialogue: 0,0:06:03.16,0:06:04.87,英文,,0,0,0,,OK.
Dialogue: 0,0:06:04.87,0:06:05.83,英文,,0,0,0,,So let's do it.
Dialogue: 0,0:06:04.87,0:06:05.83,中文,,0,0,0,,那么我们开始吧
Dialogue: 0,0:06:05.83,0:06:11.22,英文,,0,0,0,,Let's first think about what the solution looks like, and then we'll think about how you actually build it.
Dialogue: 0,0:06:05.83,0:06:11.22,中文,,0,0,0,,我们先想想解决方案是什么样的然后再考虑如何实际构建它
Dialogue: 0,0:06:11.22,0:06:13.88,英文,,0,0,0,,So here is another graph that I'll show you.
Dialogue: 0,0:06:11.22,0:06:13.88,中文,,0,0,0,,这里是另一个图我会给你看
Dialogue: 0,0:06:13.88,0:06:16.12,英文,,0,0,0,,I guess this one has little cartoon mountains on it.
Dialogue: 0,0:06:13.88,0:06:16.12,中文,,0,0,0,,我猜这个上面有一些小卡通山
Dialogue: 0,0:06:16.12,0:06:17.52,英文,,0,0,0,,I don't really know what these are.
Dialogue: 0,0:06:16.12,0:06:17.52,中文,,0,0,0,,我不太清楚这些是什么
Dialogue: 0,0:06:17.52,0:06:20.04,英文,,0,0,0,,But the important thing is we have a graph.
Dialogue: 0,0:06:17.52,0:06:20.04,中文,,0,0,0,,但重要的是我们有一个图
Dialogue: 0,0:06:20.04,0:06:21.40,英文,,0,0,0,,We have a directed graph.
Dialogue: 0,0:06:20.04,0:06:21.40,中文,,0,0,0,,我们有一个有向图
Dialogue: 0,0:06:21.40,0:06:22.52,英文,,0,0,0,,There are arrows.
Dialogue: 0,0:06:21.40,0:06:22.52,中文,,0,0,0,,有箭头
Dialogue: 0,0:06:22.52,0:06:23.78,英文,,0,0,0,,And we have edge weights.
Dialogue: 0,0:06:22.52,0:06:23.78,中文,,0,0,0,,而且我们有边权重
Dialogue: 0,0:06:23.78,0:06:26.08,英文,,0,0,0,,So not all edges are built the same.
Dialogue: 0,0:06:23.78,0:06:26.08,中文,,0,0,0,,不是所有的边都是一样的
Dialogue: 0,0:06:26.08,0:06:27.44,英文,,0,0,0,,Some edges are longer.
Dialogue: 0,0:06:26.08,0:06:27.44,中文,,0,0,0,,一些边比较长
Dialogue: 0,0:06:27.44,0:06:29.18,英文,,0,0,0,,Some edges are shorter.
Dialogue: 0,0:06:27.44,0:06:29.18,中文,,0,0,0,,一些边比较短
Dialogue: 0,0:06:29.18,0:06:32.02,英文,,0,0,0,,So what I want you to do is tell me,
Dialogue: 0,0:06:29.18,0:06:32.02,中文,,0,0,0,,那么我想让你告诉我
Dialogue: 0,0:06:32.02,0:06:34.61,英文,,0,0,0,,What is the shortest path?
Dialogue: 0,0:06:32.02,0:06:34.61,中文,,0,0,0,,什么是最短路径
Dialogue: 0,0:06:34.61,0:06:48.55,英文,,0,0,0,,And by shortest, I mean lowest weights along all the edges from the source vertex, which I'm telling you is A. So I designate to you, I want to find the shortest path from A to every other vertex in the graph.
Dialogue: 0,0:06:34.61,0:06:48.55,中文,,0,0,0,,而且最短我是指沿着从源顶点开始的所有边的最低权重我告诉你是A所以我指定给你我想找到从A到图中每个其他顶点的最短路径
Dialogue: 0,0:06:48.55,0:06:54.89,英文,,0,0,0,,Well, I guess before you do that, tell me how to get from A to F. Sorry, the numbers are messed up.
Dialogue: 0,0:06:48.55,0:06:54.89,中文,,0,0,0,,在你做之前告诉我如何从A到F抱歉数字弄错了
Dialogue: 0,0:06:54.89,0:06:56.33,英文,,0,0,0,,Here, I'll fix it.
Dialogue: 0,0:06:54.89,0:06:56.33,中文,,0,0,0,,这里我来修复它
Dialogue: 0,0:06:56.33,0:07:00.13,英文,,0,0,0,,OK, so tell me how to get from A to F.
Dialogue: 0,0:06:56.33,0:07:00.13,中文,,0,0,0,,那么告诉我如何从A到F
Dialogue: 0,0:07:00.13,0:07:04.77,英文,,0,0,0,,So maybe eyeball it, think about what algorithm you might use.
Dialogue: 0,0:07:00.13,0:07:04.77,中文,,0,0,0,,或许直观上看看思考你可能用什么算法
Dialogue: 0,0:07:04.77,0:07:10.67,英文,,0,0,0,,So I would say this is the shortest path from A to F. I go A to B to E to F. How did I see that?
Dialogue: 0,0:07:04.77,0:07:10.67,中文,,0,0,0,,我会说这是从A到F的最短路径我走A到B再到E再到F我是怎么看出来的
Dialogue: 0,0:07:10.67,0:07:12.39,英文,,0,0,0,,For now, I just kind of stared at it.
Dialogue: 0,0:07:10.67,0:07:12.39,中文,,0,0,0,,目前我只是盯着它看
Dialogue: 0,0:07:12.39,0:07:18.97,英文,,0,0,0,,But today, we're going to try to find an actual algorithm that gives you this path.
Dialogue: 0,0:07:12.39,0:07:18.97,中文,,0,0,0,,但今天我们要尝试找到一个真正的算法来指出这条路径
Dialogue: 0,0:07:18.97,0:07:25.80,英文,,0,0,0,,Second question, the thing I wanted to ask you all along is, I guess before I do that, sorry, I'm all over the place today.
Dialogue: 0,0:07:18.97,0:07:25.80,中文,,0,0,0,,第二个问题我一直想问你的是在我做那之前抱歉我今天有点乱
Dialogue: 0,0:07:25.80,0:07:27.90,英文,,0,0,0,,So I asked you, how do you get from A to F?
Dialogue: 0,0:07:25.80,0:07:27.90,中文,,0,0,0,,我问你如何从A到F
Dialogue: 0,0:07:27.90,0:07:35.63,英文,,0,0,0,,By visual inspection, this is the best path that uses the fewest edge weight total.
Dialogue: 0,0:07:27.90,0:07:35.63,中文,,0,0,0,,通过目视检查这是使用总边权值最少的最佳路径
Dialogue: 0,0:07:35.63,0:07:37.87,英文,,0,0,0,,Sorry, I'm a total mess.
Dialogue: 0,0:07:35.63,0:07:37.87,中文,,0,0,0,,对不起我一团糟
Dialogue: 0,0:07:37.87,0:07:43.89,英文,,0,0,0,,The total weight along this path, 2 plus 3 plus 4, that's the best possible way to get to F.
Dialogue: 0,0:07:37.87,0:07:43.89,中文,,0,0,0,,沿着这条路径的总权重2加3加4那就是到达F的最佳方式
Dialogue: 0,0:07:43.89,0:07:44.85,英文,,0,0,0,,OK, great.
Dialogue: 0,0:07:43.89,0:07:44.85,中文,,0,0,0,,太好了
Dialogue: 0,0:07:44.85,0:07:49.56,英文,,0,0,0,,One observation I will make, by the way, is that the solution will never have a cycle.
Dialogue: 0,0:07:44.85,0:07:49.56,中文,,0,0,0,,我要提出一个观察顺便说一句解决方案永远不会形成循环
Dialogue: 0,0:07:49.56,0:07:59.14,英文,,0,0,0,,So I will not have a solution that's like A to B to D to E to B and then D to E to F. So I will never travel in a circle.
Dialogue: 0,0:07:49.56,0:07:59.14,中文,,0,0,0,,我的解决方案不会是像A到B到D到E到B然后D到E到F这样的循环所以我永远不会走圈子
Dialogue: 0,0:07:59.14,0:08:05.48,英文,,0,0,0,,So why is it the case that I'll never travel in a circle or I'll never take a cycle in my shortest path?
Dialogue: 0,0:07:59.14,0:08:05.48,中文,,0,0,0,,那么为什么我永远不会走圈子或者永远不会在最短路径上采用循环呢
Dialogue: 0,0:08:05.48,0:08:10.09,英文,,0,0,0,,Because if I'm looking for the shortest path, then the answer is, don't take the cycle.
Dialogue: 0,0:08:05.48,0:08:10.09,中文,,0,0,0,,因为如果我在寻找最短路径那么答案就是不要走圈子
Dialogue: 0,0:08:10.09,0:08:22.41,英文,,0,0,0,,If I'm driving from point A to point B, and my directions say, go to Dallas, and then drive in a circle, and then keep driving, you could just not drive in a circle, and your path would be shorter.
Dialogue: 0,0:08:10.09,0:08:22.41,中文,,0,0,0,,如果我从A点开车到B点我的路线指示是去达拉斯然后绕圈子开车然后继续开车你可以选择不绕圈子你的路径会更短
Dialogue: 0,0:08:22.41,0:08:31.44,英文,,0,0,0,,So our solution should not have cycles, assuming all of our edges have non-negative weight.
Dialogue: 0,0:08:22.41,0:08:31.44,中文,,0,0,0,,我们的解决方案不应该有循环假设我们所有的边都是非负权重
Dialogue: 0,0:08:31.44,0:08:32.88,英文,,0,0,0,,OK, so we found the path.
Dialogue: 0,0:08:31.44,0:08:32.88,中文,,0,0,0,,我们找到了路径
Dialogue: 0,0:08:32.88,0:08:34.59,英文,,0,0,0,,We agree that there are no cycles.
Dialogue: 0,0:08:32.88,0:08:34.59,中文,,0,0,0,,我们同意没有循环
Dialogue: 0,0:08:34.59,0:08:38.71,英文,,0,0,0,,There's no point going in a circle if I'm looking for the shortest path.
Dialogue: 0,0:08:34.59,0:08:38.71,中文,,0,0,0,,如果我要找到从A到其他每个顶点的最短路径绕圈子是毫无意义的
Dialogue: 0,0:08:38.71,0:08:48.56,英文,,0,0,0,,So now the question I really wanted to get to, which is, what would the solution look like if I wanted to find the shortest path from A to every other vertex?
Dialogue: 0,0:08:38.71,0:08:48.56,中文,,0,0,0,,现在我真正想要了解的问题是如果我想找到从A到每个其他顶点的最短路径解决方案会是什么样子
Dialogue: 0,0:08:48.56,0:08:54.14,英文,,0,0,0,,So here I've highlighted the shortest path to F. But what would the shortest path be to B?
Dialogue: 0,0:08:48.56,0:08:54.14,中文,,0,0,0,,这里我标记了到 F 的最短路径但是到 B 的最短路径会是什么呢
Dialogue: 0,0:08:54.14,0:08:55.62,英文,,0,0,0,,And what about D?
Dialogue: 0,0:08:54.14,0:08:55.62,中文,,0,0,0,,那 D 呢
Dialogue: 0,0:08:55.62,0:08:57.24,英文,,0,0,0,,What about G?
Dialogue: 0,0:08:55.62,0:08:57.24,中文,,0,0,0,,G 呢
Dialogue: 0,0:08:57.24,0:08:58.74,英文,,0,0,0,,And what would the answer look like?
Dialogue: 0,0:08:57.24,0:08:58.74,中文,,0,0,0,,那答案会是什么样子的呢
Dialogue: 0,0:08:58.74,0:09:13.21,英文,,0,0,0,,Like if I wanted to present to someone the shortest path to every single vertex, what sort of data structure, like what object would I present to them to give them the answer of the shortest path to every other vertex?
Dialogue: 0,0:08:58.74,0:09:13.21,中文,,0,0,0,,比如说如果我想向某人展示到每个顶点的最短路径我应该用什么数据结构比如什么对象来向他们呈现给他们其他顶点的最短路径答案呢
Dialogue: 0,0:09:13.21,0:09:14.89,英文,,0,0,0,,It's kind of a weird question.
Dialogue: 0,0:09:13.21,0:09:14.89,中文,,0,0,0,,这有点奇怪的问题
Dialogue: 0,0:09:14.89,0:09:17.92,英文,,0,0,0,,And maybe once you see the answer, you'll kind of see what I'm hinting at.
Dialogue: 0,0:09:14.89,0:09:17.92,中文,,0,0,0,,也许一旦你看到答案你会明白我在暗示什么
Dialogue: 0,0:09:17.92,0:09:28.10,英文,,0,0,0,,But try and think about, What data structure or what object do I need to give to the user to answer their question of the shortest path to every vertex?
Dialogue: 0,0:09:17.92,0:09:28.10,中文,,0,0,0,,但是试着想一想我需要给用户什么数据结构或对象来回答他们关于到每个顶点的最短路径的问题呢
Dialogue: 0,0:09:28.10,0:09:29.64,英文,,0,0,0,,Do I give them a list?
Dialogue: 0,0:09:28.10,0:09:29.64,中文,,0,0,0,,我给他们一个列表吗
Dialogue: 0,0:09:29.64,0:09:31.60,英文,,0,0,0,,Do I give them a set?
Dialogue: 0,0:09:29.64,0:09:31.60,中文,,0,0,0,,还是给他们一个集合
Dialogue: 0,0:09:31.60,0:09:38.85,英文,,0,0,0,,What is the thing that I give them that gives them the answer to the shortest paths to every vertex question?
Dialogue: 0,0:09:31.60,0:09:38.85,中文,,0,0,0,,我给他们什么东西可以让他们得到到每个顶点的最短路径的答案呢
Dialogue: 0,0:09:38.85,0:09:47.10,英文,,0,0,0,,So one way you can figure this out is, let's draw and let's use bold to highlight the shortest path to every vertex.
Dialogue: 0,0:09:38.85,0:09:47.10,中文,,0,0,0,,你可以想出一种方法让我们画图用粗体来突出显示到每个顶点的最短路径
Dialogue: 0,0:09:47.10,0:09:50.40,英文,,0,0,0,,See if the answer looks interesting at all.
Dialogue: 0,0:09:47.10,0:09:50.40,中文,,0,0,0,,看看答案是否有趣
Dialogue: 0,0:09:50.40,0:09:53.02,英文,,0,0,0,,So here is the shortest path to every vertex.
Dialogue: 0,0:09:50.40,0:09:53.02,中文,,0,0,0,,这是到每个顶点的最短路径
Dialogue: 0,0:09:53.02,0:09:55.60,英文,,0,0,0,,So the shortest path to B, I use this edge.
Dialogue: 0,0:09:53.02,0:09:55.60,中文,,0,0,0,,到B的最短路径我使用这条边
Dialogue: 0,0:09:55.60,0:09:58.34,英文,,0,0,0,,The shortest path to C, I use this edge.
Dialogue: 0,0:09:55.60,0:09:58.34,中文,,0,0,0,,到C的最短路径我使用这条边
Dialogue: 0,0:09:58.34,0:10:01.48,英文,,0,0,0,,Here's the shortest path to E, I use these two edges.
Dialogue: 0,0:09:58.34,0:10:01.48,中文,,0,0,0,,这是到E的最短路径我使用这两条边
Dialogue: 0,0:10:01.48,0:10:03.92,英文,,0,0,0,,So I'm highlighting every edge.
Dialogue: 0,0:10:01.48,0:10:03.92,中文,,0,0,0,,我突出显示了每条边
Dialogue: 0,0:10:03.92,0:10:08.11,英文,,0,0,0,,That gets used in the shortest path to any of these vertices.
Dialogue: 0,0:10:03.92,0:10:08.11,中文,,0,0,0,,用于到达任何这些顶点的最短路径的所有这些边你会注意到一件事
Dialogue: 0,0:10:08.11,0:10:19.04,英文,,0,0,0,,And one thing you'll notice, when I highlight all these edges, the solution, the object that I return, it's a tree.
Dialogue: 0,0:10:08.11,0:10:19.04,中文,,0,0,0,,还有一件事你会注意到当我突出显示所有这些边时解决方案我返回的对象它是一棵树
Dialogue: 0,0:10:19.04,0:10:20.86,英文,,0,0,0,,Mind blown.
Dialogue: 0,0:10:19.04,0:10:20.86,中文,,0,0,0,,大开眼界
Dialogue: 0,0:10:20.86,0:10:22.02,英文,,0,0,0,,Notice that it is a tree.
Dialogue: 0,0:10:20.86,0:10:22.02,中文,,0,0,0,,注意它是一棵树
Dialogue: 0,0:10:22.02,0:10:23.86,英文,,0,0,0,,There's a couple ways to think about this.
Dialogue: 0,0:10:22.02,0:10:23.86,中文,,0,0,0,,有几种方式可以思考这个问题
Dialogue: 0,0:10:23.86,0:10:30.42,英文,,0,0,0,,So one way to think about this is, this is the union, so it's like the combination of the shortest path to every vertex.
Dialogue: 0,0:10:23.86,0:10:30.42,中文,,0,0,0,,一种思考这个问题的方式是这是一个联合就像每个顶点的最短路径的组合
Dialogue: 0,0:10:30.42,0:10:38.43,英文,,0,0,0,,So if this edge is ever used in the shortest path to any of the vertices, I will include it in the shortest paths tree.
Dialogue: 0,0:10:30.42,0:10:38.43,中文,,0,0,0,,如果这条边被用于任何顶点的最短路径我将把它包括在最短路径树中
Dialogue: 0,0:10:38.43,0:10:41.09,英文,,0,0,0,,And if I take all these vertices, I'll get a tree.
Dialogue: 0,0:10:38.43,0:10:41.09,中文,,0,0,0,,如果我取所有这些顶点我会得到一棵树
Dialogue: 0,0:10:41.09,0:10:43.83,英文,,0,0,0,,So a couple ways to maybe convince yourself that it's a tree.
Dialogue: 0,0:10:41.09,0:10:43.83,中文,,0,0,0,,有几种方式可能会让你相信它是一棵树
Dialogue: 0,0:10:43.83,0:10:46.79,英文,,0,0,0,,One way to convince yourself is to say, there are no cycles.
Dialogue: 0,0:10:43.83,0:10:46.79,中文,,0,0,0,,说服自己的一种方法是说没有循环
Dialogue: 0,0:10:46.79,0:10:48.64,英文,,0,0,0,,We convinced ourselves of that earlier.
Dialogue: 0,0:10:46.79,0:10:48.64,中文,,0,0,0,,我们之前已经说服了自己
Dialogue: 0,0:10:48.64,0:10:50.46,英文,,0,0,0,,There's no point going in circles.
Dialogue: 0,0:10:48.64,0:10:50.46,中文,,0,0,0,,绕圈子没意义
Dialogue: 0,0:10:50.46,0:10:54.70,英文,,0,0,0,,So because none of these edges will form a cycle, we have a tree.
Dialogue: 0,0:10:50.46,0:10:54.70,中文,,0,0,0,,因此因为这些边都不会形成循环我们就有了一棵树
Dialogue: 0,0:10:54.70,0:10:57.58,英文,,0,0,0,,Another way to think about it is, it's something you've kind of already seen before.
Dialogue: 0,0:10:54.70,0:10:57.58,中文,,0,0,0,,另一种思考方式是这是你已经在某种程度上见过的东西
Dialogue: 0,0:10:57.58,0:11:04.41,英文,,0,0,0,,So remember that edge2 array that we used in depth-first search and breadth-first search, where we said, how do you get to 1?
Dialogue: 0,0:10:57.58,0:11:04.41,中文,,0,0,0,,记得我们在深度优先搜索和广度优先搜索中使用的边缘数组吗我们说你怎么到达 1
Dialogue: 0,0:11:04.41,0:11:05.53,英文,,0,0,0,,You get there from 0.
Dialogue: 0,0:11:04.41,0:11:05.53,中文,,0,0,0,,你是从 0 到达的
Dialogue: 0,0:11:05.53,0:11:06.67,英文,,0,0,0,,And how do you get to 2?
Dialogue: 0,0:11:05.53,0:11:06.67,中文,,0,0,0,,你怎么到达2呢
Dialogue: 0,0:11:06.67,0:11:07.79,英文,,0,0,0,,You get there from 0.
Dialogue: 0,0:11:06.67,0:11:07.79,中文,,0,0,0,,你从0那里到达那里
Dialogue: 0,0:11:07.79,0:11:11.93,英文,,0,0,0,,Or sorry, I guess these are a little bit outdated.
Dialogue: 0,0:11:07.79,0:11:11.93,中文,,0,0,0,,或者抱歉我猜这些有点过时了
Dialogue: 0,0:11:11.93,0:11:13.67,英文,,0,0,0,,But how do you get to G?
Dialogue: 0,0:11:11.93,0:11:13.67,中文,,0,0,0,,但是你怎么到达G呢
Dialogue: 0,0:11:13.67,0:11:16.20,英文,,0,0,0,,You get there from E. And how do you get to E?
Dialogue: 0,0:11:13.67,0:11:16.20,中文,,0,0,0,,你从E那里到达那里你怎么到达E呢
Dialogue: 0,0:11:16.20,0:11:18.52,英文,,0,0,0,,You get there from B. And how do you get to B?
Dialogue: 0,0:11:16.20,0:11:18.52,中文,,0,0,0,,你从B那里到达那里你怎么到达B呢
Dialogue: 0,0:11:18.52,0:11:19.64,英文,,0,0,0,,You get there from A.
Dialogue: 0,0:11:18.52,0:11:19.64,中文,,0,0,0,,你从A那里到达那里
Dialogue: 0,0:11:19.64,0:11:25.56,英文,,0,0,0,,So every vertex has exactly one parent, that is, the way to get to that vertex.
Dialogue: 0,0:11:19.64,0:11:25.56,中文,,0,0,0,,每个顶点都恰好有一个父节点也就是说到达该顶点的方式
Dialogue: 0,0:11:25.56,0:11:29.14,英文,,0,0,0,,So that might be another way to see why this thing forms a tree.
Dialogue: 0,0:11:25.56,0:11:29.14,中文,,0,0,0,,这可能是另一种看待这个事物形成树的方式
Dialogue: 0,0:11:29.14,0:11:36.75,英文,,0,0,0,,So the shortest paths to every vertex is a tree, because every vertex has exactly one shortest way to get to it.
Dialogue: 0,0:11:29.14,0:11:36.75,中文,,0,0,0,,到每个顶点的最短路径都是一棵树因为每个顶点到达它的最短路径恰好只有一条
Dialogue: 0,0:11:36.75,0:11:45.85,英文,,0,0,0,,There's not going to be two shortest ways to get to f. f has exactly one parent, and that parent is the way to get to f. This holds for every vertex.
Dialogue: 0,0:11:36.75,0:11:45.85,中文,,0,0,0,,不会有两种到达 f 的最短路径f 恰好有一个父节点而那个父节点就是到达 f 的方式这对每个顶点都成立
Dialogue: 0,0:11:45.85,0:11:59.57,英文,,0,0,0,,So this is one of those observations that, like, it takes a little bit of staring to fully wrap your head around, but it's something that is useful to know, which is that if I want the shortest path to everywhere, the result is a tree.
Dialogue: 0,0:11:45.85,0:11:59.57,中文,,0,0,0,,这是其中一条观察结果需要花一点时间盯着看才能完全理解但这是值得知道的即如果我想要到达每个地方的最短路径结果就是一棵树
Dialogue: 0,0:11:59.57,0:12:01.25,英文,,0,0,0,,Thoughts, questions?
Dialogue: 0,0:11:59.57,0:12:01.25,中文,,0,0,0,,有什么想法、问题吗
Dialogue: 0,0:12:01.25,0:12:02.27,英文,,0,0,0,,OK.
Dialogue: 0,0:12:02.27,0:12:03.41,英文,,0,0,0,,Sorry for blowing your mind.
Dialogue: 0,0:12:02.27,0:12:03.41,中文,,0,0,0,,抱歉让你感到震惊
Dialogue: 0,0:12:03.41,0:12:04.19,英文,,0,0,0,,OK.
Dialogue: 0,0:12:04.19,0:12:07.71,英文,,0,0,0,,So one more question for you, and then we'll start designing some algorithms.
Dialogue: 0,0:12:04.19,0:12:07.71,中文,,0,0,0,,还有一个问题要问你然后我们就开始设计一些算法
Dialogue: 0,0:12:07.71,0:12:16.52,英文,,0,0,0,,So if I give you a shortest paths tree, how many vertices are going to be in the shortest paths tree?
Dialogue: 0,0:12:07.71,0:12:16.52,中文,,0,0,0,,如果我给你一个最短路径树最短路径树里会有多少个顶点
Dialogue: 0,0:12:16.52,0:12:17.88,英文,,0,0,0,,So here's an example.
Dialogue: 0,0:12:16.52,0:12:17.88,中文,,0,0,0,,这里有个例子
Dialogue: 0,0:12:17.88,0:12:20.98,英文,,0,0,0,,Sorry, how many edges are going to be in the shortest path tree?
Dialogue: 0,0:12:17.88,0:12:20.98,中文,,0,0,0,,抱歉最短路径树里会有多少条边
Dialogue: 0,0:12:20.98,0:12:21.96,英文,,0,0,0,,So here's an example.
Dialogue: 0,0:12:20.98,0:12:21.96,中文,,0,0,0,,这里有个例子
Dialogue: 0,0:12:21.96,0:12:23.16,英文,,0,0,0,,I have a graph.
Dialogue: 0,0:12:21.96,0:12:23.16,中文,,0,0,0,,我有一个图
Dialogue: 0,0:12:23.16,0:12:27.39,英文,,0,0,0,,This graph has 1, 2, 3, 4, 5, 6, 7 vertices.
Dialogue: 0,0:12:23.16,0:12:27.39,中文,,0,0,0,,这个图有1、2、3、4、5、6、7个顶点
Dialogue: 0,0:12:27.39,0:12:34.25,英文,,0,0,0,,And this graph has 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 edges.
Dialogue: 0,0:12:27.39,0:12:34.25,中文,,0,0,0,,而且这个图有1、2、3、4、5、6、7、8、9、10、11、12条边
Dialogue: 0,0:12:34.25,0:12:40.89,英文,,0,0,0,,So if I have 7 vertices, 12 edges, how many edges are in the shortest path tree?
Dialogue: 0,0:12:34.25,0:12:40.89,中文,,0,0,0,,如果我有7个顶点12条边最短路径树有多少条边
Dialogue: 0,0:12:40.89,0:12:47.00,英文,,0,0,0,,So for every edge, I either include it, it's part of the family, or I don't include it, it's not part of the family.
Dialogue: 0,0:12:40.89,0:12:47.00,中文,,0,0,0,,对于每一条边我要么包括它它是家庭的一部分要么不包括它它不是家庭的一部分
Dialogue: 0,0:12:47.00,0:12:53.62,英文,,0,0,0,,So how many edges do I bold to indicate that they are part of the shortest path tree?
Dialogue: 0,0:12:47.00,0:12:53.62,中文,,0,0,0,,那么我要加粗多少条边以表示它们是最短路径树的一部分
Dialogue: 0,0:12:53.62,0:12:55.12,英文,,0,0,0,,So for this one, I can just count.
Dialogue: 0,0:12:53.62,0:12:55.12,中文,,0,0,0,,对于这个我可以直接数
Dialogue: 0,0:12:55.12,0:12:57.79,英文,,0,0,0,,1, 2, 3, 4, 5, 6.
Dialogue: 0,0:12:55.12,0:12:57.79,中文,,0,0,0,,1, 2, 3, 4, 5, 6.
Dialogue: 0,0:12:57.79,0:13:02.81,英文,,0,0,0,,So if I have seven vertices, there are six edges in the shortest paths tree.
Dialogue: 0,0:12:57.79,0:13:02.81,中文,,0,0,0,,如果我有7个顶点最短路径树中有6条边
Dialogue: 0,0:13:02.81,0:13:14.34,英文,,0,0,0,,So question for you then is, if I generalize this to say, I give you any graph, it's got V vertices and E edges, how many edges do you include in the shortest paths tree?
Dialogue: 0,0:13:02.81,0:13:14.34,中文,,0,0,0,,那么问题就是如果我把这个泛化给你任意一个图它有V个顶点和E条边你会在最短路径树中包括多少条边
Dialogue: 0,0:13:14.34,0:13:24.17,英文,,0,0,0,,How many edges do you have to bold and include in the family of all the edges that you use to get to all of these vertices in the shortest way possible?
Dialogue: 0,0:13:14.34,0:13:24.17,中文,,0,0,0,,你需要加粗并包含到所有用于以最短方式到达所有这些顶点的边中的边的数量是多少
Dialogue: 0,0:13:24.17,0:13:27.87,英文,,0,0,0,,So if I had seven vertices, I needed six edges.
Dialogue: 0,0:13:24.17,0:13:27.87,中文,,0,0,0,,如果我有7个顶点我需要6条边
Dialogue: 0,0:13:27.87,0:13:32.22,英文,,0,0,0,,So if I have v vertices, how many edges do I need?
Dialogue: 0,0:13:27.87,0:13:32.22,中文,,0,0,0,,如果我有 V 个顶点我需要多少条边
Dialogue: 0,0:13:32.22,0:13:33.95,英文,,0,0,0,,v minus 1.
Dialogue: 0,0:13:32.22,0:13:33.95,中文,,0,0,0,,V - 1.
Dialogue: 0,0:13:33.95,0:13:36.12,英文,,0,0,0,,And so there's a couple ways to see this one.
Dialogue: 0,0:13:33.95,0:13:36.12,中文,,0,0,0,,有几种方式来看待这个
Dialogue: 0,0:13:36.12,0:13:37.26,英文,,0,0,0,,It's kind of cute.
Dialogue: 0,0:13:36.12,0:13:37.26,中文,,0,0,0,,挺可爱的
Dialogue: 0,0:13:37.26,0:13:43.52,英文,,0,0,0,,One way to see it is remember how we said every edge has exactly one parent, which is the way to get there.
Dialogue: 0,0:13:37.26,0:13:43.52,中文,,0,0,0,,其中一种看法是记住我们说的每条边都有且只有一个父节点这是到达那里的方式
Dialogue: 0,0:13:43.52,0:13:50.05,英文,,0,0,0,,So D only has one way to get there, which is G. And G has one way to get there, which is through E.
Dialogue: 0,0:13:43.52,0:13:50.77,中文,,0,0,0,,所以D只有一种到达那里的方式那就是G而G只有一种到达那里的方式那就是通过E
Dialogue: 0,0:13:50.05,0:13:57.05,英文,,0,0,0,,So every vertex has exactly one edge associated with it, which is the way to get there, except for the source.
Dialogue: 0,0:13:50.77,0:13:57.05,中文,,0,0,0,,每个顶点都有且只有一条与之关联的边那就是到达那里的方式除了源节点
Dialogue: 0,0:13:57.05,0:13:59.13,英文,,0,0,0,,You don't need to figure out how to get to the source.
Dialogue: 0,0:13:57.05,0:13:59.13,中文,,0,0,0,,你不需要想办法到达源节点
Dialogue: 0,0:13:59.13,0:13:59.69,英文,,0,0,0,,It's the source.
Dialogue: 0,0:13:59.13,0:13:59.69,中文,,0,0,0,,源节点就是它
Dialogue: 0,0:13:59.69,0:14:00.71,英文,,0,0,0,,You're already there.
Dialogue: 0,0:13:59.69,0:14:00.71,中文,,0,0,0,,你已经在那里了
Dialogue: 0,0:14:00.71,0:14:04.43,英文,,0,0,0,,So that's one way to see that it's v minus one vertices.
Dialogue: 0,0:14:00.71,0:14:04.43,中文,,0,0,0,,这就是看待它为 v 减一个顶点的一种方式
Dialogue: 0,0:14:04.43,0:14:12.44,英文,,0,0,0,,Another way to see it is that if this is a tree, every vertex has exactly one parent, and so there are v minus one edges in total.
Dialogue: 0,0:14:04.43,0:14:12.44,中文,,0,0,0,,另一种看法是如果这是一棵树每个顶点都恰好有一个父节点因此总共有 V 减一条边
Dialogue: 0,0:14:12.44,0:14:20.12,英文,,0,0,0,,Because everybody but the root has one parent, and that means that it has one edge coming out of it, or pointing at it.
Dialogue: 0,0:14:12.44,0:14:20.12,中文,,0,0,0,,因为除了根节点外每个人都有一个父节点这意味着它有一条边指向它
Dialogue: 0,0:14:20.12,0:14:21.58,英文,,0,0,0,,Okay.
Dialogue: 0,0:14:21.58,0:14:24.18,英文,,0,0,0,,So that was the shortest path tree.
Dialogue: 0,0:14:21.58,0:14:24.18,中文,,0,0,0,,这就是最短路径树
Dialogue: 0,0:14:24.18,0:14:26.36,英文,,0,0,0,,Now we understand what we are aiming for.
Dialogue: 0,0:14:24.18,0:14:26.36,中文,,0,0,0,,现在我们明白我们的目标是什么
Dialogue: 0,0:14:26.36,0:14:28.84,英文,,0,0,0,,We're looking for the shortest path to every vertex.
Dialogue: 0,0:14:26.36,0:14:28.84,中文,,0,0,0,,我们正在寻找到每个顶点的最短路径
Dialogue: 0,0:14:28.84,0:14:31.52,英文,,0,0,0,,We know the answer is going to be a set of edges.
Dialogue: 0,0:14:28.84,0:14:31.52,中文,,0,0,0,,我们知道答案将会是一组边
Dialogue: 0,0:14:31.52,0:14:34.07,英文,,0,0,0,,So tell me, which edges do you include?
Dialogue: 0,0:14:31.52,0:14:34.07,中文,,0,0,0,,那告诉我你包括哪些边
Dialogue: 0,0:14:34.07,0:14:36.01,英文,,0,0,0,,Which edges do you not include?
Dialogue: 0,0:14:34.07,0:14:36.01,中文,,0,0,0,,你不包括哪些边
Dialogue: 0,0:14:36.01,0:14:42.35,英文,,0,0,0,,And we also know that the answer, when you tell me which edges to include, you're going to end up building a tree
Dialogue: 0,0:14:36.01,0:14:42.35,中文,,0,0,0,,而且我们也知道当你告诉我要包括哪些边时你最终会构建一棵树
Dialogue: 0,0:14:42.35,0:14:45.15,英文,,0,0,0,,because every edge has exactly one way to get there.
Dialogue: 0,0:14:42.35,0:14:45.15,中文,,0,0,0,,因为每条边都有且仅有一条到达那里的方式
Dialogue: 0,0:14:45.15,0:14:49.33,英文,,0,0,0,,Sorry, every vertex has exactly one edge telling you how to get there.
Dialogue: 0,0:14:45.15,0:14:49.33,中文,,0,0,0,,抱歉每个顶点都有且仅有一条边告诉你如何到达那里
Dialogue: 0,0:14:49.33,0:14:55.93,英文,,0,0,0,,And we also saw that because this is a tree, you should have v minus 1 vertices in your shortest paths tree.
Dialogue: 0,0:14:49.33,0:14:55.93,中文,,0,0,0,,而且我们也看到因为这是一棵树你的最短路径树中应该有V - 1个顶点
Dialogue: 0,0:14:55.93,0:15:01.29,英文,,0,0,0,,So it will be all in agreement on what we have to build before we build it.
Dialogue: 0,0:14:55.93,0:15:01.29,中文,,0,0,0,,在我们开始之前我们要先就要建造什么达成一致
Dialogue: 0,0:15:01.29,0:15:02.43,英文,,0,0,0,,OK.
Dialogue: 0,0:15:02.43,0:15:03.63,英文,,0,0,0,,We all know what to build.
Dialogue: 0,0:15:02.43,0:15:03.63,中文,,0,0,0,,我们都知道要建造什么
Dialogue: 0,0:15:03.63,0:15:04.52,英文,,0,0,0,,Let's build it.
Dialogue: 0,0:15:03.63,0:15:04.52,中文,,0,0,0,,让我们开始建造吧
Dialogue: 0,0:15:04.52,0:15:10.94,英文,,0,0,0,,So last semester, I ran way over time when I showed you all of the bad algorithms on the way to get to the good one.
Dialogue: 0,0:15:04.52,0:15:10.94,中文,,0,0,0,,上个学期当我向你们展示了通往好算法的途中的所有糟糕算法时我超时了
Dialogue: 0,0:15:10.94,0:15:12.62,英文,,0,0,0,,So I will kind of speed run them.
Dialogue: 0,0:15:10.94,0:15:12.62,中文,,0,0,0,,我会快速地浏览它们
Dialogue: 0,0:15:12.62,0:15:16.83,英文,,0,0,0,,If you want to see this in gory detail, check out last semester's webcast.
Dialogue: 0,0:15:12.62,0:15:16.83,中文,,0,0,0,,如果你想看到更详细的内容请查看上学期的网络直播
Dialogue: 0,0:15:16.83,0:15:20.87,英文,,0,0,0,,But I will kind of speed through and show you some bad algorithms.
Dialogue: 0,0:15:16.83,0:15:20.87,中文,,0,0,0,,但我会快速展示一些糟糕的算法
Dialogue: 0,0:15:20.87,0:15:24.84,英文,,0,0,0,,So here is the toy tree that we will be doing.
Dialogue: 0,0:15:20.87,0:15:24.84,中文,,0,0,0,,这是我们要做的玩具树
Dialogue: 0,0:15:24.84,0:15:27.62,英文,,0,0,0,,are running the shortest path algorithms on.
Dialogue: 0,0:15:24.84,0:15:27.62,中文,,0,0,0,,正在运行最短路径算法
Dialogue: 0,0:15:27.62,0:15:30.14,英文,,0,0,0,,So here's the graph.
Dialogue: 0,0:15:27.62,0:15:30.14,中文,,0,0,0,,这是图
Dialogue: 0,0:15:30.14,0:15:31.18,英文,,0,0,0,,Here's the answer.
Dialogue: 0,0:15:30.14,0:15:31.18,中文,,0,0,0,,这就是答案
Dialogue: 0,0:15:31.18,0:15:34.62,英文,,0,0,0,,So these three edges should be part of the family.
Dialogue: 0,0:15:31.18,0:15:34.62,中文,,0,0,0,,这三条边应该是家庭的一部分
Dialogue: 0,0:15:34.62,0:15:36.90,英文,,0,0,0,,They are the shortest path tree.
Dialogue: 0,0:15:34.62,0:15:36.90,中文,,0,0,0,,它们是最短路径树
Dialogue: 0,0:15:36.90,0:15:38.86,英文,,0,0,0,,So to get to C, that's the way.
Dialogue: 0,0:15:36.90,0:15:38.86,中文,,0,0,0,,要到C走这条路
Dialogue: 0,0:15:38.86,0:15:40.40,英文,,0,0,0,,To get to B, that's the way.
Dialogue: 0,0:15:38.86,0:15:40.40,中文,,0,0,0,,要到B走这条路
Dialogue: 0,0:15:40.40,0:15:44.37,英文,,0,0,0,,To get to D, that is the way, the shortest way.
Dialogue: 0,0:15:40.40,0:15:44.37,中文,,0,0,0,,要到D这是路最短的路
Dialogue: 0,0:15:44.37,0:15:45.76,英文,,0,0,0,,OK.
Dialogue: 0,0:15:45.76,0:15:50.73,英文,,0,0,0,,So I will show you a very bad algorithm, and then I'll slowly make it better.
Dialogue: 0,0:15:45.76,0:15:50.73,中文,,0,0,0,,我会先展示一个很糟糕的算法然后我会慢慢改进它
Dialogue: 0,0:15:50.73,0:16:06.54,英文,,0,0,0,,So I'll say BFS was pretty good, so let's try to use something like BFS, which is I will start at A, and then every time I look at an edge, if that edge points to a node that's not part of the family yet, I'll add it.
Dialogue: 0,0:15:50.73,0:16:06.54,中文,,0,0,0,,我会说BFS挺好的所以我们尝试使用类似BFS的方法我会从A开始然后每次我看到一条边如果这条边指向的节点还不是家族的一部分我就会添加它
Dialogue: 0,0:16:06.54,0:16:09.70,英文,,0,0,0,,So for example, A to B.
Dialogue: 0,0:16:06.54,0:16:09.70,中文,,0,0,0,,比如从A到B
Dialogue: 0,0:16:09.70,0:16:20.71,英文,,0,0,0,,And again, I'm not going to walk through this in too much detail, but I'll add these edges because I haven't seen B before, I haven't seen C before, and I'll add this edge because I haven't seen D before.
Dialogue: 0,0:16:09.70,0:16:20.71,中文,,0,0,0,,再说一遍我不会详细解释这个但是我会添加这些边因为我之前没见过B我之前没见过C我会添加这个边因为我之前没见过D
Dialogue: 0,0:16:20.71,0:16:22.97,英文,,0,0,0,,You'll notice this is not the right answer.
Dialogue: 0,0:16:20.71,0:16:22.97,中文,,0,0,0,,你会注意到这不是正确的答案
Dialogue: 0,0:16:22.97,0:16:29.09,英文,,0,0,0,,So the reason why this is the wrong answer is because we kept throwing edges into the tree anytime we saw one.
Dialogue: 0,0:16:22.97,0:16:29.09,中文,,0,0,0,,这个答案错了的原因是因为我们每次看到一条边就往树里面扔
Dialogue: 0,0:16:29.09,0:16:36.02,英文,,0,0,0,,So for example, here we were like, well, I've never been to B, and this is an edge to B, so let's throw it into the tree.
Dialogue: 0,0:16:29.09,0:16:36.02,中文,,0,0,0,,比如这里我们想哎呀我从来没去过B这是一条通向B的边所以就扔到树里面去吧
Dialogue: 0,0:16:36.02,0:16:40.08,英文,,0,0,0,,And I've never been to C, and here's an edge to C, so let's throw that into the tree.
Dialogue: 0,0:16:36.02,0:16:40.08,中文,,0,0,0,,而且我从来没去过C在这里有一条通向C的边所以就把它扔到树里面去
Dialogue: 0,0:16:40.08,0:16:50.15,英文,,0,0,0,,So if you do that, you get an answer, but it's not a very good one, because you're throwing edges into the tree anytime an edge points at a node you've never seen before.
Dialogue: 0,0:16:40.08,0:16:50.15,中文,,0,0,0,,如果你这样做你会得到一个答案但不是一个很好的答案因为你每次看到一条边指向一个你从没见过的节点时就往树里扔
Dialogue: 0,0:16:50.15,0:16:54.49,英文,,0,0,0,,So I don't really like this algorithm, but it's a good start.
Dialogue: 0,0:16:50.15,0:16:54.49,中文,,0,0,0,,我不是很喜欢这个算法但这是一个很好的开始
Dialogue: 0,0:16:54.49,0:16:57.39,英文,,0,0,0,,And again, the slides are all there if you're interested.
Dialogue: 0,0:16:54.49,0:16:57.39,中文,,0,0,0,,而且如果你感兴趣的话幻灯片都在那里
Dialogue: 0,0:16:57.39,0:16:58.23,英文,,0,0,0,,Okay.
Dialogue: 0,0:16:58.23,0:17:00.27,英文,,0,0,0,,So why was this so bad?
Dialogue: 0,0:16:58.23,0:17:00.27,中文,,0,0,0,,那么这到底有什么问题
Dialogue: 0,0:17:00.27,0:17:04.74,英文,,0,0,0,,Well, it was kind of good because it was inspired by breadth-first search.
Dialogue: 0,0:17:00.27,0:17:04.74,中文,,0,0,0,,这有点好因为它受到了广度优先搜索的启发
Dialogue: 0,0:17:04.74,0:17:14.79,英文,,0,0,0,,In particular, it will do the breadth-first search character of visiting all the nodes that are one edge away, and then two edges away, and then three edges away, and so forth.
Dialogue: 0,0:17:04.74,0:17:14.79,中文,,0,0,0,,具体来说它将执行广度优先搜索的特性访问所有距离1个边的节点然后是2个边然后是3个边依此类推
Dialogue: 0,0:17:14.79,0:17:19.78,英文,,0,0,0,,So that's great, but we just said not all edges are built equal.
Dialogue: 0,0:17:14.79,0:17:19.78,中文,,0,0,0,,这很棒但我们刚才说过并非所有边都一样重要
Dialogue: 0,0:17:19.78,0:17:22.50,英文,,0,0,0,,So I will show you algorithm number two.
Dialogue: 0,0:17:19.78,0:17:22.50,中文,,0,0,0,,我会给你展示算法二
Dialogue: 0,0:17:22.50,0:17:27.50,英文,,0,0,0,,And this one was built by Justin, and he calls it the dummy nodes algorithm.
Dialogue: 0,0:17:22.50,0:17:27.50,中文,,0,0,0,,这个是由Justin构建的他称之为虚拟节点算法
Dialogue: 0,0:17:27.50,0:17:29.53,英文,,0,0,0,,So this one, I find it kind of cute.
Dialogue: 0,0:17:27.50,0:17:29.53,中文,,0,0,0,,这个我觉得挺可爱的
Dialogue: 0,0:17:29.53,0:17:35.85,英文,,0,0,0,,If this edge is length 5, then stick a bunch of nodes here so that it's actually five edges from A to B.
Dialogue: 0,0:17:29.53,0:17:35.85,中文,,0,0,0,,如果这条边长5那么在这里添加一堆节点这样从A到B实际上就有5条边了
Dialogue: 0,0:17:35.85,0:17:39.48,英文,,0,0,0,,And for example, this from B to D has weight 2.
Dialogue: 0,0:17:35.85,0:17:39.48,中文,,0,0,0,,例如从B到D的距离为2
Dialogue: 0,0:17:39.48,0:17:46.26,英文,,0,0,0,,So stick an extra node in there so that the distance or the number of edges from B to D is 2.
Dialogue: 0,0:17:39.48,0:17:46.26,中文,,0,0,0,,在那里添加一个额外的节点使得从B到D的距离或边的数量为2
Dialogue: 0,0:17:46.26,0:17:57.26,英文,,0,0,0,,And so now, we can use the algorithm from before, inspired by breadth-first search, where we look at all the nodes 1 away, then all the nodes 2 away, then all the nodes 3 away, and so forth.
Dialogue: 0,0:17:46.26,0:17:57.26,中文,,0,0,0,,现在我们可以使用之前的算法受到广度优先搜索的启发我们查看所有1个单位的节点然后是所有2个单位的节点然后是所有3个单位的节点依此类推
Dialogue: 0,0:17:57.26,0:18:00.48,英文,,0,0,0,,So to see this in action, here we go.
Dialogue: 0,0:17:57.26,0:18:00.48,中文,,0,0,0,,要看到这个算法的实际效果我们开始吧
Dialogue: 0,0:18:00.48,0:18:01.42,英文,,0,0,0,,So I'm here.
Dialogue: 0,0:18:00.48,0:18:01.42,中文,,0,0,0,,我在这里
Dialogue: 0,0:18:01.42,0:18:02.94,英文,,0,0,0,,I look at all the nodes 1 away.
Dialogue: 0,0:18:01.42,0:18:02.94,中文,,0,0,0,,我看着所有距离1的节点
Dialogue: 0,0:18:02.94,0:18:03.78,英文,,0,0,0,,There they are.
Dialogue: 0,0:18:02.94,0:18:03.78,中文,,0,0,0,,它们就在那里
Dialogue: 0,0:18:03.78,0:18:05.48,英文,,0,0,0,,Then I look at everything 2 away.
Dialogue: 0,0:18:03.78,0:18:05.48,中文,,0,0,0,,然后我看着所有距离2的东西
Dialogue: 0,0:18:05.48,0:18:07.31,英文,,0,0,0,,Then I look at everything 3 away.
Dialogue: 0,0:18:05.48,0:18:07.31,中文,,0,0,0,,然后我看着所有距离3的东西
Dialogue: 0,0:18:07.31,0:18:09.69,英文,,0,0,0,,And things are turning white as I visit them.
Dialogue: 0,0:18:07.31,0:18:09.69,中文,,0,0,0,,当我访问它们时它们变白了
Dialogue: 0,0:18:09.69,0:18:11.43,英文,,0,0,0,,Then I look at everything 4 away.
Dialogue: 0,0:18:09.69,0:18:11.43,中文,,0,0,0,,我看着所有距离4的东西
Dialogue: 0,0:18:11.43,0:18:13.43,英文,,0,0,0,,Then I look at everything 5 away.
Dialogue: 0,0:18:11.43,0:18:13.43,中文,,0,0,0,,看着所有距离5的东西
Dialogue: 0,0:18:13.43,0:18:15.67,英文,,0,0,0,,So this algorithm, it will work.
Dialogue: 0,0:18:13.43,0:18:15.67,中文,,0,0,0,,这个算法它会起作用.
Dialogue: 0,0:18:15.67,0:18:24.79,英文,,0,0,0,,And in particular, the key idea, I know I'm kind of speed running this, but the key idea is that I am visiting the nodes in the order of distance to source.
Dialogue: 0,0:18:15.67,0:18:24.79,中文,,0,0,0,,而且特别是关键的想法我知道我有点快进了但关键的想法是我按照距离源节点的顺序访问节点.
Dialogue: 0,0:18:24.79,0:18:31.14,英文,,0,0,0,,So instead of doing the thing, where I'm visiting one edge away, two edge away, three edges away.
Dialogue: 0,0:18:24.79,0:18:31.14,中文,,0,0,0,,不是做那件事, 其中我访问1条边2条边3条边.
Dialogue: 0,0:18:31.14,0:18:37.91,英文,,0,0,0,,I'm instead visiting all the nodes that are distance one, then all the nodes that are distance two, then all the nodes that are distance three.
Dialogue: 0,0:18:31.14,0:18:37.91,中文,,0,0,0,,而是依次访问所有距离1的节点然后所有距离2的节点然后所有距离3的节点.
Dialogue: 0,0:18:37.91,0:18:41.78,英文,,0,0,0,,So this is one of the key ideas in this section that I'm speedrunning.
Dialogue: 0,0:18:37.91,0:18:41.78,中文,,0,0,0,,这是我在这一部分快速奔跑的关键想法之一.
Dialogue: 0,0:18:41.78,0:18:47.62,英文,,0,0,0,,BFS, it visited everything one edge away, two edges away, Three edges away.
Dialogue: 0,0:18:41.78,0:18:47.62,中文,,0,0,0,,BFS它访问了所有距离为1的边距离为2的边 距离为3的边
Dialogue: 0,0:18:47.62,0:18:51.84,英文,,0,0,0,,But if I use this little dummy nodes trick, I get a different order.
Dialogue: 0,0:18:47.62,0:18:51.84,中文,,0,0,0,,但是如果我使用这个小的虚拟节点的技巧我会得到一个不同的顺序
Dialogue: 0,0:18:51.84,0:19:02.67,英文,,0,0,0,,And I want this order, because this order says I'm going to look at all the nodes that are distance one away, and then all the nodes that are distance two away, and then all the nodes that are distance three away, and so forth.
Dialogue: 0,0:18:51.84,0:19:02.67,中文,,0,0,0,,而我想要这个顺序因为这个顺序表示我要先看看所有距离为1的节点然后是所有距离为2的节点然后是所有距离为3的节点依此类推
Dialogue: 0,0:19:02.67,0:19:05.50,英文,,0,0,0,,This is sometimes called best first order.
Dialogue: 0,0:19:02.67,0:19:05.50,中文,,0,0,0,,有时候这被称为最佳优先顺序
Dialogue: 0,0:19:05.50,0:19:07.44,英文,,0,0,0,,I want this order.
Dialogue: 0,0:19:05.50,0:19:07.44,中文,,0,0,0,,我想要这个顺序
Dialogue: 0,0:19:07.44,0:19:14.63,英文,,0,0,0,,I want the order that you get if you add dummy nodes and you explore everything one away, and everything two away, and so forth.
Dialogue: 0,0:19:07.44,0:19:14.63,中文,,0,0,0,,我想要的顺序是如果你添加虚拟节点并且你探索所有距离为1的节点所有距离为2的节点依此类推
Dialogue: 0,0:19:14.63,0:19:17.44,英文,,0,0,0,,So why not just stick with this algorithm and call it a day?
Dialogue: 0,0:19:14.63,0:19:17.44,中文,,0,0,0,,那为什么不坚持使用这个算法然后一天结束呢
Dialogue: 0,0:19:17.44,0:19:21.24,英文,,0,0,0,,Well, what if you had a graph like this?
Dialogue: 0,0:19:17.44,0:19:21.24,中文,,0,0,0,,如果你有这样一个图呢
Dialogue: 0,0:19:21.24,0:19:21.82,英文,,0,0,0,,316,800.
Dialogue: 0,0:19:21.24,0:19:21.82,中文,,0,0,0,,316,800
Dialogue: 0,0:19:21.82,0:19:29.46,英文,,0,0,0,,Well, you can have fun drawing 316,000 little nodes in between A and B, but I will not do that.
Dialogue: 0,0:19:21.82,0:19:29.46,中文,,0,0,0,,你可以在A和B之间画出316,000个小节点但我不会这样做
Dialogue: 0,0:19:29.46,0:19:31.54,英文,,0,0,0,,So I'm going to go find something better.
Dialogue: 0,0:19:29.46,0:19:31.54,中文,,0,0,0,,我要去找更好的东西
Dialogue: 0,0:19:31.54,0:19:34.86,英文,,0,0,0,,So we saw algorithm number one, BFS.
Dialogue: 0,0:19:31.54,0:19:34.86,中文,,0,0,0,,我们看到了算法一BFS
Dialogue: 0,0:19:34.86,0:19:39.20,英文,,0,0,0,,It visited one edge away, two edge away, three edges away.
Dialogue: 0,0:19:34.86,0:19:39.20,中文,,0,0,0,,它访问了一条边的距离两条边的距离三条边的距离
Dialogue: 0,0:19:39.20,0:19:43.02,英文,,0,0,0,,We saw dummy nodes, which gave me this best first order, which I like.
Dialogue: 0,0:19:39.20,0:19:43.02,中文,,0,0,0,,我们看到了虚拟节点这让我得到了这个最佳的第一顺序我很喜欢
Dialogue: 0,0:19:43.02,0:19:44.24,英文,,0,0,0,,I want to keep that.
Dialogue: 0,0:19:43.02,0:19:44.24,中文,,0,0,0,,我想保留那个
Dialogue: 0,0:19:44.24,0:19:48.73,英文,,0,0,0,,But I don't want to have to introduce hundreds of thousands of dummy nodes.
Dialogue: 0,0:19:44.24,0:19:48.73,中文,,0,0,0,,但我不想要引入成千上万的虚拟节点
Dialogue: 0,0:19:48.73,0:19:50.03,英文,,0,0,0,,That's just too many.
Dialogue: 0,0:19:48.73,0:19:50.03,中文,,0,0,0,,那太多了
Dialogue: 0,0:19:50.03,0:19:51.75,英文,,0,0,0,,But I want to keep this order.
Dialogue: 0,0:19:50.03,0:19:51.75,中文,,0,0,0,,但我想保留这个顺序
Dialogue: 0,0:19:51.75,0:19:55.11,英文,,0,0,0,,So I'm going to try to use best first search.
Dialogue: 0,0:19:51.75,0:19:55.11,中文,,0,0,0,,我打算尝试使用最佳优先搜索
Dialogue: 0,0:19:55.11,0:20:00.59,英文,,0,0,0,,That is, I want to explore the closer things before the further things with distance.
Dialogue: 0,0:19:55.11,0:20:00.59,中文,,0,0,0,,也就是说我想要在距离较近的事物之前探索更接近的事物
Dialogue: 0,0:20:00.59,0:20:03.12,英文,,0,0,0,,And so that's what this third algorithm is doing.
Dialogue: 0,0:20:00.59,0:20:03.12,中文,,0,0,0,,这就是第三个算法在做的事情
Dialogue: 0,0:20:03.12,0:20:04.57,英文,,0,0,0,,And again, there's a lot of words.
Dialogue: 0,0:20:03.12,0:20:04.57,中文,,0,0,0,,还有有很多词
Dialogue: 0,0:20:04.57,0:20:06.99,英文,,0,0,0,,I annotated it for you.
Dialogue: 0,0:20:04.57,0:20:06.99,中文,,0,0,0,,我给你做了注解
Dialogue: 0,0:20:06.99,0:20:12.21,英文,,0,0,0,,there's still one problem, which is this algorithm still doesn't give you the right answer.
Dialogue: 0,0:20:06.99,0:20:12.21,中文,,0,0,0,,还有一个问题就是这个算法仍然没有给出正确的答案
Dialogue: 0,0:20:12.21,0:20:22.37,英文,,0,0,0,,And so the final fix we have to make to truly get something correct, the first fix we made is, well, let's go best first instead of going in a level order.
Dialogue: 0,0:20:12.21,0:20:22.37,中文,,0,0,0,,我们要做的最终修正是第一个修正是好吧让我们首先选择最好的而不是按层次顺序
Dialogue: 0,0:20:22.37,0:20:26.22,英文,,0,0,0,,So don't go one edge away, two edge away, three edges away.
Dialogue: 0,0:20:22.37,0:20:26.22,中文,,0,0,0,,不要走1条边2条边3条边
Dialogue: 0,0:20:26.22,0:20:31.00,英文,,0,0,0,,Instead, go best first, go distance one, distance two, distance three.
Dialogue: 0,0:20:26.22,0:20:31.00,中文,,0,0,0,,相反首先选择最好的走1步走2步走3步
Dialogue: 0,0:20:31.00,0:20:35.30,英文,,0,0,0,,But there was one more problem, which is right here,
Dialogue: 0,0:20:31.00,0:20:35.30,中文,,0,0,0,,但还有一个问题就在这里
Dialogue: 0,0:20:35.30,0:20:38.30,英文,,0,0,0,,What was the criteria for adding an edge?
Dialogue: 0,0:20:35.30,0:20:38.30,中文,,0,0,0,,添加边的标准是什么
Dialogue: 0,0:20:38.30,0:20:45.23,英文,,0,0,0,,Well, so far, we've just been saying, if this edge points at somewhere you haven't been, add it to the family.
Dialogue: 0,0:20:38.30,0:20:45.23,中文,,0,0,0,,到目前为止我们只是在说如果这条边指向一个你没有去过的地方就把它添加到家族中
Dialogue: 0,0:20:45.23,0:20:49.67,英文,,0,0,0,,So for example, I've never been to B, so let's just add this edge.
Dialogue: 0,0:20:45.23,0:20:49.67,中文,,0,0,0,,例如我从未去过 B所以让我们添加这条边
Dialogue: 0,0:20:49.67,0:20:55.36,英文,,0,0,0,,And I've never been to C. This is the first edge I've seen to get to C, so I'll throw it into the family.
Dialogue: 0,0:20:49.67,0:20:55.36,中文,,0,0,0,,我从未去过 C这是我见过的第一条通往 C 的边所以我会把它扔进家族里
Dialogue: 0,0:20:55.36,0:20:59.24,英文,,0,0,0,,And this is the first time I've seen an edge going to D, so I'll throw it into the family.
Dialogue: 0,0:20:55.36,0:20:59.24,中文,,0,0,0,,这是我第一次看到通往 D 的边所以我会把它扔进家族里
Dialogue: 0,0:20:59.24,0:21:02.44,英文,,0,0,0,,That's what the algorithm inspired by BFS sets.
Dialogue: 0,0:20:59.24,0:21:02.44,中文,,0,0,0,,这就是受 BFS 启发的算法所做的
Dialogue: 0,0:21:02.44,0:21:11.99,英文,,0,0,0,,It says, if you see an edge pointing at someone that's not part of your shortest path tree yet, then add that edge, because that's a way to get there.
Dialogue: 0,0:21:02.44,0:21:11.99,中文,,0,0,0,,它说如果你看到一个指向还不在你的最短路径树中的人的边那就添加这个边因为那是到达那里的一种方式
Dialogue: 0,0:21:11.99,0:21:19.11,英文,,0,0,0,,But if you pause the movie to see what went wrong in this algorithm, well, let's consider right here.
Dialogue: 0,0:21:11.99,0:21:19.11,中文,,0,0,0,,但如果你暂停电影来看这个算法出了什么问题那么让我们在这里考虑一下
Dialogue: 0,0:21:19.11,0:21:22.79,英文,,0,0,0,,So I know I'm kind of skipping you into the middle of the movie here.
Dialogue: 0,0:21:19.11,0:21:22.79,中文,,0,0,0,,我知道我有点把你带到电影中间的感觉
Dialogue: 0,0:21:22.79,0:21:34.38,英文,,0,0,0,,But at this point, we have A to B. This edge was thrown into the family because we said we were at A, and we looked at this edge, and we said, do we know how to get to B yet?
Dialogue: 0,0:21:22.79,0:21:34.38,中文,,0,0,0,,但在这一点上我们有A到B这条边被加入到家族中因为我们说我们在A点我们看了这条边我们问自己我们知道怎么到B吗
Dialogue: 0,0:21:34.38,0:21:35.22,英文,,0,0,0,,No.
Dialogue: 0,0:21:34.38,0:21:35.22,中文,,0,0,0,,不
Dialogue: 0,0:21:35.22,0:21:38.28,英文,,0,0,0,,But this is a way to get to B. So let's add this edge.
Dialogue: 0,0:21:35.22,0:21:38.28,中文,,0,0,0,,但这是到达B的一种方式所以让我们添加这个边
Dialogue: 0,0:21:38.28,0:21:39.20,英文,,0,0,0,,Let's bold it.
Dialogue: 0,0:21:38.28,0:21:39.20,中文,,0,0,0,,让我们把它加粗
Dialogue: 0,0:21:39.20,0:21:40.40,英文,,0,0,0,,Let's use it.
Dialogue: 0,0:21:39.20,0:21:40.40,中文,,0,0,0,,我们来用它
Dialogue: 0,0:21:40.40,0:21:54.29,英文,,0,0,0,,So I'm using this edge to get to B. Later, I get to C, and I'm considering all the edges coming out of C. And I look at this edge, C to B, and I say, C to B, should you be part of the family?
Dialogue: 0,0:21:40.40,0:21:54.29,中文,,0,0,0,,我正在使用这条边到达 B然后我到达 C考虑所有从 C 出发的边我看着这条边从 C 到 B我说从 C 到 B你应该成为家庭的一部分吗
Dialogue: 0,0:21:54.29,0:21:59.34,英文,,0,0,0,,Our current algorithm says, no, C to B, do not use this edge.
Dialogue: 0,0:21:54.29,0:21:59.34,中文,,0,0,0,,我们当前的算法说不从 C 到 B不要使用这条边
Dialogue: 0,0:21:59.34,0:22:00.02,英文,,0,0,0,,Why?
Dialogue: 0,0:21:59.34,0:22:00.02,中文,,0,0,0,,为什么
Dialogue: 0,0:22:00.02,0:22:04.12,英文,,0,0,0,,Because I already have a way to get to B, so why bother using this edge?
Dialogue: 0,0:22:00.02,0:22:04.12,中文,,0,0,0,,因为我已经有一种方法到达 B那么为什么要费心使用这条边呢
Dialogue: 0,0:22:04.12,0:22:05.48,英文,,0,0,0,,But what should we have done?
Dialogue: 0,0:22:04.12,0:22:05.48,中文,,0,0,0,,但我们应该怎么做
Dialogue: 0,0:22:05.48,0:22:08.24,英文,,0,0,0,,Why was the thing I just said broken?
Dialogue: 0,0:22:05.48,0:22:08.24,中文,,0,0,0,,刚才我说的那件事为什么会出错
Dialogue: 0,0:22:08.24,0:22:16.36,英文,,0,0,0,,So the reasoning in our current algorithm, what we've built so far, is vertex B. We already have a way to get there.
Dialogue: 0,0:22:08.24,0:22:16.36,中文,,0,0,0,,我们当前算法的推理到目前为止我们建立的是顶点B我们已经有一种方法可以到达那里
Dialogue: 0,0:22:16.36,0:22:20.30,英文,,0,0,0,,So when I'm looking at the C to B edge, don't use it.
Dialogue: 0,0:22:16.36,0:22:20.30,中文,,0,0,0,,当我看到C到B的边时不要使用它
Dialogue: 0,0:22:20.30,0:22:22.60,英文,,0,0,0,,But should I have used this edge?
Dialogue: 0,0:22:20.30,0:22:22.60,中文,,0,0,0,,但是我应该使用这条边吗
Dialogue: 0,0:22:22.60,0:22:23.38,英文,,0,0,0,,Yes.
Dialogue: 0,0:22:22.60,0:22:23.38,中文,,0,0,0,,是的
Dialogue: 0,0:22:23.38,0:22:26.56,英文,,0,0,0,,Why should I have used this edge to get to B?
Dialogue: 0,0:22:23.38,0:22:26.56,中文,,0,0,0,,为什么我应该使用这条边到达B呢
Dialogue: 0,0:22:26.56,0:22:33.44,英文,,0,0,0,,Because if I use this edge to get to b, I have total distance 1 plus 1, which is 2.
Dialogue: 0,0:22:26.56,0:22:33.44,中文,,0,0,0,,因为如果我使用这条边到达B我有总距离1加1即2
Dialogue: 0,0:22:33.44,0:22:36.20,英文,,0,0,0,,And 2 is better than 5.
Dialogue: 0,0:22:33.44,0:22:36.20,中文,,0,0,0,,而2比5更好
Dialogue: 0,0:22:36.20,0:22:44.79,英文,,0,0,0,,So the final fix we have to make, as first was a fix, another fix we have to make to truly get this correct is
Dialogue: 0,0:22:36.20,0:22:44.79,中文,,0,0,0,,因此我们必须进行最终修复我们必须做另一个修复才能真正正确地解决这个问题
Dialogue: 0,0:22:44.79,0:22:53.79,英文,,0,0,0,,we should not add an edge if there's no previous way to get to b, but we should also be brave enough to Throw out edges.
Dialogue: 0,0:22:44.79,0:22:53.79,中文,,0,0,0,,即如果没有到达 b 的先前路径我们就不应该添加边但我们也应该足够勇敢去抛弃边
Dialogue: 0,0:22:53.79,0:22:59.68,英文,,0,0,0,,We should be kicking people out of the family if we find better ways to get to B.
Dialogue: 0,0:22:53.79,0:22:59.68,中文,,0,0,0,,如果我们发现更好的方法到达 B我们应该将人们从家庭中踢出去
Dialogue: 0,0:22:59.68,0:23:07.10,英文,,0,0,0,,So we should go best first, but the final thing we have to do is we need to be brave enough to throw out edges if we find a better one.
Dialogue: 0,0:22:59.68,0:23:07.10,中文,,0,0,0,,我们应该先找到最好的如果我们能找到更好的方法我们需要足够勇敢地抛弃边缘
Dialogue: 0,0:23:07.10,0:23:15.79,英文,,0,0,0,,So in this case, this edge, C to B, is a better way to get to B than the original edge we found of weight 5.
Dialogue: 0,0:23:07.10,0:23:15.79,中文,,0,0,0,,在这种情况下这条边从 C 到 B是比我们找到的原始权重为 5 的边更好的方法到达 B
Dialogue: 0,0:23:15.79,0:23:19.89,英文,,0,0,0,,So we need to be brave enough to say this A to B edge, we are kicking you out.
Dialogue: 0,0:23:15.79,0:23:19.89,中文,,0,0,0,,我们需要勇敢地说这条从 A 到 B 的边我们要把你踢出去
Dialogue: 0,0:23:19.89,0:23:20.91,英文,,0,0,0,,You are exiled.
Dialogue: 0,0:23:19.89,0:23:20.91,中文,,0,0,0,,你被放逐了
Dialogue: 0,0:23:20.91,0:23:22.71,英文,,0,0,0,,You are no longer part of the family.
Dialogue: 0,0:23:20.91,0:23:22.71,中文,,0,0,0,,你不再是家庭的一部分
Dialogue: 0,0:23:22.71,0:23:27.60,英文,,0,0,0,,We are instead going to use the C to B edge because it is better.
Dialogue: 0,0:23:22.71,0:23:27.60,中文,,0,0,0,,我们反而会使用C到B的边因为它更好
Dialogue: 0,0:23:27.60,0:23:35.18,英文,,0,0,0,,And by adding that second improvement, we finally get something called Dijkstra's algorithm, which I promise I will walk you through shortly.
Dialogue: 0,0:23:27.60,0:23:35.18,中文,,0,0,0,,通过添加第二个改进我们最终得到了一种叫做迪杰斯特拉算法的东西我保证我会马上带你们走过的
Dialogue: 0,0:23:35.18,0:23:38.40,英文,,0,0,0,,But any questions about my super quick speed run?
Dialogue: 0,0:23:35.18,0:23:38.40,中文,,0,0,0,,不过对于我超快速跑的任何问题吗
Dialogue: 0,0:23:38.40,0:23:40.28,英文,,0,0,0,,So there were two fixes I had to make.
Dialogue: 0,0:23:38.40,0:23:40.28,中文,,0,0,0,,我得做两个修复
Dialogue: 0,0:23:40.28,0:23:46.90,英文,,0,0,0,,One was go in best first order, so look at all the closer nodes by distance instead of number of edges.
Dialogue: 0,0:23:40.28,0:23:46.90,中文,,0,0,0,,一个是按照最佳顺序进行看看距离更近的节点而不是边的数量
Dialogue: 0,0:23:46.90,0:23:54.61,英文,,0,0,0,,And the second fix was do not add edges, or don't just add edges if you have not been at vertex before.
Dialogue: 0,0:23:46.90,0:23:54.61,中文,,0,0,0,,第二个修复是不要添加边或者说如果你之前没有到达过顶点就不要添加边
Dialogue: 0,0:23:54.61,0:24:01.92,英文,,0,0,0,,So for example, We saw here, I already found a way to B, but if I'm at C, I should still use this edge.
Dialogue: 0,0:23:54.61,0:24:01.92,中文,,0,0,0,,所以例如 我们在这里看到我已经找到了一种到达B的方法但是如果我在C我仍然应该使用这个边
Dialogue: 0,0:24:01.92,0:24:07.60,英文,,0,0,0,,Look, I'm kicking this five edge out, and I'm replacing it with this one edge because it's better.
Dialogue: 0,0:24:01.92,0:24:07.60,中文,,0,0,0,,看我把这五条边踢出去了我用这条更好的边替换了它
Dialogue: 0,0:24:07.60,0:24:16.51,英文,,0,0,0,,So those are the two high-level ideas you get from this unit, but I will admit it's a lot of slides, so I kind of went through it a little quickly.
Dialogue: 0,0:24:07.60,0:24:16.51,中文,,0,0,0,,这两个高层次的想法就是你从这个单元中得到的但我得承认幻灯片有很多所以我有点快速地浏览了一下
Dialogue: 0,0:24:16.51,0:24:20.22,英文,,0,0,0,,Again, if you wanted to see it in more detail, check out last semester.
Dialogue: 0,0:24:16.51,0:24:20.22,中文,,0,0,0,,再次如果你想看更详细的内容可以查看上学期的内容
Dialogue: 0,0:24:20.22,0:24:22.08,英文,,0,0,0,,OK, sorry, did I lose anyone?
Dialogue: 0,0:24:20.22,0:24:22.08,中文,,0,0,0,,抱歉有人听不懂吗
Dialogue: 0,0:24:22.08,0:24:23.38,英文,,0,0,0,,Are we all still good?
Dialogue: 0,0:24:22.08,0:24:23.38,中文,,0,0,0,,我们还都明白吗
Dialogue: 0,0:24:23.38,0:24:28.60,英文,,0,0,0,,Ready to see the full correct algorithm instead of some bad ones that I invented?
Dialogue: 0,0:24:23.38,0:24:28.60,中文,,0,0,0,,准备好看到完全正确的算法而不是我编造的一些糟糕的算法
Dialogue: 0,0:24:28.60,0:24:29.96,英文,,0,0,0,,OK.
Dialogue: 0,0:24:29.96,0:24:37.73,英文,,0,0,0,,So the fully correct algorithm, which uses the same two ideas, and I'll call them out as we see them, it is called Dijkstra's algorithm.
Dialogue: 0,0:24:29.96,0:24:37.73,中文,,0,0,0,,完全正确的算法使用了相同的两个思路我会在我们看到它们时称之为它们它被称为迪杰斯特拉算法
Dialogue: 0,0:24:37.73,0:24:49.81,英文,,0,0,0,,And it's going to use the two best ideas or the two good ideas that we saw, which are go best first and be brave enough to kick out edges if you find a better way to get to the vertex.
Dialogue: 0,0:24:37.73,0:24:49.81,中文,,0,0,0,,它将使用我们看到的两个最好的思路或两个好的思路即最佳优先和足够勇敢地排除边缘如果你找到了到达顶点的更好的方式
Dialogue: 0,0:24:49.81,0:24:52.17,英文,,0,0,0,,So here is how we're going to do it.
Dialogue: 0,0:24:49.81,0:24:52.17,中文,,0,0,0,,我们要这样做
Dialogue: 0,0:24:52.17,0:24:57.33,英文,,0,0,0,,I'm going to keep track of the best known distance to every vertex.
Dialogue: 0,0:24:52.17,0:24:57.33,中文,,0,0,0,,我将跟踪到每个顶点的已知最佳距离
Dialogue: 0,0:24:57.33,0:25:02.50,英文,,0,0,0,,So look, these little pink numbers, they tell me the best known ways to get to every vertex.
Dialogue: 0,0:24:57.33,0:25:02.50,中文,,0,0,0,,看这些小粉红色的数字它们告诉我到达每个顶点的最佳已知方式
Dialogue: 0,0:25:02.50,0:25:05.58,英文,,0,0,0,,What is the best known distance to A, the source?
Dialogue: 0,0:25:02.50,0:25:05.58,中文,,0,0,0,,到A源点的已知最佳距离是多少
Dialogue: 0,0:25:05.58,0:25:09.52,英文,,0,0,0,,It's 0, because how do you get from A to A?
Dialogue: 0,0:25:05.58,0:25:09.52,中文,,0,0,0,,这是 0因为你怎么从 A 到 A
Dialogue: 0,0:25:09.52,0:25:11.26,英文,,0,0,0,,Like, done, you're there, right?
Dialogue: 0,0:25:09.52,0:25:11.26,中文,,0,0,0,,就像完成了你就在那里对吧
Dialogue: 0,0:25:11.26,0:25:14.54,英文,,0,0,0,,So the distance from A to A is zero.
Dialogue: 0,0:25:11.26,0:25:14.54,中文,,0,0,0,,从 A 到 A 的距离是0
Dialogue: 0,0:25:14.54,0:25:17.28,英文,,0,0,0,,What about the best known distance to B?
Dialogue: 0,0:25:14.54,0:25:17.28,中文,,0,0,0,,最短距离到达 B 是多少
Dialogue: 0,0:25:17.28,0:25:21.24,英文,,0,0,0,,Right now it's infinity, because I don't know how to get to B. Look, none of my edges are bold.
Dialogue: 0,0:25:17.28,0:25:21.24,中文,,0,0,0,,现在是无穷大因为我不知道怎么到达 B看我的边都不粗
Dialogue: 0,0:25:21.24,0:25:24.14,英文,,0,0,0,,I have no idea what the shortest path to B is.
Dialogue: 0,0:25:21.24,0:25:24.14,中文,,0,0,0,,我完全不知道到达 B 的最短路径是什么
Dialogue: 0,0:25:24.14,0:25:33.23,英文,,0,0,0,,And likewise with C, D, E, F, G. So all of these vertices, the best known distance to them, which I'm always going to write in pink, is infinity.
Dialogue: 0,0:25:24.14,0:25:33.23,中文,,0,0,0,,对于 C、D、E、F、G 也是一样所有这些顶点到达它们的最短距离我会一直用粉色标注是无穷大
Dialogue: 0,0:25:33.23,0:25:34.97,英文,,0,0,0,,I don't know how to get there yet.
Dialogue: 0,0:25:33.23,0:25:34.97,中文,,0,0,0,,我还不知道怎么去那里
Dialogue: 0,0:25:34.97,0:25:37.21,英文,,0,0,0,,Okay, so here we go.
Dialogue: 0,0:25:34.97,0:25:37.21,中文,,0,0,0,,那我们开始吧
Dialogue: 0,0:25:37.21,0:25:41.55,英文,,0,0,0,,I am going to always pick the closest edge to the source.
Dialogue: 0,0:25:37.21,0:25:41.55,中文,,0,0,0,,我会始终选择距离源点最近的边
Dialogue: 0,0:25:41.55,0:25:42.75,英文,,0,0,0,,How do I know who's closest?
Dialogue: 0,0:25:41.55,0:25:42.75,中文,,0,0,0,,我怎么知道谁最近
Dialogue: 0,0:25:42.75,0:25:46.35,英文,,0,0,0,,Well, look at these pink numbers and pick the one that's closest.
Dialogue: 0,0:25:42.75,0:25:46.35,中文,,0,0,0,,看看这些粉色的数字选最近的那个
Dialogue: 0,0:25:46.35,0:25:50.10,英文,,0,0,0,,So in this case, who is the closest node to S?
Dialogue: 0,0:25:46.35,0:25:50.10,中文,,0,0,0,,在这种情况下谁是距离S最近的节点
Dialogue: 0,0:25:50.10,0:25:55.12,英文,,0,0,0,,Well, it's S. It's got a priority of zero, or a best-known distance of zero.
Dialogue: 0,0:25:50.10,0:25:55.12,中文,,0,0,0,,就是S它的优先级是0或者说是最佳已知距离是0
Dialogue: 0,0:25:55.12,0:25:59.77,英文,,0,0,0,,Everyone else has a best-known distance of infinity, so I will start with S.
Dialogue: 0,0:25:55.12,0:25:59.77,中文,,0,0,0,,其他人都有一个无限远的最佳距离所以我会从S开始
Dialogue: 0,0:25:59.77,0:26:02.95,英文,,0,0,0,,OK, let's start with S. So here's what I will do.
Dialogue: 0,0:25:59.77,0:26:02.95,中文,,0,0,0,,我们从S开始所以这是我要做的
Dialogue: 0,0:26:02.95,0:26:05.81,英文,,0,0,0,,I will consider all of the outgoing edges.
Dialogue: 0,0:26:02.95,0:26:05.81,中文,,0,0,0,,我会考虑所有的出边
Dialogue: 0,0:26:05.81,0:26:13.09,英文,,0,0,0,,And remember, one of our problems from one of our bad algorithms was we were a little bit too nice with adding edges.
Dialogue: 0,0:26:05.81,0:26:13.09,中文,,0,0,0,,还记得我们从一个糟糕的算法中得到的一个问题是我们对添加边太好了一点
Dialogue: 0,0:26:13.09,0:26:14.53,英文,,0,0,0,,So we just said, you know what?
Dialogue: 0,0:26:13.09,0:26:14.53,中文,,0,0,0,,我们就说你知道吗
Dialogue: 0,0:26:14.53,0:26:17.69,英文,,0,0,0,,If I've never been to B before, let's just add the edge to the family.
Dialogue: 0,0:26:14.53,0:26:17.69,中文,,0,0,0,,如果我以前从未去过B我们就把这条边加到家族里
Dialogue: 0,0:26:17.69,0:26:19.00,英文,,0,0,0,,How bad can it be?
Dialogue: 0,0:26:17.69,0:26:19.00,中文,,0,0,0,,能有多糟
Dialogue: 0,0:26:19.00,0:26:24.88,英文,,0,0,0,,And if I've never seen an edge to C before and it's the first edge to C that I've seen, let's add it to the family.
Dialogue: 0,0:26:19.00,0:26:24.88,中文,,0,0,0,,如果我以前从未见过指向 C 的边并且这是我见过的第一条指向 C 的边让我们把它加入家族吧
Dialogue: 0,0:26:24.88,0:26:29.58,英文,,0,0,0,,But remember, we need to be a little bit more careful and be willing to throw out edges.
Dialogue: 0,0:26:24.88,0:26:29.58,中文,,0,0,0,,但记住我们需要再小心一点并愿意放弃一些边
Dialogue: 0,0:26:29.58,0:26:41.01,英文,,0,0,0,,So in order to throw out edges and give ourselves the bravery to choose the best paths and abandon worse ones, I'm going to introduce a process called relaxation.
Dialogue: 0,0:26:29.58,0:26:41.01,中文,,0,0,0,,为了放弃一些边并给自己勇气选择最佳路径并放弃更差的路径我要介绍一个叫做放弃的过程
Dialogue: 0,0:26:41.01,0:26:44.58,英文,,0,0,0,,It is a weird term, I'm sorry, but I didn't name it.
Dialogue: 0,0:26:41.01,0:26:44.58,中文,,0,0,0,,这是一个奇怪的术语抱歉但这不是我起的名字
Dialogue: 0,0:26:44.58,0:26:49.88,英文,,0,0,0,,So The process for relaxation, you relax an edge.
Dialogue: 0,0:26:44.58,0:26:49.88,中文,,0,0,0,,放弃的过程你放弃一条边
Dialogue: 0,0:26:49.88,0:26:51.88,英文,,0,0,0,,So the operation is done on an edge.
Dialogue: 0,0:26:49.88,0:26:51.88,中文,,0,0,0,,这个操作是在一条边上完成的
Dialogue: 0,0:26:51.88,0:26:52.90,英文,,0,0,0,,You don't relax something else.
Dialogue: 0,0:26:51.88,0:26:52.90,中文,,0,0,0,,你不放弃其他东西
Dialogue: 0,0:26:52.90,0:26:54.08,英文,,0,0,0,,You don't relax the graph.
Dialogue: 0,0:26:52.90,0:26:54.08,中文,,0,0,0,,你不放弃图
Dialogue: 0,0:26:54.08,0:26:55.88,英文,,0,0,0,,You relax an edge.
Dialogue: 0,0:26:54.08,0:26:55.88,中文,,0,0,0,,你放弃一条边
Dialogue: 0,0:26:55.88,0:26:58.84,英文,,0,0,0,,And to relax an edge, you need to compare two things.
Dialogue: 0,0:26:55.88,0:26:58.84,中文,,0,0,0,,放弃一条边你需要比较两件事情
Dialogue: 0,0:26:58.84,0:27:02.36,英文,,0,0,0,,Here's the math that you have to do, and then I'll tell you why it's useful.
Dialogue: 0,0:26:58.84,0:27:02.36,中文,,0,0,0,,这里是你需要做的数学然后我会告诉你为什么它有用
Dialogue: 0,0:27:02.36,0:27:08.33,英文,,0,0,0,,So mechanically, the math you have to do to relax is you need to add two numbers.
Dialogue: 0,0:27:02.36,0:27:08.33,中文,,0,0,0,,从机械的角度来看你需要做的数学就是要加两个数字
Dialogue: 0,0:27:08.33,0:27:09.71,英文,,0,0,0,,I'm sorry, that's what you got to do.
Dialogue: 0,0:27:08.33,0:27:09.71,中文,,0,0,0,,抱歉那就是你要做的事情
Dialogue: 0,0:27:09.71,0:27:10.65,英文,,0,0,0,,I know it's tough.
Dialogue: 0,0:27:09.71,0:27:10.65,中文,,0,0,0,,我知道这很难
Dialogue: 0,0:27:10.65,0:27:16.49,英文,,0,0,0,,So I'm going to add two numbers, which are, what is the total cost to get to A so far?
Dialogue: 0,0:27:10.65,0:27:16.49,中文,,0,0,0,,我要加两个数字就是到目前为止到达A的总成本是多少
Dialogue: 0,0:27:16.49,0:27:17.05,英文,,0,0,0,,0.
Dialogue: 0,0:27:16.49,0:27:17.05,中文,,0,0,0,,0
Dialogue: 0,0:27:17.05,0:27:19.05,英文,,0,0,0,,What is the cost along the edge?
Dialogue: 0,0:27:17.05,0:27:19.05,中文,,0,0,0,,边上的成本是多少
Dialogue: 0,0:27:19.05,0:27:19.61,英文,,0,0,0,,2.
Dialogue: 0,0:27:19.05,0:27:19.61,中文,,0,0,0,,2
Dialogue: 0,0:27:19.61,0:27:24.14,英文,,0,0,0,,If I add 0 plus 2, I get 2.
Dialogue: 0,0:27:19.61,0:27:24.14,中文,,0,0,0,,如果我把0+2得到2
Dialogue: 0,0:27:24.14,0:27:24.78,英文,,0,0,0,,Thank you, class.
Dialogue: 0,0:27:24.14,0:27:24.78,中文,,0,0,0,,谢谢同学们
Dialogue: 0,0:27:24.78,0:27:26.16,英文,,0,0,0,,OK, so I get 2.
Dialogue: 0,0:27:24.78,0:27:26.16,中文,,0,0,0,,我明白了我得到了2
Dialogue: 0,0:27:26.16,0:27:33.14,英文,,0,0,0,,And so that is the total cost to get to B if I go through A and use the edge that I'm looking at right now.
Dialogue: 0,0:27:26.16,0:27:33.14,中文,,0,0,0,,那么如果我经过A并使用我现在正在查看的边那么到达B的总成本就是这样
Dialogue: 0,0:27:33.14,0:27:35.22,英文,,0,0,0,,It's 0 plus 2, total cost of 2.
Dialogue: 0,0:27:33.14,0:27:35.22,中文,,0,0,0,,这是0+2总成本是2
Dialogue: 0,0:27:35.22,0:27:44.99,英文,,0,0,0,,So I'm going to compare the sum that I just did, which is 2, against the best-known distance to B. What is the current best-known distance to B?
Dialogue: 0,0:27:35.22,0:27:44.99,中文,,0,0,0,,我要比较刚刚做的总和也就是2与到达B的最佳已知距离当前到达B的最佳已知距离是多少
Dialogue: 0,0:27:44.99,0:27:46.01,英文,,0,0,0,,Infinity.
Dialogue: 0,0:27:44.99,0:27:46.01,中文,,0,0,0,,无穷大
Dialogue: 0,0:27:46.01,0:27:46.99,英文,,0,0,0,,Which do you like better?
Dialogue: 0,0:27:46.01,0:27:46.99,中文,,0,0,0,,你更喜欢哪一个
Dialogue: 0,0:27:46.99,0:27:53.36,英文,,0,0,0,,Do you like infinity distance to B better, or do you like 0 plus 2 distance to B better?
Dialogue: 0,0:27:46.99,0:27:53.36,中文,,0,0,0,,你更喜欢到达B的无穷远距离还是更喜欢0+2的距离
Dialogue: 0,0:27:53.36,0:27:56.52,英文,,0,0,0,,I like 0 plus 2 because it's closer.
Dialogue: 0,0:27:53.36,0:27:56.52,中文,,0,0,0,,我喜欢0+2因为它更接近
Dialogue: 0,0:27:56.52,0:28:08.12,英文,,0,0,0,,So this realization succeeds, and I say, two, you can join the family because going through A is a better path than whatever else I used to have, which in this case was nothing.
Dialogue: 0,0:27:56.52,0:28:08.12,中文,,0,0,0,,这个认识成功了我说两个你可以加入这个家庭因为通过A是比我之前任何其他选择都更好的路径在这种情况下什么都没有
Dialogue: 0,0:28:08.12,0:28:10.36,英文,,0,0,0,,And same thing here, 0 plus 1.
Dialogue: 0,0:28:08.12,0:28:10.36,中文,,0,0,0,,同样的道理0+1
Dialogue: 0,0:28:10.36,0:28:13.60,英文,,0,0,0,,If I go through A to get to C, it costs me 1.
Dialogue: 0,0:28:10.36,0:28:13.60,中文,,0,0,0,,如果我通过A到达C那么我需要花费1
Dialogue: 0,0:28:13.60,0:28:15.10,英文,,0,0,0,,That's better than infinity.
Dialogue: 0,0:28:13.60,0:28:15.10,中文,,0,0,0,,这比无穷大好
Dialogue: 0,0:28:15.10,0:28:17.14,英文,,0,0,0,,So this realization succeeds.
Dialogue: 0,0:28:15.10,0:28:17.14,中文,,0,0,0,,这个认识成功了
Dialogue: 0,0:28:17.14,0:28:19.64,英文,,0,0,0,,And I want to use the z. So look, I'm updating.
Dialogue: 0,0:28:17.14,0:28:19.64,中文,,0,0,0,,我想要使用z所以看我在更新
Dialogue: 0,0:28:19.64,0:28:22.04,英文,,0,0,0,,And I'm saying, this is no longer infinity.
Dialogue: 0,0:28:19.64,0:28:22.04,中文,,0,0,0,,我在说这不再是无限的了
Dialogue: 0,0:28:22.04,0:28:24.52,英文,,0,0,0,,I now have a better path to get to B. It's 2.
Dialogue: 0,0:28:22.04,0:28:24.52,中文,,0,0,0,,现在我有了更好的路径去到B就是2
Dialogue: 0,0:28:24.52,0:28:26.67,英文,,0,0,0,,And I have a better way to get to C. It's 1.
Dialogue: 0,0:28:24.52,0:28:26.67,中文,,0,0,0,,而且我有了一个更好的方法去到C就是1
Dialogue: 0,0:28:26.67,0:28:30.83,英文,,0,0,0,,There might be something better in the future, but those are the best ones that I found so far.
Dialogue: 0,0:28:26.67,0:28:30.83,中文,,0,0,0,,未来可能会有更好的选择但目前这些是我找到的最好的
Dialogue: 0,0:28:30.83,0:28:36.11,英文,,0,0,0,,I will record their distances, and I will record that I'm adding these edges to the family.
Dialogue: 0,0:28:30.83,0:28:36.11,中文,,0,0,0,,我会记录它们的距离并记录我正在将这些边添加到家族中
Dialogue: 0,0:28:36.11,0:28:38.10,英文,,0,0,0,,How do I get to B from A?
Dialogue: 0,0:28:36.11,0:28:38.10,中文,,0,0,0,,我怎么从A到B
Dialogue: 0,0:28:38.10,0:28:41.06,英文,,0,0,0,,How do I get to C from A?
Dialogue: 0,0:28:38.10,0:28:41.06,中文,,0,0,0,,我怎么从A到C
Dialogue: 0,0:28:41.06,0:28:41.98,英文,,0,0,0,,Look, they're bold.
Dialogue: 0,0:28:41.06,0:28:41.98,中文,,0,0,0,,看它们很大胆
Dialogue: 0,0:28:41.98,0:28:43.48,英文,,0,0,0,,They're part of the family.
Dialogue: 0,0:28:41.98,0:28:43.48,中文,,0,0,0,,它们是家族的一部分
Dialogue: 0,0:28:43.48,0:28:44.74,英文,,0,0,0,,OK.
Dialogue: 0,0:28:44.74,0:28:45.78,英文,,0,0,0,,So there we go.
Dialogue: 0,0:28:44.74,0:28:45.78,中文,,0,0,0,,我们开始吧
Dialogue: 0,0:28:45.78,0:28:47.30,英文,,0,0,0,,I've added them to the family.
Dialogue: 0,0:28:45.78,0:28:47.30,中文,,0,0,0,,我已经把它们加入到家族里了
Dialogue: 0,0:28:47.30,0:28:48.34,英文,,0,0,0,,Let's keep going.
Dialogue: 0,0:28:47.30,0:28:48.34,中文,,0,0,0,,继续前进吧
Dialogue: 0,0:28:48.34,0:28:52.92,英文,,0,0,0,,So now I have all of these as my best known distances in pink.
Dialogue: 0,0:28:48.34,0:28:52.92,中文,,0,0,0,,现在我把所有这些都标记为我最熟悉的距离了
Dialogue: 0,0:28:52.92,0:28:55.98,英文,,0,0,0,,I want you to pick the next node to explore.
Dialogue: 0,0:28:52.92,0:28:55.98,中文,,0,0,0,,我想让你选择下一个要探索的节点
Dialogue: 0,0:28:55.98,0:28:58.04,英文,,0,0,0,,So who do you want to explore next?
Dialogue: 0,0:28:55.98,0:28:58.04,中文,,0,0,0,,那么你想要探索谁
Dialogue: 0,0:28:58.04,0:29:00.14,英文,,0,0,0,,Do you want to explore G next?
Dialogue: 0,0:28:58.04,0:29:00.14,中文,,0,0,0,,你想要探索 G 吗
Dialogue: 0,0:29:00.14,0:29:02.79,英文,,0,0,0,,Do you want to explore B, C, A?
Dialogue: 0,0:29:00.14,0:29:02.79,中文,,0,0,0,,你想要探索 B、C、A 吗
Dialogue: 0,0:29:02.79,0:29:04.97,英文,,0,0,0,,And remember, we need to go best first.
Dialogue: 0,0:29:02.79,0:29:04.97,中文,,0,0,0,,记住我们需要以最好的方式前进
Dialogue: 0,0:29:04.97,0:29:06.69,英文,,0,0,0,,That's the key idea.
Dialogue: 0,0:29:04.97,0:29:06.69,中文,,0,0,0,,这是关键想法
Dialogue: 0,0:29:06.69,0:29:11.11,英文,,0,0,0,,We need to look at all the things that are closer before looking at the things that are further.
Dialogue: 0,0:29:06.69,0:29:11.11,中文,,0,0,0,,我们需要先看那些更近的东西然后再看那些更远的东西
Dialogue: 0,0:29:11.11,0:29:17.59,英文,,0,0,0,,So according to my pink numbers, who is the closest node that I have not explored yet?
Dialogue: 0,0:29:11.11,0:29:17.59,中文,,0,0,0,,根据我的粉色数字最接近的尚未探索的节点是谁
Dialogue: 0,0:29:17.59,0:29:20.72,英文,,0,0,0,,Well, I already did A, so I don't need to explore A again.
Dialogue: 0,0:29:17.59,0:29:20.72,中文,,0,0,0,,我已经完成了A我不需要再探索A了
Dialogue: 0,0:29:20.72,0:29:25.40,英文,,0,0,0,,But look at C. It's got best known distance of 1, and I have not explored it yet.
Dialogue: 0,0:29:20.72,0:29:25.40,中文,,0,0,0,,但看看C它的已知最佳距离是1而且我还没有探索过它
Dialogue: 0,0:29:25.40,0:29:28.18,英文,,0,0,0,,And 1 is lower than all of these other pink numbers.
Dialogue: 0,0:29:25.40,0:29:28.18,中文,,0,0,0,,而且1比所有其他粉色数字都要低
Dialogue: 0,0:29:28.18,0:29:30.80,英文,,0,0,0,,So I'm going to choose to explore C next.
Dialogue: 0,0:29:28.18,0:29:30.80,中文,,0,0,0,,我打算选择下一个探索C
Dialogue: 0,0:29:30.80,0:29:33.17,英文,,0,0,0,,That's me going in the best first order.
Dialogue: 0,0:29:30.80,0:29:33.17,中文,,0,0,0,,这就是我按最佳顺序前进的方式
Dialogue: 0,0:29:33.17,0:29:38.15,英文,,0,0,0,,It's like if I had added the dummy nodes and chosen an order, this is the order I would have chosen.
Dialogue: 0,0:29:33.17,0:29:38.15,中文,,0,0,0,,就好像我添加了虚拟节点并选择了顺序一样这就是我会选择的顺序
Dialogue: 0,0:29:38.15,0:29:39.57,英文,,0,0,0,,So I want to keep this order.
Dialogue: 0,0:29:38.15,0:29:39.57,中文,,0,0,0,,我想保持这个顺序
Dialogue: 0,0:29:39.57,0:29:45.62,英文,,0,0,0,,So now let's look at C, and let's relax all of the edges coming out of C. So there's just one.
Dialogue: 0,0:29:39.57,0:29:45.62,中文,,0,0,0,,现在让我们来看看 C让我们放弃所有从 C 出发的边所以只有一个
Dialogue: 0,0:29:45.62,0:29:48.05,英文,,0,0,0,,It's this one.
Dialogue: 0,0:29:45.62,0:29:48.05,中文,,0,0,0,,就是这个
Dialogue: 0,0:29:48.05,0:29:49.37,英文,,0,0,0,,Again, I do some math.
Dialogue: 0,0:29:48.05,0:29:49.37,中文,,0,0,0,,再次我做一些数学
Dialogue: 0,0:29:49.37,0:29:56.14,英文,,0,0,0,,If I go through C, I take the route through C, and I go to F, how much does it cost to get to F?
Dialogue: 0,0:29:49.37,0:29:56.14,中文,,0,0,0,,如果我经过 C我走经过 C然后去到 F到达 F 需要多少费用
Dialogue: 0,0:29:56.14,0:30:09.31,英文,,0,0,0,,Well, according to this number, it cost me 1 to get to C. Then it cost me an extra 15 to get to F. So the total cost to get to F should be 1 plus 15, which is 16.
Dialogue: 0,0:29:56.14,0:30:09.31,中文,,0,0,0,,根据这个数字到达 C 的费用是 1然后到达 F 需要额外的 15到达 F 的总费用应该是 1 加上 15即 16
Dialogue: 0,0:30:09.31,0:30:10.93,英文,,0,0,0,,Is that better than infinity?
Dialogue: 0,0:30:09.31,0:30:10.93,中文,,0,0,0,,这比无穷大好吗
Dialogue: 0,0:30:10.93,0:30:11.59,英文,,0,0,0,,Yes.
Dialogue: 0,0:30:11.59,0:30:13.95,英文,,0,0,0,,So this edge, welcome to the family.
Dialogue: 0,0:30:11.59,0:30:13.95,中文,,0,0,0,,这个边欢迎加入我们的家庭
Dialogue: 0,0:30:13.95,0:30:17.73,英文,,0,0,0,,You are now part of the shortest path tree for now.
Dialogue: 0,0:30:13.95,0:30:17.73,中文,,0,0,0,,你现在暂时成为最短路径树的一部分
Dialogue: 0,0:30:17.73,0:30:23.06,英文,,0,0,0,,unless I find something better, and I update the best-known distance to F to 16.
Dialogue: 0,0:30:17.73,0:30:23.06,中文,,0,0,0,,除非我找到更好的我会把到 F 的最佳距离更新为 16
Dialogue: 0,0:30:23.06,0:30:24.98,英文,,0,0,0,,Okay, here are my distances so far.
Dialogue: 0,0:30:23.06,0:30:24.98,中文,,0,0,0,,这是我目前的距离
Dialogue: 0,0:30:24.98,0:30:27.80,英文,,0,0,0,,The pink numbers, those are my best-known distances.
Dialogue: 0,0:30:24.98,0:30:27.80,中文,,0,0,0,,粉色的数字那些是我已知的最佳距离
Dialogue: 0,0:30:27.80,0:30:30.62,英文,,0,0,0,,Who would you like to explore next?
Dialogue: 0,0:30:27.80,0:30:30.62,中文,,0,0,0,,你想要探索下一个是谁
Dialogue: 0,0:30:30.62,0:30:32.94,英文,,0,0,0,,I'm going to make you do it this time, so audience participation.
Dialogue: 0,0:30:30.62,0:30:32.94,中文,,0,0,0,,这次我要让你们参与一下
Dialogue: 0,0:30:32.94,0:30:34.52,英文,,0,0,0,,Tell me who you want to explore next.
Dialogue: 0,0:30:32.94,0:30:34.52,中文,,0,0,0,,告诉我你们想要探索谁
Dialogue: 0,0:30:34.52,0:30:37.13,英文,,0,0,0,,Who wants to explore A next?
Dialogue: 0,0:30:34.52,0:30:37.13,中文,,0,0,0,,谁想要下一个探索A
Dialogue: 0,0:30:37.13,0:30:38.61,英文,,0,0,0,,Trick question, we've already been there.
Dialogue: 0,0:30:37.13,0:30:38.61,中文,,0,0,0,,考你们呢我们已经去过那儿了
Dialogue: 0,0:30:38.61,0:30:41.10,英文,,0,0,0,,Who wants to explore C next?
Dialogue: 0,0:30:38.61,0:30:41.10,中文,,0,0,0,,谁想要下一个探索C
Dialogue: 0,0:30:41.10,0:30:41.72,英文,,0,0,0,,Trick question.
Dialogue: 0,0:30:41.10,0:30:41.72,中文,,0,0,0,,考你们呢
Dialogue: 0,0:30:41.72,0:30:42.86,英文,,0,0,0,,We've already been there.
Dialogue: 0,0:30:41.72,0:30:42.86,中文,,0,0,0,,我们已经去过那儿了
Dialogue: 0,0:30:42.86,0:30:44.92,英文,,0,0,0,,Who wants to explore F next?
Dialogue: 0,0:30:42.86,0:30:44.92,中文,,0,0,0,,谁想探索 F
Dialogue: 0,0:30:44.92,0:30:45.69,英文,,0,0,0,,Any takers?
Dialogue: 0,0:30:44.92,0:30:45.69,中文,,0,0,0,,有人愿意吗
Dialogue: 0,0:30:45.69,0:30:47.07,英文,,0,0,0,,Anyone want to do E?
Dialogue: 0,0:30:45.69,0:30:47.07,中文,,0,0,0,,有人想做 E 吗
Dialogue: 0,0:30:47.07,0:30:48.27,英文,,0,0,0,,Anyone want to do B?
Dialogue: 0,0:30:47.07,0:30:48.27,中文,,0,0,0,,有人想做 B 吗
Dialogue: 0,0:30:48.27,0:30:50.05,英文,,0,0,0,,OK, we want to do B. Why?
Dialogue: 0,0:30:48.27,0:30:50.05,中文,,0,0,0,,我们想做 B为什么呢
Dialogue: 0,0:30:50.05,0:30:53.39,英文,,0,0,0,,Because it's the closest node that we have not explored yet.
Dialogue: 0,0:30:50.05,0:30:53.39,中文,,0,0,0,,因为它是我们尚未探索的最近的节点
Dialogue: 0,0:30:53.39,0:30:55.50,英文,,0,0,0,,And remember, we're going best first.
Dialogue: 0,0:30:53.39,0:30:55.50,中文,,0,0,0,,记住我们要按最佳优先级进行
Dialogue: 0,0:30:55.50,0:30:57.96,英文,,0,0,0,,We want to look at all the closer things first.
Dialogue: 0,0:30:55.50,0:30:57.96,中文,,0,0,0,,我们先看看所有更近的东西
Dialogue: 0,0:30:57.96,0:31:00.32,英文,,0,0,0,,So let's explore B next.
Dialogue: 0,0:30:57.96,0:31:00.32,中文,,0,0,0,,那么让我们接下来探索 B
Dialogue: 0,0:31:00.32,0:31:04.97,英文,,0,0,0,,So I'm going to highlight B, I'm going to mark it to say I've been there, no more exploring it a second time.
Dialogue: 0,0:31:00.32,0:31:04.97,中文,,0,0,0,,我要突出 B我要标记它表示我已经去过那里不再探索第二次了
Dialogue: 0,0:31:04.97,0:31:10.79,英文,,0,0,0,,I'm going to look at these three outgoing edges, and we're going to do some relaxation together.
Dialogue: 0,0:31:04.97,0:31:10.79,中文,,0,0,0,,我要看看这三条出边然后我们一起放弃一下
Dialogue: 0,0:31:10.79,0:31:18.08,英文,,0,0,0,,So let's relax B to D, which is I want to consider this edge and maybe put it in the family, maybe not.
Dialogue: 0,0:31:10.79,0:31:18.08,中文,,0,0,0,,让我们把 B 放弃到 D也就是说我想考虑这条边也许把它放到这个家族里也许不
Dialogue: 0,0:31:18.08,0:31:19.94,英文,,0,0,0,,So how do I get to B?
Dialogue: 0,0:31:18.08,0:31:19.94,中文,,0,0,0,,那么我怎么去 B
Dialogue: 0,0:31:19.94,0:31:21.39,英文,,0,0,0,,Cost of two.
Dialogue: 0,0:31:19.94,0:31:21.39,中文,,0,0,0,,成本为两个
Dialogue: 0,0:31:21.39,0:31:23.43,英文,,0,0,0,,Then I need to take this edge, cost of 11.
Dialogue: 0,0:31:21.39,0:31:23.43,中文,,0,0,0,,然后我需要考虑这条边成本为11
Dialogue: 0,0:31:23.43,0:31:25.85,英文,,0,0,0,,So the sum is 13.
Dialogue: 0,0:31:23.43,0:31:25.85,中文,,0,0,0,,这样总和是13
Dialogue: 0,0:31:25.85,0:31:27.43,英文,,0,0,0,,Is that better than infinity?
Dialogue: 0,0:31:25.85,0:31:27.43,中文,,0,0,0,,这比无穷大要好吗
Dialogue: 0,0:31:27.43,0:31:28.25,英文,,0,0,0,,Yes.
Dialogue: 0,0:31:27.43,0:31:28.25,中文,,0,0,0,,是的
Dialogue: 0,0:31:28.25,0:31:32.63,英文,,0,0,0,,So B to D edge, welcome to the shortest path tree you can join.
Dialogue: 0,0:31:28.25,0:31:32.63,中文,,0,0,0,,那么B到D的边欢迎加入最短路径树
Dialogue: 0,0:31:32.63,0:31:38.83,英文,,0,0,0,,B to E, well, cost 2 to get to B, 3 more to get to E, 5 is better than infinity.
Dialogue: 0,0:31:32.63,0:31:38.83,中文,,0,0,0,,B到E到B的成本为2再加3到E5比无穷大要好
Dialogue: 0,0:31:38.83,0:31:42.23,英文,,0,0,0,,So B to E, welcome to the shortest path tree.
Dialogue: 0,0:31:38.83,0:31:42.23,中文,,0,0,0,,那么B到E欢迎加入最短路径树
Dialogue: 0,0:31:42.23,0:31:43.77,英文,,0,0,0,,You are admitted.
Dialogue: 0,0:31:42.23,0:31:43.77,中文,,0,0,0,,你被录取了
Dialogue: 0,0:31:43.77,0:31:47.39,英文,,0,0,0,,Finally, something interesting is happening, because I'm not comparing to infinity.
Dialogue: 0,0:31:43.77,0:31:47.39,中文,,0,0,0,,终于有点有趣的事情发生了因为我不是在与无穷大进行比较
Dialogue: 0,0:31:47.39,0:31:49.71,英文,,0,0,0,,Tell me about this edge right here.
Dialogue: 0,0:31:47.39,0:31:49.71,中文,,0,0,0,,告诉我这里的边缘情况
Dialogue: 0,0:31:49.71,0:31:50.89,英文,,0,0,0,,What is the sum?
Dialogue: 0,0:31:49.71,0:31:50.89,中文,,0,0,0,,总和是多少
Dialogue: 0,0:31:50.89,0:31:59.07,英文,,0,0,0,,So try and think, what two numbers am I about to call out to figure out, if I use this edge to get to C, what is the total cost?
Dialogue: 0,0:31:50.89,0:31:59.07,中文,,0,0,0,,尝试思考一下我接下来要喊出哪两个数字以便弄清楚如果我使用这条边到达 C总成本是多少
Dialogue: 0,0:31:59.07,0:32:02.90,英文,,0,0,0,,I want to go through B to get to C. What is the total cost?
Dialogue: 0,0:31:59.07,0:32:02.90,中文,,0,0,0,,我想要通过 B 去到 C总成本是多少
Dialogue: 0,0:32:02.90,0:32:04.78,英文,,0,0,0,,I need to add two numbers.
Dialogue: 0,0:32:02.90,0:32:04.78,中文,,0,0,0,,我需要添加两个数字
Dialogue: 0,0:32:04.78,0:32:08.00,英文,,0,0,0,,Try and think in your mind what numbers I'm about to call out.
Dialogue: 0,0:32:04.78,0:32:08.00,中文,,0,0,0,,试着想一想我接下来要喊出哪些数字
Dialogue: 0,0:32:08.00,0:32:13.04,英文,,0,0,0,,So I need to figure out, how much does it cost to get to B?
Dialogue: 0,0:32:08.00,0:32:13.04,中文,,0,0,0,,那么我需要想一想到B要花多少钱
Dialogue: 0,0:32:13.04,0:32:13.58,英文,,0,0,0,,2.
Dialogue: 0,0:32:13.04,0:32:13.58,中文,,0,0,0,,2
Dialogue: 0,0:32:13.58,0:32:14.32,英文,,0,0,0,,How do I know that?
Dialogue: 0,0:32:13.58,0:32:14.32,中文,,0,0,0,,我怎么知道
Dialogue: 0,0:32:14.32,0:32:15.22,英文,,0,0,0,,Because that's what it says.
Dialogue: 0,0:32:14.32,0:32:15.22,中文,,0,0,0,,因为就是这么写的
Dialogue: 0,0:32:15.22,0:32:17.74,英文,,0,0,0,,The best known cost to B is 2.
Dialogue: 0,0:32:15.22,0:32:17.74,中文,,0,0,0,,到B的最佳估算成本是2
Dialogue: 0,0:32:17.74,0:32:19.01,英文,,0,0,0,,Then I need to add what?
Dialogue: 0,0:32:17.74,0:32:19.01,中文,,0,0,0,,然后我需要加什么
Dialogue: 0,0:32:19.01,0:32:26.65,英文,,0,0,0,,I need to add the cost of using this edge to get to C, because I want to get to C through B. That's what this edge is.
Dialogue: 0,0:32:19.01,0:32:26.65,中文,,0,0,0,,我需要添加使用这个边的成本来到达C因为我想通过B到达C这就是这个边的作用
Dialogue: 0,0:32:26.65,0:32:35.29,英文,,0,0,0,,So I need to add 2, the cost of B, plus 5, the additional cost to get to C. And I get 2 plus 5, 7.
Dialogue: 0,0:32:26.65,0:32:35.29,中文,,0,0,0,,我需要加上2B的成本再加上5到达C的额外成本然后我得到2加57
Dialogue: 0,0:32:35.29,0:32:37.83,英文,,0,0,0,,And here comes the actually interesting thing.
Dialogue: 0,0:32:35.29,0:32:37.83,中文,,0,0,0,,这里就是真正有趣的地方
Dialogue: 0,0:32:37.83,0:32:39.75,英文,,0,0,0,,I know a lot of infinities have been compared to.
Dialogue: 0,0:32:37.83,0:32:39.75,中文,,0,0,0,,我知道很多无穷大都被比较过了
Dialogue: 0,0:32:39.75,0:32:40.63,英文,,0,0,0,,It's kind of boring.
Dialogue: 0,0:32:39.75,0:32:40.63,中文,,0,0,0,,这有点无聊
Dialogue: 0,0:32:40.63,0:32:56.60,英文,,0,0,0,,But this one's interesting, because I'm comparing 7, which is the cost of using this edge, against 1, which was the original best-known cost of getting to C. So do you want to admit this edge into the shortest paths tree, the family?
Dialogue: 0,0:32:40.63,0:32:56.60,中文,,0,0,0,,但这个有趣因为我在比较7这是使用这个边的成本对比1那是到达C的原始最佳已知成本那么你想要把这个边纳入最短路径树家族中吗
Dialogue: 0,0:32:56.60,0:32:59.28,英文,,0,0,0,,Who wants this edge to join the group?
Dialogue: 0,0:32:56.60,0:32:59.28,中文,,0,0,0,,谁想要这个边加入到组中
Dialogue: 0,0:32:59.28,0:33:01.37,英文,,0,0,0,,Who does not like this edge and does not want it to join?
Dialogue: 0,0:32:59.28,0:33:01.37,中文,,0,0,0,,谁不喜欢这条边不想让它加入
Dialogue: 0,0:33:01.37,0:33:02.29,英文,,0,0,0,,I agree.
Dialogue: 0,0:33:01.37,0:33:02.29,中文,,0,0,0,,我同意
Dialogue: 0,0:33:02.29,0:33:04.51,英文,,0,0,0,,This edge, you do not get to join.
Dialogue: 0,0:33:02.29,0:33:04.51,中文,,0,0,0,,这条边你不能加入
Dialogue: 0,0:33:04.51,0:33:12.85,英文,,0,0,0,,Because I already had a better way to get to C. This edge would be a worse way to get to C. So this relaxation fails.
Dialogue: 0,0:33:04.51,0:33:12.85,中文,,0,0,0,,因为我已经有了更好的方法去C这条边会是一个更糟糕的方法去C所以这种放弃是失败的
Dialogue: 0,0:33:12.85,0:33:21.93,英文,,0,0,0,,I do not visit C. So look, when I bold a bunch of edges, 11 joins, 3 joins, this edge of weight 5, no joining.
Dialogue: 0,0:33:12.85,0:33:21.93,中文,,0,0,0,,我不访问C看当我加粗了一堆边11个加入3个加入这条边权重为5没有加入
Dialogue: 0,0:33:21.93,0:33:23.39,英文,,0,0,0,,We don't like you.
Dialogue: 0,0:33:21.93,0:33:23.39,中文,,0,0,0,,我们不喜欢你
Dialogue: 0,0:33:23.39,0:33:23.97,英文,,0,0,0,,You suck.
Dialogue: 0,0:33:23.39,0:33:23.97,中文,,0,0,0,,你很糟糕
Dialogue: 0,0:33:23.97,0:33:24.47,英文,,0,0,0,,Sorry.
Dialogue: 0,0:33:23.97,0:33:24.47,中文,,0,0,0,,抱歉
Dialogue: 0,0:33:24.47,0:33:26.51,英文,,0,0,0,,OK.
Dialogue: 0,0:33:26.51,0:33:27.45,英文,,0,0,0,,Let's keep going.
Dialogue: 0,0:33:26.51,0:33:27.45,中文,,0,0,0,,我们继续
Dialogue: 0,0:33:27.45,0:33:32.49,英文,,0,0,0,,So again, I need to pick another edge or another vertex and then relax all of its outgoing edges.
Dialogue: 0,0:33:27.45,0:33:32.49,中文,,0,0,0,,我需要再次选择另一个边或另一个顶点然后放弃其所有的出边
Dialogue: 0,0:33:32.49,0:33:34.45,英文,,0,0,0,,And again, we are going best first.
Dialogue: 0,0:33:32.49,0:33:34.45,中文,,0,0,0,,而且我们再次采用最佳优先搜索
Dialogue: 0,0:33:34.45,0:33:37.03,英文,,0,0,0,,So I look. Marked, marked, marked.
Dialogue: 0,0:33:34.45,0:33:37.03,中文,,0,0,0,,所以我看 标记了标记了标记了
Dialogue: 0,0:33:37.03,0:33:39.72,英文,,0,0,0,,No point exploring those again.
Dialogue: 0,0:33:37.03,0:33:39.72,中文,,0,0,0,,别再探索那些了
Dialogue: 0,0:33:39.72,0:33:41.34,英文,,0,0,0,,13, 5, 16, infinity.
Dialogue: 0,0:33:39.72,0:33:41.34,中文,,0,0,0,,13、5、16、无穷
Dialogue: 0,0:33:41.34,0:33:46.48,英文,,0,0,0,,I like E next because it's the closest one that I haven't explored yet.
Dialogue: 0,0:33:41.34,0:33:46.48,中文,,0,0,0,,我喜欢接下来的E因为它是我还没有探索过的最近的一个
Dialogue: 0,0:33:46.48,0:33:51.36,英文,,0,0,0,,So let's go relaxing from E. There are three edges to relax.
Dialogue: 0,0:33:46.48,0:33:51.36,中文,,0,0,0,,那我们就从E开始放弃一下有三条边需要放弃
Dialogue: 0,0:33:51.36,0:33:56.19,英文,,0,0,0,,I want you to tell me which ones join the family and which ones do not.
Dialogue: 0,0:33:51.36,0:33:56.19,中文,,0,0,0,,我希望你告诉我哪些边加入了家庭哪些没有
Dialogue: 0,0:33:56.19,0:33:57.81,英文,,0,0,0,,I'll start with the easy one.
Dialogue: 0,0:33:56.19,0:33:57.81,中文,,0,0,0,,我从简单的开始
Dialogue: 0,0:33:57.81,0:34:08.84,英文,,0,0,0,,e to g. So first think about what numbers you have to compare, and then tell me if e to g gets to join the family of the shortest edges or the edges in the shortest path tree.
Dialogue: 0,0:33:57.81,0:34:08.84,中文,,0,0,0,,E到G首先想想你需要比较的数字然后告诉我E到G是否加入了最短边的家庭或最短路径树的边
Dialogue: 0,0:34:08.84,0:34:12.24,英文,,0,0,0,,Who wants to admit e to g and let it join?
Dialogue: 0,0:34:08.84,0:34:12.24,中文,,0,0,0,,谁想要承认e到g然后让它加入
Dialogue: 0,0:34:12.24,0:34:15.22,英文,,0,0,0,,Who does not like e to g and does not want it to join?
Dialogue: 0,0:34:12.24,0:34:15.22,中文,,0,0,0,,谁不喜欢e到g并且不想让它加入
Dialogue: 0,0:34:15.22,0:34:21.75,英文,,0,0,0,,OK, so the numbers I compare are, if I go through E, then the total cost is 5 plus 5 is 10.
Dialogue: 0,0:34:15.22,0:34:21.75,中文,,0,0,0,,我比较的数字是如果我经过E那么总成本是5加5得10
Dialogue: 0,0:34:21.75,0:34:24.81,英文,,0,0,0,,That's better than the best known cost of G, which is infinity.
Dialogue: 0,0:34:21.75,0:34:24.81,中文,,0,0,0,,这比已知的G的最佳成本好那是无穷大
Dialogue: 0,0:34:24.81,0:34:26.25,英文,,0,0,0,,So I like this edge.
Dialogue: 0,0:34:24.81,0:34:26.25,中文,,0,0,0,,我喜欢这条边
Dialogue: 0,0:34:26.25,0:34:30.01,英文,,0,0,0,,E to G, you are admitted to the shortest path street.
Dialogue: 0,0:34:26.25,0:34:30.01,中文,,0,0,0,,E到G你被录取进了最短路径街
Dialogue: 0,0:34:30.01,0:34:32.19,英文,,0,0,0,,What about this one?
Dialogue: 0,0:34:30.01,0:34:32.19,中文,,0,0,0,,这个呢
Dialogue: 0,0:34:32.19,0:34:35.54,英文,,0,0,0,,F, sorry, E to C.
Dialogue: 0,0:34:32.19,0:34:35.54,中文,,0,0,0,,抱歉E 到 C
Dialogue: 0,0:34:35.54,0:34:37.94,英文,,0,0,0,,So this edge, who would like this edge?
Dialogue: 0,0:34:35.54,0:34:37.94,中文,,0,0,0,,这个边谁想要这个边
Dialogue: 0,0:34:37.94,0:34:45.60,英文,,0,0,0,,And remember, you've got to add two numbers, then compare it to the best known cost to C. So tell me, who wants to add E to C to the family?
Dialogue: 0,0:34:37.94,0:34:45.60,中文,,0,0,0,,记住你得加两个数字然后把它与到达 C 的已知最佳成本进行比较那么告诉我谁想把 E 加到 C 到家庭里
Dialogue: 0,0:34:45.60,0:34:47.43,英文,,0,0,0,,Who does not want to add it?
Dialogue: 0,0:34:45.60,0:34:47.43,中文,,0,0,0,,谁不想加进去
Dialogue: 0,0:34:47.43,0:34:48.11,英文,,0,0,0,,I agree.
Dialogue: 0,0:34:47.43,0:34:48.11,中文,,0,0,0,,我同意
Dialogue: 0,0:34:48.11,0:34:56.11,英文,,0,0,0,,This edge, you are ass, because E to C, well, to get to E, it costs 5.
Dialogue: 0,0:34:48.11,0:34:56.11,中文,,0,0,0,,这条边你很傻因为从 E 到 C到达 E 的成本是 5
Dialogue: 0,0:34:56.11,0:35:02.25,英文,,0,0,0,,Then I need to pay an extra 1 to get to C. So the total cost going through E is 6.
Dialogue: 0,0:34:56.11,0:35:02.25,中文,,0,0,0,,然后我需要额外付 1 到达 C通过 E 的总成本是 6
Dialogue: 0,0:35:02.25,0:35:07.16,英文,,0,0,0,,But I already had a way to get to CF cost 1, so I do not want to use this edge.
Dialogue: 0,0:35:02.25,0:35:07.16,中文,,0,0,0,,但我已经有一种方法可以到达 CF 成本为 1我不想使用这个边
Dialogue: 0,0:35:07.16,0:35:09.02,英文,,0,0,0,,You are not admitted to the family.
Dialogue: 0,0:35:07.16,0:35:09.02,中文,,0,0,0,,你没有被允许加入这个家庭
Dialogue: 0,0:35:09.02,0:35:11.36,英文,,0,0,0,,Go home and think about your choices.
Dialogue: 0,0:35:09.02,0:35:11.36,中文,,0,0,0,,回家好好想想你的选择
Dialogue: 0,0:35:11.36,0:35:12.42,英文,,0,0,0,,OK.
Dialogue: 0,0:35:12.42,0:35:13.42,英文,,0,0,0,,What about this final edge?
Dialogue: 0,0:35:12.42,0:35:13.42,中文,,0,0,0,,这最后一条边呢
Dialogue: 0,0:35:13.42,0:35:14.76,英文,,0,0,0,,This one's kind of interesting.
Dialogue: 0,0:35:13.42,0:35:14.76,中文,,0,0,0,,这个有点有趣
Dialogue: 0,0:35:14.76,0:35:20.04,英文,,0,0,0,,So E to F. Again, think about the two numbers you have to add.
Dialogue: 0,0:35:14.76,0:35:20.04,中文,,0,0,0,,所以 E 到 F再次考虑你需要加的两个数字
Dialogue: 0,0:35:20.04,0:35:25.10,英文,,0,0,0,,If I use this edge to get to F, what is the total cost to get to F?
Dialogue: 0,0:35:20.04,0:35:25.10,中文,,0,0,0,,如果我使用这条边到达 F到达 F 的总成本是多少
Dialogue: 0,0:35:25.10,0:35:32.40,英文,,0,0,0,,So the numbers I think we need to add are 5, because that's the best known way to get to E, plus 4 for using this edge, I get 9.
Dialogue: 0,0:35:25.10,0:35:32.40,中文,,0,0,0,,我认为我们需要相加的数字是 5因为那是到达 E 的最佳已知方式再加上使用这条边的 4我得到了 9
Dialogue: 0,0:35:32.40,0:35:34.62,英文,,0,0,0,,Every time I relax, I've got to add two numbers.
Dialogue: 0,0:35:32.40,0:35:34.62,中文,,0,0,0,,每次我放弃时我都得加两个数字
Dialogue: 0,0:35:34.62,0:35:37.82,英文,,0,0,0,,So 9, is it better than 16?
Dialogue: 0,0:35:34.62,0:35:37.82,中文,,0,0,0,,那么 9比 16 好吗
Dialogue: 0,0:35:37.82,0:35:38.92,英文,,0,0,0,,I think it is.
Dialogue: 0,0:35:37.82,0:35:38.92,中文,,0,0,0,,我认为是的
Dialogue: 0,0:35:38.92,0:35:44.36,英文,,0,0,0,,So with that in mind, who wants to add E to F and admit it into the family?
Dialogue: 0,0:35:38.92,0:35:44.36,中文,,0,0,0,,考虑到这一点谁想要把 E 加到 F 并将其纳入家庭
Dialogue: 0,0:35:44.36,0:35:45.37,英文,,0,0,0,,Me too.
Dialogue: 0,0:35:44.36,0:35:45.37,中文,,0,0,0,,我也是
Dialogue: 0,0:35:45.37,0:35:47.57,英文,,0,0,0,,So this gets to enter the family.
Dialogue: 0,0:35:45.37,0:35:47.57,中文,,0,0,0,,这个可以加入家庭了
Dialogue: 0,0:35:47.57,0:35:49.55,英文,,0,0,0,,But this is the critical part right here.
Dialogue: 0,0:35:47.57,0:35:49.55,中文,,0,0,0,,但这里才是关键部分
Dialogue: 0,0:35:49.55,0:36:00.30,英文,,0,0,0,,This is the part where you have to be brave and trust the algorithm, which is, if I add e to f to the family, well, there was already a way to get to f. It was using this 15 edge.
Dialogue: 0,0:35:49.55,0:36:00.30,中文,,0,0,0,,这是你必须勇敢并相信算法的部分如果我把 E 添加到 F 到家庭里那么其实已经有一种方法可以到达 F它是使用这个 15 边
Dialogue: 0,0:36:00.30,0:36:01.54,英文,,0,0,0,,But guess what?
Dialogue: 0,0:36:00.30,0:36:01.54,中文,,0,0,0,,但猜猜看
Dialogue: 0,0:36:01.54,0:36:03.08,英文,,0,0,0,,This 15?
Dialogue: 0,0:36:01.54,0:36:03.08,中文,,0,0,0,,这个 15
Dialogue: 0,0:36:03.08,0:36:09.49,英文,,0,0,0,,You are no longer part of the family, because I found a better way to get to f. And that was to use this edge right here.
Dialogue: 0,0:36:03.08,0:36:09.49,中文,,0,0,0,,你不再是家庭的一部分了因为我找到了一个更好的到达 F 的方法那就是使用这个边
Dialogue: 0,0:36:09.49,0:36:12.91,英文,,0,0,0,,So look, 15, you used to be part of the family.
Dialogue: 0,0:36:09.49,0:36:12.91,中文,,0,0,0,,看15你曾经是家庭的一部分
Dialogue: 0,0:36:12.91,0:36:21.78,英文,,0,0,0,,You used to be the best known way to get to f. But now, I found a better way to get to f, which is to use this 5 plus 4 of total distance 9.
Dialogue: 0,0:36:12.91,0:36:21.78,中文,,0,0,0,,你以前是到达 F 的最佳方式但现在我找到了一个更好的方法来到达 F就是使用这个总距离为 9 的 5 + 4
Dialogue: 0,0:36:21.78,0:36:24.42,英文,,0,0,0,,So this edge of weight 15.
Dialogue: 0,0:36:21.78,0:36:24.42,中文,,0,0,0,,这条边的权重是 15
Dialogue: 0,0:36:24.42,0:36:28.13,英文,,0,0,0,,We thought you were good at first, but it turns out you also suck.
Dialogue: 0,0:36:24.42,0:36:28.13,中文,,0,0,0,,我们一开始以为你很厉害但事实证明你也很糟糕
Dialogue: 0,0:36:28.13,0:36:29.21,英文,,0,0,0,,So goodbye.
Dialogue: 0,0:36:28.13,0:36:29.21,中文,,0,0,0,,再见
Dialogue: 0,0:36:29.21,0:36:30.39,英文,,0,0,0,,You are gone.
Dialogue: 0,0:36:29.21,0:36:30.39,中文,,0,0,0,,你走了
Dialogue: 0,0:36:30.39,0:36:31.88,英文,,0,0,0,,Look, I unbolded it.
Dialogue: 0,0:36:30.39,0:36:31.88,中文,,0,0,0,,看我把它取消加粗了
Dialogue: 0,0:36:31.88,0:36:32.78,英文,,0,0,0,,So it's gone.
Dialogue: 0,0:36:31.88,0:36:32.78,中文,,0,0,0,,它消失了
Dialogue: 0,0:36:32.78,0:36:34.06,英文,,0,0,0,,I kicked it out.
Dialogue: 0,0:36:32.78,0:36:34.06,中文,,0,0,0,,我把它踢出去了
Dialogue: 0,0:36:34.06,0:36:36.08,英文,,0,0,0,,You are no longer part of the tree.
Dialogue: 0,0:36:34.06,0:36:36.08,中文,,0,0,0,,你不再是树的一部分了
Dialogue: 0,0:36:36.08,0:36:38.09,英文,,0,0,0,,So that's something we have to be able to do.
Dialogue: 0,0:36:36.08,0:36:38.09,中文,,0,0,0,,这是我们必须能够做的事情
Dialogue: 0,0:36:38.09,0:36:39.75,英文,,0,0,0,,That was our second improvement.
Dialogue: 0,0:36:38.09,0:36:39.75,中文,,0,0,0,,那是我们的第二次改进
Dialogue: 0,0:36:39.75,0:36:41.99,英文,,0,0,0,,So our first improvement was go best first.
Dialogue: 0,0:36:39.75,0:36:41.99,中文,,0,0,0,,我们的第一次改进是最佳优先
Dialogue: 0,0:36:41.99,0:36:49.57,英文,,0,0,0,,Our second improvement is we have to be brave enough to kick out edges if we find a better way to get to a vertex.
Dialogue: 0,0:36:41.99,0:36:49.57,中文,,0,0,0,,我们的第二个改进是如果我们找到了更好的方法到达一个顶点我们必须勇敢地踢出边缘
Dialogue: 0,0:36:49.57,0:36:54.73,英文,,0,0,0,,In this case, I found a better way to get to F, so I abandoned this edge.
Dialogue: 0,0:36:49.57,0:36:54.73,中文,,0,0,0,,在这种情况下我找到了一种更好的方法去F所以我放弃了这条边
Dialogue: 0,0:36:54.73,0:36:55.65,英文,,0,0,0,,You suck.
Dialogue: 0,0:36:54.73,0:36:55.65,中文,,0,0,0,,你很糟糕
Dialogue: 0,0:36:55.65,0:36:56.53,英文,,0,0,0,,Go away.
Dialogue: 0,0:36:55.65,0:36:56.53,中文,,0,0,0,,走开
Dialogue: 0,0:36:56.53,0:36:56.97,英文,,0,0,0,,Go home.
Dialogue: 0,0:36:56.53,0:36:56.97,中文,,0,0,0,,回家吧
Dialogue: 0,0:36:56.97,0:37:02.32,英文,,0,0,0,,And think about your choices, because you are not the best way to get to F.
Dialogue: 0,0:36:56.97,0:37:02.32,中文,,0,0,0,,好好考虑一下你的选择因为你不是到达 F 的最佳方式
Dialogue: 0,0:37:02.32,0:37:04.46,英文,,0,0,0,,OK, so I'm going to speed through the last few.
Dialogue: 0,0:37:02.32,0:37:04.46,中文,,0,0,0,,我会快速浏览一下最后几个
Dialogue: 0,0:37:04.46,0:37:08.52,英文,,0,0,0,,I have two vertices that I have not visited yet.
Dialogue: 0,0:37:04.46,0:37:08.52,中文,,0,0,0,,我有两个顶点还没访问过
Dialogue: 0,0:37:08.52,0:37:09.60,英文,,0,0,0,,This one has 10.
Dialogue: 0,0:37:08.52,0:37:09.60,中文,,0,0,0,,这个有 10 个
Dialogue: 0,0:37:09.60,0:37:10.94,英文,,0,0,0,,This one has weight 13.
Dialogue: 0,0:37:09.60,0:37:10.94,中文,,0,0,0,,这个的权重是13
Dialogue: 0,0:37:10.94,0:37:13.74,英文,,0,0,0,,I'm going to do 10 first, because I want to go best first.
Dialogue: 0,0:37:10.94,0:37:13.74,中文,,0,0,0,,我要先做10因为我想先做最好的
Dialogue: 0,0:37:13.74,0:37:18.39,英文,,0,0,0,,So I start at G. And here's another one where I need to compare two numbers.
Dialogue: 0,0:37:13.74,0:37:18.39,中文,,0,0,0,,我从G开始还有一个地方我需要比较两个数字
Dialogue: 0,0:37:18.39,0:37:19.59,英文,,0,0,0,,How do I get to D?
Dialogue: 0,0:37:18.39,0:37:19.59,中文,,0,0,0,,我怎么去D
Dialogue: 0,0:37:19.59,0:37:24.71,英文,,0,0,0,,Well, if I go through G, it costs me 10 to get to G. That's what the number says.
Dialogue: 0,0:37:19.59,0:37:24.71,中文,,0,0,0,,好吧如果我经过G到G的花费是10这就是数字所说的
Dialogue: 0,0:37:24.71,0:37:28.51,英文,,0,0,0,,Plus 1 to get to D for a total of 11.
Dialogue: 0,0:37:24.71,0:37:28.51,中文,,0,0,0,,再加1到D总共是11
Dialogue: 0,0:37:28.51,0:37:33.21,英文,,0,0,0,,Well, my original best-known way to get to D was 13, and 11 is better.
Dialogue: 0,0:37:28.51,0:37:33.21,中文,,0,0,0,,我的最初的最佳方法到达D是13而11更好
Dialogue: 0,0:37:33.21,0:37:40.75,英文,,0,0,0,,So here's another case where we have to be brave, and we have to say, this edge right here that I am relaxing, this is a better way to get to D.
Dialogue: 0,0:37:33.21,0:37:40.75,中文,,0,0,0,,这里又是另一个情况我们必须勇敢一点必须说我正在放弃的这条边这是到达D的更好方式
Dialogue: 0,0:37:40.75,0:37:45.75,英文,,0,0,0,,Originally, I thought this was the way to D, but I just found something better.
Dialogue: 0,0:37:40.75,0:37:45.75,中文,,0,0,0,,最初我以为这是到达D的方法但我刚发现了更好的方法
Dialogue: 0,0:37:45.75,0:37:55.33,英文,,0,0,0,,So the original way to get to D, this edge right here from B to D, I'm sorry, but you suck, and you need to go away because I found a better way to get to D.
Dialogue: 0,0:37:45.75,0:37:55.33,中文,,0,0,0,,原来到达D的方法就是从B到D的这条边现在不行你需要离开因为我找到了一个更好的到达D的方法
Dialogue: 0,0:37:55.33,0:38:03.33,英文,,0,0,0,,So it's kind of a mean algorithm, but it does the job as long as you're willing to always kick out edges if you find someone better.
Dialogue: 0,0:37:55.33,0:38:03.33,中文,,0,0,0,,这有点刻薄的算法但只要你愿意它就能完成任务总是把不好的边赶走
Dialogue: 0,0:38:03.33,0:38:05.37,英文,,0,0,0,,That's the process of relaxation.
Dialogue: 0,0:38:03.33,0:38:05.37,中文,,0,0,0,,这就是放弃的过程
Dialogue: 0,0:38:05.37,0:38:07.53,英文,,0,0,0,,That is what makes Dijkstra's tick.
Dialogue: 0,0:38:05.37,0:38:07.53,中文,,0,0,0,,这就是迪杰斯特拉算法的奥秘所在
Dialogue: 0,0:38:07.53,0:38:11.65,英文,,0,0,0,,So it really is just the relaxation operation over and over and over and over again.
Dialogue: 0,0:38:07.53,0:38:11.65,中文,,0,0,0,,实际上就是一次又一次的放弃操作
Dialogue: 0,0:38:11.65,0:38:13.51,英文,,0,0,0,,You're going to get super comfortable with it.
Dialogue: 0,0:38:11.65,0:38:13.51,中文,,0,0,0,,你会对它变得非常熟悉
Dialogue: 0,0:38:13.51,0:38:14.59,英文,,0,0,0,,But that's the idea.
Dialogue: 0,0:38:13.51,0:38:14.59,中文,,0,0,0,,但这就是想法
Dialogue: 0,0:38:14.59,0:38:15.99,英文,,0,0,0,,You add two numbers.
Dialogue: 0,0:38:14.59,0:38:15.99,中文,,0,0,0,,你加两个数字
Dialogue: 0,0:38:15.99,0:38:27.96,英文,,0,0,0,,And if the sum of those two numbers, the way to get to the vertex, is better than whatever you had earlier, add it to the family, potentially kick out some older, worse way to get to that vertex.
Dialogue: 0,0:38:15.99,0:38:27.96,中文,,0,0,0,,如果这两个数字的和达到顶点的方式比你之前拥有的任何方式都好就将其添加到族群中可能会淘汰一些老旧、更糟糕的达到该顶点的方式
Dialogue: 0,0:38:27.96,0:38:29.50,英文,,0,0,0,,OK, and now every node is marked.
Dialogue: 0,0:38:27.96,0:38:29.50,中文,,0,0,0,,现在每个节点都标记了
Dialogue: 0,0:38:29.50,0:38:30.82,英文,,0,0,0,,We've been everywhere.
Dialogue: 0,0:38:29.50,0:38:30.82,中文,,0,0,0,,我们已经走遍了每个地方
Dialogue: 0,0:38:30.82,0:38:32.80,英文,,0,0,0,,This final relaxation will fail.
Dialogue: 0,0:38:30.82,0:38:32.80,中文,,0,0,0,,这最后的放弃会失败
Dialogue: 0,0:38:32.80,0:38:36.70,英文,,0,0,0,,So we found our shortest path tree.
Dialogue: 0,0:38:32.80,0:38:36.70,中文,,0,0,0,,我们找到了我们的最短路径树
Dialogue: 0,0:38:36.70,0:38:38.25,英文,,0,0,0,,OK.
Dialogue: 0,0:38:38.25,0:38:38.97,英文,,0,0,0,,Great.
Dialogue: 0,0:38:38.97,0:38:46.01,英文,,0,0,0,,So a couple of final things I will call out is, remember, we need to use our distance2 and edge2 arrays.
Dialogue: 0,0:38:38.97,0:38:46.01,中文,,0,0,0,,最后要提醒的一点是记住我们需要使用我们的 distTo 和 edgeTo 数组
Dialogue: 0,0:38:46.01,0:38:50.80,英文,,0,0,0,,And this is just because, in code, I can't be bolding lines.
Dialogue: 0,0:38:46.01,0:38:50.80,中文,,0,0,0,,这只是因为在代码中我不能够加粗行
Dialogue: 0,0:38:50.80,0:38:55.44,英文,,0,0,0,,If I'm writing a piece of Java code, I can't be like, bold the line and unbold the line.
Dialogue: 0,0:38:50.80,0:38:55.44,中文,,0,0,0,,如果我写了一段 Java 代码我不能像这样加粗行然后取消加粗
Dialogue: 0,0:38:55.44,0:38:56.54,英文,,0,0,0,,That doesn't make sense.
Dialogue: 0,0:38:55.44,0:38:56.54,中文,,0,0,0,,那没有意义
Dialogue: 0,0:38:56.54,0:39:01.98,英文,,0,0,0,,So we're going to use the edge2 array to keep track of the best known way to get to every vertex.
Dialogue: 0,0:38:56.54,0:39:01.98,中文,,0,0,0,,我们将使用 edgeTo 数组来跟踪到达每个顶点的最佳已知方法
Dialogue: 0,0:39:01.98,0:39:04.88,英文,,0,0,0,,So for example, let's pause, I don't know, right here.
Dialogue: 0,0:39:01.98,0:39:04.88,中文,,0,0,0,,举个例子让我们停一下我不知道就在这里
Dialogue: 0,0:39:04.88,0:39:06.88,英文,,0,0,0,,What is the best known way to E?
Dialogue: 0,0:39:04.88,0:39:06.88,中文,,0,0,0,,什么是到达 E 的最佳已知方式
Dialogue: 0,0:39:06.88,0:39:13.48,英文,,0,0,0,,According to the H208 array, the best known way to get to E is through B. We've seen that before.
Dialogue: 0,0:39:06.88,0:39:13.48,中文,,0,0,0,,根据 H208 数组到达 E 的最佳已知方式是通过 B我们以前见过这种情况
Dialogue: 0,0:39:13.48,0:39:18.72,英文,,0,0,0,,Also, when I write these pink numbers, you can't go into Java and be like, make the number pink.
Dialogue: 0,0:39:13.48,0:39:18.72,中文,,0,0,0,,而且当我写这些粉色数字时你不能进入 Java 并说让数字变成粉色
Dialogue: 0,0:39:18.72,0:39:19.76,英文,,0,0,0,,That doesn't work.
Dialogue: 0,0:39:18.72,0:39:19.76,中文,,0,0,0,,那行不通
Dialogue: 0,0:39:19.76,0:39:25.81,英文,,0,0,0,,Instead, we're going to use the distanceTo array to tell me the best known distance to every vertex.
Dialogue: 0,0:39:19.76,0:39:25.81,中文,,0,0,0,,相反我们将使用 distanceTo 数组来告诉我到每个顶点的最佳已知距离
Dialogue: 0,0:39:25.81,0:39:33.93,英文,,0,0,0,,So for example, right now, the pink number associated with d, the best known way to get to d, has weight 13.
Dialogue: 0,0:39:25.81,0:39:33.93,中文,,0,0,0,,例如现在与 D 关联的粉色数字到达 D 的最佳已知方式权重为 13
Dialogue: 0,0:39:33.93,0:39:38.41,英文,,0,0,0,,So the distance to d, the best known distance, is 13.
Dialogue: 0,0:39:33.93,0:39:38.41,中文,,0,0,0,,所以到 D 的距离最佳已知距离是 13
Dialogue: 0,0:39:38.41,0:39:46.08,英文,,0,0,0,,One final improvement that we'll make, just to make the algorithm faster, you don't have to do this, but it makes the algorithm faster
Dialogue: 0,0:39:38.41,0:39:46.08,中文,,0,0,0,,我们最后会做一个改进只是为了让算法更快你不一定非要这样做但是这样做会让算法更快
Dialogue: 0,0:39:46.08,0:39:54.08,英文,,0,0,0,, so everyone does it, is, do you remember when we paused, like, right here, and I had to ask you, hey, what node do you want to explore next?
Dialogue: 0,0:39:46.08,0:39:54.08,中文,,0,0,0,,每个人都这样做你还记得我们暂停的时候就在这里然后我得问你嘿你想要探索哪个节点
Dialogue: 0,0:39:54.08,0:39:55.68,英文,,0,0,0,,And OK, maybe I'll pause somewhere else.
Dialogue: 0,0:39:54.08,0:39:55.68,中文,,0,0,0,,也许我会在别的地方暂停
Dialogue: 0,0:39:55.68,0:39:58.14,英文,,0,0,0,,OK, let's pause, I don't know, right here.
Dialogue: 0,0:39:55.68,0:39:58.14,中文,,0,0,0,,让我们暂停一下我也不知道就在这里吧
Dialogue: 0,0:39:58.14,0:40:02.36,英文,,0,0,0,,And let's say, I want you to tell me, what node do we explore next?
Dialogue: 0,0:39:58.14,0:40:02.36,中文,,0,0,0,,假设我想让你告诉我我们接下来要探索哪个节点
Dialogue: 0,0:40:02.36,0:40:04.71,英文,,0,0,0,,And I was like, do you want 0?
Dialogue: 0,0:40:02.36,0:40:04.71,中文,,0,0,0,,我就像你想要0吗
Dialogue: 0,0:40:04.71,0:40:06.23,英文,,0,0,0,,Do you want 2?
Dialogue: 0,0:40:04.71,0:40:06.23,中文,,0,0,0,,你想要2吗
Dialogue: 0,0:40:06.23,0:40:09.25,英文,,0,0,0,,Do you want A, B, C, D, E, F, G?
Dialogue: 0,0:40:06.23,0:40:09.25,中文,,0,0,0,,你想要ABCDEFG吗
Dialogue: 0,0:40:09.25,0:40:12.75,英文,,0,0,0,,And I want you to find the node with the smallest pink number.
Dialogue: 0,0:40:09.25,0:40:12.75,中文,,0,0,0,,而且我想你找到带有最小粉红色数字的节点
Dialogue: 0,0:40:12.75,0:40:21.33,英文,,0,0,0,,You can do that, but that's going to be slow, because you need to check every single node to find the node with the smallest number, which in this particular slide is E.
Dialogue: 0,0:40:12.75,0:40:21.33,中文,,0,0,0,,你可以这样做但这会很慢因为你需要检查每个单独的节点找到具有最小数字的节点而在这个特定的幻灯片中是E
Dialogue: 0,0:40:21.33,0:40:24.94,英文,,0,0,0,,So to make it faster, I'm actually going to use a priority queue.
Dialogue: 0,0:40:21.33,0:40:24.94,中文,,0,0,0,,为了让它更快我实际上要使用优先队列
Dialogue: 0,0:40:24.94,0:40:31.56,英文,,0,0,0,,And the priority queue is going to let me very quickly find the node that is the closest that I have not explored so far.
Dialogue: 0,0:40:24.94,0:40:31.56,中文,,0,0,0,,优先队列会让我非常快速地找到到目前为止未探索的最接近的节点
Dialogue: 0,0:40:31.56,0:40:33.66,英文,,0,0,0,,So this time, I'm going to walk through it really quickly.
Dialogue: 0,0:40:31.56,0:40:33.66,中文,,0,0,0,,这次我会很快地浏览它
Dialogue: 0,0:40:33.66,0:40:38.97,英文,,0,0,0,,But this time, watch the priority queue at the bottom, which I have not called out until now.
Dialogue: 0,0:40:33.66,0:40:38.97,中文,,0,0,0,,但是这次请看底部的优先队列直到现在我还没有提到它
Dialogue: 0,0:40:38.97,0:40:45.11,英文,,0,0,0,,So at the beginning, B, C, D, E, F, G. I have not been to any of these nodes.
Dialogue: 0,0:40:38.97,0:40:45.11,中文,,0,0,0,,一开始BCDEFG我还没有去过这些节点
Dialogue: 0,0:40:45.11,0:40:46.71,英文,,0,0,0,,So look, they're all green.
Dialogue: 0,0:40:45.11,0:40:46.71,中文,,0,0,0,,你看它们都是绿色的
Dialogue: 0,0:40:46.71,0:40:47.57,英文,,0,0,0,,They've not been marked yet.
Dialogue: 0,0:40:46.71,0:40:47.57,中文,,0,0,0,,它们还没有被标记
Dialogue: 0,0:40:47.57,0:40:48.87,英文,,0,0,0,,I have not been to them.
Dialogue: 0,0:40:47.57,0:40:48.87,中文,,0,0,0,,我还没有去过它们
Dialogue: 0,0:40:48.87,0:40:53.67,英文,,0,0,0,,And they all have best known distance or priority of infinity.
Dialogue: 0,0:40:48.87,0:40:53.67,中文,,0,0,0,,它们都具有无穷远的最佳已知距离或优先级
Dialogue: 0,0:40:53.67,0:40:58.90,英文,,0,0,0,,Now I pull off one of the nodes, which is A. So I guess A wasn't there.
Dialogue: 0,0:40:53.67,0:40:58.90,中文,,0,0,0,,现在我拉出其中一个节点就是 A所以我猜 A 不在那里了
Dialogue: 0,0:40:58.90,0:41:00.84,英文,,0,0,0,,Some people put A there at the beginning.
Dialogue: 0,0:40:58.90,0:41:00.84,中文,,0,0,0,,有些人一开始就把 A 放在那里
Dialogue: 0,0:41:00.84,0:41:01.76,英文,,0,0,0,,Some people don't.
Dialogue: 0,0:41:00.84,0:41:01.76,中文,,0,0,0,,有些人则不这样做
Dialogue: 0,0:41:01.76,0:41:06.64,英文,,0,0,0,,But anyway, I'm going to pull off B. I could have pulled off any of these, but I'll choose B.
Dialogue: 0,0:41:01.76,0:41:06.64,中文,,0,0,0,,但无论如何我要执行B我本来可以执行任何一个但我会选择B
Dialogue: 0,0:41:06.64,0:41:08.08,英文,,0,0,0,,Then I update the priorities.
Dialogue: 0,0:41:06.64,0:41:08.08,中文,,0,0,0,,然后我更新优先级
Dialogue: 0,0:41:08.08,0:41:16.08,英文,,0,0,0,,So look, when this infinity got replaced by a 2 and this infinity got replaced by a 1, I will update the priorities in my priority queue.
Dialogue: 0,0:41:08.08,0:41:16.08,中文,,0,0,0,,看当这个无穷大被2替换这个无穷大被1替换时我会更新我的优先级队列
Dialogue: 0,0:41:16.08,0:41:20.10,英文,,0,0,0,,And then now, instead of looking at all the nodes and being like, should I look at A next?
Dialogue: 0,0:41:16.08,0:41:20.10,中文,,0,0,0,,然后现在不再是看所有的节点然后决定下一个应该看A吗
Dialogue: 0,0:41:20.10,0:41:21.19,英文,,0,0,0,,Should I look at B next?
Dialogue: 0,0:41:20.10,0:41:21.19,中文,,0,0,0,,下一个应该看B吗
Dialogue: 0,0:41:21.19,0:41:22.01,英文,,0,0,0,,Should I look at C next?
Dialogue: 0,0:41:21.19,0:41:22.01,中文,,0,0,0,,下一个应该看C吗
Dialogue: 0,0:41:22.01,0:41:23.15,英文,,0,0,0,,That's too slow.
Dialogue: 0,0:41:22.01,0:41:23.15,中文,,0,0,0,,那太慢了
Dialogue: 0,0:41:23.15,0:41:28.21,英文,,0,0,0,,But in the priority queue, look, it tells me who is the closest and has the best priority.
Dialogue: 0,0:41:23.15,0:41:28.21,中文,,0,0,0,,但是在优先队列中看它告诉我谁是最接近且优先级最高的
Dialogue: 0,0:41:28.21,0:41:31.71,英文,,0,0,0,,It's C. And the priority queue is going to make that quick.
Dialogue: 0,0:41:28.21,0:41:31.71,中文,,0,0,0,,就是C而优先队列会让这一切迅速进行
Dialogue: 0,0:41:31.71,0:41:33.93,英文,,0,0,0,,So look, I take C out of the fringe.
Dialogue: 0,0:41:31.71,0:41:33.93,中文,,0,0,0,,看我把C从边缘中取出来
Dialogue: 0,0:41:33.93,0:41:35.85,英文,,0,0,0,,I relax all of its outgoing edges.
Dialogue: 0,0:41:33.93,0:41:35.85,中文,,0,0,0,,我放弃所有它的出边
Dialogue: 0,0:41:35.85,0:41:38.23,英文,,0,0,0,,If I have to change any priorities, I will do so.
Dialogue: 0,0:41:35.85,0:41:38.23,中文,,0,0,0,,如果我必须改变任何优先级我会这么做
Dialogue: 0,0:41:38.23,0:41:41.00,英文,,0,0,0,,And then in the priority queue, I'll say, who's closest?
Dialogue: 0,0:41:38.23,0:41:41.00,中文,,0,0,0,,然后在优先队列中我会问谁是最接近的
Dialogue: 0,0:41:41.00,0:41:42.66,英文,,0,0,0,,Who should I explore next?
Dialogue: 0,0:41:41.00,0:41:42.66,中文,,0,0,0,,接下来我应该探索谁
Dialogue: 0,0:41:42.66,0:41:44.78,英文,,0,0,0,,I should explore B next.
Dialogue: 0,0:41:42.66,0:41:44.78,中文,,0,0,0,,我应该接着探索B
Dialogue: 0,0:41:44.78,0:41:49.38,英文,,0,0,0,,And the priority queue makes it very easy for me to find who has the best priority.
Dialogue: 0,0:41:44.78,0:41:49.38,中文,,0,0,0,,而且优先队列让我很容易找到谁有最高的优先级
Dialogue: 0,0:41:49.38,0:41:52.45,英文,,0,0,0,,So when I relax some nodes, I update the priorities.
Dialogue: 0,0:41:49.38,0:41:52.45,中文,,0,0,0,,当我放弃一些节点时我会更新优先级
Dialogue: 0,0:41:52.45,0:41:54.87,英文,,0,0,0,,And I ask the priority queue, who's next?
Dialogue: 0,0:41:52.45,0:41:54.87,中文,,0,0,0,,然后我问优先队列接下来是谁
Dialogue: 0,0:41:54.87,0:41:58.53,英文,,0,0,0,,And the priority queue says E has the lowest priority.
Dialogue: 0,0:41:54.87,0:41:58.53,中文,,0,0,0,,优先队列说E的优先级最低
Dialogue: 0,0:41:58.53,0:42:04.61,英文,,0,0,0,,So try and go explore and relax the edges coming out of E next.
Dialogue: 0,0:41:58.53,0:42:04.61,中文,,0,0,0,,试着去探索和放弃从E出来的边
Dialogue: 0,0:42:04.61,0:42:06.15,英文,,0,0,0,,Then I look at this priority queue.
Dialogue: 0,0:42:04.61,0:42:06.15,中文,,0,0,0,,然后我看看这个优先队列
Dialogue: 0,0:42:06.15,0:42:10.69,英文,,0,0,0,,And it says, well, now the lowest priority is F. So check out F next.
Dialogue: 0,0:42:06.15,0:42:10.69,中文,,0,0,0,,它说现在最低优先级是F所以下一步看看F
Dialogue: 0,0:42:10.69,0:42:12.21,英文,,0,0,0,,And then check out G next.
Dialogue: 0,0:42:10.69,0:42:12.21,中文,,0,0,0,,然后下一步看看G
Dialogue: 0,0:42:12.21,0:42:13.89,英文,,0,0,0,,And then check out D next.
Dialogue: 0,0:42:12.21,0:42:13.89,中文,,0,0,0,,然后下一步看看D
Dialogue: 0,0:42:13.89,0:42:19.80,英文,,0,0,0,,So the priority queue is just a faster way to look for which node to explore next.
Dialogue: 0,0:42:13.89,0:42:19.80,中文,,0,0,0,,优先队列只是一种更快的方式来查找下一个要探索的节点
Dialogue: 0,0:42:19.80,0:42:22.68,英文,,0,0,0,,And we add it because it makes things faster.
Dialogue: 0,0:42:19.80,0:42:22.68,中文,,0,0,0,,我们添加它是因为它可以加快速度
Dialogue: 0,0:42:22.68,0:42:30.01,英文,,0,0,0,,But for intuition, if you want to just look at the pink numbers and pick whoever's closest that you haven't explored yet, that will also be correct.
Dialogue: 0,0:42:22.68,0:42:30.01,中文,,0,0,0,,但就直觉而言如果你只想看看粉色数字并选择最接近但尚未探索的人那也是正确的
Dialogue: 0,0:42:30.01,0:42:35.91,英文,,0,0,0,,It's just not something you could code because I don't know how to tell Java about pink numbers.
Dialogue: 0,0:42:30.01,0:42:35.91,中文,,0,0,0,,只是这不是你可以编码的东西因为我不知道如何告诉Java关于粉色数字
Dialogue: 0,0:42:35.91,0:42:37.34,英文,,0,0,0,,OK.
Dialogue: 0,0:42:37.34,0:42:40.71,英文,,0,0,0,,That's it for Dijkstra's on how it runs.
Dialogue: 0,0:42:37.34,0:42:40.71,中文,,0,0,0,,Dijkstra算法的运行就是这样
Dialogue: 0,0:42:40.71,0:42:44.53,英文,,0,0,0,,So anything else you want to know about it before I tell you why it works?
Dialogue: 0,0:42:40.71,0:42:44.53,中文,,0,0,0,,那在我告诉你为什么它有效之前你还想知道别的什么吗
Dialogue: 0,0:42:44.53,0:42:54.84,英文,,0,0,0,,I'll give you a little sketch question.
Dialogue: 0,0:42:44.53,0:42:54.84,中文,,0,0,0,,我给你一个简单的示意问题
Dialogue: 0,0:42:54.84,0:43:07.68,英文,,0,0,0,,The question was, maybe I don't totally follow it.
Dialogue: 0,0:42:54.84,0:43:07.68,中文,,0,0,0,,问题是也许我不太理解
Dialogue: 0,0:43:07.68,0:43:08.14,英文,,0,0,0,,Ah, I see.
Dialogue: 0,0:43:07.68,0:43:08.14,中文,,0,0,0,,啊我明白了
Dialogue: 0,0:43:08.14,0:43:15.20,英文,,0,0,0,,So what if instead of using these pink numbers and say, who's closest to A, I explore who's closest to E?
Dialogue: 0,0:43:08.14,0:43:15.20,中文,,0,0,0,,如果我不是用这些粉色数字而是说谁离A最近我探索谁离E最近呢
Dialogue: 0,0:43:15.20,0:43:16.59,英文,,0,0,0,,You'd probably get different behavior.
Dialogue: 0,0:43:15.20,0:43:16.59,中文,,0,0,0,,你可能会遇到不同的行为
Dialogue: 0,0:43:16.59,0:43:23.79,英文,,0,0,0,,Because remember, one of the key ideas as we were building our way to the good algorithm was to use the best first order.
Dialogue: 0,0:43:16.59,0:43:23.79,中文,,0,0,0,,因为记住当我们逐步构建优秀算法的关键思想之一是使用最佳首次顺序
Dialogue: 0,0:43:23.79,0:43:28.39,英文,,0,0,0,,I want to keep this order, the order inspired by this little dummy node's idea.
Dialogue: 0,0:43:23.79,0:43:28.39,中文,,0,0,0,,我想保持这个顺序这个顺序受到了这个小虚拟节点想法的启发
Dialogue: 0,0:43:28.39,0:43:33.28,英文,,0,0,0,,I want to keep this order, because this guarantees I visit things that are closer
Dialogue: 0,0:43:28.39,0:43:33.28,中文,,0,0,0,,我想保持这个顺序因为这保证了我先访问更近的东西
Dialogue: 0,0:43:33.28,0:43:35.40,英文,,0,0,0,,before I visit things that are further.
Dialogue: 0,0:43:33.28,0:43:35.40,中文,,0,0,0,,在我访问更远的东西之前
Dialogue: 0,0:43:35.40,0:43:38.90,英文,,0,0,0,,That's what gives me the Dijkstra's algorithm's shortest paths.
Dialogue: 0,0:43:35.40,0:43:38.90,中文,,0,0,0,,这就是为什么我能得到迪杰斯特拉算法的最短路径
Dialogue: 0,0:43:38.90,0:43:48.21,英文,,0,0,0,,Because I care about things that are closer to A, so I should always look at things that are closer to A before I examine things that are further away from A. That's a good question.
Dialogue: 0,0:43:38.90,0:43:48.21,中文,,0,0,0,,因为我关心更接近A的东西我应该总是先看看更接近A的东西再去检查那些更远离A的东西这是个好问题
Dialogue: 0,0:43:48.21,0:43:52.95,英文,,0,0,0,,I guess you get different behavior if you tweak the algorithm a little bit.
Dialogue: 0,0:43:48.21,0:43:52.95,中文,,0,0,0,,我猜你稍微调整算法会得到不同的行为
Dialogue: 0,0:43:52.95,0:43:54.81,英文,,0,0,0,,OK, anything else you want to know?
Dialogue: 0,0:43:52.95,0:43:54.81,中文,,0,0,0,,还有其他你想知道的吗
Dialogue: 0,0:43:54.81,0:43:57.19,英文,,0,0,0,,Any burning questions on Zoom?
Dialogue: 0,0:43:54.81,0:43:57.19,中文,,0,0,0,,Zoom 有什么紧急问题吗
Dialogue: 0,0:43:57.19,0:43:58.00,英文,,0,0,0,,OK.
Dialogue: 0,0:43:58.00,0:44:00.06,英文,,0,0,0,,So here's some pseudocode.
Dialogue: 0,0:43:58.00,0:44:00.06,中文,,0,0,0,,这是一些伪代码
Dialogue: 0,0:44:00.06,0:44:02.00,英文,,0,0,0,,I will not talk about it in great detail.
Dialogue: 0,0:44:00.06,0:44:02.00,中文,,0,0,0,,我不会详细讨论它
Dialogue: 0,0:44:02.00,0:44:03.40,英文,,0,0,0,,This is what relaxation means.
Dialogue: 0,0:44:02.00,0:44:03.40,中文,,0,0,0,,这就是放弃的含义
Dialogue: 0,0:44:03.40,0:44:06.80,英文,,0,0,0,,Here's the little sum that I've been doing over and over and over again.
Dialogue: 0,0:44:03.40,0:44:06.80,中文,,0,0,0,,这就是我一遍又一遍做的小总结
Dialogue: 0,0:44:06.80,0:44:13.21,英文,,0,0,0,,Consider the distance to the incoming vertex plus the additional edge.
Dialogue: 0,0:44:06.80,0:44:13.21,中文,,0,0,0,,考虑到到达顶点的距离再加上额外的边
Dialogue: 0,0:44:13.21,0:44:14.23,英文,,0,0,0,,There's the sum.
Dialogue: 0,0:44:13.21,0:44:14.23,中文,,0,0,0,,这就是总和
Dialogue: 0,0:44:14.23,0:44:15.83,英文,,0,0,0,,And then tell me if it's better.
Dialogue: 0,0:44:14.23,0:44:15.83,中文,,0,0,0,,然后告诉我哪个更好
Dialogue: 0,0:44:15.83,0:44:16.93,英文,,0,0,0,,Then update the priority.
Dialogue: 0,0:44:15.83,0:44:16.93,中文,,0,0,0,,然后更新优先级
Dialogue: 0,0:44:16.93,0:44:18.35,英文,,0,0,0,,You've seen that all before.
Dialogue: 0,0:44:16.93,0:44:18.35,中文,,0,0,0,,你之前都见过
Dialogue: 0,0:44:18.35,0:44:21.77,英文,,0,0,0,,And I said, relax all the edges from every vertex.
Dialogue: 0,0:44:18.35,0:44:21.77,中文,,0,0,0,,然后我说放弃每个顶点的所有边
Dialogue: 0,0:44:21.77,0:44:24.83,英文,,0,0,0,,Visit the vertices in best first order.
Dialogue: 0,0:44:21.77,0:44:24.83,中文,,0,0,0,,按照最佳优先顺序访问顶点
Dialogue: 0,0:44:24.83,0:44:28.07,英文,,0,0,0,,Look at the closer ones first, then look at the further ones.
Dialogue: 0,0:44:24.83,0:44:28.07,中文,,0,0,0,,先看看更近的然后再看更远的
Dialogue: 0,0:44:28.07,0:44:30.15,英文,,0,0,0,,That is what guarantees best first order.
Dialogue: 0,0:44:28.07,0:44:30.15,中文,,0,0,0,,这就是保证最佳优先顺序的方法
Dialogue: 0,0:44:30.15,0:44:55.47,英文,,0,0,0,,Oh, another question.
Dialogue: 0,0:44:30.15,0:44:55.47,中文,,0,0,0,,哦又一个问题
Dialogue: 0,0:44:55.47,0:44:57.49,英文,,0,0,0,,Yeah, got it.
Dialogue: 0,0:44:55.47,0:44:57.49,中文,,0,0,0,,是的明白了
Dialogue: 0,0:44:57.49,0:44:59.23,英文,,0,0,0,,So a couple of clarifications of the priority queue.
Dialogue: 0,0:44:57.49,0:44:59.23,中文,,0,0,0,,对优先队列的一些澄清
Dialogue: 0,0:44:59.23,0:45:00.43,英文,,0,0,0,,Great questions, by the way.
Dialogue: 0,0:44:59.23,0:45:00.43,中文,,0,0,0,,顺便说一句问题很棒
Dialogue: 0,0:45:00.43,0:45:03.11,英文,,0,0,0,,So one question was, how does the queue start?
Dialogue: 0,0:45:00.43,0:45:03.11,中文,,0,0,0,,一个问题是队列是怎么开始的呢
Dialogue: 0,0:45:03.11,0:45:05.79,英文,,0,0,0,,It starts with every vertex I have not visited.
Dialogue: 0,0:45:03.11,0:45:05.79,中文,,0,0,0,,它是从我还没访问过的每个顶点开始的
Dialogue: 0,0:45:05.79,0:45:08.47,英文,,0,0,0,,And every time I visit a vertex, I remove it.
Dialogue: 0,0:45:05.79,0:45:08.47,中文,,0,0,0,,每次我访问一个顶点我就把它移除掉
Dialogue: 0,0:45:08.47,0:45:10.01,英文,,0,0,0,,So look, when I visit B, it is gone.
Dialogue: 0,0:45:08.47,0:45:10.01,中文,,0,0,0,,看当我访问 B 时它就消失了
Dialogue: 0,0:45:10.01,0:45:17.58,英文,,0,0,0,,I remove it from the fringe, and it will never appear again.
Dialogue: 0,0:45:10.01,0:45:17.58,中文,,0,0,0,,我把它从 fringe 中移除了它再也不会出现了
Dialogue: 0,0:45:17.58,0:45:21.48,英文,,0,0,0,,So in this particular implementation, I don't add more vertices into the fringe.
Dialogue: 0,0:45:17.58,0:45:21.48,中文,,0,0,0,,在这个特定的实现中我不会向 fringe 中添加更多的顶点
Dialogue: 0,0:45:21.48,0:45:27.35,英文,,0,0,0,,They are all there at the beginning, and then I slowly remove them one by one every time I visit a vertex.
Dialogue: 0,0:45:21.48,0:45:27.35,中文,,0,0,0,,它们一开始就都在那里然后每次我访问一个顶点时我慢慢地一个一个地移除它们
Dialogue: 0,0:45:27.35,0:45:31.39,英文,,0,0,0,,So if you look at the fringe, it's slowly losing nodes one by one.
Dialogue: 0,0:45:27.35,0:45:31.39,中文,,0,0,0,,如果你看一下边缘它正逐渐失去一个节点
Dialogue: 0,0:45:31.39,0:45:37.31,英文,,0,0,0,,And every time I find a better way to get to a node and I change one of these priorities, I need to change it in the fringe as well.
Dialogue: 0,0:45:31.39,0:45:37.31,中文,,0,0,0,,每次我找到更好的方式到达一个节点并且我改变其中一个优先级时我也需要在边缘中进行相应的更改
Dialogue: 0,0:45:37.31,0:45:38.98,英文,,0,0,0,,That's a great question.
Dialogue: 0,0:45:37.31,0:45:38.98,中文,,0,0,0,,这是一个很好的问题
Dialogue: 0,0:45:38.98,0:45:45.37,英文,,0,0,0,,OK, one more, and I'll keep it pushing.
Dialogue: 0,0:45:38.98,0:45:45.37,中文,,0,0,0,,再来一个我会继续推进
Dialogue: 0,0:45:45.37,0:45:49.37,英文,,0,0,0,,The question was, do I have to update the priority queue every time I update a node?
Dialogue: 0,0:45:45.37,0:45:49.37,中文,,0,0,0,,问题是我每次更新一个节点都要更新优先队列吗
Dialogue: 0,0:45:49.37,0:45:50.22,英文,,0,0,0,,Oh, do I have to sort it?
Dialogue: 0,0:45:49.37,0:45:50.22,中文,,0,0,0,,我需要对它进行排序吗
Dialogue: 0,0:45:50.22,0:45:52.34,英文,,0,0,0,,Well, remember, the priority queue is the heap.
Dialogue: 0,0:45:50.22,0:45:52.34,中文,,0,0,0,,记住优先队列就是堆
Dialogue: 0,0:45:52.34,0:45:54.84,英文,,0,0,0,,It's the thing that we saw from a couple of lectures ago.
Dialogue: 0,0:45:52.34,0:45:54.84,中文,,0,0,0,,这是我们几堂课前看到的东西
Dialogue: 0,0:45:54.84,0:45:57.04,英文,,0,0,0,,So I don't have to worry about how it works.
Dialogue: 0,0:45:54.84,0:45:57.04,中文,,0,0,0,,我不用担心它是如何工作的
Dialogue: 0,0:45:57.04,0:46:02.04,英文,,0,0,0,,I just know that the priority queue will always return for me the edge that is closest.
Dialogue: 0,0:45:57.04,0:46:02.04,中文,,0,0,0,,我只知道优先队列会始终为我返回最接近的边
Dialogue: 0,0:46:02.04,0:46:05.61,英文,,0,0,0,,And how it does that efficiently is something from two lectures ago.
Dialogue: 0,0:46:02.04,0:46:05.61,中文,,0,0,0,,它是如何高效地实现的是两堂课前的内容
Dialogue: 0,0:46:05.61,0:46:11.09,英文,,0,0,0,,So we can abstract it away and say, that little heap, sinking and swimming thing, they can deal with it.
Dialogue: 0,0:46:05.61,0:46:11.09,中文,,0,0,0,,我们可以将其抽象化说那个小堆下沉和浮出的东西他们可以处理它
Dialogue: 0,0:46:11.09,0:46:16.92,英文,,0,0,0,,And then we can just trust that the priority queue will always give us the edge that's closest that we haven't seen before.
Dialogue: 0,0:46:11.09,0:46:16.92,中文,,0,0,0,,然后我们可以相信优先队列总会给我们之前未见过的最接近的边
Dialogue: 0,0:46:16.92,0:46:18.04,英文,,0,0,0,,That's a great question.
Dialogue: 0,0:46:16.92,0:46:18.04,中文,,0,0,0,,这是个好问题
Dialogue: 0,0:46:18.04,0:46:19.70,英文,,0,0,0,,So we don't need to sort this ourselves.
Dialogue: 0,0:46:18.04,0:46:19.70,中文,,0,0,0,,我们不需要自己排序
Dialogue: 0,0:46:19.70,0:46:22.66,英文,,0,0,0,,We'll let the priority queue do all the hard work.
Dialogue: 0,0:46:19.70,0:46:22.66,中文,,0,0,0,,我们让优先队列来做所有的繁重工作
Dialogue: 0,0:46:22.66,0:46:25.78,英文,,0,0,0,,OK, I'm going to keep it pushing because I have something interesting to show you.
Dialogue: 0,0:46:22.66,0:46:25.78,中文,,0,0,0,,我要继续下去因为我有一些有趣的东西要给你看
Dialogue: 0,0:46:25.78,0:46:29.34,英文,,0,0,0,,So remember a couple of invariants that make this algorithm work.
Dialogue: 0,0:46:25.78,0:46:29.34,中文,,0,0,0,,记住一些使这个算法工作的不变量
Dialogue: 0,0:46:29.34,0:46:34.16,英文,,0,0,0,,One of them is the best known way to get to v. That is what edge 2 is.
Dialogue: 0,0:46:29.34,0:46:34.16,中文,,0,0,0,,其中一个是到达v的最佳已知方法这就是边2的作用
Dialogue: 0,0:46:34.16,0:46:36.60,英文,,0,0,0,,And remember, we could possibly have better edges.
Dialogue: 0,0:46:34.16,0:46:36.60,中文,,0,0,0,,还记得我们可能有更好的边
Dialogue: 0,0:46:36.60,0:46:44.00,英文,,0,0,0,,We need to be brave and be willing to kick out edges and say, you are ass, get out of here, and I'll use a better edge.
Dialogue: 0,0:46:36.60,0:46:44.00,中文,,0,0,0,,我们需要勇敢并且愿意淘汰边并说你是废物离开这里我会使用更好的边
Dialogue: 0,0:46:44.00,0:46:48.08,英文,,0,0,0,,And remember, the distance2 array tells me the best known total distance.
Dialogue: 0,0:46:44.00,0:46:48.08,中文,,0,0,0,,记住distTo数组告诉我目前为止最佳的总距离
Dialogue: 0,0:46:48.08,0:46:49.24,英文,,0,0,0,,And that can also update.
Dialogue: 0,0:46:48.08,0:46:49.24,中文,,0,0,0,,而且这个也可以更新
Dialogue: 0,0:46:49.24,0:46:56.65,英文,,0,0,0,,If I find a better way to get to a vertex, I should update distance2 and change the pink number to make it smaller.
Dialogue: 0,0:46:49.24,0:46:56.65,中文,,0,0,0,,如果我找到了到达某个顶点的更好方法我应该更新distTo并改变粉色数字使其变小
Dialogue: 0,0:46:56.65,0:47:04.59,英文,,0,0,0,,If I find something better, the priority queue, this is the thing we just talked about, it contains all the vertices that I still have to visit.
Dialogue: 0,0:46:56.65,0:47:04.59,中文,,0,0,0,,如果我找到了更好的东西优先队列这就是我们刚刚谈论的东西它包含了我仍然需要访问的所有顶点
Dialogue: 0,0:47:04.59,0:47:07.35,英文,,0,0,0,,So anything that I still have to visit is in the priority queue.
Dialogue: 0,0:47:04.59,0:47:07.35,中文,,0,0,0,,任何我仍然需要访问的东西都在优先队列中
Dialogue: 0,0:47:07.35,0:47:12.74,英文,,0,0,0,,When I visit a vertex, I remove it from the priority queue, never to be re-added again.
Dialogue: 0,0:47:07.35,0:47:12.74,中文,,0,0,0,,当我访问一个顶点时我会将其从优先队列中移除永远不会再次添加
Dialogue: 0,0:47:12.74,0:47:18.70,英文,,0,0,0,,And so I can use the priority queue to choose and see who I should dequeue next and who I should visit next.
Dialogue: 0,0:47:12.74,0:47:18.70,中文,,0,0,0,,我可以使用优先队列来选择和查看我应该下一步出队的是谁以及我应该下一步访问的是谁
Dialogue: 0,0:47:18.70,0:47:20.84,英文,,0,0,0,,So as we said, we are going best first.
Dialogue: 0,0:47:18.70,0:47:20.84,中文,,0,0,0,,正如我们所说的我们会从最接近的节点开始
Dialogue: 0,0:47:20.84,0:47:24.28,英文,,0,0,0,,We start with all the closer nodes, and then we visit all the further ones.
Dialogue: 0,0:47:20.84,0:47:24.28,中文,,0,0,0,,我们先访问所有更近的节点然后再访问所有更远的节点
Dialogue: 0,0:47:24.28,0:47:26.92,英文,,0,0,0,,By the way, nodes and vertices, same thing.
Dialogue: 0,0:47:24.28,0:47:26.92,中文,,0,0,0,,顺便说一句节点和顶点其实是一个意思
Dialogue: 0,0:47:26.92,0:47:29.02,英文,,0,0,0,,I just use them a little bit interchangeably.
Dialogue: 0,0:47:26.92,0:47:29.02,中文,,0,0,0,,我只是有时候会交替使用它们
Dialogue: 0,0:47:29.02,0:47:30.04,英文,,0,0,0,,OK.
Dialogue: 0,0:47:30.04,0:47:31.55,英文,,0,0,0,,So here's the key thing.
Dialogue: 0,0:47:30.04,0:47:31.55,中文,,0,0,0,,这里的关键是
Dialogue: 0,0:47:31.55,0:47:36.35,英文,,0,0,0,,If there's only one thing you learn from this section, it's got to be this one, which is... See, everyone quieted when I said that.
Dialogue: 0,0:47:31.55,0:47:36.35,中文,,0,0,0,,如果你从这一部分只学到一件事那就一定是这个就是……看我说完这句话后大家都安静了
Dialogue: 0,0:47:36.35,0:47:46.50,英文,,0,0,0,,So the one thing you have to know is when you relax, there is a property that makes Dijkstra's work, which is relaxation always fails
Dialogue: 0,0:47:36.35,0:47:46.50,中文,,0,0,0,,你要知道的一件事就是当你放弃的时候有一个属性让迪杰斯特拉算法生效那就是放弃总是失败
Dialogue: 0,0:47:46.50,0:47:50.88,英文,,0,0,0,,if your edge points to a vertex you've already visited before.
Dialogue: 0,0:47:46.50,0:47:50.88,中文,,0,0,0,,如果你的边指向之前已经访问过的顶点
Dialogue: 0,0:47:50.88,0:47:51.92,英文,,0,0,0,,I'll say it again.
Dialogue: 0,0:47:50.88,0:47:51.92,中文,,0,0,0,,我再说一遍
Dialogue: 0,0:47:51.92,0:48:01.65,英文,,0,0,0,,If you relax a vertex or an edge and the edge points at a vertex that you've already been to before, that relaxation is guaranteed to fail.
Dialogue: 0,0:47:51.92,0:48:01.65,中文,,0,0,0,,如果你放弃一个顶点或一条边而且这条边指向的顶点你之前已经访问过那么这次放弃肯定会失败
Dialogue: 0,0:48:01.65,0:48:04.30,英文,,0,0,0,,I don't even have to look at the numbers and I know this.
Dialogue: 0,0:48:01.65,0:48:04.30,中文,,0,0,0,,我甚至不用看数字就知道这个
Dialogue: 0,0:48:04.30,0:48:07.16,英文,,0,0,0,,So for example, let's go find one here.
Dialogue: 0,0:48:04.30,0:48:07.16,中文,,0,0,0,,例如让我们在这里找一个
Dialogue: 0,0:48:07.16,0:48:10.10,英文,,0,0,0,,Okay, this one, E to C.
Dialogue: 0,0:48:07.16,0:48:10.10,中文,,0,0,0,,这个从 E 到 C
Dialogue: 0,0:48:10.10,0:48:13.76,英文,,0,0,0,,I could look at the numbers and I could add 5 plus 1, it's worse than 1.
Dialogue: 0,0:48:10.10,0:48:13.76,中文,,0,0,0,,我可以看数字可以加5加1比1还糟糕
Dialogue: 0,0:48:13.76,0:48:20.63,英文,,0,0,0,,But it turns out, I can just look at this and say, this edge is pointing at a vertex that I've already visited before.
Dialogue: 0,0:48:13.76,0:48:20.63,中文,,0,0,0,,但事实证明我只需看这个就能说这条边指向了一个我已经访问过的顶点
Dialogue: 0,0:48:20.63,0:48:21.65,英文,,0,0,0,,Look, it's white.
Dialogue: 0,0:48:20.63,0:48:21.65,中文,,0,0,0,,看是白色的
Dialogue: 0,0:48:21.65,0:48:25.85,英文,,0,0,0,,I've already been to C. This relaxation is guaranteed to fail.
Dialogue: 0,0:48:21.65,0:48:25.85,中文,,0,0,0,,我已经去过C了这个放弃是肯定会失败的
Dialogue: 0,0:48:25.85,0:48:28.27,英文,,0,0,0,,I don't even have to look at these numbers and I know.
Dialogue: 0,0:48:25.85,0:48:28.27,中文,,0,0,0,,我甚至不用看这些数字就知道
Dialogue: 0,0:48:28.27,0:48:31.21,英文,,0,0,0,,That is the invariant that really makes Dijkstra's work.
Dialogue: 0,0:48:28.27,0:48:31.21,中文,,0,0,0,,这就是真正使Dijkstra的工作起作用的不变量
Dialogue: 0,0:48:31.21,0:48:36.44,英文,,0,0,0,,If you wrap your head around that, you will have a deep mastery level understanding of Dijkstra's.
Dialogue: 0,0:48:31.21,0:48:36.44,中文,,0,0,0,,如果你能理解这一点你就会对Dijkstra有深入的掌握
Dialogue: 0,0:48:36.44,0:48:38.40,英文,,0,0,0,,You'll be like the wizard of Dijkstra's.
Dialogue: 0,0:48:36.44,0:48:38.40,中文,,0,0,0,,你会变成 Dijkstra 的巫师
Dialogue: 0,0:48:38.40,0:48:46.36,英文,,0,0,0,,So the key idea is, If you look at this edge and it points at a vertex that's already been visited, this relaxation, forget the numbers.
Dialogue: 0,0:48:38.40,0:48:46.36,中文,,0,0,0,,所以关键是 如果你看这条边它指向的顶点已经被访问过了这个放弃忘记数字
Dialogue: 0,0:48:46.36,0:48:48.47,英文,,0,0,0,,It's going to fail.
Dialogue: 0,0:48:46.36,0:48:48.47,中文,,0,0,0,,这会失败的
Dialogue: 0,0:48:48.47,0:48:49.81,英文,,0,0,0,,Let me tell you why.
Dialogue: 0,0:48:48.47,0:48:49.81,中文,,0,0,0,,让我告诉你为什么
Dialogue: 0,0:48:49.81,0:48:52.17,英文,,0,0,0,,OK, that is the property.
Dialogue: 0,0:48:49.81,0:48:52.17,中文,,0,0,0,,那就是属性
Dialogue: 0,0:48:52.17,0:48:55.57,英文,,0,0,0,,And so here's the proof sketch in words.
Dialogue: 0,0:48:52.17,0:48:55.57,中文,,0,0,0,,这是用文字勾勒的证明草图
Dialogue: 0,0:48:55.57,0:48:58.41,英文,,0,0,0,,That's a lot to read, so I'll show you a picture.
Dialogue: 0,0:48:55.57,0:48:58.41,中文,,0,0,0,,这可是很多要读的东西所以我会给你看张图片
Dialogue: 0,0:48:58.41,0:49:02.90,英文,,0,0,0,,So this is the first step of a lot of steps of a proof that's inductive.
Dialogue: 0,0:48:58.41,0:49:02.90,中文,,0,0,0,,这是很多步骤中的第一步一个归纳证明的开始
Dialogue: 0,0:49:02.90,0:49:06.84,英文,,0,0,0,,I'm not going to talk about all the steps, but I'll give you a little picture to see why it works.
Dialogue: 0,0:49:02.90,0:49:06.84,中文,,0,0,0,,我不会讲述所有的步骤但我会给你一个小图示来解释为什么它有效
Dialogue: 0,0:49:06.84,0:49:15.37,英文,,0,0,0,,So do we all agree that at the very beginning, the best way to get to the source has cost 0?
Dialogue: 0,0:49:06.84,0:49:15.37,中文,,0,0,0,,那么我们都同意在最开始的时候最好的方法是到达源头的成本为0吗
Dialogue: 0,0:49:15.37,0:49:18.41,英文,,0,0,0,,The best way to get to the source is done.
Dialogue: 0,0:49:15.37,0:49:18.41,中文,,0,0,0,,到达源头的最佳方式已经完成
Dialogue: 0,0:49:18.41,0:49:19.33,英文,,0,0,0,,You're there.
Dialogue: 0,0:49:18.41,0:49:19.33,中文,,0,0,0,,你已经到达那里了
Dialogue: 0,0:49:19.33,0:49:22.11,英文,,0,0,0,,That's the way to get to the source.
Dialogue: 0,0:49:19.33,0:49:22.11,中文,,0,0,0,,这就是到达源头的方式
Dialogue: 0,0:49:22.11,0:49:25.07,英文,,0,0,0,,Now, remember, we're visiting in best first order.
Dialogue: 0,0:49:22.11,0:49:25.07,中文,,0,0,0,,现在记住我们按照最佳顺序进行访问
Dialogue: 0,0:49:25.07,0:49:32.32,英文,,0,0,0,,So let's say we have a bunch of edges coming out of S. And the closest vertex to S is this one, V1.
Dialogue: 0,0:49:25.07,0:49:32.32,中文,,0,0,0,,我们假设我们有一堆从 S 出发的边而最接近 S 的顶点是这个V1
Dialogue: 0,0:49:32.32,0:49:36.82,英文,,0,0,0,,You're the closest to S. You have distance C. And everyone else is further.
Dialogue: 0,0:49:32.32,0:49:36.82,中文,,0,0,0,,你是最接近 S 的你的距离是 C其他人都更远
Dialogue: 0,0:49:36.82,0:49:43.38,英文,,0,0,0,,Look, more than C, more than C, more than C. So all of these, after I relax them, these edges join the family.
Dialogue: 0,0:49:36.82,0:49:43.38,中文,,0,0,0,,看大于 C大于 C大于 C所以这些边在我放弃它们之后都加入了这个家庭
Dialogue: 0,0:49:43.38,0:49:48.26,英文,,0,0,0,,But all of these vertices are further away from
Dialogue: 0,0:49:43.38,0:49:48.26,中文,,0,0,0,,但是所有这些顶点距离 S 都更远
Dialogue: 0,0:49:48.26,0:49:48.84,英文,,0,0,0,,S then V1.
Dialogue: 0,0:49:48.26,0:49:48.84,中文,,0,0,0,,比 V1 还要远
Dialogue: 0,0:49:48.84,0:49:49.90,英文,,0,0,0,,Do you agree?
Dialogue: 0,0:49:48.84,0:49:49.90,中文,,0,0,0,,你同意吗
Dialogue: 0,0:49:49.90,0:49:51.42,英文,,0,0,0,,That's what I enforced.
Dialogue: 0,0:49:49.90,0:49:51.42,中文,,0,0,0,,这就是我执行的内容
Dialogue: 0,0:49:51.42,0:49:58.58,英文,,0,0,0,,V1 is the closest one, has distance C. Everybody else has distance more than C. They're further away.
Dialogue: 0,0:49:51.42,0:49:58.58,中文,,0,0,0,,V1 是最接近的一个距离为 C其他人的距离都大于 C他们离得更远
Dialogue: 0,0:49:58.58,0:50:00.82,英文,,0,0,0,,Now let's consider an edge like this.
Dialogue: 0,0:49:58.58,0:50:00.82,中文,,0,0,0,,现在让我们考虑这样一个边
Dialogue: 0,0:50:00.82,0:50:04.44,英文,,0,0,0,,This edge is pointing back at V1.
Dialogue: 0,0:50:00.82,0:50:04.44,中文,,0,0,0,,这条边指向 V1
Dialogue: 0,0:50:04.44,0:50:07.76,英文,,0,0,0,,So will this relaxation, if I try to relax...
Dialogue: 0,0:50:04.44,0:50:07.76,中文,,0,0,0,,如果我试图放弃这种放弃也会吗
Dialogue: 0,0:50:07.76,0:50:08.92,英文,,0,0,0,,Will it succeed?
Dialogue: 0,0:50:07.76,0:50:08.92,中文,,0,0,0,,会成功吗
Dialogue: 0,0:50:08.92,0:50:10.96,英文,,0,0,0,,Remember, we've got to add two numbers.
Dialogue: 0,0:50:08.92,0:50:10.96,中文,,0,0,0,,记住我们得加两个数字
Dialogue: 0,0:50:10.96,0:50:16.57,英文,,0,0,0,,I've got to add this number, which is already greater than c, plus another number.
Dialogue: 0,0:50:10.96,0:50:16.57,中文,,0,0,0,,我得把这个数字加上去它已经比 c 大了再加一个数字
Dialogue: 0,0:50:16.57,0:50:25.41,英文,,0,0,0,,If I take a number that's already greater than c and I add even more to it, well, that's still going to be greater than c. So this relaxation will fail.
Dialogue: 0,0:50:16.57,0:50:25.41,中文,,0,0,0,,如果我拿一个已经比 c 大的数字再加上更多的话那还是会比 c 大的这个放弃策略会失败
Dialogue: 0,0:50:25.41,0:50:30.13,英文,,0,0,0,,That's the key idea for why relaxations to visited nodes will fail.
Dialogue: 0,0:50:25.41,0:50:30.13,中文,,0,0,0,,这就是为什么对已访问节点的放弃会失败的关键思想
Dialogue: 0,0:50:30.13,0:50:38.71,英文,,0,0,0,,So see right here, this vertex, the best known distance to it, it's already greater than c. And then I add another edge to put on even more weight.
Dialogue: 0,0:50:30.13,0:50:38.71,中文,,0,0,0,,看这里这个顶点到它的最佳已知距离已经比 c 大了然后我再添加一条边增加更多的权重
Dialogue: 0,0:50:38.71,0:50:41.01,英文,,0,0,0,,That's going to be greater than c.
Dialogue: 0,0:50:38.71,0:50:41.01,中文,,0,0,0,,那就会比 c 大
Dialogue: 0,0:50:41.01,0:50:42.51,英文,,0,0,0,,That's the key idea that makes this work.
Dialogue: 0,0:50:41.01,0:50:42.51,中文,,0,0,0,,这就是使这个工作的关键思想
Dialogue: 0,0:50:42.51,0:50:46.43,英文,,0,0,0,,And this holds for any other deep vertex in the graph that you care about.
Dialogue: 0,0:50:42.51,0:50:46.43,中文,,0,0,0,,而且这对于图中任何其他你关心的深度顶点都成立
Dialogue: 0,0:50:46.43,0:50:48.20,英文,,0,0,0,,Like, look at this vertex right here.
Dialogue: 0,0:50:46.43,0:50:48.20,中文,,0,0,0,,看看这个顶点
Dialogue: 0,0:50:48.20,0:50:50.52,英文,,0,0,0,,How much does it cost to get to this vertex?
Dialogue: 0,0:50:48.20,0:50:50.52,中文,,0,0,0,,到这个顶点要花多少钱
Dialogue: 0,0:50:50.52,0:50:55.02,英文,,0,0,0,,More than c, because I had to go through some other vertices more than c already.
Dialogue: 0,0:50:50.52,0:50:55.02,中文,,0,0,0,,比c多因为我已经经过了一些其他的顶点
Dialogue: 0,0:50:55.02,0:51:03.74,英文,,0,0,0,,If it's already more than c, and then I add even more weight, the total weight will be greater than c. That's why the relaxation to visited vertices will fail.
Dialogue: 0,0:50:55.02,0:51:03.74,中文,,0,0,0,,如果已经超过c了再加上更多的重量总重会超过c这就是为什么对已访问顶点的放弃会失败
Dialogue: 0,0:51:03.74,0:51:08.48,英文,,0,0,0,,is because you've already paid more than C, then you've got to pay even more, going to fail.
Dialogue: 0,0:51:03.74,0:51:08.48,中文,,0,0,0,,就是因为你已经支付了超过C的金额然后你还得支付更多这会失败
Dialogue: 0,0:51:08.48,0:51:11.26,英文,,0,0,0,,So that's what guarantees the optimality.
Dialogue: 0,0:51:08.48,0:51:11.26,中文,,0,0,0,,这就保证了最优性
Dialogue: 0,0:51:11.26,0:51:12.98,英文,,0,0,0,,And I guess I will pause here.
Dialogue: 0,0:51:11.26,0:51:12.98,中文,,0,0,0,,我想我会在这里暂停
Dialogue: 0,0:51:12.98,0:51:15.38,英文,,0,0,0,,I'll finish Dijkstra's next time because I don't want to keep you late.
Dialogue: 0,0:51:12.98,0:51:15.38,中文,,0,0,0,,下次我会完成戴克斯特拉算法因为我不想让你太晚
Dialogue: 0,0:51:15.38,0:51:16.56,英文,,0,0,0,,But that's the key idea.
Dialogue: 0,0:51:15.38,0:51:16.56,中文,,0,0,0,,但这是关键点
Dialogue: 0,0:51:16.56,0:51:19.26,英文,,0,0,0,,So remember, you've got to relax your nose in best first order.
Dialogue: 0,0:51:16.56,0:51:19.26,中文,,0,0,0,,记住在最佳优先顺序中你必须放弃你的鼻子
Dialogue: 0,0:51:19.26,0:51:25.98,英文,,0,0,0,,And remember, the key invariant that will make you the Dijkstra's wizard is to remember that relaxation
Dialogue: 0,0:51:19.26,0:51:25.98,中文,,0,0,0,,还记得使你成为戴克斯特拉算法高手的关键不变量是记住放弃
Dialogue: 0,0:51:25.98,0:51:29.18,英文,,0,0,0,,Pointing at vertices you've already been to will fail.
Dialogue: 0,0:51:25.98,0:51:29.18,中文,,0,0,0,,指向你已经访问过的顶点会失败
Dialogue: 0,0:51:29.18,0:51:30.68,英文,,0,0,0,,That's what this slide says.
Dialogue: 0,0:51:29.18,0:51:30.68,中文,,0,0,0,,这就是这张幻灯片的意思
Dialogue: 0,0:51:30.68,0:51:31.10,英文,,0,0,0,,OK.
Dialogue: 0,0:51:31.10,0:51:32.63,英文,,0,0,0,,Sorry for keeping you a minute late.
Dialogue: 0,0:51:31.10,0:51:32.63,中文,,0,0,0,,抱歉让你等了一分钟
Dialogue: 0,0:51:32.63,0:51:35.49,英文,,0,0,0,,I will see you on Friday?
Dialogue: 0,0:51:32.63,0:51:35.49,中文,,0,0,0,,星期五见
Dialogue: 0,0:51:35.49,0:51:36.11,英文,,0,0,0,,Friday.
Dialogue: 0,0:51:35.49,0:51:36.11,中文,,0,0,0,,星期五
Dialogue: 0,0:51:36.11,0:51:36.21,英文,,0,0,0,,OK.
