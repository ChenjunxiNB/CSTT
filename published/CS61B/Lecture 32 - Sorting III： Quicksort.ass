[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 3
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Export Encoding: Unicode (UTF-8)
Audio File: D:/python_code/video_tool/video_tool/result/cs61b/Lecture 31 - Software Engineering II.mp4
Video File: D:/python_code/video_tool/video_tool/result/cs61b/Lecture 31 - Software Engineering II.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.750000
Scroll Position: 832
Active Line: 833
Video Position: 3959

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,14,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.33333,1.33333,2,6,6,8,1
Style: 英文,Arial,24,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1.33333,1.33333,2,2,2,6,1
Style: 中文,微软雅黑,38,&H0029EEF1,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1.33333,1.33333,2,2,2,20,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,
Dialogue: 0,0:00:05.74,0:00:09.47,英文,,0,0,0,,By the way, you might have noticed, there's no Justin.
Dialogue: 0,0:00:05.74,0:00:09.47,中文,,0,0,0,,对了 你可能已经注意到了 Justin 不在
Dialogue: 0,0:00:09.47,0:00:12.17,英文,,0,0,0,,Went to go stare at the sun or something.
Dialogue: 0,0:00:09.47,0:00:12.17,中文,,0,0,0,,他去看太阳了还是干嘛去了
Dialogue: 0,0:00:12.17,0:00:13.25,英文,,0,0,0,,There's no Peyron.
Dialogue: 0,0:00:12.17,0:00:13.25,中文,,0,0,0,,Peyron 也不在
Dialogue: 0,0:00:13.25,0:00:19.21,英文,,0,0,0,,So I'm his secret ruler twin brother, and I'm here to tell you all about Quicksilver.
Dialogue: 0,0:00:13.25,0:00:19.21,中文,,0,0,0,,我是他秘密统治的双胞胎兄弟 我来这里是为了告诉你关于 快速排序(快速排序) 的一切
Dialogue: 0,0:00:19.21,0:00:22.81,英文,,0,0,0,,So I hope you're ready.
Dialogue: 0,0:00:19.21,0:00:22.81,中文,,0,0,0,,我希望你已经准备好了
Dialogue: 0,0:00:22.81,0:00:26.06,英文,,0,0,0,,Okay, quicksort is really cool.
Dialogue: 0,0:00:22.81,0:00:26.06,中文,,0,0,0,,好的 快速排序 真的很酷
Dialogue: 0,0:00:26.06,0:00:29.34,英文,,0,0,0,,It's so cool that those other two clowns could not do it justice.
Dialogue: 0,0:00:26.06,0:00:29.34,中文,,0,0,0,,它太酷了 以至于那两个小丑无法公正地评价它
Dialogue: 0,0:00:29.34,0:00:33.10,英文,,0,0,0,,So I'm here to show you the coolest known sort.
Dialogue: 0,0:00:29.34,0:00:33.10,中文,,0,0,0,,我来这里向你展示最酷的已知排序算法
Dialogue: 0,0:00:33.10,0:00:34.52,英文,,0,0,0,,So I hope you're ready.
Dialogue: 0,0:00:33.10,0:00:34.52,中文,,0,0,0,,我希望你已经准备好了
Dialogue: 0,0:00:34.52,0:00:38.25,英文,,0,0,0,,So those other two weirdos, they came and they were like, oh, selection sort is N squared.
Dialogue: 0,0:00:34.52,0:00:38.25,中文,,0,0,0,,那两个怪人 他们来了 他们说 选择排序的时间复杂度是 N^2
Dialogue: 0,0:00:38.25,0:00:39.27,英文,,0,0,0,,I hope you're impressed.
Dialogue: 0,0:00:38.25,0:00:39.27,中文,,0,0,0,,我希望你印象深刻
Dialogue: 0,0:00:39.27,0:00:40.17,英文,,0,0,0,,But you weren't.
Dialogue: 0,0:00:39.27,0:00:40.17,中文,,0,0,0,,但你没有
Dialogue: 0,0:00:40.17,0:00:45.05,英文,,0,0,0,,You wanted to see the fastest known empirical sort, which was none of these.
Dialogue: 0,0:00:40.17,0:00:45.05,中文,,0,0,0,,你想看到的是已知最快的经验排序 而不是这些
Dialogue: 0,0:00:45.05,0:00:47.37,英文,,0,0,0,,It was the sort we will be seeing today.
Dialogue: 0,0:00:45.05,0:00:47.37,中文,,0,0,0,,这就是我们今天要看到的排序算法
Dialogue: 0,0:00:47.37,0:00:49.48,英文,,0,0,0,,Those two guys,
Dialogue: 0,0:00:47.37,0:00:49.48,中文,,0,0,0,,那两个人
Dialogue: 0,0:00:49.48,0:00:50.12,英文,,0,0,0,,Forget about them.
Dialogue: 0,0:00:49.48,0:00:50.12,中文,,0,0,0,,忘掉他们吧
Dialogue: 0,0:00:50.12,0:00:51.12,英文,,0,0,0,,They don't know about this.
Dialogue: 0,0:00:50.12,0:00:51.12,中文,,0,0,0,,他们不知道这个
Dialogue: 0,0:00:51.12,0:00:54.34,英文,,0,0,0,,OK, so, so far, you've seen these sorts.
Dialogue: 0,0:00:51.12,0:00:54.34,中文,,0,0,0,,好的 到目前为止 你已经看到了这些排序算法
Dialogue: 0,0:00:54.34,0:01:04.71,英文,,0,0,0,,And they might have told you, and they might have not, that the way that you keep the sorts distinct in your mind is to remember that each of the sorts has a different core operation.
Dialogue: 0,0:00:54.34,0:01:04.71,中文,,0,0,0,,他们可能告诉过你 也可能没有告诉你 在你的脑海中区分这些排序算法的方法是记住每种排序算法都有不同的核心操作
Dialogue: 0,0:01:04.71,0:01:07.93,英文,,0,0,0,,For example, SelectionSort, the thing you were doing over and over again.
Dialogue: 0,0:01:04.71,0:01:07.93,中文,,0,0,0,,例如 选择排序 你一直在做的事情
Dialogue: 0,0:01:07.93,0:01:10.21,英文,,0,0,0,,Just take the small item, put it at the front.
Dialogue: 0,0:01:07.93,0:01:10.21,中文,,0,0,0,,把小的元素放到前面
Dialogue: 0,0:01:10.21,0:01:15.79,英文,,0,0,0,,InsertionSort, the core operation was swapping items and traveling them forward.
Dialogue: 0,0:01:10.21,0:01:15.79,中文,,0,0,0,,插入排序的核心操作是交换元素并向前移动它们
Dialogue: 0,0:01:15.79,0:01:19.42,英文,,0,0,0,,But QuickSort, it's built on this much stranger
Dialogue: 0,0:01:15.79,0:01:19.42,中文,,0,0,0,,但快速排序建立在一个更奇怪的想法之上
Dialogue: 0,0:01:19.42,0:01:23.30,英文,,0,0,0,,Very cool horror idea, which is the thing I want to show you.
Dialogue: 0,0:01:19.42,0:01:23.30,中文,,0,0,0,,一个非常酷的恐怖想法 我想展示给你看
Dialogue: 0,0:01:23.30,0:01:33.36,英文,,0,0,0,,And so the weird thing about Quicksort, to begin this story of coolness and weirdness, is that it was actually invented by this novice programmer called Tony Hoare.
Dialogue: 0,0:01:23.30,0:01:33.36,中文,,0,0,0,,快速排序的奇怪之处在于 这个酷炫而又奇怪的故事始于一个叫做 Tony Hoare 的新手程序员发明了它
Dialogue: 0,0:01:33.36,0:01:35.26,英文,,0,0,0,,Tony and I, we're pretty similar.
Dialogue: 0,0:01:33.36,0:01:35.26,中文,,0,0,0,,Tony 和我 我们很相似
Dialogue: 0,0:01:35.26,0:01:37.80,英文,,0,0,0,,We have the vision to see something like Quicksort.
Dialogue: 0,0:01:35.26,0:01:37.80,中文,,0,0,0,,我们都有远见卓识 能看到像快速排序这样的东西
Dialogue: 0,0:01:37.80,0:01:39.30,英文,,0,0,0,,And so...
Dialogue: 0,0:01:37.80,0:01:39.30,中文,,0,0,0,,
Dialogue: 0,0:01:39.30,0:01:45.12,英文,,0,0,0,,What he was doing was he was running some sort of machine translation program, and he needed to sort a list of words.
Dialogue: 0,0:01:39.30,0:01:45.12,中文,,0,0,0,,他当时在运行某种机器翻译程序 需要对单词列表进行排序
Dialogue: 0,0:01:45.12,0:01:47.99,英文,,0,0,0,,But this was 1960. There was no Google.
Dialogue: 0,0:01:45.12,0:01:47.99,中文,,0,0,0,,但那是 1960 年  没有 Google
Dialogue: 0,0:01:47.99,0:01:53.95,英文,,0,0,0,,So Tony, just like me, whenever I'm stuck on a problem, because I'm the cool version, I just invent the sorting algorithm myself.
Dialogue: 0,0:01:47.99,0:01:53.95,中文,,0,0,0,,所以 Tony 就像我一样 每当我遇到问题时 因为我是酷酷的版本 我会自己发明排序算法
Dialogue: 0,0:01:53.95,0:01:55.87,英文,,0,0,0,,So that's what we'll be doing today.
Dialogue: 0,0:01:53.95,0:01:55.87,中文,,0,0,0,,这就是我们今天要做的
Dialogue: 0,0:01:55.87,0:01:59.41,英文,,0,0,0,,So here's the core operation that makes QuickSort work.
Dialogue: 0,0:01:55.87,0:01:59.41,中文,,0,0,0,,以下是使快速排序工作的核心操作
Dialogue: 0,0:01:59.41,0:02:04.40,英文,,0,0,0,,If you have this core operation, the rest of today is just putting the rest of the pieces together.
Dialogue: 0,0:01:59.41,0:02:04.40,中文,,0,0,0,,如果你掌握了这个核心操作 今天剩下的时间就是把其余的部分拼凑起来
Dialogue: 0,0:02:04.40,0:02:06.96,英文,,0,0,0,,Core operation is called partitioning.
Dialogue: 0,0:02:04.40,0:02:06.96,中文,,0,0,0,,核心操作称为分区
Dialogue: 0,0:02:06.96,0:02:10.82,英文,,0,0,0,,So to do a partition, the first thing you do is you pick one item.
Dialogue: 0,0:02:06.96,0:02:10.82,中文,,0,0,0,,要进行分区 首先要做的是选择一个元素
Dialogue: 0,0:02:10.82,0:02:15.62,英文,,0,0,0,,It's already kind of strange that you have to arbitrarily pick one item, but that's what you're going to do.
Dialogue: 0,0:02:10.82,0:02:15.62,中文,,0,0,0,,你必须任意选择一个元素 这已经有点奇怪了 但你必须这样做
Dialogue: 0,0:02:15.62,0:02:16.80,英文,,0,0,0,,So I pick one item here.
Dialogue: 0,0:02:15.62,0:02:16.80,中文,,0,0,0,,我在这里选择一个元素
Dialogue: 0,0:02:16.80,0:02:17.84,英文,,0,0,0,,I chose 10.
Dialogue: 0,0:02:16.80,0:02:17.84,中文,,0,0,0,,我选择了 10
Dialogue: 0,0:02:17.84,0:02:19.69,英文,,0,0,0,,You could have chosen something else.
Dialogue: 0,0:02:17.84,0:02:19.69,中文,,0,0,0,,你也可以选别的
Dialogue: 0,0:02:19.69,0:02:23.97,英文,,0,0,0,,And what I want you to do is I want you to rearrange the entire array.
Dialogue: 0,0:02:19.69,0:02:23.97,中文,,0,0,0,,我希望你重新排列整个数组
Dialogue: 0,0:02:23.97,0:02:26.11,英文,,0,0,0,,You can swap any items around that you want.
Dialogue: 0,0:02:23.97,0:02:26.11,中文,,0,0,0,,你可以随意交换任何元素的位置
Dialogue: 0,0:02:26.11,0:02:35.04,英文,,0,0,0,,including the 10, so you can move everything around, but the result should be such that everything to the left of 10 is less than or equal to 10,
Dialogue: 0,0:02:26.11,0:02:35.04,中文,,0,0,0,,包括 10 所以你可以随意移动所有元素 但结果应该是 10 左边的所有元素都小于或等于 10 -
Dialogue: 0,0:02:35.04,0:02:39.04,英文,,0,0,0,,and everything to the right of 10 is greater than or equal to 10.
Dialogue: 0,0:02:35.04,0:02:39.04,中文,,0,0,0,,而 10 右边的所有元素都大于或等于 10
Dialogue: 0,0:02:39.04,0:02:39.96,英文,,0,0,0,,That's the rule.
Dialogue: 0,0:02:39.04,0:02:39.96,中文,,0,0,0,,这就是规则
Dialogue: 0,0:02:39.96,0:02:50.90,英文,,0,0,0,,There might be multiple valid partitions, but I want you to run an operation such that everything to the left of 10 is less than or equal to 10, everything to the right of 10 is greater than or equal to 10.
Dialogue: 0,0:02:39.96,0:02:50.90,中文,,0,0,0,,可能存在多个有效分区 但我希望你进行操作 使 10 左边的所有元素都小于或等于 10 10 右边的所有元素都大于或等于 10
Dialogue: 0,0:02:50.90,0:02:58.75,英文,,0,0,0,,So now the question for you is, which of these partitions actually makes sense and obeys the rules that we just talked about?
Dialogue: 0,0:02:50.90,0:02:58.75,中文,,0,0,0,,现在你的问题是 哪些分区实际上是有意义的 并且遵循我们刚才讨论的规则？
Dialogue: 0,0:02:58.75,0:02:59.55,英文,,0,0,0,,So you can try and guess.
Dialogue: 0,0:02:58.75,0:02:59.55,中文,,0,0,0,,你可以试着猜猜
Dialogue: 0,0:02:59.55,0:03:03.57,英文,,0,0,0,,And remember, everything to the left of 10 has to be less than or equal to 10.
Dialogue: 0,0:02:59.55,0:03:03.57,中文,,0,0,0,,记住 10 左边的所有元素都必须小于或等于 10
Dialogue: 0,0:03:03.57,0:03:06.54,英文,,0,0,0,,Everything to the right of 10 has to be greater than or equal to 10.
Dialogue: 0,0:03:03.57,0:03:06.54,中文,,0,0,0,,10 右边的所有元素都必须大于或等于 10
Dialogue: 0,0:03:06.54,0:03:10.26,英文,,0,0,0,,Does anyone see one that for sure doesn't work?
Dialogue: 0,0:03:06.54,0:03:10.26,中文,,0,0,0,,有人看到肯定不符合要求的吗？
Dialogue: 0,0:03:10.26,0:03:12.92,英文,,0,0,0,,D. I don't like D either, because look, here's 10.
Dialogue: 0,0:03:10.26,0:03:12.92,中文,,0,0,0,,D 我也不喜欢 D 因为你看 这是 10
Dialogue: 0,0:03:12.92,0:03:14.40,英文,,0,0,0,,There's 4 to the right.
Dialogue: 0,0:03:12.92,0:03:14.40,中文,,0,0,0,,右边有个 4
Dialogue: 0,0:03:14.40,0:03:18.53,英文,,0,0,0,,That doesn't work, because everything to the right of 10 has to be greater than or equal to.
Dialogue: 0,0:03:14.40,0:03:18.53,中文,,0,0,0,,这不行 因为 10 右边的所有元素都必须大于或等于 10
Dialogue: 0,0:03:18.53,0:03:23.67,英文,,0,0,0,,And if you go through and you check them all, you'll realize that the other ones are OK.
Dialogue: 0,0:03:18.53,0:03:23.67,中文,,0,0,0,,如果你仔细检查所有选项 你会发现其他的都可以
Dialogue: 0,0:03:23.67,0:03:25.51,英文,,0,0,0,,So there were three valid partitions here.
Dialogue: 0,0:03:23.67,0:03:25.51,中文,,0,0,0,,这里有三个有效分区
Dialogue: 0,0:03:25.51,0:03:26.77,英文,,0,0,0,,There are more out there.
Dialogue: 0,0:03:25.51,0:03:26.77,中文,,0,0,0,,还有更多
Dialogue: 0,0:03:26.77,0:03:28.99,英文,,0,0,0,,But these are the three that we chose.
Dialogue: 0,0:03:26.77,0:03:28.99,中文,,0,0,0,,但这是我们选择的三个
Dialogue: 0,0:03:28.99,0:03:36.21,英文,,0,0,0,,By the way, just to bring it up, because since sometimes people ask, the 10 could move as part of the partition.
Dialogue: 0,0:03:28.99,0:03:36.21,中文,,0,0,0,,顺便说一下 因为有时候人们会问 10 可以作为分区的一部分移动
Dialogue: 0,0:03:36.21,0:03:38.26,英文,,0,0,0,,So it does not have to stay in place.
Dialogue: 0,0:03:36.21,0:03:38.26,中文,,0,0,0,,它不必待在原地
Dialogue: 0,0:03:38.26,0:03:43.51,英文,,0,0,0,,But the cool thing about partitioning, I guess before I go on,
Dialogue: 0,0:03:38.26,0:03:43.51,中文,,0,0,0,,不过分区有个很酷的地方 在继续之前我想说的是
Dialogue: 0,0:03:43.51,0:03:50.51,英文,,0,0,0,,is that once everything to the left of 10 is less than 10, and everything to the right of 10 is greater than 10, if you look at this 10,
Dialogue: 0,0:03:43.51,0:03:50.51,中文,,0,0,0,,一旦 10 左边的所有数字都小于 10 10 右边的所有数字都大于 10 你再看这个 10
Dialogue: 0,0:03:50.51,0:03:52.07,英文,,0,0,0,,It's in the right place.
Dialogue: 0,0:03:50.51,0:03:52.07,中文,,0,0,0,,它就在正确的位置上
Dialogue: 0,0:03:52.07,0:03:53.33,英文,,0,0,0,,How do I know that?
Dialogue: 0,0:03:52.07,0:03:53.33,中文,,0,0,0,,我怎么知道呢？
Dialogue: 0,0:03:53.33,0:04:00.94,英文,,0,0,0,,Because whatever the actual sort is, I don't know what the correct sorted version of the array is, but I know that everything less than 10 has to be to its left.
Dialogue: 0,0:03:53.33,0:04:00.94,中文,,0,0,0,,因为不管实际排序是什么样的 我不知道这个数组排序后的正确版本是什么 但我知道所有小于 10 的数字都必须在它左边
Dialogue: 0,0:04:00.94,0:04:03.46,英文,,0,0,0,,Everything greater than or equal to 10 has to be to its right.
Dialogue: 0,0:04:00.94,0:04:03.46,中文,,0,0,0,,所有大于或等于 10 的数字都必须在它右边
Dialogue: 0,0:04:03.46,0:04:07.42,英文,,0,0,0,,So therefore, this 10, it must be in the correct place.
Dialogue: 0,0:04:03.46,0:04:07.42,中文,,0,0,0,,这个 10 它一定在正确的位置上
Dialogue: 0,0:04:07.42,0:04:12.91,英文,,0,0,0,,So somehow, by partitioning, I have actually sorted the array on one item.
Dialogue: 0,0:04:07.42,0:04:12.91,中文,,0,0,0,,通过分区 我实际上已经对数组中的一个元素进行了排序
Dialogue: 0,0:04:12.91,0:04:14.40,英文,,0,0,0,,Kind of a weird idea.
Dialogue: 0,0:04:12.91,0:04:14.40,中文,,0,0,0,,这想法有点奇怪
Dialogue: 0,0:04:14.40,0:04:17.58,英文,,0,0,0,,But that's what we'll be doing, because we're cool.
Dialogue: 0,0:04:14.40,0:04:17.58,中文,,0,0,0,,但这就是我们要做的 因为我们很酷
Dialogue: 0,0:04:17.58,0:04:19.82,英文,,0,0,0,,And you don't want to tell those other two guys that we're doing this.
Dialogue: 0,0:04:17.58,0:04:19.82,中文,,0,0,0,,而且你不想告诉那两个家伙我们在做这个
Dialogue: 0,0:04:19.82,0:04:21.66,英文,,0,0,0,,But that's the idea.
Dialogue: 0,0:04:19.82,0:04:21.66,中文,,0,0,0,,但这就是我们的想法
Dialogue: 0,0:04:21.66,0:04:26.06,英文,,0,0,0,,We're going to sort an array on exactly one item without regard to the others.
Dialogue: 0,0:04:21.66,0:04:26.06,中文,,0,0,0,,我们要对数组中的一个元素进行排序 而不考虑其他元素
Dialogue: 0,0:04:26.06,0:04:35.22,英文,,0,0,0,,And the way to sort an array on one item is to put all the items less than to the left, all the items greater than to the right, and you're done.
Dialogue: 0,0:04:26.06,0:04:35.22,中文,,0,0,0,,对一个元素进行排序的方法是将所有小于它的元素放在左边 所有大于它的元素放在右边 就完成了
Dialogue: 0,0:04:35.22,0:04:38.85,英文,,0,0,0,,That one item that you partitioned on is in the right place.
Dialogue: 0,0:04:35.22,0:04:38.85,中文,,0,0,0,,你进行分区操作的那个元素就在正确的位置上
Dialogue: 0,0:04:38.85,0:04:43.99,英文,,0,0,0,,We don't know where everything else goes, but the one item found its rightful place.
Dialogue: 0,0:04:38.85,0:04:43.99,中文,,0,0,0,,我们不知道其他元素的位置 但这个元素找到了它正确的位置
Dialogue: 0,0:04:43.99,0:04:47.61,英文,,0,0,0,,So question for you, then, is how do we actually partition?
Dialogue: 0,0:04:43.99,0:04:47.61,中文,,0,0,0,,那么问题来了 我们到底如何进行分区呢？
Dialogue: 0,0:04:47.61,0:04:49.37,英文,,0,0,0,,What is the algorithm for doing this?
Dialogue: 0,0:04:47.61,0:04:49.37,中文,,0,0,0,,执行此操作的算法是什么？
Dialogue: 0,0:04:49.37,0:04:52.65,英文,,0,0,0,,I showed you some answers, and you told me which ones were valid.
Dialogue: 0,0:04:49.37,0:04:52.65,中文,,0,0,0,,我给你展示了一些答案 你告诉我哪些是有效的
Dialogue: 0,0:04:52.65,0:04:54.83,英文,,0,0,0,,But how would you actually do this?
Dialogue: 0,0:04:52.65,0:04:54.83,中文,,0,0,0,,但你实际上会怎么做呢？
Dialogue: 0,0:04:54.83,0:05:00.26,英文,,0,0,0,,It turns out there is also a very cool algorithm to partition an array.
Dialogue: 0,0:04:54.83,0:05:00.26,中文,,0,0,0,,事实证明 还有一个非常酷的算法可以对数组进行分区
Dialogue: 0,0:05:00.26,0:05:03.46,英文,,0,0,0,,But before I show that to you, let's think about what those other guys would have done.
Dialogue: 0,0:05:00.26,0:05:03.46,中文,,0,0,0,,不过先别着急 我们先想想其他程序员会怎么做
Dialogue: 0,0:05:03.46,0:05:05.42,英文,,0,0,0,,Because those other guys, they're not like you and me.
Dialogue: 0,0:05:03.46,0:05:05.42,中文,,0,0,0,,因为他们不像你我这样
Dialogue: 0,0:05:05.42,0:05:07.94,英文,,0,0,0,,They don't have the vision to see these cool algorithms.
Dialogue: 0,0:05:05.42,0:05:07.94,中文,,0,0,0,,他们没有眼光 看不到这些炫酷的算法
Dialogue: 0,0:05:07.94,0:05:11.32,英文,,0,0,0,,So they probably would have done the dumbest thing they could think of.
Dialogue: 0,0:05:07.94,0:05:11.32,中文,,0,0,0,,他们可能会用最笨的方法
Dialogue: 0,0:05:11.32,0:05:13.02,英文,,0,0,0,,Because that's the kind of guys they are.
Dialogue: 0,0:05:11.32,0:05:13.02,中文,,0,0,0,,毕竟他们就是这样的人
Dialogue: 0,0:05:13.02,0:05:14.68,英文,,0,0,0,,I know how they think.
Dialogue: 0,0:05:13.02,0:05:14.68,中文,,0,0,0,,我知道他们的思路
Dialogue: 0,0:05:14.68,0:05:20.97,英文,,0,0,0,,And so tell me, if you were those other guys, what's the simplest partition algorithm you can think of?
Dialogue: 0,0:05:14.68,0:05:20.97,中文,,0,0,0,,告诉我 如果你和他们一样 能想到的最简单的分区算法是什么？
Dialogue: 0,0:05:20.97,0:05:22.21,英文,,0,0,0,,Try and come up with something.
Dialogue: 0,0:05:20.97,0:05:22.21,中文,,0,0,0,,试着想一个
Dialogue: 0,0:05:22.21,0:05:25.99,英文,,0,0,0,,It doesn't even have to be asymptotically optimal.
Dialogue: 0,0:05:22.21,0:05:25.99,中文,,0,0,0,,它甚至不需要渐进最优
Dialogue: 0,0:05:25.99,0:05:28.65,英文,,0,0,0,,It doesn't have to be memory efficient.
Dialogue: 0,0:05:25.99,0:05:28.65,中文,,0,0,0,,也不需要内存效率高
Dialogue: 0,0:05:28.65,0:05:34.13,英文,,0,0,0,,Just come up with the simplest thing you can think of such that, and here I want to partition on 6.
Dialogue: 0,0:05:28.65,0:05:34.13,中文,,0,0,0,,只要想出你能想到的最简单的方法 这里我要按 6 进行分区
Dialogue: 0,0:05:34.13,0:05:37.90,英文,,0,0,0,,So I've chosen 6 to be my partition because I've got to choose something.
Dialogue: 0,0:05:34.13,0:05:37.90,中文,,0,0,0,,我选择 6 作为分区依据 因为总得选个数字
Dialogue: 0,0:05:37.90,0:05:43.66,英文,,0,0,0,,I want everything less than 6, which I've helpfully highlighted in red, to show up on the left of 6.
Dialogue: 0,0:05:37.90,0:05:43.66,中文,,0,0,0,,我希望所有小于 6 的数字（我已经贴心地用红色标出来了）出现在 6 的左边
Dialogue: 0,0:05:43.66,0:05:50.85,英文,,0,0,0,,And I want everything that is greater than 6, or sorry, greater than or equal to 6, to show up on the right of 6.
Dialogue: 0,0:05:43.66,0:05:50.85,中文,,0,0,0,,我希望所有大于 6 的数字 或者说大于等于 6 的数字 出现在 6 的右边
Dialogue: 0,0:05:50.85,0:05:53.25,英文,,0,0,0,,So I just need a valid partition on 6.
Dialogue: 0,0:05:50.85,0:05:53.25,中文,,0,0,0,,我只需要一个有效的按 6 分区的算法
Dialogue: 0,0:05:53.25,0:05:57.43,英文,,0,0,0,,Everything less than or equal to 6 on the left, everything greater than or equal to 6 on the right.
Dialogue: 0,0:05:53.25,0:05:57.43,中文,,0,0,0,,所有小于或等于 6 的数字在左边 所有大于或等于 6 的数字在右边
Dialogue: 0,0:05:57.43,0:05:58.79,英文,,0,0,0,,There are multiple answers.
Dialogue: 0,0:05:57.43,0:05:58.79,中文,,0,0,0,,答案有很多种
Dialogue: 0,0:05:58.79,0:05:59.89,英文,,0,0,0,,Here are two.
Dialogue: 0,0:05:58.79,0:05:59.89,中文,,0,0,0,,这里有两个
Dialogue: 0,0:05:59.89,0:06:01.91,英文,,0,0,0,,So think like those other two people.
Dialogue: 0,0:05:59.89,0:06:01.91,中文,,0,0,0,,像那两个人一样思考
Dialogue: 0,0:06:01.91,0:06:04.09,英文,,0,0,0,,Give me the simplest algorithm you can think of.
Dialogue: 0,0:06:01.91,0:06:04.09,中文,,0,0,0,,告诉我你能想到的最简单的算法
Dialogue: 0,0:06:04.09,0:06:11.52,英文,,0,0,0,,Does anyone have one that they think is just going to work, and you don't even have to draw me pictures to convince yourself that it works?
Dialogue: 0,0:06:04.09,0:06:11.52,中文,,0,0,0,,有谁已经有可行思路了吗？ 不用画图解释的那种
Dialogue: 0,0:06:11.52,0:06:14.04,英文,,0,0,0,,Scan the array and do what?
Dialogue: 0,0:06:11.52,0:06:14.04,中文,,0,0,0,,扫描数组然后做什么？
Dialogue: 0,0:06:14.04,0:06:14.94,英文,,0,0,0,,Scan it?
Dialogue: 0,0:06:14.04,0:06:14.94,中文,,0,0,0,,扫描它？
Dialogue: 0,0:06:14.94,0:06:16.85,英文,,0,0,0,,Sorry?
Dialogue: 0,0:06:14.94,0:06:16.85,中文,,0,0,0,,抱歉？
Dialogue: 0,0:06:16.85,0:06:19.53,英文,,0,0,0,,Sorry, say that one more time, because I can't hear you.
Dialogue: 0,0:06:16.85,0:06:19.53,中文,,0,0,0,,抱歉 再说一遍 我听不清
Dialogue: 0,0:06:19.53,0:06:21.75,英文,,0,0,0,,Take the 6 and do what with it?
Dialogue: 0,0:06:19.53,0:06:21.75,中文,,0,0,0,,取 6  然后做什么？
Dialogue: 0,0:06:21.75,0:06:22.93,英文,,0,0,0,,Oh, comparison, sure.
Dialogue: 0,0:06:21.75,0:06:22.93,中文,,0,0,0,,哦 比较 当然
Dialogue: 0,0:06:22.93,0:06:25.14,英文,,0,0,0,,And then what do you do once you finish comparing?
Dialogue: 0,0:06:22.93,0:06:25.14,中文,,0,0,0,,比较完之后做什么？
Dialogue: 0,0:06:25.14,0:06:27.08,英文,,0,0,0,,So let's say I look at the 8, it's greater than 6.
Dialogue: 0,0:06:25.14,0:06:27.08,中文,,0,0,0,,假设我看到了 8 它大于 6
Dialogue: 0,0:06:27.08,0:06:32.42,英文,,0,0,0,,What do I do with it?
Dialogue: 0,0:06:27.08,0:06:32.42,中文,,0,0,0,,我该怎么办？
Dialogue: 0,0:06:32.42,0:06:36.22,英文,,0,0,0,,I leave it in its place, and then what if it's less than 6?
Dialogue: 0,0:06:32.42,0:06:36.22,中文,,0,0,0,,把它留在原地 如果它小于 6 呢？
Dialogue: 0,0:06:36.22,0:06:36.94,英文,,0,0,0,,Put it to the left.
Dialogue: 0,0:06:36.22,0:06:36.94,中文,,0,0,0,,把它放在左边
Dialogue: 0,0:06:36.94,0:06:39.38,英文,,0,0,0,,Oh, so I'd have to swap it over?
Dialogue: 0,0:06:36.94,0:06:39.38,中文,,0,0,0,,哦 我得把它交换过来？
Dialogue: 0,0:06:39.38,0:06:40.54,英文,,0,0,0,,Yeah, that might work, right?
Dialogue: 0,0:06:39.38,0:06:40.54,中文,,0,0,0,,是的 这可能行得通 对吧？
Dialogue: 0,0:06:40.54,0:06:44.00,英文,,0,0,0,,I think if you do that, you actually end up doing an insertion sort to some extent.
Dialogue: 0,0:06:40.54,0:06:44.00,中文,,0,0,0,,我想如果你这样做 你最终会在某种程度上进行插入排序
Dialogue: 0,0:06:44.00,0:06:44.54,英文,,0,0,0,,So that would work.
Dialogue: 0,0:06:44.00,0:06:44.54,中文,,0,0,0,,那可行
Dialogue: 0,0:06:44.54,0:06:46.22,英文,,0,0,0,,Yeah, you can maybe swap some elements around.
Dialogue: 0,0:06:44.54,0:06:46.22,中文,,0,0,0,,是的 你可以交换一些元素
Dialogue: 0,0:06:46.22,0:06:49.43,英文,,0,0,0,,There are actually tons of valid answers to this one.
Dialogue: 0,0:06:46.22,0:06:49.43,中文,,0,0,0,,这个问题实际上有很多有效的答案
Dialogue: 0,0:06:49.43,0:06:50.31,英文,,0,0,0,,And we'll see one.
Dialogue: 0,0:06:49.43,0:06:50.31,中文,,0,0,0,,我们会看到一个
Dialogue: 0,0:06:50.31,0:06:51.43,英文,,0,0,0,,We'll see more later.
Dialogue: 0,0:06:50.31,0:06:51.43,中文,,0,0,0,,我们稍后会看到更多
Dialogue: 0,0:06:51.43,0:06:53.93,英文,,0,0,0,,Oh, do you have batteries for me?
Dialogue: 0,0:06:51.43,0:06:53.93,中文,,0,0,0,,有电池吗？
Dialogue: 0,0:06:53.93,0:07:14.16,英文,,0,0,0,,OK, hold that thought and maybe think about some other algorithms while I swap batteries real quick.
Dialogue: 0,0:06:53.93,0:07:14.16,中文,,0,0,0,,等我一下 我换个电池 你先想想其他算法
Dialogue: 0,0:07:14.16,0:07:17.74,英文,,0,0,0,,Yeah, I think all those are dead.
Dialogue: 0,0:07:14.16,0:07:17.74,中文,,0,0,0,,我觉得那些都没电了
Dialogue: 0,0:07:17.74,0:07:18.55,英文,,0,0,0,,OK, just kidding.
Dialogue: 0,0:07:17.74,0:07:18.55,中文,,0,0,0,,开玩笑的
Dialogue: 0,0:07:18.55,0:07:20.63,英文,,0,0,0,,We're going to be using this mic for a little bit longer.
Dialogue: 0,0:07:18.55,0:07:20.63,中文,,0,0,0,,这个麦克风我们还得用一会儿
Dialogue: 0,0:07:20.63,0:07:21.59,英文,,0,0,0,,All right.
Dialogue: 0,0:07:20.63,0:07:21.59,中文,,0,0,0,,好的
Dialogue: 0,0:07:21.59,0:07:24.27,英文,,0,0,0,,So there's all sorts of other algorithms you can think of.
Dialogue: 0,0:07:21.59,0:07:24.27,中文,,0,0,0,,我们可以考虑各种各样的算法
Dialogue: 0,0:07:24.27,0:07:27.51,英文,,0,0,0,,Here's one that I like, which I think just works.
Dialogue: 0,0:07:24.27,0:07:27.51,中文,,0,0,0,,我喜欢这个算法 我觉得它很有效
Dialogue: 0,0:07:27.51,0:07:28.39,英文,,0,0,0,,Where did the slide go?
Dialogue: 0,0:07:27.51,0:07:28.39,中文,,0,0,0,,幻灯片去哪了？
Dialogue: 0,0:07:28.39,0:07:28.99,英文,,0,0,0,,I don't know.
Dialogue: 0,0:07:28.39,0:07:28.99,中文,,0,0,0,,我不知道
Dialogue: 0,0:07:28.99,0:07:30.77,英文,,0,0,0,,I guess we're too cool for the slide.
Dialogue: 0,0:07:28.99,0:07:30.77,中文,,0,0,0,,我们好像不需要幻灯片
Dialogue: 0,0:07:30.77,0:07:37.33,英文,,0,0,0,,So one approach that I think works just fine is let's just scan all the elements and copy all the red items.
Dialogue: 0,0:07:30.77,0:07:37.33,中文,,0,0,0,,我认为有一种方法很有效 就是扫描所有元素 然后复制所有红色的元素
Dialogue: 0,0:07:37.33,0:07:38.63,英文,,0,0,0,,So I scan.
Dialogue: 0,0:07:37.33,0:07:38.63,中文,,0,0,0,,我先扫描
Dialogue: 0,0:07:38.63,0:07:39.49,英文,,0,0,0,,Don't copy, don't copy.
Dialogue: 0,0:07:38.63,0:07:39.49,中文,,0,0,0,,不复制 不复制
Dialogue: 0,0:07:39.49,0:07:40.37,英文,,0,0,0,,OK, I see the three.
Dialogue: 0,0:07:39.49,0:07:40.37,中文,,0,0,0,,好的 我看到3了
Dialogue: 0,0:07:40.37,0:07:40.99,英文,,0,0,0,,I copy it.
Dialogue: 0,0:07:40.37,0:07:40.99,中文,,0,0,0,,我复制它
Dialogue: 0,0:07:40.99,0:07:42.17,英文,,0,0,0,,The one, the two.
Dialogue: 0,0:07:40.99,0:07:42.17,中文,,0,0,0,,1 2
Dialogue: 0,0:07:42.17,0:07:42.95,英文,,0,0,0,,I don't copy this.
Dialogue: 0,0:07:42.17,0:07:42.95,中文,,0,0,0,,我不复制这个
Dialogue: 0,0:07:42.95,0:07:43.75,英文,,0,0,0,,And the four.
Dialogue: 0,0:07:42.95,0:07:43.75,中文,,0,0,0,,还有4
Dialogue: 0,0:07:43.75,0:07:45.08,英文,,0,0,0,,So I wrote those down.
Dialogue: 0,0:07:43.75,0:07:45.08,中文,,0,0,0,,我把它们都写下来了
Dialogue: 0,0:07:45.08,0:07:48.60,英文,,0,0,0,,And then I go back to the beginning, and I scan again, and I copy all the white items.
Dialogue: 0,0:07:45.08,0:07:48.60,中文,,0,0,0,,然后我回到开头 再次扫描 复制所有白色的元素
Dialogue: 0,0:07:48.60,0:07:53.02,英文,,0,0,0,,And then I look left to right, scan the array again, and I copy all the blue items.
Dialogue: 0,0:07:48.60,0:07:53.02,中文,,0,0,0,,接着 我从左到右扫描数组 复制所有蓝色的元素
Dialogue: 0,0:07:53.02,0:07:56.56,英文,,0,0,0,,So hopefully, we're convinced that that will work.
Dialogue: 0,0:07:53.02,0:07:56.56,中文,,0,0,0,,希望我们确信这样做有效
Dialogue: 0,0:07:56.56,0:07:58.36,英文,,0,0,0,,Is it the coolest partition algorithm?
Dialogue: 0,0:07:56.56,0:07:58.36,中文,,0,0,0,,这是最酷的分区算法吗？
Dialogue: 0,0:07:58.36,0:08:00.74,英文,,0,0,0,,No, because this is the ones those other guys came up with.
Dialogue: 0,0:07:58.36,0:08:00.74,中文,,0,0,0,,不是 因为这是其他人想出来的
Dialogue: 0,0:08:00.74,0:08:10.92,英文,,0,0,0,,But it will work, because I just scan the array three times, copying the less than items first, copying the equal items first, and then copying the greater than items last.
Dialogue: 0,0:08:00.74,0:08:10.92,中文,,0,0,0,,但这会奏效 因为我只扫描了数组三次 首先复制小于基准值的元素 然后复制等于基准值的元素 最后复制大于基准值的元素
Dialogue: 0,0:08:10.92,0:08:13.22,英文,,0,0,0,,OK, that's going to be good enough for now.
Dialogue: 0,0:08:10.92,0:08:13.22,中文,,0,0,0,,好的 目前这样就够了
Dialogue: 0,0:08:13.22,0:08:18.13,英文,,0,0,0,,We'll come back and come up with more clever partitioning algorithms later.
Dialogue: 0,0:08:13.22,0:08:18.13,中文,,0,0,0,,我们之后会回来想出更巧妙的分区算法
Dialogue: 0,0:08:18.13,0:08:21.89,英文,,0,0,0,,But at least we know what a partition is, and we know how to compute it.
Dialogue: 0,0:08:18.13,0:08:21.89,中文,,0,0,0,,但至少我们知道了什么是分区 以及如何计算它
Dialogue: 0,0:08:21.89,0:08:23.05,英文,,0,0,0,,Good.
Dialogue: 0,0:08:21.89,0:08:23.05,中文,,0,0,0,,很好
Dialogue: 0,0:08:23.05,0:08:28.63,英文,,0,0,0,,So with the core operation, we know that partitioning is the operation that's going to make quicksort work.
Dialogue: 0,0:08:23.05,0:08:28.63,中文,,0,0,0,,通过核心操作 我们知道分区是使快速排序算法起作用的操作
Dialogue: 0,0:08:28.63,0:08:33.11,英文,,0,0,0,,We can now apply this operation over and over to actually sort the array.
Dialogue: 0,0:08:28.63,0:08:33.11,中文,,0,0,0,,现在我们可以反复应用这个操作来实际排序数组
Dialogue: 0,0:08:33.11,0:08:38.71,英文,,0,0,0,,Because after you partition an array, here I partitioned on 6, is this array sorted?
Dialogue: 0,0:08:33.11,0:08:38.71,中文,,0,0,0,,因为在你对一个数组进行分区之后 这里我对 6 进行了分区 这个数组排序了吗？
Dialogue: 0,0:08:38.71,0:08:42.04,英文,,0,0,0,,No. 3, 1, 2, 4, that's not sorted.
Dialogue: 0,0:08:38.71,0:08:42.04,中文,,0,0,0,,没有  3, 1, 2, 4 这没有排序
Dialogue: 0,0:08:42.04,0:08:45.56,英文,,0,0,0,,But if I partition some more, maybe I can get it sorted.
Dialogue: 0,0:08:42.04,0:08:45.56,中文,,0,0,0,,但如果我再进行一些分区 也许我可以让它排序
Dialogue: 0,0:08:45.56,0:08:46.94,英文,,0,0,0,,So that's what I will do.
Dialogue: 0,0:08:45.56,0:08:46.94,中文,,0,0,0,,这就是我要做的
Dialogue: 0,0:08:46.94,0:08:49.87,英文,,0,0,0,,So here, I'm going to pick any item to be the pivot.
Dialogue: 0,0:08:46.94,0:08:49.87,中文,,0,0,0,,在这里 我将选择任何元素作为基准值
Dialogue: 0,0:08:49.87,0:08:51.35,英文,,0,0,0,,I will choose the leftmost for now.
Dialogue: 0,0:08:49.87,0:08:51.35,中文,,0,0,0,,我现在选择最左边的
Dialogue: 0,0:08:51.35,0:08:52.61,英文,,0,0,0,,So I chose 5.
Dialogue: 0,0:08:51.35,0:08:52.61,中文,,0,0,0,,我选择 5
Dialogue: 0,0:08:52.61,0:08:56.07,英文,,0,0,0,,I partitioned on 5, so now 5 is in its right place.
Dialogue: 0,0:08:52.61,0:08:56.07,中文,,0,0,0,,我按 5 进行了分区 所以现在 5 在它正确的位置上
Dialogue: 0,0:08:56.07,0:08:59.00,英文,,0,0,0,,And I know that this 5 is not going to move again.
Dialogue: 0,0:08:56.07,0:08:59.00,中文,,0,0,0,,而且我知道这个 5 不会再移动了
Dialogue: 0,0:08:59.00,0:09:02.00,英文,,0,0,0,,Because everything to this right is greater than or equal to 5.
Dialogue: 0,0:08:59.00,0:09:02.00,中文,,0,0,0,,因为右边所有的东西都大于或等于 5
Dialogue: 0,0:09:02.00,0:09:06.40,英文,,0,0,0,,Everything to the left of right, or 5, is less than or equal to 5.
Dialogue: 0,0:09:02.00,0:09:06.40,中文,,0,0,0,,右边或 5 左边的所有东西都小于或等于 5
Dialogue: 0,0:09:06.40,0:09:12.00,英文,,0,0,0,,So this 5 is in the right place it should be if the entire array sorted.
Dialogue: 0,0:09:06.40,0:09:12.00,中文,,0,0,0,,这个 5 在正确的位置上 如果整个数组排序 它应该在那里
Dialogue: 0,0:09:12.00,0:09:16.99,英文,,0,0,0,,So now we could maybe partition on some other elements, like 3, 2, 1, 7.
Dialogue: 0,0:09:12.00,0:09:16.99,中文,,0,0,0,,现在我们可以对其他一些元素进行分区 比如 3、2、1、7
Dialogue: 0,0:09:16.99,0:09:28.58,英文,,0,0,0,,But if I look at this, that's the order that things got swapped according to my 3-scan partition algorithm, where I just copied all the less than items, and the equal to items, and the greater than items.
Dialogue: 0,0:09:16.99,0:09:28.58,中文,,0,0,0,,但如果我看看这个 这就是根据我的 3 扫描分区算法交换东西的顺序 我只是复制了所有小于、等于和大于的元素
Dialogue: 0,0:09:28.58,0:09:36.50,英文,,0,0,0,,So the question is, how would I use the partition algorithm operation over and over again to actually sort this array?
Dialogue: 0,0:09:28.58,0:09:36.50,中文,,0,0,0,,问题是 我将如何一遍又一遍地使用分区算法操作来实际对这个数组进行排序？
Dialogue: 0,0:09:36.50,0:09:43.39,英文,,0,0,0,,Well, one thing I could do, and I bet if those other guys were here, they would show you this, is maybe they would just take the next element, 3,
Dialogue: 0,0:09:36.50,0:09:43.39,中文,,0,0,0,,我可以做的一件事 我打赌如果其他人在场 他们会告诉你 也许他们会取下一个元素 3
Dialogue: 0,0:09:43.39,0:09:50.39,英文,,0,0,0,,and then partition the entire array on 3, find out where it goes, and then take 2, partition it on the entire array,
Dialogue: 0,0:09:43.39,0:09:50.39,中文,,0,0,0,,然后在 3 上对整个数组进行分区 找出它在哪里 然后取 2 在整个数组上对其进行分区
Dialogue: 0,0:09:50.39,0:09:54.39,英文,,0,0,0,,find out where it goes, and do this over and over again.
Dialogue: 0,0:09:50.39,0:09:54.39,中文,,0,0,0,,找出它在哪里 然后一遍又一遍地这样做
Dialogue: 0,0:09:54.39,0:09:55.61,英文,,0,0,0,,But if you do that,
Dialogue: 0,0:09:54.39,0:09:55.61,中文,,0,0,0,,但如果你这样做
Dialogue: 0,0:09:55.61,0:10:03.83,英文,,0,0,0,,You're kind of wasting some work, because if I look at this 5, it sort of acts like a wall, because think about all the things to the left of 5.
Dialogue: 0,0:09:55.61,0:10:03.83,中文,,0,0,0,,你有点浪费了一些工作 因为如果我看看这个 5 它有点像一堵墙 因为想想 5 左边的所有东西
Dialogue: 0,0:10:03.83,0:10:04.91,英文,,0,0,0,,3, 2, 1, and 4.
Dialogue: 0,0:10:03.83,0:10:04.91,中文,,0,0,0,,3、2、1 和 4
Dialogue: 0,0:10:04.91,0:10:09.03,英文,,0,0,0,,Could any of them cross over to the other side of 5?
Dialogue: 0,0:10:04.91,0:10:09.03,中文,,0,0,0,,它们中的任何一个能越过 5 的另一边吗？
Dialogue: 0,0:10:09.03,0:10:10.83,英文,,0,0,0,,No, because they're all less than 5.
Dialogue: 0,0:10:09.03,0:10:10.83,中文,,0,0,0,,不能 因为它们都小于 5
Dialogue: 0,0:10:10.83,0:10:12.37,英文,,0,0,0,,And what about 7, 8, and 6?
Dialogue: 0,0:10:10.83,0:10:12.37,中文,,0,0,0,,那 7、8 和 6 呢？
Dialogue: 0,0:10:12.37,0:10:15.73,英文,,0,0,0,,Could any of these cross over to the left of 5?
Dialogue: 0,0:10:12.37,0:10:15.73,中文,,0,0,0,,这些中的任何一个能越过 5 的左边吗？
Dialogue: 0,0:10:15.73,0:10:18.28,英文,,0,0,0,,No, because they're all greater than or equal to 5.
Dialogue: 0,0:10:15.73,0:10:18.28,中文,,0,0,0,,不能 因为它们都大于或等于 5
Dialogue: 0,0:10:18.28,0:10:24.24,英文,,0,0,0,,So not only is 5 in its correct place, that is, when I finish sorting the array,
Dialogue: 0,0:10:18.28,0:10:24.24,中文,,0,0,0,,所以 5 不仅在它正确的位置上 也就是说 当我完成数组的排序时
Dialogue: 0,0:10:24.24,0:10:28.24,英文,,0,0,0,,I know that's where it's going to land, but I have actually formed two smaller subproblems.
Dialogue: 0,0:10:24.24,0:10:28.24,中文,,0,0,0,,我知道它会落在哪里 但我实际上已经形成了两个更小的子问题
Dialogue: 0,0:10:28.24,0:10:32.11,英文,,0,0,0,,I no longer have to go back to this big problem to continue partitioning.
Dialogue: 0,0:10:28.24,0:10:32.11,中文,,0,0,0,,我不再需要回到这个大问题来继续分区
Dialogue: 0,0:10:32.11,0:10:36.17,英文,,0,0,0,,I could actually just solve the small problem to the left and the small problem to the right.
Dialogue: 0,0:10:32.11,0:10:36.17,中文,,0,0,0,,我实际上可以只解决左边的小问题和右边的小问题
Dialogue: 0,0:10:36.17,0:10:39.37,英文,,0,0,0,,And once they're both solved, I will be done.
Dialogue: 0,0:10:36.17,0:10:39.37,中文,,0,0,0,,两个都搞定 就大功告成了
Dialogue: 0,0:10:39.37,0:10:54.11,英文,,0,0,0,,That's the cool observation about partitioning, is that after you finish partitioning, not only do you find the correct location for the number 5, but you've also now created two smaller subproblems that you can solve separately.
Dialogue: 0,0:10:39.37,0:10:54.11,中文,,0,0,0,,分区最妙的地方在于 完成分区后 不仅找到了数字 5 的正确位置 还创建了两个可以分别解决的更小子问题
Dialogue: 0,0:10:54.11,0:10:58.52,英文,,0,0,0,,And once you finish solving each side, you will have a sorted array.
Dialogue: 0,0:10:54.11,0:10:58.52,中文,,0,0,0,,解决完两边 数组就排序好了
Dialogue: 0,0:10:58.52,0:10:59.04,英文,,0,0,0,,OK.
Dialogue: 0,0:10:58.52,0:10:59.04,中文,,0,0,0,,好的
Dialogue: 0,0:10:59.04,0:11:02.84,英文,,0,0,0,,Bask in the glory of Quicksort for a second while I swap batteries.
Dialogue: 0,0:10:59.04,0:11:02.84,中文,,0,0,0,,我去换个电池 你们先感受一下快速排序的魅力吧
Dialogue: 0,0:11:02.84,0:11:03.98,英文,,0,0,0,,Sorry.
Dialogue: 0,0:11:02.84,0:11:03.98,中文,,0,0,0,,抱歉
Dialogue: 0,0:11:03.98,0:11:04.62,英文,,0,0,0,,OK.
Dialogue: 0,0:11:03.98,0:11:04.62,中文,,0,0,0,,好的
Dialogue: 0,0:11:04.62,0:11:15.35,英文,,0,0,0,,Thanks.
Dialogue: 0,0:11:04.62,0:11:15.35,中文,,0,0,0,,谢谢
Dialogue: 0,0:11:15.35,0:11:19.03,英文,,0,0,0,,Those are the old ones.
Dialogue: 0,0:11:15.35,0:11:19.03,中文,,0,0,0,,那些是旧电池
Dialogue: 0,0:11:19.03,0:11:21.01,英文,,0,0,0,,OK, hopefully it's still OK on Zoom.
Dialogue: 0,0:11:19.03,0:11:21.01,中文,,0,0,0,,好 希望 Zoom 上还能正常
Dialogue: 0,0:11:21.01,0:11:25.84,英文,,0,0,0,,OK, so here you can see I now have two smaller arrays, the 3, 2, 1, 4, and the 7, 8, 6.
Dialogue: 0,0:11:21.01,0:11:25.84,中文,,0,0,0,,现在可以看到 我有了两个更小的数组 3、2、1、4 和 7、8、6
Dialogue: 0,0:11:25.84,0:11:31.38,英文,,0,0,0,,I sort each side separately, and my array will be sorted.
Dialogue: 0,0:11:25.84,0:11:31.38,中文,,0,0,0,,我分别对两边进行排序 我的数组就会有序
Dialogue: 0,0:11:31.38,0:11:32.20,英文,,0,0,0,,OK, good.
Dialogue: 0,0:11:31.38,0:11:32.20,中文,,0,0,0,,很好
Dialogue: 0,0:11:32.20,0:11:38.79,英文,,0,0,0,,So at this point, by the way, what you could do is you could say, I'll merge for the left half, and I'll merge for the right half.
Dialogue: 0,0:11:32.20,0:11:38.79,中文,,0,0,0,,顺便说一句 此时你可以说 我要合并左半部分 然后合并右半部分
Dialogue: 0,0:11:38.79,0:11:42.78,英文,,0,0,0,,You could do that, but maybe to
Dialogue: 0,0:11:38.79,0:11:42.78,中文,,0,0,0,,你可以这样做 但也许是为了
Dialogue: 0,0:11:42.78,0:11:47.38,英文,,0,0,0,,I don't know, fully use quicksort all the way to the end.
Dialogue: 0,0:11:42.78,0:11:47.38,中文,,0,0,0,,我不知道 充分利用快速排序直到最后
Dialogue: 0,0:11:47.38,0:11:50.12,英文,,0,0,0,,What if I quicksorted the left half and I quicksorted the right half?
Dialogue: 0,0:11:47.38,0:11:50.12,中文,,0,0,0,,如果我对左半部分和右半部分进行快速排序呢？
Dialogue: 0,0:11:50.12,0:11:51.84,英文,,0,0,0,,So it's a recursive algorithm.
Dialogue: 0,0:11:50.12,0:11:51.84,中文,,0,0,0,,它是一种递归算法
Dialogue: 0,0:11:51.84,0:11:53.02,英文,,0,0,0,,So I could do that.
Dialogue: 0,0:11:51.84,0:11:53.02,中文,,0,0,0,,我可以这样做
Dialogue: 0,0:11:53.02,0:11:56.43,英文,,0,0,0,,If I wanted to quicksort the left half, I would take the number 3.
Dialogue: 0,0:11:53.02,0:11:56.43,中文,,0,0,0,,如果我想对左半部分进行快速排序 我会取数字 3
Dialogue: 0,0:11:56.43,0:12:01.55,英文,,0,0,0,,It would be my new partition, because for now, I'm just choosing the leftmost item as the partition.
Dialogue: 0,0:11:56.43,0:12:01.55,中文,,0,0,0,,这将是我的新分区 因为目前 我只是选择最左边的元素作为分区
Dialogue: 0,0:12:01.55,0:12:04.63,英文,,0,0,0,,I would take all the items less than 3, put them on the left of 3.
Dialogue: 0,0:12:01.55,0:12:04.63,中文,,0,0,0,,我会把所有小于 3 的元素放在 3 的左边
Dialogue: 0,0:12:04.63,0:12:06.75,英文,,0,0,0,,All the items greater than 3, put them on the right.
Dialogue: 0,0:12:04.63,0:12:06.75,中文,,0,0,0,,所有大于 3 的元素都放在右边
Dialogue: 0,0:12:06.75,0:12:08.89,英文,,0,0,0,,Do I have to worry about 7, 8, 6?
Dialogue: 0,0:12:06.75,0:12:08.89,中文,,0,0,0,,我需要担心 7、8、6 吗？
Dialogue: 0,0:12:08.89,0:12:10.14,英文,,0,0,0,,No, that's a separate subproblem.
Dialogue: 0,0:12:08.89,0:12:10.14,中文,,0,0,0,,不用 那是一个单独的子问题
Dialogue: 0,0:12:10.14,0:12:11.78,英文,,0,0,0,,That's someone else's problem.
Dialogue: 0,0:12:10.14,0:12:11.78,中文,,0,0,0,,那是别人的问题
Dialogue: 0,0:12:11.78,0:12:12.74,英文,,0,0,0,,And so I can partition on 3.
Dialogue: 0,0:12:11.78,0:12:12.74,中文,,0,0,0,,我可以在 3 上进行分区
Dialogue: 0,0:12:12.74,0:12:14.62,英文,,0,0,0,,This is a valid partition on 3.
Dialogue: 0,0:12:12.74,0:12:14.62,中文,,0,0,0,,这是在 3 上的一个有效分区
Dialogue: 0,0:12:14.62,0:12:16.74,英文,,0,0,0,,It's not the only one, but it's one of them.
Dialogue: 0,0:12:14.62,0:12:16.74,中文,,0,0,0,,这不是唯一的一个 但它是其中之一
Dialogue: 0,0:12:16.74,0:12:21.21,英文,,0,0,0,,Everything less than or equal to 3 on the left, everything greater than or equal to 3 on the right.
Dialogue: 0,0:12:16.74,0:12:21.21,中文,,0,0,0,,所有小于或等于 3 的元素都在左边 所有大于或等于 3 的元素都在右边
Dialogue: 0,0:12:21.21,0:12:24.49,英文,,0,0,0,,And likewise, on this side, I chose 7 to be the partition.
Dialogue: 0,0:12:21.21,0:12:24.49,中文,,0,0,0,,同样 在这一边 我选择 7 作为分区
Dialogue: 0,0:12:24.49,0:12:25.94,英文,,0,0,0,,I partitioned on 7.
Dialogue: 0,0:12:24.49,0:12:25.94,中文,,0,0,0,,我在 7 上进行了分区
Dialogue: 0,0:12:25.94,0:12:28.60,英文,,0,0,0,,And now I've actually created four smaller subproblems.
Dialogue: 0,0:12:25.94,0:12:28.60,中文,,0,0,0,,现在我实际上创建了四个更小的子问题
Dialogue: 0,0:12:28.60,0:12:30.18,英文,,0,0,0,,So you see where this is going.
Dialogue: 0,0:12:28.60,0:12:30.18,中文,,0,0,0,,你知道这是怎么回事了
Dialogue: 0,0:12:30.18,0:12:36.95,英文,,0,0,0,,Now I have this subproblem, which is 2 and 1, this subproblem, which is the single element, this subproblem, this subproblem.
Dialogue: 0,0:12:30.18,0:12:36.95,中文,,0,0,0,,现在我有了这个子问题 它是 2 和 1 这个子问题 是单个元素 这个子问题 这个子问题
Dialogue: 0,0:12:36.95,0:12:44.09,英文,,0,0,0,,And in fact, the 3, the 5, and the 7, the three things I've partitioned on, they've all fallen into their correct places.
Dialogue: 0,0:12:36.95,0:12:44.09,中文,,0,0,0,,事实上 3、5 和 7 我分区的这三样东西 它们都已经落在了正确的位置上
Dialogue: 0,0:12:44.09,0:12:47.74,英文,,0,0,0,,So when I finish sorting the array, I know that this is where the 3 is going to go.
Dialogue: 0,0:12:44.09,0:12:47.74,中文,,0,0,0,,当我完成数组排序时 我知道这就是 3 将要去的地方
Dialogue: 0,0:12:47.74,0:12:49.14,英文,,0,0,0,,That's where the 5's going.
Dialogue: 0,0:12:47.74,0:12:49.14,中文,,0,0,0,,那是 5 将要去的地方
Dialogue: 0,0:12:49.14,0:12:51.10,英文,,0,0,0,,That's where the 7 is going.
Dialogue: 0,0:12:49.14,0:12:51.10,中文,,0,0,0,,那是 7 将要去的地方
Dialogue: 0,0:12:51.10,0:12:53.14,英文,,0,0,0,,That's quicksort.
Dialogue: 0,0:12:51.10,0:12:53.14,中文,,0,0,0,,这就是快速排序
Dialogue: 0,0:12:53.14,0:12:54.60,英文,,0,0,0,,It's based on partitions.
Dialogue: 0,0:12:53.14,0:12:54.60,中文,,0,0,0,,基于分区
Dialogue: 0,0:12:54.60,0:12:55.60,英文,,0,0,0,,So you partition.
Dialogue: 0,0:12:54.60,0:12:55.60,中文,,0,0,0,,划分一下
Dialogue: 0,0:12:55.60,0:12:57.59,英文,,0,0,0,,For now, we'll choose the leftmost item.
Dialogue: 0,0:12:55.60,0:12:57.59,中文,,0,0,0,,现在 选择最左边的项
Dialogue: 0,0:12:57.59,0:12:59.17,英文,,0,0,0,,Later, I'll show you.
Dialogue: 0,0:12:57.59,0:12:59.17,中文,,0,0,0,,稍后会演示
Dialogue: 0,0:12:59.17,0:13:01.25,英文,,0,0,0,,Don't tell the other guys, but I'll show you something cooler.
Dialogue: 0,0:12:59.17,0:13:01.25,中文,,0,0,0,,别告诉其他人 来点更酷的
Dialogue: 0,0:13:01.25,0:13:04.61,英文,,0,0,0,,And then I'll quicksort the left half, and I'll quicksort the right half.
Dialogue: 0,0:13:01.25,0:13:04.61,中文,,0,0,0,,快速排序左边 再排序右边
Dialogue: 0,0:13:04.61,0:13:12.61,英文,,0,0,0,,So just to see it in action one more time, and then you can stop me for thoughts or questions, I will take the leftmost item, which is 32.
Dialogue: 0,0:13:04.61,0:13:12.61,中文,,0,0,0,,再演示一遍 有想法或问题随时喊停 选最左边的项 32
Dialogue: 0,0:13:12.61,0:13:17.18,英文,,0,0,0,,And I've helpfully colored everything less than 32 red and everything greater than 32 blue.
Dialogue: 0,0:13:12.61,0:13:17.18,中文,,0,0,0,,小于 32 的标红 大于 32 的标蓝
Dialogue: 0,0:13:17.18,0:13:19.46,英文,,0,0,0,,You don't have to, but I did on the slide.
Dialogue: 0,0:13:17.18,0:13:19.46,中文,,0,0,0,,可以不用 但幻灯片里标了
Dialogue: 0,0:13:19.46,0:13:22.36,英文,,0,0,0,,And I partitioned on 32.
Dialogue: 0,0:13:19.46,0:13:22.36,中文,,0,0,0,,以 32 为基准分区
Dialogue: 0,0:13:22.36,0:13:25.39,英文,,0,0,0,,So everything to the left of 32 is less than or equal to 32.
Dialogue: 0,0:13:22.36,0:13:25.39,中文,,0,0,0,,32 左边的都小于等于 32
Dialogue: 0,0:13:25.39,0:13:27.63,英文,,0,0,0,,Everything to the right is greater than or equal to.
Dialogue: 0,0:13:25.39,0:13:27.63,中文,,0,0,0,,右边的都大于等于 32
Dialogue: 0,0:13:27.63,0:13:28.75,英文,,0,0,0,,You get the idea.
Dialogue: 0,0:13:27.63,0:13:28.75,中文,,0,0,0,,懂了吧
Dialogue: 0,0:13:28.75,0:13:30.35,英文,,0,0,0,,Now I've created two subproblems.
Dialogue: 0,0:13:28.75,0:13:30.35,中文,,0,0,0,,现在有两个子问题
Dialogue: 0,0:13:30.35,0:13:33.84,英文,,0,0,0,,So I'll quicksort the left half, and I'll quicksort the right half.
Dialogue: 0,0:13:30.35,0:13:33.84,中文,,0,0,0,,分别快速排序左右两边
Dialogue: 0,0:13:33.84,0:13:35.56,英文,,0,0,0,,32 is locked in place.
Dialogue: 0,0:13:33.84,0:13:35.56,中文,,0,0,0,,32 锁定到位
Dialogue: 0,0:13:35.56,0:13:42.19,英文,,0,0,0,,I don't know what the true sort is yet, but I know whatever the true sort is going to be, that's where the 32 is going to go.
Dialogue: 0,0:13:35.56,0:13:42.19,中文,,0,0,0,,还不知道最终排序 但无论怎么排 32 都在现在的位置
Dialogue: 0,0:13:42.19,0:13:46.10,英文,,0,0,0,,Sure. Then I can quicksort the entire left half.
Dialogue: 0,0:13:42.19,0:13:46.10,中文,,0,0,0,,当然  然后快速排序整个左边
Dialogue: 0,0:13:46.10,0:13:48.18,英文,,0,0,0,,Then I can quicksort the entire right half.
Dialogue: 0,0:13:46.10,0:13:48.18,中文,,0,0,0,,再排序整个右边
Dialogue: 0,0:13:48.18,0:13:51.84,英文,,0,0,0,,So I kind of skipped over things because that's the kind of guy I am.
Dialogue: 0,0:13:48.18,0:13:51.84,中文,,0,0,0,,我跳过了一些内容 因为我就是这样的人
Dialogue: 0,0:13:51.84,0:13:58.98,英文,,0,0,0,,But if you were like those other two guys and you want to see it in more detail, there are some extra slides that will walk you through the entire thing front to back.
Dialogue: 0,0:13:51.84,0:13:58.98,中文,,0,0,0,,但如果你跟那两位一样 想了解更详细的内容 这里有一些额外的幻灯片 可以带你完整地了解整个过程
Dialogue: 0,0:13:58.98,0:14:02.70,英文,,0,0,0,,So if you're not convinced that the recursive step works, check this out.
Dialogue: 0,0:13:58.98,0:14:02.70,中文,,0,0,0,,如果你不相信递归步骤有效 看看这个
Dialogue: 0,0:14:02.70,0:14:04.88,英文,,0,0,0,,You can watch the partitions go all the way down.
Dialogue: 0,0:14:02.70,0:14:04.88,中文,,0,0,0,,你可以看到分区一直向下进行
Dialogue: 0,0:14:04.88,0:14:09.80,英文,,0,0,0,,And in fact, here's actually a recursive tree showing you what partition operations happen.
Dialogue: 0,0:14:04.88,0:14:09.80,中文,,0,0,0,,事实上 这里有一棵递归树 展示了分区操作的发生情况
Dialogue: 0,0:14:09.80,0:14:13.32,英文,,0,0,0,,So for example, the 32 was the first thing we partitioned.
Dialogue: 0,0:14:09.80,0:14:13.32,中文,,0,0,0,,例如 32 是我们第一个分区的东西
Dialogue: 0,0:14:13.32,0:14:14.98,英文,,0,0,0,,And then we had two subproblems.
Dialogue: 0,0:14:13.32,0:14:14.98,中文,,0,0,0,,然后我们有两个子问题
Dialogue: 0,0:14:14.98,0:14:16.82,英文,,0,0,0,,Remember, we partitioned the 15 and the 41.
Dialogue: 0,0:14:14.98,0:14:16.82,中文,,0,0,0,,还记得吗 我们对 15 和 41 进行了分区
Dialogue: 0,0:14:16.82,0:14:19.14,英文,,0,0,0,,So there's the 15.
Dialogue: 0,0:14:16.82,0:14:19.14,中文,,0,0,0,,15 在这里
Dialogue: 0,0:14:19.14,0:14:22.54,英文,,0,0,0,,And then the 15 partitions on two smaller problems, so forth.
Dialogue: 0,0:14:19.14,0:14:22.54,中文,,0,0,0,,然后 15 分区成两个更小的子问题 以此类推
Dialogue: 0,0:14:22.54,0:14:24.47,英文,,0,0,0,,So that's QuickSort.
Dialogue: 0,0:14:22.54,0:14:24.47,中文,,0,0,0,,这就是快速排序
Dialogue: 0,0:14:24.47,0:14:27.25,英文,,0,0,0,,You partition and partition again all the way down.
Dialogue: 0,0:14:24.47,0:14:27.25,中文,,0,0,0,,你不断地进行分区 一直向下
Dialogue: 0,0:14:27.25,0:14:34.45,英文,,0,0,0,,And the two key ideas I want you to take away, one of them is how partitioning works, what the operation actually does.
Dialogue: 0,0:14:27.25,0:14:34.45,中文,,0,0,0,,我想让你们记住两个关键点 一个是分区是如何工作的 这个操作实际上是做什么的
Dialogue: 0,0:14:34.45,0:14:39.23,英文,,0,0,0,,And the second key idea is that once you partition, you create two smaller problems.
Dialogue: 0,0:14:34.45,0:14:39.23,中文,,0,0,0,,第二个关键点是 一旦你分区 你就会创建两个更小的子问题
Dialogue: 0,0:14:39.23,0:14:47.49,英文,,0,0,0,,That's what makes Quicksort fast, is the fact that after you partition, there are now two smaller subproblems that can each be solved separately.
Dialogue: 0,0:14:39.23,0:14:47.49,中文,,0,0,0,,这就是快速排序速度快的原因 因为在你分区之后 现在有两个更小的子问题可以分别解决
Dialogue: 0,0:14:47.49,0:14:51.19,英文,,0,0,0,,Kind of has the same flavor as MergeSort, but it's a bit wilder.
Dialogue: 0,0:14:47.49,0:14:51.19,中文,,0,0,0,,有点像归并排序 但更狂野一些
Dialogue: 0,0:14:51.19,0:14:52.58,英文,,0,0,0,,OK.
Dialogue: 0,0:14:51.19,0:14:52.58,中文,,0,0,0,,好的
Dialogue: 0,0:14:52.58,0:14:53.28,英文,,0,0,0,,So that's Quicksort.
Dialogue: 0,0:14:52.58,0:14:53.28,中文,,0,0,0,,这就是快速排序
Dialogue: 0,0:14:53.28,0:14:54.72,英文,,0,0,0,,There are extra slides.
Dialogue: 0,0:14:53.28,0:14:54.72,中文,,0,0,0,,还有额外的幻灯片
Dialogue: 0,0:14:54.72,0:14:58.70,英文,,0,0,0,,What do you want to know about Quicksort before I show you more?
Dialogue: 0,0:14:54.72,0:14:58.70,中文,,0,0,0,,在我展示更多内容之前 你想了解关于快速排序的哪些内容？
Dialogue: 0,0:14:58.70,0:15:00.30,英文,,0,0,0,,Runtime, soon.
Dialogue: 0,0:14:58.70,0:15:00.30,中文,,0,0,0,,马上说运行时间
Dialogue: 0,0:15:00.30,0:15:02.12,英文,,0,0,0,,How do you manage to find the middle point?
Dialogue: 0,0:15:00.30,0:15:02.12,中文,,0,0,0,,你怎么找到中间点的？
Dialogue: 0,0:15:02.12,0:15:02.80,英文,,0,0,0,,Soon.
Dialogue: 0,0:15:02.12,0:15:02.80,中文,,0,0,0,,马上
Dialogue: 0,0:15:02.80,0:15:05.32,英文,,0,0,0,,Anything else?
Dialogue: 0,0:15:02.80,0:15:05.32,中文,,0,0,0,,还有其他问题吗？
Dialogue: 0,0:15:05.32,0:15:10.07,英文,,0,0,0,,OK, there were two questions on Zoom, but they'll be answered in due time.
Dialogue: 0,0:15:05.32,0:15:10.07,中文,,0,0,0,,好的 Zoom 上有两个问题 稍后会回答
Dialogue: 0,0:15:10.07,0:15:12.91,英文,,0,0,0,,OK, so that's QuickSort.
Dialogue: 0,0:15:10.07,0:15:12.91,中文,,0,0,0,,好的 这就是快速排序
Dialogue: 0,0:15:12.91,0:15:19.08,英文,,0,0,0,,By the way, in terms of naming, if I were to name this using the same naming convention as the other sorts, I would have called it PartitionSort
Dialogue: 0,0:15:12.91,0:15:19.08,中文,,0,0,0,,顺便说一下 就命名而言 如果我用其他排序相同的命名约定来命名它 我会称它为分区排序
Dialogue: 0,0:15:19.08,0:15:27.08,英文,,0,0,0,,because that's the operation that it's doing, just like how we called MergeSort MergeSort because it was merging at every time step.
Dialogue: 0,0:15:19.08,0:15:27.08,中文,,0,0,0,,因为这就是它正在进行的操作 就像我们将归并排序称为归并排序一样 因为它在每个时间步都在合并
Dialogue: 0,0:15:27.08,0:15:30.92,英文,,0,0,0,,But Tony and I, you know, We're built different.
Dialogue: 0,0:15:27.08,0:15:30.92,中文,,0,0,0,,但是 Tony 和我 你知道  我们与众不同
Dialogue: 0,0:15:30.92,0:15:37.63,英文,,0,0,0,,So instead of saying partition sort, we just called it quicksort, even though we didn't know it was the fastest sorting algorithm.
Dialogue: 0,0:15:30.92,0:15:37.63,中文,,0,0,0,,我们没有说分区排序 而是称它为快速排序 即使我们不知道它是最快的排序算法
Dialogue: 0,0:15:37.63,0:15:45.40,英文,,0,0,0,,But it turns out, Tony was either lucky or had the vision, because quicksort is actually the fastest known sort if you run experiments.
Dialogue: 0,0:15:37.63,0:15:45.40,中文,,0,0,0,,但事实证明 Tony 要么是幸运 要么是有远见 因为如果你进行实验 快速排序实际上是最快的已知排序
Dialogue: 0,0:15:45.40,0:15:55.18,英文,,0,0,0,,It's fast. So the next thing we will do is try and calculate how fast exactly is the fastest known comparison sort.
Dialogue: 0,0:15:45.40,0:15:55.18,中文,,0,0,0,,它很快  所以接下来我们要做的是尝试计算最快的已知比较排序到底有多快
Dialogue: 0,0:15:55.18,0:15:57.66,英文,,0,0,0,,So that's coming up next.
Dialogue: 0,0:15:55.18,0:15:57.66,中文,,0,0,0,,接下来就讲这个
Dialogue: 0,0:15:57.66,0:16:00.79,英文,,0,0,0,,I saw someone predicted a runtime in chat earlier.
Dialogue: 0,0:15:57.66,0:16:00.79,中文,,0,0,0,,我看到之前有人在聊天中预测了运行时间
Dialogue: 0,0:16:00.79,0:16:02.19,英文,,0,0,0,,So let's see if you're right.
Dialogue: 0,0:16:00.79,0:16:02.19,中文,,0,0,0,,让我们看看你说的对不对
Dialogue: 0,0:16:02.19,0:16:03.75,英文,,0,0,0,,So let's start with the best case.
Dialogue: 0,0:16:02.19,0:16:03.75,中文,,0,0,0,,那么让我们从最好的情况开始
Dialogue: 0,0:16:03.75,0:16:07.85,英文,,0,0,0,,Let's say we get super lucky because not only am I a pretty cool guy, I'm pretty lucky too.
Dialogue: 0,0:16:03.75,0:16:07.85,中文,,0,0,0,,假设我们超级幸运 因为我不仅是个很酷的人 而且也很幸运
Dialogue: 0,0:16:07.85,0:16:13.13,英文,,0,0,0,,So what if I'm very lucky and every time I choose the pivot, so I choose this item,
Dialogue: 0,0:16:07.85,0:16:13.13,中文,,0,0,0,,如果我很幸运 每次我选择主元 也就是我选择这个元素
Dialogue: 0,0:16:13.13,0:16:17.13,英文,,0,0,0,,turns out half the items are less than the pivot and half the items are greater than the pivot.
Dialogue: 0,0:16:13.13,0:16:17.13,中文,,0,0,0,,结果发现一半的元素小于主元 一半的元素大于主元 会怎么样呢？
Dialogue: 0,0:16:17.13,0:16:26.62,英文,,0,0,0,,So every time I choose the pivot, I get super lucky and it lands exactly in the middle because half the items are to its left and half the items are to its right.
Dialogue: 0,0:16:17.13,0:16:26.62,中文,,0,0,0,,每次我选择主元 我都超级幸运 它正好落在中间 因为一半的元素在它的左边 一半的元素在它的右边
Dialogue: 0,0:16:26.62,0:16:28.00,英文,,0,0,0,,I take this array.
Dialogue: 0,0:16:26.62,0:16:28.00,中文,,0,0,0,,看这个数组
Dialogue: 0,0:16:28.00,0:16:29.90,英文,,0,0,0,,You can pretend it's got some numbers inside.
Dialogue: 0,0:16:28.00,0:16:29.90,中文,,0,0,0,,假设里面有一些数字
Dialogue: 0,0:16:29.90,0:16:32.02,英文,,0,0,0,,Let's say I get super lucky on this item.
Dialogue: 0,0:16:29.90,0:16:32.02,中文,,0,0,0,,假如我很幸运 挑中了这个元素
Dialogue: 0,0:16:32.02,0:16:34.06,英文,,0,0,0,,It lands directly in the middle.
Dialogue: 0,0:16:32.02,0:16:34.06,中文,,0,0,0,,它正好落在中间
Dialogue: 0,0:16:34.06,0:16:36.28,英文,,0,0,0,,All the items to the left are less than this item.
Dialogue: 0,0:16:34.06,0:16:36.28,中文,,0,0,0,,左边所有的元素都小于这个元素
Dialogue: 0,0:16:36.28,0:16:39.02,英文,,0,0,0,,All the items to the right are greater than this item.
Dialogue: 0,0:16:36.28,0:16:39.02,中文,,0,0,0,,右边所有的元素都大于这个元素
Dialogue: 0,0:16:39.02,0:16:40.58,英文,,0,0,0,,By the way, sometimes I say less than.
Dialogue: 0,0:16:39.02,0:16:40.58,中文,,0,0,0,,顺便说一下 有时我说“小于”
Dialogue: 0,0:16:40.58,0:16:41.86,英文,,0,0,0,,I mean less than or equal to.
Dialogue: 0,0:16:40.58,0:16:41.86,中文,,0,0,0,,我的意思是小于或等于
Dialogue: 0,0:16:41.86,0:16:43.90,英文,,0,0,0,,So sorry if I tripped you up on that.
Dialogue: 0,0:16:41.86,0:16:43.90,中文,,0,0,0,,如果这让你困惑了 我很抱歉
Dialogue: 0,0:16:43.90,0:16:44.54,英文,,0,0,0,,Great.
Dialogue: 0,0:16:43.90,0:16:44.54,中文,,0,0,0,,很好
Dialogue: 0,0:16:44.54,0:16:46.12,英文,,0,0,0,,Now I have two smaller problems.
Dialogue: 0,0:16:44.54,0:16:46.12,中文,,0,0,0,,现在我有两个更小的问题
Dialogue: 0,0:16:46.12,0:16:47.98,英文,,0,0,0,,So I'll solve each one separately.
Dialogue: 0,0:16:46.12,0:16:47.98,中文,,0,0,0,,我会分别解决它们
Dialogue: 0,0:16:47.98,0:16:50.08,英文,,0,0,0,,And let's say I get lucky again.
Dialogue: 0,0:16:47.98,0:16:50.08,中文,,0,0,0,,假设我又幸运了
Dialogue: 0,0:16:50.08,0:16:53.76,英文,,0,0,0,,This pivot that I choose for the left subarray happens to land in the middle.
Dialogue: 0,0:16:50.08,0:16:53.76,中文,,0,0,0,,我为左侧子数组选择的这个轴点正好落在中间
Dialogue: 0,0:16:53.76,0:16:57.97,英文,,0,0,0,,This pivot that I choose for the right subarray happens to land in the middle as well.
Dialogue: 0,0:16:53.76,0:16:57.97,中文,,0,0,0,,我为右侧子数组选择的这个轴点也正好落在中间
Dialogue: 0,0:16:57.97,0:16:58.59,英文,,0,0,0,,OK, great.
Dialogue: 0,0:16:57.97,0:16:58.59,中文,,0,0,0,,好的 很好
Dialogue: 0,0:16:58.59,0:17:01.71,英文,,0,0,0,,Now I've created four subproblems.
Dialogue: 0,0:16:58.59,0:17:01.71,中文,,0,0,0,,现在我创建了四个子问题
Dialogue: 0,0:17:01.71,0:17:03.69,英文,,0,0,0,,And for each subproblem, I choose the pivot.
Dialogue: 0,0:17:01.71,0:17:03.69,中文,,0,0,0,,对于每个子问题 我都选择轴点
Dialogue: 0,0:17:03.69,0:17:13.52,英文,,0,0,0,,And let's say I get lucky again, and that pivot lands in the middle of its subarray so that half the items are less than that pivot, half the items are greater than that pivot in that subarray.
Dialogue: 0,0:17:03.69,0:17:13.52,中文,,0,0,0,,假设我又幸运了 那个轴点正好落在它子数组的中间 这样一半的元素小于那个轴点 一半的元素大于那个轴点
Dialogue: 0,0:17:13.52,0:17:14.32,英文,,0,0,0,,OK, great.
Dialogue: 0,0:17:13.52,0:17:14.32,中文,,0,0,0,,好的 很好
Dialogue: 0,0:17:14.32,0:17:17.76,英文,,0,0,0,,And now these are all the things left to be sorted in green.
Dialogue: 0,0:17:14.32,0:17:17.76,中文,,0,0,0,,现在绿色部分就是待排序的元素
Dialogue: 0,0:17:17.76,0:17:23.46,英文,,0,0,0,,Everything in black has already been the pivot once and has already been sorted into its rightful place.
Dialogue: 0,0:17:17.76,0:17:23.46,中文,,0,0,0,,黑色部分的元素都做过一次基准元素 并且已经排好序了
Dialogue: 0,0:17:23.46,0:17:24.26,英文,,0,0,0,,All these are of size 1.
Dialogue: 0,0:17:23.46,0:17:24.26,中文,,0,0,0,,这些元素的大小都是 1
Dialogue: 0,0:17:24.26,0:17:27.13,英文,,0,0,0,,So if I partition on size 1,
Dialogue: 0,0:17:24.26,0:17:27.13,中文,,0,0,0,,如果对大小为 1 的元素进行分区
Dialogue: 0,0:17:27.13,0:17:27.97,英文,,0,0,0,,I'm done.
Dialogue: 0,0:17:27.13,0:17:27.97,中文,,0,0,0,,那就完成了
Dialogue: 0,0:17:27.97,0:17:29.31,英文,,0,0,0,,It's a base case.
Dialogue: 0,0:17:27.97,0:17:29.31,中文,,0,0,0,,这就是基本情况
Dialogue: 0,0:17:29.31,0:17:30.87,英文,,0,0,0,,And so we're done.
Dialogue: 0,0:17:29.31,0:17:30.87,中文,,0,0,0,,我们完成了
Dialogue: 0,0:17:30.87,0:17:37.25,英文,,0,0,0,,So that's what Quicksort looks like if you get lucky and every pivot that you choose lands directly in the middle.
Dialogue: 0,0:17:30.87,0:17:37.25,中文,,0,0,0,,这就是快速排序的运行方式 如果你足够幸运 选择的每个基准元素都恰好落在中间
Dialogue: 0,0:17:37.25,0:17:41.47,英文,,0,0,0,,So what kind of runtime are we looking at here?
Dialogue: 0,0:17:37.25,0:17:41.47,中文,,0,0,0,,那么它的运行时间是多少呢？
Dialogue: 0,0:17:41.47,0:17:44.49,英文,,0,0,0,,Well, one thing we could do is, it seems like a recursive algorithm.
Dialogue: 0,0:17:41.47,0:17:44.49,中文,,0,0,0,,我们可以做的一件事是 它看起来像一个递归算法
Dialogue: 0,0:17:44.49,0:17:47.06,英文,,0,0,0,,So I want to draw that recursive tree.
Dialogue: 0,0:17:44.49,0:17:47.06,中文,,0,0,0,,我想画出递归树
Dialogue: 0,0:17:47.06,0:17:53.24,英文,,0,0,0,,Think about how much work is done per call and per layer, things like that.
Dialogue: 0,0:17:47.06,0:17:53.24,中文,,0,0,0,,想想每次调用和每层做了多少工作 诸如此类的事情
Dialogue: 0,0:17:53.24,0:17:53.98,英文,,0,0,0,,Let's see.
Dialogue: 0,0:17:53.24,0:17:53.98,中文,,0,0,0,,让我们来看看
Dialogue: 0,0:17:53.98,0:18:01.08,英文,,0,0,0,,Well, at the top level, how much time does it take to partition on this left-most item?
Dialogue: 0,0:17:53.98,0:18:01.08,中文,,0,0,0,,那么 在最顶层 对最左边的元素进行分区需要多长时间？
Dialogue: 0,0:18:01.08,0:18:07.14,英文,,0,0,0,,I guess I didn't tell you how long that silly partition algorithm from earlier, the three-scan approach, took.
Dialogue: 0,0:18:01.08,0:18:07.14,中文,,0,0,0,,我猜我没告诉你之前那个简单的分区算法 三扫描方法 需要多长时间
Dialogue: 0,0:18:07.14,0:18:14.82,英文,,0,0,0,,But hopefully, it doesn't feel too much of a leap that it takes n time, because I have to scan the array to find all the items less than the pivot.
Dialogue: 0,0:18:07.14,0:18:14.82,中文,,0,0,0,,但希望你不要觉得它需要 N 时间 因为我必须扫描数组才能找到所有小于基准元素的元素
Dialogue: 0,0:18:14.82,0:18:18.00,英文,,0,0,0,,I scan the array again to find all the items equal to the pivot.
Dialogue: 0,0:18:14.82,0:18:18.00,中文,,0,0,0,,我再次扫描数组以找到所有等于基准元素的元素
Dialogue: 0,0:18:18.00,0:18:21.78,英文,,0,0,0,,And I scan it again to find all the items greater than the pivot.
Dialogue: 0,0:18:18.00,0:18:21.78,中文,,0,0,0,,我再次扫描它以找到所有大于基准元素的元素
Dialogue: 0,0:18:21.78,0:18:23.32,英文,,0,0,0,,Each scan takes n time.
Dialogue: 0,0:18:21.78,0:18:23.32,中文,,0,0,0,,每次扫描都需要 N 时间
Dialogue: 0,0:18:23.32,0:18:26.65,英文,,0,0,0,,There are three scans, still theta of n time.
Dialogue: 0,0:18:23.32,0:18:26.65,中文,,0,0,0,,总共有三次扫描 仍然是 Θ(N) 时间
Dialogue: 0,0:18:26.65,0:18:32.77,英文,,0,0,0,,So at the top, I run approximately n work to create this pivot, where I shuffle all the items around.
Dialogue: 0,0:18:26.65,0:18:32.77,中文,,0,0,0,,首先 我需要做大约 N 次操作来创建这个轴点 也就是把所有元素重新排序
Dialogue: 0,0:18:32.77,0:18:36.61,英文,,0,0,0,,Everything less than is to the left, everything greater than to the right.
Dialogue: 0,0:18:32.77,0:18:36.61,中文,,0,0,0,,小于轴点的元素放到左边 大于轴点的元素放到右边
Dialogue: 0,0:18:36.61,0:18:38.93,英文,,0,0,0,,Now I have two smaller subproblems.
Dialogue: 0,0:18:36.61,0:18:38.93,中文,,0,0,0,,现在 我得到了两个更小的子问题
Dialogue: 0,0:18:38.93,0:18:41.41,英文,,0,0,0,,How long does partitioning on each one take?
Dialogue: 0,0:18:38.93,0:18:41.41,中文,,0,0,0,,划分每一个子问题需要花费多长时间？
Dialogue: 0,0:18:41.41,0:18:46.42,英文,,0,0,0,,Well, on this side, I have roughly n over 2 items, and I have to partition.
Dialogue: 0,0:18:41.41,0:18:46.42,中文,,0,0,0,,嗯 这边 我大约有 N/2 个元素 需要进行划分
Dialogue: 0,0:18:46.42,0:18:51.04,英文,,0,0,0,,So it's going to take me n over 2 time, because we know partitioning is a linear time.
Dialogue: 0,0:18:46.42,0:18:51.04,中文,,0,0,0,,这需要花费 N/2 的时间 因为我们知道划分操作是线性时间
Dialogue: 0,0:18:51.04,0:18:54.24,英文,,0,0,0,,On the right side, I have n over 2 items.
Dialogue: 0,0:18:51.04,0:18:54.24,中文,,0,0,0,,在右边 我也有 N/2 个元素
Dialogue: 0,0:18:54.24,0:18:55.60,英文,,0,0,0,,I need to partition on them.
Dialogue: 0,0:18:54.24,0:18:55.60,中文,,0,0,0,,我需要对它们进行划分
Dialogue: 0,0:18:55.60,0:18:58.15,英文,,0,0,0,,So that will take me n over 2 time.
Dialogue: 0,0:18:55.60,0:18:58.15,中文,,0,0,0,,这也会花费 N/2 的时间
Dialogue: 0,0:18:58.15,0:18:59.57,英文,,0,0,0,,So there are two subproblems.
Dialogue: 0,0:18:58.15,0:18:59.57,中文,,0,0,0,,现在有两个子问题
Dialogue: 0,0:18:59.57,0:19:01.37,英文,,0,0,0,,Each one takes n over 2 time.
Dialogue: 0,0:18:59.57,0:19:01.37,中文,,0,0,0,,每个子问题都需要 N/2 的时间
Dialogue: 0,0:19:01.37,0:19:05.95,英文,,0,0,0,,So at this level, there's a total amount of n work.
Dialogue: 0,0:19:01.37,0:19:05.95,中文,,0,0,0,,在这一层 总共需要做 N 次操作
Dialogue: 0,0:19:05.95,0:19:07.91,英文,,0,0,0,,Maybe you see where this is going.
Dialogue: 0,0:19:05.95,0:19:07.91,中文,,0,0,0,,也许你已经看出来接下来会发生什么
Dialogue: 0,0:19:07.91,0:19:10.55,英文,,0,0,0,,At the next level, I now have four subproblems.
Dialogue: 0,0:19:07.91,0:19:10.55,中文,,0,0,0,,在下一层 我现在有四个子问题
Dialogue: 0,0:19:10.55,0:19:14.59,英文,,0,0,0,,And assuming perfect split, every time I choose to pivot, it lands in the middle.
Dialogue: 0,0:19:10.55,0:19:14.59,中文,,0,0,0,,假设每次选择轴点时 它都完美地落在中间 将元素分成两半
Dialogue: 0,0:19:14.59,0:19:16.42,英文,,0,0,0,,Then I have four subproblems.
Dialogue: 0,0:19:14.59,0:19:16.42,中文,,0,0,0,,那么我就有四个子问题
Dialogue: 0,0:19:16.42,0:19:19.00,英文,,0,0,0,,Each one has n over 4 items.
Dialogue: 0,0:19:16.42,0:19:19.00,中文,,0,0,0,,每个子问题都有 N/4 个元素
Dialogue: 0,0:19:19.00,0:19:20.46,英文,,0,0,0,,And there are four subproblems.
Dialogue: 0,0:19:19.00,0:19:20.46,中文,,0,0,0,,并且 一共有四个子问题
Dialogue: 0,0:19:20.46,0:19:24.04,英文,,0,0,0,,So the total amount of work is n again.
Dialogue: 0,0:19:20.46,0:19:24.04,中文,,0,0,0,,总的操作次数还是 N
Dialogue: 0,0:19:24.04,0:19:25.30,英文,,0,0,0,,And again, and again, and again.
Dialogue: 0,0:19:24.04,0:19:25.30,中文,,0,0,0,,一次又一次 都是这样
Dialogue: 0,0:19:25.30,0:19:32.43,英文,,0,0,0,,So as I go all the way down, the amount of work done at every level is n. And how much smaller are the subproblems getting?
Dialogue: 0,0:19:25.30,0:19:32.43,中文,,0,0,0,,当我一直往下走的时候 每一层的计算量都是 N 那子问题的规模缩小了多少呢？
Dialogue: 0,0:19:32.43,0:19:44.02,英文,,0,0,0,,Well, at the first level, the subproblem was size n. And then at the next level, the subproblems were of size n over 2, and then n over 4, n over 8, n over 16, all the way down to problems of size 1.
Dialogue: 0,0:19:32.43,0:19:44.02,中文,,0,0,0,,在第一层 子问题的规模是 N 然后在下一层 子问题的规模是 N/2 然后是 N/4、N/8、N/16 一直到规模为 1 的问题
Dialogue: 0,0:19:44.02,0:19:48.35,英文,,0,0,0,,So how many times do I have to divide n by 2 before I reach 1?
Dialogue: 0,0:19:44.02,0:19:48.35,中文,,0,0,0,,那么 我需要将 N 除以 2 多少次才能得到 1？
Dialogue: 0,0:19:48.35,0:19:51.17,英文,,0,0,0,,That happens to be log n. That's what log n means.
Dialogue: 0,0:19:48.35,0:19:51.17,中文,,0,0,0,,刚好是 log N 这就是 log N 的含义
Dialogue: 0,0:19:51.17,0:19:54.75,英文,,0,0,0,,It's the number of times you cut n in half before it reaches 1.
Dialogue: 0,0:19:51.17,0:19:54.75,中文,,0,0,0,,它表示将 N 一直除以 2 直到它变成 1 所需的次数
Dialogue: 0,0:19:54.75,0:20:01.15,英文,,0,0,0,,So there are log n levels before I can divide this problem all the way down to size 1 problems.
Dialogue: 0,0:19:54.75,0:20:01.15,中文,,0,0,0,,在将问题一直分解到规模为 1 的问题之前 有 log N 层
Dialogue: 0,0:20:01.15,0:20:03.65,英文,,0,0,0,,And each level takes n work.
Dialogue: 0,0:20:01.15,0:20:03.65,中文,,0,0,0,,每一层都需要 N 的计算量
Dialogue: 0,0:20:03.65,0:20:09.32,英文,,0,0,0,,So my total runtime is theta of n log n, in the best case.
Dialogue: 0,0:20:03.65,0:20:09.32,中文,,0,0,0,,在最优情况下 我的总运行时间是 Θ(N log N)
Dialogue: 0,0:20:09.32,0:20:11.02,英文,,0,0,0,,OK, great.
Dialogue: 0,0:20:09.32,0:20:11.02,中文,,0,0,0,,好的 很好
Dialogue: 0,0:20:11.02,0:20:13.16,英文,,0,0,0,,Thoughts, questions, is that OK?
Dialogue: 0,0:20:11.02,0:20:13.16,中文,,0,0,0,,有什么想法或问题吗？这样可以吗？
Dialogue: 0,0:20:13.16,0:20:18.18,英文,,0,0,0,,Kind of has a similar flavor to merge sort, but we did it with partitioning instead.
Dialogue: 0,0:20:13.16,0:20:18.18,中文,,0,0,0,,有点像归并排序 但我们使用的是分区而不是归并
Dialogue: 0,0:20:18.18,0:20:19.80,英文,,0,0,0,,What about the worst case?
Dialogue: 0,0:20:18.18,0:20:19.80,中文,,0,0,0,,那最坏情况呢？
Dialogue: 0,0:20:19.80,0:20:23.99,英文,,0,0,0,,The worst case would be, what if the subproblems weren't so perfectly balanced?
Dialogue: 0,0:20:19.80,0:20:23.99,中文,,0,0,0,,最坏的情况是 如果子问题没有那么完美地平衡呢？
Dialogue: 0,0:20:23.99,0:20:30.65,英文,,0,0,0,,So right here, when I chose the pivot, it landed in the middle, and I got two subproblems that were perfectly balanced.
Dialogue: 0,0:20:23.99,0:20:30.65,中文,,0,0,0,,就像这里 当我选择枢轴时 它落在了中间 我得到了两个完美平衡的子问题
Dialogue: 0,0:20:30.65,0:20:32.82,英文,,0,0,0,,But what if that wasn't the case?
Dialogue: 0,0:20:30.65,0:20:32.82,中文,,0,0,0,,但如果不是这种情况呢？
Dialogue: 0,0:20:32.82,0:20:34.70,英文,,0,0,0,,So what if I chose the pivot?
Dialogue: 0,0:20:32.82,0:20:34.70,中文,,0,0,0,,如果我选择的枢轴...
Dialogue: 0,0:20:34.70,0:20:36.76,英文,,0,0,0,,And it actually stayed in place.
Dialogue: 0,0:20:34.70,0:20:36.76,中文,,0,0,0,,它实际上保持在原地
Dialogue: 0,0:20:36.76,0:20:40.24,英文,,0,0,0,,It stayed on the leftmost side, and I created two subproblems.
Dialogue: 0,0:20:36.76,0:20:40.24,中文,,0,0,0,,它停留在最左侧 我创建了两个子问题
Dialogue: 0,0:20:40.24,0:20:44.80,英文,,0,0,0,,One of the subproblems is everything, and the other subproblem is nothing.
Dialogue: 0,0:20:40.24,0:20:44.80,中文,,0,0,0,,其中一个子问题包含了所有元素 而另一个子问题则为空
Dialogue: 0,0:20:44.80,0:20:51.80,英文,,0,0,0,,In other words, whatever pivot this is, there are no items less than or equal to the pivot, and every item is greater than or equal to the pivot.
Dialogue: 0,0:20:44.80,0:20:51.80,中文,,0,0,0,,换句话说 无论这个枢轴是什么 都没有小于或等于枢轴的元素 而每个元素都大于或等于枢轴
Dialogue: 0,0:20:51.80,0:20:54.06,英文,,0,0,0,,They all end up on one side.
Dialogue: 0,0:20:51.80,0:20:54.06,中文,,0,0,0,,最后都堆到一边了
Dialogue: 0,0:20:54.06,0:20:55.83,英文,,0,0,0,,Well, then I have to solve both subproblems.
Dialogue: 0,0:20:54.06,0:20:55.83,中文,,0,0,0,,那我就得解决两个子问题
Dialogue: 0,0:20:55.83,0:20:59.27,英文,,0,0,0,,The left subproblem takes me no time to solve because it's nothing.
Dialogue: 0,0:20:55.83,0:20:59.27,中文,,0,0,0,,左边这个子问题不用解决 因为它什么都没有
Dialogue: 0,0:20:59.27,0:21:01.99,英文,,0,0,0,,The right subproblem has n minus 1 items.
Dialogue: 0,0:20:59.27,0:21:01.99,中文,,0,0,0,,右边的子问题有 N-1 个元素
Dialogue: 0,0:21:01.99,0:21:03.22,英文,,0,0,0,,I have to solve that.
Dialogue: 0,0:21:01.99,0:21:03.22,中文,,0,0,0,,我得解决它
Dialogue: 0,0:21:03.22,0:21:07.16,英文,,0,0,0,,What if I choose a pivot, the leftmost item, and I get unlucky again?
Dialogue: 0,0:21:03.22,0:21:07.16,中文,,0,0,0,,如果我选一个基准点 最左边的元素 然后又运气不好呢？
Dialogue: 0,0:21:07.16,0:21:08.32,英文,,0,0,0,,I'm like, oh, man.
Dialogue: 0,0:21:07.16,0:21:08.32,中文,,0,0,0,,我就会想 天哪
Dialogue: 0,0:21:08.32,0:21:13.28,英文,,0,0,0,,Well, now, again, if I choose this pivot and I'm unlucky,
Dialogue: 0,0:21:08.32,0:21:13.28,中文,,0,0,0,,好吧 现在 如果我选这个基准点 又运气不好
Dialogue: 0,0:21:13.28,0:21:18.00,英文,,0,0,0,,I still get two subproblems, but everything to the left of this pivot is nothing.
Dialogue: 0,0:21:13.28,0:21:18.00,中文,,0,0,0,,我仍然会得到两个子问题 但这个基准点左边什么都没有
Dialogue: 0,0:21:18.00,0:21:20.86,英文,,0,0,0,,That is, there are no items less than or equal to this pivot.
Dialogue: 0,0:21:18.00,0:21:20.86,中文,,0,0,0,,也就是说 没有元素小于或等于这个基准点
Dialogue: 0,0:21:20.86,0:21:23.30,英文,,0,0,0,,All the items are greater than or equal to this pivot.
Dialogue: 0,0:21:20.86,0:21:23.30,中文,,0,0,0,,所有元素都大于或等于这个基准点
Dialogue: 0,0:21:23.30,0:21:27.08,英文,,0,0,0,,So I get a problem of size n minus 2 that I have to solve.
Dialogue: 0,0:21:23.30,0:21:27.08,中文,,0,0,0,,我得到了一个大小为 N-2 的问题 我必须解决它
Dialogue: 0,0:21:27.08,0:21:31.96,英文,,0,0,0,,And then to solve that, if I get unlucky again, see where this is going, I choose the pivot.
Dialogue: 0,0:21:27.08,0:21:31.96,中文,,0,0,0,,然后为了解决这个问题 如果我又运气不好 看看会发生什么 我选择基准点
Dialogue: 0,0:21:31.96,0:21:32.66,英文,,0,0,0,,I'm unlucky.
Dialogue: 0,0:21:31.96,0:21:32.66,中文,,0,0,0,,我运气不好
Dialogue: 0,0:21:32.66,0:21:34.63,英文,,0,0,0,,All the items end up to the right of the pivot.
Dialogue: 0,0:21:32.66,0:21:34.63,中文,,0,0,0,,所有元素都跑到基准点的右边了
Dialogue: 0,0:21:34.63,0:21:38.31,英文,,0,0,0,,I have a subproblem of size n minus 3 to solve.
Dialogue: 0,0:21:34.63,0:21:38.31,中文,,0,0,0,,我有一个大小为 N-3 的子问题要解决
Dialogue: 0,0:21:38.31,0:21:44.71,英文,,0,0,0,,So this creates a sum that I can compute, which is, well, here I have n work to partition.
Dialogue: 0,0:21:38.31,0:21:44.71,中文,,0,0,0,,这就产生了一个我可以计算的总和 也就是 在这里我有 N 个工作要做分区
Dialogue: 0,0:21:44.71,0:21:46.91,英文,,0,0,0,,I create a subproblem of size n minus 1.
Dialogue: 0,0:21:44.71,0:21:46.91,中文,,0,0,0,,我创建了一个大小为 N-1 的子问题
Dialogue: 0,0:21:46.91,0:21:49.39,英文,,0,0,0,,To partition that, it takes me n minus 1 time.
Dialogue: 0,0:21:46.91,0:21:49.39,中文,,0,0,0,,要对它进行分区 需要 N-1 的时间
Dialogue: 0,0:21:49.39,0:21:51.45,英文,,0,0,0,,Creates a subproblem of n minus 2.
Dialogue: 0,0:21:49.39,0:21:51.45,中文,,0,0,0,,创建了一个 N-2 的子问题
Dialogue: 0,0:21:51.45,0:21:58.39,英文,,0,0,0,,I have to take n minus 2 time to solve that subproblem, n minus 3, n minus 4, all the way down to 1.
Dialogue: 0,0:21:51.45,0:21:58.39,中文,,0,0,0,,我需要 N 减 2 次才能解决那个子问题 N 减 3 N 减 4 一直到 1
Dialogue: 0,0:21:58.39,0:22:02.40,英文,,0,0,0,,What is the sum of n plus n minus 1 plus n minus 2 all the way down to 1?
Dialogue: 0,0:21:58.39,0:22:02.40,中文,,0,0,0,,N 加上 N 减 1 加上 N 减 2 一直到 1 的总和是多少？
Dialogue: 0,0:22:02.40,0:22:05.95,英文,,0,0,0,,Well, that's theta of n squared.
Dialogue: 0,0:22:02.40,0:22:05.95,中文,,0,0,0,,嗯 那是 Θ(N^2)
Dialogue: 0,0:22:05.95,0:22:07.23,英文,,0,0,0,,It's kind of weird.
Dialogue: 0,0:22:05.95,0:22:07.23,中文,,0,0,0,,这有点奇怪
Dialogue: 0,0:22:07.23,0:22:13.69,英文,,0,0,0,,Even though QuickSort is the fastest known sort, it actually has a case where the runtime is n-squared.
Dialogue: 0,0:22:07.23,0:22:13.69,中文,,0,0,0,,即使快速排序是最快的排序算法 它实际上也有一种情况 运行时间是 N^2
Dialogue: 0,0:22:13.69,0:22:19.28,英文,,0,0,0,,By the way, if you're wondering what would I fill in these boxes to cause the worst-case behavior,
Dialogue: 0,0:22:13.69,0:22:19.28,中文,,0,0,0,,顺便说一句 如果你想知道我会在这些框中填写什么来导致最坏情况的行为
Dialogue: 0,0:22:19.28,0:22:25.28,英文,,0,0,0,,like what numbers would go in these boxes for the worst-case QuickSort, here is a possible sequence of numbers.
Dialogue: 0,0:22:19.28,0:22:25.28,中文,,0,0,0,,比如在最坏情况下快速排序的这些框中会填入哪些数字 这里有一个可能的数字序列
Dialogue: 0,0:22:25.28,0:22:30.72,英文,,0,0,0,,Try plugging this in, 1, 2, 3, 4, 5, 6, and you'll realize that if I partition on 1,
Dialogue: 0,0:22:25.28,0:22:30.72,中文,,0,0,0,,试试代入这个 1、2、3、4、5、6 你会发现如果我以 1 进行分区
Dialogue: 0,0:22:30.72,0:22:34.75,英文,,0,0,0,,Everything ends up to the right of 1, and I get a subproblem of size n minus 1.
Dialogue: 0,0:22:30.72,0:22:34.75,中文,,0,0,0,,所有东西最终都位于 1 的右边 我得到了一个大小为 N 减 1 的子问题
Dialogue: 0,0:22:34.75,0:22:38.15,英文,,0,0,0,,And then if I choose 2 as the pivot, everything ends up to the right of 2.
Dialogue: 0,0:22:34.75,0:22:38.15,中文,,0,0,0,,然后如果我选择 2 作为基准 所有东西最终都位于 2 的右边
Dialogue: 0,0:22:38.15,0:22:41.21,英文,,0,0,0,,And then I choose 3 as the pivot, and everything ends up to the right of 3.
Dialogue: 0,0:22:38.15,0:22:41.21,中文,,0,0,0,,然后我选择 3 作为基准 所有东西最终都位于 3 的右边
Dialogue: 0,0:22:41.21,0:22:47.15,英文,,0,0,0,,And every single operation takes n, n minus 1, n minus 2, all the way down to 1.
Dialogue: 0,0:22:41.21,0:22:47.15,中文,,0,0,0,,每次操作都需要 N、N 减 1、N 减 2 一直到 1
Dialogue: 0,0:22:47.15,0:22:52.95,英文,,0,0,0,,So it's kind of weird that QuickSort, even though it's fast for almost all cases,
Dialogue: 0,0:22:47.15,0:22:52.95,中文,,0,0,0,,有点奇怪的是 快速排序 即使它在几乎所有情况下都很快
Dialogue: 0,0:22:52.95,0:22:57.95,英文,,0,0,0,,if you give it the already sorted array, it chokes badly and gives you an n squared algorithm.
Dialogue: 0,0:22:52.95,0:22:57.95,中文,,0,0,0,,如果你给它一个已经排序的数组 它会严重阻塞并给你一个 N^2算法
Dialogue: 0,0:22:57.95,0:22:59.35,英文,,0,0,0,,It's kind of weird.
Dialogue: 0,0:22:57.95,0:22:59.35,中文,,0,0,0,,这有点奇怪
Dialogue: 0,0:22:59.35,0:23:01.10,英文,,0,0,0,,OK.
Dialogue: 0,0:22:59.35,0:23:01.10,中文,,0,0,0,,好的
Dialogue: 0,0:23:01.10,0:23:03.82,英文,,0,0,0,,So that was our quick sort runtime analysis.
Dialogue: 0,0:23:01.10,0:23:03.82,中文,,0,0,0,,这就是我们的快速排序运行时分析
Dialogue: 0,0:23:03.82,0:23:07.30,英文,,0,0,0,,In the best case, if we get lucky, we get n log n behavior.
Dialogue: 0,0:23:03.82,0:23:07.30,中文,,0,0,0,,在最好的情况下 如果我们幸运的话 我们得到 N log N 的行为
Dialogue: 0,0:23:07.30,0:23:09.87,英文,,0,0,0,,The problem always splits cleanly into two.
Dialogue: 0,0:23:07.30,0:23:09.87,中文,,0,0,0,,这个问题总是可以干净地分成两部分
Dialogue: 0,0:23:09.87,0:23:16.87,英文,,0,0,0,,Technically, if you want it to be really precise and pedantic, you could be really careful and be like, well, technically, the pivot doesn't count.
Dialogue: 0,0:23:09.87,0:23:16.87,中文,,0,0,0,,从技术上讲 如果你想让它非常精确和迂腐 你可以非常小心 就像 好吧 从技术上讲 基准不重要
Dialogue: 0,0:23:16.87,0:23:19.21,英文,,0,0,0,,But it's OK.
Dialogue: 0,0:23:16.87,0:23:19.21,中文,,0,0,0,,但是没关系
Dialogue: 0,0:23:19.21,0:23:20.57,英文,,0,0,0,,We didn't bother with that.
Dialogue: 0,0:23:19.21,0:23:20.57,中文,,0,0,0,,我们没有理会那个
Dialogue: 0,0:23:20.57,0:23:23.03,英文,,0,0,0,,We got n log n anyway, and it turned out to be okay.
Dialogue: 0,0:23:20.57,0:23:23.03,中文,,0,0,0,,反正也是 N log N 结果还不错
Dialogue: 0,0:23:23.03,0:23:25.83,英文,,0,0,0,,So hopefully the argument was good enough for you.
Dialogue: 0,0:23:23.03,0:23:25.83,中文,,0,0,0,,希望这个论证让你满意
Dialogue: 0,0:23:25.83,0:23:30.52,英文,,0,0,0,,And in the worst case, we saw the runtime was n squared,
Dialogue: 0,0:23:25.83,0:23:30.52,中文,,0,0,0,,在最坏情况下 我们看到运行时间是 N^2
Dialogue: 0,0:23:30.52,0:23:38.52,英文,,0,0,0,,because every time, instead of splitting the problem into two equally-sized subproblems, we actually ended up only decreasing the size of the problem by one every single time.
Dialogue: 0,0:23:30.52,0:23:38.52,中文,,0,0,0,,因为每次不是将问题分成两个大小相等的子问题 而是每次都只是将问题的大小减少 1
Dialogue: 0,0:23:38.52,0:23:45.47,英文,,0,0,0,,So that's kind of weird that QuickSort actually has different best and worst case behaviors compared to something like MergeSort,
Dialogue: 0,0:23:38.52,0:23:45.47,中文,,0,0,0,,奇怪的是 快速排序实际上与 归并排序 等算法相比 具有不同的最佳和最差情况行为
Dialogue: 0,0:23:45.47,0:23:51.47,英文,,0,0,0,,which no matter what numbers you feed into MergeSort, you will always get n log n asymptotic runtime.
Dialogue: 0,0:23:45.47,0:23:51.47,中文,,0,0,0,,无论你向 归并排序 输入什么数字 你总是会得到 N log N 的渐近运行时间
Dialogue: 0,0:23:51.47,0:23:58.56,英文,,0,0,0,,You can feed in the sorted array, you can feed in any array you want, random array, MergeSort is always n log n.
Dialogue: 0,0:23:51.47,0:23:58.56,中文,,0,0,0,,你可以输入已排序的数组 也可以输入任何你想要的数组 随机数组 归并排序 始终是 N log N
Dialogue: 0,0:23:58.56,0:24:07.09,英文,,0,0,0,,So if Quicksort has this weird case where it chokes on arrays that are already sorted, how can it be the fastest sort in real life?
Dialogue: 0,0:23:58.56,0:24:07.09,中文,,0,0,0,,那么 如果 快速排序 在处理已排序数组时出现这种奇怪的情况 它怎么能成为现实生活中最快的排序算法呢？
Dialogue: 0,0:24:07.09,0:24:14.27,英文,,0,0,0,,Well, it turns out that for almost all arrays in the world, Quicksort is n log n expected runtime.
Dialogue: 0,0:24:07.09,0:24:14.27,中文,,0,0,0,,嗯 事实证明 对于世界上几乎所有数组 快速排序 的预期运行时间都是 N log N
Dialogue: 0,0:24:14.27,0:24:16.63,英文,,0,0,0,,So that's what we'll be showing next.
Dialogue: 0,0:24:14.27,0:24:16.63,中文,,0,0,0,,这就是我们接下来要展示的内容
Dialogue: 0,0:24:16.63,0:24:18.68,英文,,0,0,0,,But before that, thoughts on the worst and best case?
Dialogue: 0,0:24:16.63,0:24:18.68,中文,,0,0,0,,但在此之前 对最坏和最佳情况有什么想法？
Dialogue: 0,0:24:18.68,0:24:26.80,英文,,0,0,0,,Yeah.
Dialogue: 0,0:24:18.68,0:24:26.80,中文,,0,0,0,,嗯
Dialogue: 0,0:24:26.80,0:24:29.73,英文,,0,0,0,,Yeah, there was a question of, what if I just check if it's sorted first?
Dialogue: 0,0:24:26.80,0:24:29.73,中文,,0,0,0,,嗯 有个问题 如果我先检查它是否已排序呢？
Dialogue: 0,0:24:29.73,0:24:30.51,英文,,0,0,0,,That's a good point.
Dialogue: 0,0:24:29.73,0:24:30.51,中文,,0,0,0,,这是个好问题
Dialogue: 0,0:24:30.51,0:24:37.69,英文,,0,0,0,,We're going to solve the n squared case soon, but stay tuned, because it's something I want to get rid of, but not yet.
Dialogue: 0,0:24:30.51,0:24:37.69,中文,,0,0,0,,我们很快就会解决 N^2的情况 但请继续关注 因为这是我想要摆脱的 但现在还不是时候
Dialogue: 0,0:24:37.69,0:24:41.14,英文,,0,0,0,,OK, for now, we'll live with it, and we'll keep going.
Dialogue: 0,0:24:37.69,0:24:41.14,中文,,0,0,0,,好的 现在 我们将忍受它 并将继续前进
Dialogue: 0,0:24:41.14,0:24:48.37,英文,,0,0,0,,So the first thing I want to argue to you is that if I give you a random array, so it doesn't have to be a sorted array,
Dialogue: 0,0:24:41.14,0:24:48.37,中文,,0,0,0,,首先我想告诉你的是 如果我给你一个随机数组 它不一定是排序数组
Dialogue: 0,0:24:48.37,0:24:57.37,英文,,0,0,0,,there's any old random array, with extremely high probability, like the probability that I have an evil twin, that kind of probability will never happen.
Dialogue: 0,0:24:48.37,0:24:57.37,中文,,0,0,0,,任何旧的随机数组 都极有可能（就像我有邪恶双胞胎的概率一样）永远不会发生
Dialogue: 0,0:24:57.37,0:25:00.31,英文,,0,0,0,,It's going to be n log n expected.
Dialogue: 0,0:24:57.37,0:25:00.31,中文,,0,0,0,,预期的结果将是 N log N
Dialogue: 0,0:25:00.31,0:25:03.73,英文,,0,0,0,,So to actually prove it, I have to pull out some math and do an integral.
Dialogue: 0,0:25:00.31,0:25:03.73,中文,,0,0,0,,要真正证明这一点 我必须拿出一些数学知识并做一个积分
Dialogue: 0,0:25:03.73,0:25:04.83,英文,,0,0,0,,I'm not going to do that.
Dialogue: 0,0:25:03.73,0:25:04.83,中文,,0,0,0,,我不会这么做
Dialogue: 0,0:25:04.83,0:25:13.92,英文,,0,0,0,,I will just show you two intuitive arguments that I hope convince you that quicksort is n log n expected with extremely high probability.
Dialogue: 0,0:25:04.83,0:25:13.92,中文,,0,0,0,,我将只向你展示两个直观的论点 我希望它们能让你相信 快速排序 在极大概率下是 N log N 预期的
Dialogue: 0,0:25:13.92,0:25:16.06,英文,,0,0,0,,Like, astronomical probability.
Dialogue: 0,0:25:13.92,0:25:16.06,中文,,0,0,0,,就像天文数字一样的概率
Dialogue: 0,0:25:16.06,0:25:25.95,英文,,0,0,0,,OK, so here's my first argument, which is, well, maybe we're not super lucky, and every time the problem ends up in exactly, or the pivot ends up exactly in the middle.
Dialogue: 0,0:25:16.06,0:25:25.95,中文,,0,0,0,,好 我的第一个论点是 也许我们不是每次都那么幸运 基准值每次都正好落在正中间
Dialogue: 0,0:25:25.95,0:25:30.06,英文,,0,0,0,,Maybe we're also not super unlucky in that it always ends up
Dialogue: 0,0:25:25.95,0:25:30.06,中文,,0,0,0,,也许我们也不是每次都那么倒霉 它总是
Dialogue: 0,0:25:30.06,0:25:34.46,英文,,0,0,0,,exactly as the first element, and we have the n squared case.
Dialogue: 0,0:25:30.06,0:25:34.46,中文,,0,0,0,,正好是第一个元素 然后就变成了 N^2的情况
Dialogue: 0,0:25:34.46,0:25:36.94,英文,,0,0,0,,But let's say we are pretty unlucky.
Dialogue: 0,0:25:34.46,0:25:36.94,中文,,0,0,0,,但假设我们真的很倒霉
Dialogue: 0,0:25:36.94,0:25:38.72,英文,,0,0,0,,We're very, very unlucky.
Dialogue: 0,0:25:36.94,0:25:38.72,中文,,0,0,0,,非常非常倒霉
Dialogue: 0,0:25:38.72,0:25:46.67,英文,,0,0,0,,Not the worst case, but we're very unlucky in the sense that every time we choose the pivot, it's always pretty close to either edge.
Dialogue: 0,0:25:38.72,0:25:46.67,中文,,0,0,0,,不是最坏的情况 但我们非常倒霉 因为每次我们选择基准值时 它总是非常接近边缘
Dialogue: 0,0:25:46.67,0:25:55.19,英文,,0,0,0,,And by pretty close, I mean, let's say that there's always 10% of items on one side of the pivot and 90% of items on the other side of the pivot.
Dialogue: 0,0:25:46.67,0:25:55.19,中文,,0,0,0,,“非常接近”的意思是 假设基准值的一侧总是 10% 的元素 而另一侧有 90% 的元素
Dialogue: 0,0:25:55.19,0:25:58.53,英文,,0,0,0,,If this was a random array, how often would this happen?
Dialogue: 0,0:25:55.19,0:25:58.53,中文,,0,0,0,,如果这是一个随机数组 这种情况发生的频率是多少？
Dialogue: 0,0:25:58.53,0:26:05.60,英文,,0,0,0,,Approximately 10% of the time, you would get this unlucky case where you have these two very imbalanced arrays.
Dialogue: 0,0:25:58.53,0:26:05.60,中文,,0,0,0,,大约 10% 的情况下 你会遇到这种倒霉的情况 你有两个非常不平衡的数组
Dialogue: 0,0:26:05.60,0:26:07.30,英文,,0,0,0,,One side has 10% of the items.
Dialogue: 0,0:26:05.60,0:26:07.30,中文,,0,0,0,,一侧有 10% 的元素
Dialogue: 0,0:26:07.30,0:26:09.42,英文,,0,0,0,,One side has 90% of the items.
Dialogue: 0,0:26:07.30,0:26:09.42,中文,,0,0,0,,一侧有 90% 的元素
Dialogue: 0,0:26:09.42,0:26:15.46,英文,,0,0,0,,So the probability that one side is 10% of the array or smaller is 10%.
Dialogue: 0,0:26:09.42,0:26:15.46,中文,,0,0,0,,一侧是数组的 10% 或更小的概率是 10%
Dialogue: 0,0:26:15.46,0:26:19.72,英文,,0,0,0,,It's like picking a number between 1 and 10 at random and getting 1.
Dialogue: 0,0:26:15.46,0:26:19.72,中文,,0,0,0,,这就像随机选择 1 到 10 之间的数字并得到 1 一样
Dialogue: 0,0:26:19.72,0:26:22.41,英文,,0,0,0,,You'd have to be pretty unlucky to get the 1.
Dialogue: 0,0:26:19.72,0:26:22.41,中文,,0,0,0,,你得非常倒霉才能得到 1
Dialogue: 0,0:26:22.41,0:26:24.89,英文,,0,0,0,,So that's the argument we're going to go with.
Dialogue: 0,0:26:22.41,0:26:24.89,中文,,0,0,0,,这就是我们要讨论的论点
Dialogue: 0,0:26:24.89,0:26:27.01,英文,,0,0,0,,So let's say this happens every single time.
Dialogue: 0,0:26:24.89,0:26:27.01,中文,,0,0,0,,假设这种情况每次都发生
Dialogue: 0,0:26:27.01,0:26:30.40,英文,,0,0,0,,Like every time you choose the number between 1 and 10 at random, you get 1.
Dialogue: 0,0:26:27.01,0:26:30.40,中文,,0,0,0,,就像每次你随机选择 1 到 10 之间的数字 你都会得到 1
Dialogue: 0,0:26:30.40,0:26:33.28,英文,,0,0,0,,You get super unlucky.
Dialogue: 0,0:26:30.40,0:26:33.28,中文,,0,0,0,,你非常倒霉
Dialogue: 0,0:26:33.28,0:26:37.18,英文,,0,0,0,,If we get super unlucky, let's see what happens on my array.
Dialogue: 0,0:26:33.28,0:26:37.18,中文,,0,0,0,,如果我们非常倒霉 让我们看看我的数组会发生什么
Dialogue: 0,0:26:37.18,0:26:39.58,英文,,0,0,0,,Let's say n, you can use n if you wanted to.
Dialogue: 0,0:26:37.18,0:26:39.58,中文,,0,0,0,,假设 N 你可以用 N 表示
Dialogue: 0,0:26:39.58,0:26:44.44,英文,,0,0,0,,I'll just shove in 100 if it makes the math a little bit nicer, but you can do this with n as well.
Dialogue: 0,0:26:39.58,0:26:44.44,中文,,0,0,0,,为了方便计算 我假设有 100 个元素 但你也可以用 N 来表示
Dialogue: 0,0:26:44.44,0:26:47.98,英文,,0,0,0,,Let's say I have 100 items, and I'm very unlucky with my pivot.
Dialogue: 0,0:26:44.44,0:26:47.98,中文,,0,0,0,,假设我有 100 个元素 然后我选取了一个很糟糕的基准值
Dialogue: 0,0:26:47.98,0:26:50.93,英文,,0,0,0,,So roughly speaking, just give me an estimate.
Dialogue: 0,0:26:47.98,0:26:50.93,中文,,0,0,0,,那么大致来说 给我一个估计值
Dialogue: 0,0:26:50.93,0:26:53.43,英文,,0,0,0,,How many items are to the left of this pivot?
Dialogue: 0,0:26:50.93,0:26:53.43,中文,,0,0,0,,这个基准值的左侧有多少个元素？
Dialogue: 0,0:26:53.43,0:27:00.04,英文,,0,0,0,,How many items are to the right of this pivot if I am unlucky and my pivot ends up close to the edge?
Dialogue: 0,0:26:53.43,0:27:00.04,中文,,0,0,0,,如果我很不幸 基准值最终靠近边缘 那么它右侧有多少个元素？
Dialogue: 0,0:27:00.04,0:27:05.91,英文,,0,0,0,,Well, based on this 10% argument, I have approximately 10 items to the left of the pivot.
Dialogue: 0,0:27:00.04,0:27:05.91,中文,,0,0,0,,根据 10% 的说法 基准值左侧大约有 10 个元素
Dialogue: 0,0:27:05.91,0:27:10.49,英文,,0,0,0,,That's approximately 10%, and 90% of items to the right side.
Dialogue: 0,0:27:05.91,0:27:10.49,中文,,0,0,0,,大约是 10% 而右侧有 90% 的元素
Dialogue: 0,0:27:10.49,0:27:12.65,英文,,0,0,0,,This is pretty imbalanced.
Dialogue: 0,0:27:10.49,0:27:12.65,中文,,0,0,0,,这很不平衡
Dialogue: 0,0:27:12.65,0:27:16.40,英文,,0,0,0,,The most balanced case would be two equal-sized subproblems, and that'll be fastest.
Dialogue: 0,0:27:12.65,0:27:16.40,中文,,0,0,0,,最平衡的情况是两个大小相等的子问题 这样速度最快
Dialogue: 0,0:27:16.40,0:27:17.94,英文,,0,0,0,,But I've gotten pretty unlucky here.
Dialogue: 0,0:27:16.40,0:27:17.94,中文,,0,0,0,,但我现在运气不太好
Dialogue: 0,0:27:17.94,0:27:21.22,英文,,0,0,0,,I have a smaller problem and a much larger problem.
Dialogue: 0,0:27:17.94,0:27:21.22,中文,,0,0,0,,我有一个较小的问题和一个大得多的问题
Dialogue: 0,0:27:21.22,0:27:22.74,英文,,0,0,0,,Well, I got to solve them both.
Dialogue: 0,0:27:21.22,0:27:22.74,中文,,0,0,0,,我得把它们都解决掉
Dialogue: 0,0:27:22.74,0:27:23.78,英文,,0,0,0,,So let's go and solve them.
Dialogue: 0,0:27:22.74,0:27:23.78,中文,,0,0,0,,那我们来解决它们吧
Dialogue: 0,0:27:23.78,0:27:24.88,英文,,0,0,0,,One of them has 10 items.
Dialogue: 0,0:27:23.78,0:27:24.88,中文,,0,0,0,,其中一个有 10 个元素
Dialogue: 0,0:27:24.88,0:27:26.59,英文,,0,0,0,,One of them has 90 items.
Dialogue: 0,0:27:24.88,0:27:26.59,中文,,0,0,0,,另一个有 90 个元素
Dialogue: 0,0:27:26.59,0:27:30.41,英文,,0,0,0,,So what happens when I solve the easier problem, the one with 10 items?
Dialogue: 0,0:27:26.59,0:27:30.41,中文,,0,0,0,,那么 当我解决较简单的问题 即有 10 个元素的那个问题时会发生什么？
Dialogue: 0,0:27:30.41,0:27:35.15,英文,,0,0,0,,Let's say I choose the left item as the pivot, and I get unlucky again.
Dialogue: 0,0:27:30.41,0:27:35.15,中文,,0,0,0,,假设我选择最左侧的元素作为基准值 我又一次运气不好
Dialogue: 0,0:27:35.15,0:27:37.66,英文,,0,0,0,,I roll the one on my dice or whatever.
Dialogue: 0,0:27:35.15,0:27:37.66,中文,,0,0,0,,我掷骰子 结果是一
Dialogue: 0,0:27:37.66,0:27:46.36,英文,,0,0,0,,Well, in that case, I would get another problem that's 10% of the size and another subproblem that's 90% of the size. of the subproblem.
Dialogue: 0,0:27:37.66,0:27:46.36,中文,,0,0,0,,在这种情况下 我会得到另一个子问题 其大小是原问题的 10% 另一个子问题是原问题的 90%
Dialogue: 0,0:27:46.36,0:27:50.55,英文,,0,0,0,,So if it's got 10 items, what are the sizes of the two subproblems that pop out?
Dialogue: 0,0:27:46.36,0:27:50.55,中文,,0,0,0,,如果有 10 个元素 拆分后两个子问题的规模分别是多少？
Dialogue: 0,0:27:50.55,0:27:58.42,英文,,0,0,0,,If I get unlucky, well, one of them is going to be one item, and one of them is going to be nine items.
Dialogue: 0,0:27:50.55,0:27:58.42,中文,,0,0,0,,如果运气不好 其中一个子问题会包含 1 个元素 另一个包含 9 个
Dialogue: 0,0:27:58.42,0:28:00.30,英文,,0,0,0,,That's what we're saying when we get unlucky.
Dialogue: 0,0:27:58.42,0:28:00.30,中文,,0,0,0,,这就是我们所说的运气不好的情况
Dialogue: 0,0:28:00.30,0:28:03.63,英文,,0,0,0,,We have 10% of items on one side, 90% on the other.
Dialogue: 0,0:28:00.30,0:28:03.63,中文,,0,0,0,,一边有 10% 的元素 另一边有 90%
Dialogue: 0,0:28:03.63,0:28:09.65,英文,,0,0,0,,If my input subproblem was of size 10, I'd get one item on one side and nine items on the other side.
Dialogue: 0,0:28:03.63,0:28:09.65,中文,,0,0,0,,如果输入的子问题规模是 10 一边会有 1 个元素 另一边会有 9 个
Dialogue: 0,0:28:09.65,0:28:11.85,英文,,0,0,0,,Another imbalanced case.
Dialogue: 0,0:28:09.65,0:28:11.85,中文,,0,0,0,,又是不平衡的情况
Dialogue: 0,0:28:11.85,0:28:16.13,英文,,0,0,0,,I really wish the problems were equal size, but they're not because I'm getting unlucky.
Dialogue: 0,0:28:11.85,0:28:16.13,中文,,0,0,0,,我真希望问题规模相等 但因为运气不好 它们并不相等
Dialogue: 0,0:28:16.13,0:28:17.63,英文,,0,0,0,,What about this right side?
Dialogue: 0,0:28:16.13,0:28:17.63,中文,,0,0,0,,那右边呢？
Dialogue: 0,0:28:17.63,0:28:25.72,英文,,0,0,0,,Let's say I choose a pivot and instead of Landing in the middle I get unlucky again three times in a row what are the chances
Dialogue: 0,0:28:17.63,0:28:25.72,中文,,0,0,0,,假设我选择一个基准点 结果不是落在中间 而是连续三次不走运 那会是怎样的概率？
Dialogue: 0,0:28:25.72,0:28:31.72,英文,,0,0,0,,nd this time again I have one problem that's 10% of the size one problem was 90% of the size so okay
Dialogue: 0,0:28:25.72,0:28:31.72,中文,,0,0,0,,这次我又遇到了一个问题 其中 10% 的规模是一个问题 90% 的规模是另一个问题
Dialogue: 0,0:28:31.72,0:28:36.72,英文,,0,0,0,, I guess to pull up the left side first remember there was one item nine items good
Dialogue: 0,0:28:31.72,0:28:36.72,中文,,0,0,0,,我想先把左侧拉起来 记得有一个元素和九个元素
Dialogue: 0,0:28:36.72,0:28:38.58,英文,,0,0,0,,now on this right side how many items were there?
Dialogue: 0,0:28:36.72,0:28:38.58,中文,,0,0,0,,很好 现在在这个右侧有多少个元素？
Dialogue: 0,0:28:38.58,0:28:40.36,英文,,0,0,0,,There were 90 items.
Dialogue: 0,0:28:38.58,0:28:40.36,中文,,0,0,0,,有 90 个元素
Dialogue: 0,0:28:40.36,0:28:45.84,英文,,0,0,0,,And if 10% fall on one side and 90% fall on the other side, what's 10% of 90?
Dialogue: 0,0:28:40.36,0:28:45.84,中文,,0,0,0,,如果 10% 在一边 90% 在另一边 90 的 10% 是多少？
Dialogue: 0,0:28:45.84,0:28:47.08,英文,,0,0,0,,Well, that's 9.
Dialogue: 0,0:28:45.84,0:28:47.08,中文,,0,0,0,,嗯 是 9
Dialogue: 0,0:28:47.08,0:28:48.70,英文,,0,0,0,,What's 90% of 90?
Dialogue: 0,0:28:47.08,0:28:48.70,中文,,0,0,0,,90 的 90% 是多少？
Dialogue: 0,0:28:48.70,0:28:49.56,英文,,0,0,0,,That's 81.
Dialogue: 0,0:28:48.70,0:28:49.56,中文,,0,0,0,,是 81
Dialogue: 0,0:28:49.56,0:28:50.82,英文,,0,0,0,,See, I can do the math.
Dialogue: 0,0:28:49.56,0:28:50.82,中文,,0,0,0,,看 我会算数
Dialogue: 0,0:28:50.82,0:28:53.78,英文,,0,0,0,,And so now I have four subproblems.
Dialogue: 0,0:28:50.82,0:28:53.78,中文,,0,0,0,,现在我有四个子问题
Dialogue: 0,0:28:53.78,0:28:55.08,英文,,0,0,0,,They're pretty uneven.
Dialogue: 0,0:28:53.78,0:28:55.08,中文,,0,0,0,,它们很不均匀
Dialogue: 0,0:28:55.08,0:28:59.18,英文,,0,0,0,,Look, I have one that's 81 items, and I have one that's just one item.
Dialogue: 0,0:28:55.08,0:28:59.18,中文,,0,0,0,,看 我有一个包含 81 个元素的子问题 还有一个只包含 1 个元素的
Dialogue: 0,0:28:59.18,0:29:04.17,英文,,0,0,0,,So as I do this more, I'm getting all these lopsided arrays, and I have to solve all of them.
Dialogue: 0,0:28:59.18,0:29:04.17,中文,,0,0,0,,这样拆分下去 我得到一堆大小不一的数组 都得解决
Dialogue: 0,0:29:04.17,0:29:10.34,英文,,0,0,0,,But if I keep going down, eventually, even the largest subproblem, this one right here, this will cut by 90%,
Dialogue: 0,0:29:04.17,0:29:10.34,中文,,0,0,0,,但如果继续拆 最终即使是最大的子问题 也就是这一个 它也会缩小 90%
Dialogue: 0,0:29:10.34,0:29:17.34,英文,,0,0,0,,and then by another 90%, then by another 90%, all the way down until it reaches a size 1 array.
Dialogue: 0,0:29:10.34,0:29:17.34,中文,,0,0,0,,然后再缩小 90% 以此类推 直到它变成大小为 1 的数组
Dialogue: 0,0:29:17.34,0:29:18.70,英文,,0,0,0,,So I'll get there.
Dialogue: 0,0:29:17.34,0:29:18.70,中文,,0,0,0,,总会解决的
Dialogue: 0,0:29:18.70,0:29:20.95,英文,,0,0,0,,It'll just take more levels.
Dialogue: 0,0:29:18.70,0:29:20.95,中文,,0,0,0,,只不过需要更多层级
Dialogue: 0,0:29:20.95,0:29:24.11,英文,,0,0,0,,Are we OK with at least the picture so far?
Dialogue: 0,0:29:20.95,0:29:24.11,中文,,0,0,0,,目前为止 这样的图示大家能理解吗？
Dialogue: 0,0:29:24.11,0:29:25.85,英文,,0,0,0,,It's kind of a weird picture to look at.
Dialogue: 0,0:29:24.11,0:29:25.85,中文,,0,0,0,,看起来有点奇怪
Dialogue: 0,0:29:25.85,0:29:29.85,英文,,0,0,0,,Basically, the idea is instead of landing in the middle, I always land toward one side.
Dialogue: 0,0:29:25.85,0:29:29.85,中文,,0,0,0,,基本思路就是 我总是落在一边 而不是中间
Dialogue: 0,0:29:29.85,0:29:35.02,英文,,0,0,0,,And every time I split the problems, they're uneven, but in a way such that 90% of items are on one side, 10% of items are on the other side.
Dialogue: 0,0:29:29.85,0:29:35.02,中文,,0,0,0,,每次拆分问题 它们都不均匀 但 90% 的元素在一侧 10% 的元素在另一侧
Dialogue: 0,0:29:35.02,0:29:40.64,英文,,0,0,0,,OK, good.
Dialogue: 0,0:29:35.02,0:29:40.64,中文,,0,0,0,,好的
Dialogue: 0,0:29:40.64,0:29:43.03,英文,,0,0,0,,So how much work is done at every level?
Dialogue: 0,0:29:40.64,0:29:43.03,中文,,0,0,0,,那么每层做了多少工作？
Dialogue: 0,0:29:43.03,0:29:46.15,英文,,0,0,0,,Let's do asymptotic runtime on this analysis now.
Dialogue: 0,0:29:43.03,0:29:46.15,中文,,0,0,0,,现在来分析一下渐进运行时间
Dialogue: 0,0:29:46.15,0:29:48.87,英文,,0,0,0,,So we know that every time we split, the array gets smaller.
Dialogue: 0,0:29:46.15,0:29:48.87,中文,,0,0,0,,我们知道每次拆分 数组都会变小
Dialogue: 0,0:29:48.87,0:29:50.90,英文,,0,0,0,,But how much smaller exactly?
Dialogue: 0,0:29:48.87,0:29:50.90,中文,,0,0,0,,但到底小了多少呢？
Dialogue: 0,0:29:50.90,0:29:52.72,英文,,0,0,0,,And how much smaller are the subproblems?
Dialogue: 0,0:29:50.90,0:29:52.72,中文,,0,0,0,,子问题又小了多少？
Dialogue: 0,0:29:52.72,0:29:58.21,英文,,0,0,0,,Well, at the top level, I still have to do n work, because I have to partition this whole array here.
Dialogue: 0,0:29:52.72,0:29:58.21,中文,,0,0,0,,在顶层 我仍然要做 N 个工作 因为我必须划分整个数组
Dialogue: 0,0:29:58.21,0:30:03.57,英文,,0,0,0,,Well, I still have to do n work, because I have a smaller array to partition and a larger array to partition.
Dialogue: 0,0:29:58.21,0:30:03.57,中文,,0,0,0,,我仍然要做 N 个工作 因为我有一个较小的数组要划分 还有一个较大的数组要划分
Dialogue: 0,0:30:03.57,0:30:08.91,英文,,0,0,0,,But in total, the amount of work is still n. Maybe the small one's faster, but the large one is slower.
Dialogue: 0,0:30:03.57,0:30:08.91,中文,,0,0,0,,但总的来说 工作量仍然是 N 也许小的那个更快 但大的那个更慢
Dialogue: 0,0:30:08.91,0:30:14.23,英文,,0,0,0,,So if you add it all up, you're still going to end up partitioning approximately n items.
Dialogue: 0,0:30:08.91,0:30:14.23,中文,,0,0,0,,如果你把它们加起来 你最终还是要划分大约 N 个元素
Dialogue: 0,0:30:14.23,0:30:15.49,英文,,0,0,0,,And same thing at the next level.
Dialogue: 0,0:30:14.23,0:30:15.49,中文,,0,0,0,,下一层也是一样
Dialogue: 0,0:30:15.49,0:30:18.31,英文,,0,0,0,,It's true you have four subproblems that are of different sizes.
Dialogue: 0,0:30:15.49,0:30:18.31,中文,,0,0,0,,没错 你有四个大小不同的子问题
Dialogue: 0,0:30:18.31,0:30:26.23,英文,,0,0,0,,But if you added up the total amount of work done for each subproblem, you would still get n. And the same holds for every single level.
Dialogue: 0,0:30:18.31,0:30:26.23,中文,,0,0,0,,但如果你把每个子问题的工作量加起来 仍然是 N 每一层都是如此
Dialogue: 0,0:30:26.23,0:30:30.74,英文,,0,0,0,,So then the only problem we have to solve is, how many levels are there?
Dialogue: 0,0:30:26.23,0:30:30.74,中文,,0,0,0,,我们唯一要解决的问题是 有多少层？
Dialogue: 0,0:30:30.74,0:30:37.50,英文,,0,0,0,,And this will tell us the runtime of QuickSort, not in the best or worst case, but in this specific case that I'm painting.
Dialogue: 0,0:30:30.74,0:30:37.50,中文,,0,0,0,,这将告诉我们快速排序的运行时间 不是在最好或最坏的情况下 而是在我描述的这个特定情况下
Dialogue: 0,0:30:37.50,0:30:39.48,英文,,0,0,0,,So how many levels are there?
Dialogue: 0,0:30:37.50,0:30:39.48,中文,,0,0,0,,那么有多少层呢？
Dialogue: 0,0:30:39.48,0:30:41.95,英文,,0,0,0,,Well, at the first level, I had 100 items.
Dialogue: 0,0:30:39.48,0:30:41.95,中文,,0,0,0,,在第一层 我有 100 个元素
Dialogue: 0,0:30:41.95,0:30:46.23,英文,,0,0,0,,And then the largest remaining subproblem was 90% of that size.
Dialogue: 0,0:30:41.95,0:30:46.23,中文,,0,0,0,,然后 剩下的最大的子问题是它大小的 90%
Dialogue: 0,0:30:46.23,0:30:50.07,英文,,0,0,0,,So at 90 items, there were more subproblems, but they'll vanish quicker.
Dialogue: 0,0:30:46.23,0:30:50.07,中文,,0,0,0,,在 90 个元素时 有更多的子问题 但它们会消失得更快
Dialogue: 0,0:30:50.07,0:30:52.55,英文,,0,0,0,,Then I had a subproblem of size 81.
Dialogue: 0,0:30:50.07,0:30:52.55,中文,,0,0,0,,然后我有一个大小为 81 的子问题
Dialogue: 0,0:30:52.55,0:30:56.20,英文,,0,0,0,,And then there are some other smaller subproblems that will probably vanish quicker.
Dialogue: 0,0:30:52.55,0:30:56.20,中文,,0,0,0,,然后还有一些更小的子问题 它们可能会消失得更快
Dialogue: 0,0:30:56.20,0:30:57.74,英文,,0,0,0,,Then what about the next level?
Dialogue: 0,0:30:56.20,0:30:57.74,中文,,0,0,0,,那么下一层呢？
Dialogue: 0,0:30:57.74,0:31:06.50,英文,,0,0,0,,There will be a subproblem that is 90% of 81, and then another subproblem that's 90% of that, and then 90% of that, and then 90% of that.
Dialogue: 0,0:30:57.74,0:31:06.50,中文,,0,0,0,,会有一个子问题是 81 的 90% 然后是另一个子问题是它的 90% 然后是 90% 然后是 90%
Dialogue: 0,0:31:06.50,0:31:17.70,英文,,0,0,0,,So the question is, how many times do you have to take an array of size n and reduce it by 90%, 90%, 90% before you get to arrays of size 1?
Dialogue: 0,0:31:06.50,0:31:17.70,中文,,0,0,0,,问题是 你要把一个大小为 N 的数组缩小 90% 90% 90% 多少次才能得到大小为 1 的数组？
Dialogue: 0,0:31:17.70,0:31:22.13,英文,,0,0,0,,Well, it turns out that is still a logarithm.
Dialogue: 0,0:31:17.70,0:31:22.13,中文,,0,0,0,,事实证明 这仍然是一个对数
Dialogue: 0,0:31:22.13,0:31:27.95,英文,,0,0,0,,Mind-blowing, because remember, the idea with the logarithm is it's the number of times you divide.
Dialogue: 0,0:31:22.13,0:31:27.95,中文,,0,0,0,,这令人难以置信 因为记住 对数的概念是你除的次数
Dialogue: 0,0:31:27.95,0:31:30.57,英文,,0,0,0,,We said by 2 earlier, because we were thinking base 2.
Dialogue: 0,0:31:27.95,0:31:30.57,中文,,0,0,0,,我们之前说是 2 因为我们在考虑以 2 为底
Dialogue: 0,0:31:30.57,0:31:35.13,英文,,0,0,0,,But you could also do it with other stranger numbers, like, for example, 10 over 9.
Dialogue: 0,0:31:30.57,0:31:35.13,中文,,0,0,0,,但你也可以用其他奇怪的数字 比如 10/9
Dialogue: 0,0:31:35.13,0:31:43.36,英文,,0,0,0,,That would be the equivalent of multiplying by 0.9, or taking the array and cutting it to 90% of its size every single time.
Dialogue: 0,0:31:35.13,0:31:43.36,中文,,0,0,0,,这相当于乘以 0.9 或者每次将数组缩小到其大小的 90%
Dialogue: 0,0:31:43.36,0:31:54.59,英文,,0,0,0,,So the number of times you have to cut an array down to 90% of its size before it reaches 1, it's still a log n asymptotic behavior.
Dialogue: 0,0:31:43.36,0:31:54.59,中文,,0,0,0,,在你将数组缩小到其大小的 90% 之前 它达到 1 的次数仍然是对数 N 的渐近行为
Dialogue: 0,0:31:54.59,0:31:56.23,英文,,0,0,0,,It just has a different base.
Dialogue: 0,0:31:54.59,0:31:56.23,中文,,0,0,0,,它只是底数不同
Dialogue: 0,0:31:56.23,0:32:04.99,英文,,0,0,0,,So because the number of levels is still log n, my runtime for this pretty bad case algorithm is actually still n log n.
Dialogue: 0,0:31:56.23,0:32:04.99,中文,,0,0,0,,由于层数仍然是对数 N 这个非常糟糕的算法的运行时间实际上仍然是 N log N
Dialogue: 0,0:32:04.99,0:32:12.06,英文,,0,0,0,,So even if I get super unlucky, and my pivot always lands up very skewed toward one side, I still get n log n behavior.
Dialogue: 0,0:32:04.99,0:32:12.06,中文,,0,0,0,,即使我非常不走运 基准值总是偏向一边 我仍然可以得到 N log N 的时间复杂度
Dialogue: 0,0:32:12.06,0:32:25.01,英文,,0,0,0,,It's going to be slower in real life, but asymptotically, it's still n log n. The only thing that changed is the base, because instead of the subproblems becoming size 50% each time, they were size 90% each time.
Dialogue: 0,0:32:12.06,0:32:25.01,中文,,0,0,0,,实际情况会慢一些 但渐进时间复杂度仍然是 N log N 唯一改变的是底数 因为子问题的规模每次不是缩小 50% 而是 90%
Dialogue: 0,0:32:25.01,0:32:33.95,英文,,0,0,0,,And the number of times I have to multiply by 90% before I reach problems of size 1, it's still log n, just with a different base.
Dialogue: 0,0:32:25.01,0:32:33.95,中文,,0,0,0,,而在我达到问题规模为 1 之前 我需要乘以 90% 的次数仍然是 log N 只是底数不同
Dialogue: 0,0:32:33.95,0:32:35.91,英文,,0,0,0,,What would people like to know on Zoom?
Dialogue: 0,0:32:33.95,0:32:35.91,中文,,0,0,0,,Zoom 上的同学还有什么问题吗？
Dialogue: 0,0:32:35.91,0:32:41.13,英文,,0,0,0,,There was questions about, do you count the black boxes and why is it O and not beta?
Dialogue: 0,0:32:35.91,0:32:41.13,中文,,0,0,0,,有人问 是否要计算黑色框？为什么是大 O 表示法而不是 Θ 表示法？
Dialogue: 0,0:32:41.13,0:32:49.20,英文,,0,0,0,,I think both of those have the same answer, which is that if you want it to be really precise, are you really doing n work at this layer?
Dialogue: 0,0:32:41.13,0:32:49.20,中文,,0,0,0,,我认为这两个问题的答案是一样的 那就是如果你想非常精确 你在这一层真的做了 N 次操作吗？
Dialogue: 0,0:32:49.20,0:32:54.34,英文,,0,0,0,,Not really. You're doing n minus 1 work because the black partitioned item doesn't count.
Dialogue: 0,0:32:49.20,0:32:54.34,中文,,0,0,0,,并不是  你做了 N-1 次操作 因为黑色分区项不计入
Dialogue: 0,0:32:54.34,0:32:56.62,英文,,0,0,0,,And at this layer, are you really doing n work?
Dialogue: 0,0:32:54.34,0:32:56.62,中文,,0,0,0,,在这一层 你真的做了 N 次操作吗？
Dialogue: 0,0:32:56.62,0:33:00.00,英文,,0,0,0,,Not really. You're doing n minus 3 work because these don't count.
Dialogue: 0,0:32:56.62,0:33:00.00,中文,,0,0,0,,并不是  你做了 N-3 次操作 因为这些不计入
Dialogue: 0,0:33:00.00,0:33:07.35,英文,,0,0,0,,So if you want it to be really precise, you could actually take those out and do a really careful analysis and then tighten this bound to theta.
Dialogue: 0,0:33:00.00,0:33:07.35,中文,,0,0,0,,如果你想非常精确 你实际上可以把它们去掉 做一个非常仔细的分析 然后把这个界限收紧到 Θ 表示法
Dialogue: 0,0:33:07.35,0:33:12.59,英文,,0,0,0,,But I've decided just to be lazy for a lecture and give you a big O bound.
Dialogue: 0,0:33:07.35,0:33:12.59,中文,,0,0,0,,但我决定在课堂上偷个懒 给你们一个大 O 表示法的界限
Dialogue: 0,0:33:12.59,0:33:19.36,英文,,0,0,0,,But if you wanted to, I believe if you did the exact analysis, you'd get something like theta of n log n minus n or something.
Dialogue: 0,0:33:12.59,0:33:19.36,中文,,0,0,0,,但如果你想的话 我相信如果你做了精确的分析 你会得到类似于 Θ(N log N - N) 之类的结果
Dialogue: 0,0:33:19.36,0:33:21.30,英文,,0,0,0,,And the lower order term would drop away.
Dialogue: 0,0:33:19.36,0:33:21.30,中文,,0,0,0,,而低阶项会被舍弃
Dialogue: 0,0:33:21.30,0:33:23.20,英文,,0,0,0,,That's a good question, though.
Dialogue: 0,0:33:21.30,0:33:23.20,中文,,0,0,0,,不过 这是个好问题
Dialogue: 0,0:33:23.20,0:33:25.26,英文,,0,0,0,,Why use quicksort if they're both n log n?
Dialogue: 0,0:33:23.20,0:33:25.26,中文,,0,0,0,,如果它们都是 N log N 为什么要用快速排序？
Dialogue: 0,0:33:25.26,0:33:26.48,英文,,0,0,0,,Soon.
Dialogue: 0,0:33:25.26,0:33:26.48,中文,,0,0,0,,稍后再说
Dialogue: 0,0:33:26.48,0:33:29.66,英文,,0,0,0,,Why is quicksort faster?
Dialogue: 0,0:33:26.48,0:33:29.66,中文,,0,0,0,,为什么快速排序更快？
Dialogue: 0,0:33:29.66,0:33:30.26,英文,,0,0,0,,Soon.
Dialogue: 0,0:33:29.66,0:33:30.26,中文,,0,0,0,,稍后再说
Dialogue: 0,0:33:30.26,0:33:32.58,英文,,0,0,0,,But for now, I just want to convince you that it's fast.
Dialogue: 0,0:33:30.26,0:33:32.58,中文,,0,0,0,,但现在 我只想让你相信它很快
Dialogue: 0,0:33:32.58,0:33:41.75,英文,,0,0,0,,And for random arrays, like most arrays in the world, you will not get the n squared behavior, even if you're super unlucky like this.
Dialogue: 0,0:33:32.58,0:33:41.75,中文,,0,0,0,,对于随机数组 就像世界上大多数数组一样 即使你像这样超级倒霉 也不会出现 N^2行为
Dialogue: 0,0:33:41.75,0:33:51.80,英文,,0,0,0,,So the punchline is, even if you're really unlucky, every time you pick a number between 1 and 10, you get the 1, you are still guaranteed n log n behavior.
Dialogue: 0,0:33:41.75,0:33:51.80,中文,,0,0,0,,关键是 即使你真的不走运 每次你从 1 到 10 中选择一个数字 你都得到 1 你仍然保证 N log N 行为
Dialogue: 0,0:33:51.80,0:33:53.40,英文,,0,0,0,,Here's the second argument.
Dialogue: 0,0:33:51.80,0:33:53.40,中文,,0,0,0,,这是第二个论点
Dialogue: 0,0:33:53.40,0:33:58.45,英文,,0,0,0,,This is one of those ones where those other guys would not have done it justice, so I have to be here and show it to you.
Dialogue: 0,0:33:53.40,0:33:58.45,中文,,0,0,0,,这是其他家伙无法公正对待的事情之一 所以我必须在这里向你展示
Dialogue: 0,0:33:58.45,0:34:03.25,英文,,0,0,0,,Turns out, Quicksort is actually the same thing as BinarySearchTreeSort.
Dialogue: 0,0:33:58.45,0:34:03.25,中文,,0,0,0,,事实证明 快速排序 实际上与 BiNarySearchTree Sort(BST Sort二叉搜索树排序)相同
Dialogue: 0,0:34:03.25,0:34:04.97,英文,,0,0,0,,Oh, what's BinarySearchTreeSort?
Dialogue: 0,0:34:03.25,0:34:04.97,中文,,0,0,0,,哦 什么是 BiNarySearchTreeSort？
Dialogue: 0,0:34:04.97,0:34:08.09,英文,,0,0,0,,Well, imagine if I took all the items.
Dialogue: 0,0:34:04.97,0:34:08.09,中文,,0,0,0,,好吧 想象一下 如果我拿走了所有物品
Dialogue: 0,0:34:08.09,0:34:11.63,英文,,0,0,0,,in this array, left to right, and I shove them in a binary search tree.
Dialogue: 0,0:34:08.09,0:34:11.63,中文,,0,0,0,,在这个数组中 从左到右 我把它们塞进一个二叉搜索树中
Dialogue: 0,0:34:11.63,0:34:15.99,英文,,0,0,0,,So I start at the left, I go to the right, and I put everything in a binary search tree.
Dialogue: 0,0:34:11.63,0:34:15.99,中文,,0,0,0,,我从左边开始 到右边 我把所有东西都放进一个二叉搜索树中
Dialogue: 0,0:34:15.99,0:34:17.93,英文,,0,0,0,,And this is just a regular old binary search tree.
Dialogue: 0,0:34:15.99,0:34:17.93,中文,,0,0,0,,这只是一个普通的旧二叉搜索树
Dialogue: 0,0:34:17.93,0:34:21.43,英文,,0,0,0,,There's no balancing, there's no red and black links, nothing like that.
Dialogue: 0,0:34:17.93,0:34:21.43,中文,,0,0,0,,没有平衡 没有红黑链接 没有那样的事情
Dialogue: 0,0:34:21.43,0:34:25.58,英文,,0,0,0,,I just take the items and I insert them into a binary search tree.
Dialogue: 0,0:34:21.43,0:34:25.58,中文,,0,0,0,,我只是拿走这些物品 然后将它们插入到二叉搜索树中
Dialogue: 0,0:34:25.58,0:34:33.10,英文,,0,0,0,,And then once I insert things into a binary search tree, I can do an in-order traversal, and the results will be a sorted array.
Dialogue: 0,0:34:25.58,0:34:33.10,中文,,0,0,0,,然后 一旦我将东西插入到二叉搜索树中 我就可以进行中序遍历 结果将是一个排序数组
Dialogue: 0,0:34:33.10,0:34:36.83,英文,,0,0,0,,And if you're not convinced, go back and think about what the in-order traversal is.
Dialogue: 0,0:34:33.10,0:34:36.83,中文,,0,0,0,,如果你不相信 回去想想中序遍历是什么
Dialogue: 0,0:34:36.83,0:34:44.30,英文,,0,0,0,,Remember, the in-order traversal says, visit all the things to my left, visit me, and then visit all the things to my right.
Dialogue: 0,0:34:36.83,0:34:44.30,中文,,0,0,0,,记住 中序遍历说 访问我左边所有东西 访问我 然后访问我右边所有东西
Dialogue: 0,0:34:44.30,0:34:47.48,英文,,0,0,0,,that will give you a sorted array if you do it recursively.
Dialogue: 0,0:34:44.30,0:34:47.48,中文,,0,0,0,,如果你递归地这样做 它会给你一个排序数组
Dialogue: 0,0:34:47.48,0:34:56.14,英文,,0,0,0,,But the idea behind BST sort is take all the items, put them in a binary search tree, and traverse it in the right order to get the sorted array.
Dialogue: 0,0:34:47.48,0:34:56.14,中文,,0,0,0,,但是 BST 排序背后的想法是获取所有元素 将它们放入二叉搜索树中 并以正确的顺序遍历它以获取排序数组
Dialogue: 0,0:34:56.14,0:34:59.95,英文,,0,0,0,,So here's what it looks like if I take the 5 and I stick it in the binary search tree.
Dialogue: 0,0:34:56.14,0:34:59.95,中文,,0,0,0,,如果我取 5 并将其粘贴到二叉搜索树中 它看起来像这样
Dialogue: 0,0:34:59.95,0:35:03.55,英文,,0,0,0,,Well, the binary search tree has one item. It's 5.
Dialogue: 0,0:34:59.95,0:35:03.55,中文,,0,0,0,,好吧 二叉搜索树有一个元素  是 5
Dialogue: 0,0:35:03.55,0:35:05.01,英文,,0,0,0,,That wasn't very interesting.
Dialogue: 0,0:35:03.55,0:35:05.01,中文,,0,0,0,,没什么意思
Dialogue: 0,0:35:05.01,0:35:10.87,英文,,0,0,0,,Now I take the next item, which is 3, and I put it in the binary search tree, and it shows up to the left of 5.
Dialogue: 0,0:35:05.01,0:35:10.87,中文,,0,0,0,,下一个是 3 把它放到二叉搜索树中 它出现在 5 的左边
Dialogue: 0,0:35:10.87,0:35:12.91,英文,,0,0,0,,Then I take the next item, which is 2.
Dialogue: 0,0:35:10.87,0:35:12.91,中文,,0,0,0,,再下一个是 2
Dialogue: 0,0:35:12.91,0:35:14.29,英文,,0,0,0,,I put it in the binary search tree.
Dialogue: 0,0:35:12.91,0:35:14.29,中文,,0,0,0,,把它放到二叉搜索树中
Dialogue: 0,0:35:14.29,0:35:15.03,英文,,0,0,0,,And I started the 5.
Dialogue: 0,0:35:14.29,0:35:15.03,中文,,0,0,0,,从 5 开始
Dialogue: 0,0:35:15.03,0:35:16.05,英文,,0,0,0,,It's less than 5.
Dialogue: 0,0:35:15.03,0:35:16.05,中文,,0,0,0,,它小于 5
Dialogue: 0,0:35:16.05,0:35:17.31,英文,,0,0,0,,I go to the left.
Dialogue: 0,0:35:16.05,0:35:17.31,中文,,0,0,0,,往左走
Dialogue: 0,0:35:17.31,0:35:18.17,英文,,0,0,0,,It's less than 3.
Dialogue: 0,0:35:17.31,0:35:18.17,中文,,0,0,0,,它小于 3
Dialogue: 0,0:35:18.17,0:35:19.25,英文,,0,0,0,,I go to the left.
Dialogue: 0,0:35:18.17,0:35:19.25,中文,,0,0,0,,继续往左
Dialogue: 0,0:35:19.25,0:35:21.37,英文,,0,0,0,,That's a good place to put the 2.
Dialogue: 0,0:35:19.25,0:35:21.37,中文,,0,0,0,,把 2 放在这里
Dialogue: 0,0:35:21.37,0:35:23.27,英文,,0,0,0,,By the way, the binary search tree, there's no balance.
Dialogue: 0,0:35:21.37,0:35:23.27,中文,,0,0,0,,顺便说一下 这个二叉搜索树没有平衡
Dialogue: 0,0:35:23.27,0:35:27.64,英文,,0,0,0,,I'm just putting them straight in there with no regard for any sort of balance.
Dialogue: 0,0:35:23.27,0:35:27.64,中文,,0,0,0,,我只是把它们直接放进去 没有考虑任何平衡
Dialogue: 0,0:35:27.64,0:35:28.90,英文,,0,0,0,,Then I insert the 1.
Dialogue: 0,0:35:27.64,0:35:28.90,中文,,0,0,0,,然后插入 1
Dialogue: 0,0:35:28.90,0:35:31.18,英文,,0,0,0,,So I started the 5, left, left, left.
Dialogue: 0,0:35:28.90,0:35:31.18,中文,,0,0,0,,从 5 开始 左、左、左
Dialogue: 0,0:35:31.18,0:35:32.44,英文,,0,0,0,,I insert the 1.
Dialogue: 0,0:35:31.18,0:35:32.44,中文,,0,0,0,,插入 1
Dialogue: 0,0:35:32.44,0:35:33.46,英文,,0,0,0,,Then I insert the 7.
Dialogue: 0,0:35:32.44,0:35:33.46,中文,,0,0,0,,然后插入 7
Dialogue: 0,0:35:33.46,0:35:34.38,英文,,0,0,0,,It goes there.
Dialogue: 0,0:35:33.46,0:35:34.38,中文,,0,0,0,,它去那里
Dialogue: 0,0:35:34.38,0:35:35.86,英文,,0,0,0,,Then I insert the 8.
Dialogue: 0,0:35:34.38,0:35:35.86,中文,,0,0,0,,然后插入 8
Dialogue: 0,0:35:35.86,0:35:37.34,英文,,0,0,0,,Then I insert the 4.
Dialogue: 0,0:35:35.86,0:35:37.34,中文,,0,0,0,,然后插入 4
Dialogue: 0,0:35:37.34,0:35:38.16,英文,,0,0,0,,Where does the 4 go?
Dialogue: 0,0:35:37.34,0:35:38.16,中文,,0,0,0,,4 放在哪里？
Dialogue: 0,0:35:38.16,0:35:39.44,英文,,0,0,0,,Well, I start at the 5.
Dialogue: 0,0:35:38.16,0:35:39.44,中文,,0,0,0,,我先从 5 开始
Dialogue: 0,0:35:39.44,0:35:40.12,英文,,0,0,0,,It's less than 5.
Dialogue: 0,0:35:39.44,0:35:40.12,中文,,0,0,0,,它小于 5
Dialogue: 0,0:35:40.12,0:35:41.72,英文,,0,0,0,,I go to the 3.
Dialogue: 0,0:35:40.12,0:35:41.72,中文,,0,0,0,,我走到 3
Dialogue: 0,0:35:41.72,0:35:43.08,英文,,0,0,0,,It's greater than 3.
Dialogue: 0,0:35:41.72,0:35:43.08,中文,,0,0,0,,它大于 3
Dialogue: 0,0:35:43.08,0:35:44.16,英文,,0,0,0,,Right there.
Dialogue: 0,0:35:43.08,0:35:44.16,中文,,0,0,0,,就在这里
Dialogue: 0,0:35:44.16,0:35:45.35,英文,,0,0,0,,What about the 6?
Dialogue: 0,0:35:44.16,0:35:45.35,中文,,0,0,0,,那 6 呢？
Dialogue: 0,0:35:45.35,0:35:49.67,英文,,0,0,0,,Well, 6 is greater than 5, so I go here.
Dialogue: 0,0:35:45.35,0:35:49.67,中文,,0,0,0,,6 大于 5 所以我要走到这边
Dialogue: 0,0:35:49.67,0:35:52.67,英文,,0,0,0,,6 is less than 7, so I put it there.
Dialogue: 0,0:35:49.67,0:35:52.67,中文,,0,0,0,,6 小于 7 所以我就把它放在那里
Dialogue: 0,0:35:52.67,0:36:00.43,英文,,0,0,0,,So once I have everything in my binary search tree, I can do an in-order traversal, and I will get 1, 2, 3, 4, 5, 6, 7, 8.
Dialogue: 0,0:35:52.67,0:36:00.43,中文,,0,0,0,,一旦我把所有东西都放进我的二叉搜索树中 我就可以进行中序遍历 就会得到 1、2、3、4、5、6、7、8
Dialogue: 0,0:36:00.43,0:36:02.49,英文,,0,0,0,,That's binary search tree sort.
Dialogue: 0,0:36:00.43,0:36:02.49,中文,,0,0,0,,这就是二叉搜索树排序
Dialogue: 0,0:36:02.49,0:36:13.94,英文,,0,0,0,,So I showed you binary search tree sort, I showed you quick sort, and the thing that is really weird, but is actually true, is that these two are actually the same sort.
Dialogue: 0,0:36:02.49,0:36:13.94,中文,,0,0,0,,我向你展示了二叉搜索树排序 也展示了快速排序 而真正奇怪但却是事实的是 这两种排序实际上是相同的
Dialogue: 0,0:36:13.94,0:36:15.78,英文,,0,0,0,,And what do I mean by the same sort?
Dialogue: 0,0:36:13.94,0:36:15.78,中文,,0,0,0,,相同的排序是什么意思呢？
Dialogue: 0,0:36:15.78,0:36:20.53,英文,,0,0,0,,I mean that the series of comparisons that they make is actually the same.
Dialogue: 0,0:36:15.78,0:36:20.53,中文,,0,0,0,,我的意思是它们进行的比较序列实际上是相同的
Dialogue: 0,0:36:20.53,0:36:29.36,英文,,0,0,0,,So if I think about what actually characterizes a search, well, one way to characterize a search is to write down the complete sequence of comparisons that you make.
Dialogue: 0,0:36:20.53,0:36:29.36,中文,,0,0,0,,如果我考虑是什么真正地描述了一种搜索 那么 描述搜索的一种方法是写下你进行的完整的比较序列
Dialogue: 0,0:36:29.36,0:36:35.91,英文,,0,0,0,,So for example, if I was selection sorting this, then I'd write down that I compare 5 to everybody else,
Dialogue: 0,0:36:29.36,0:36:35.91,中文,,0,0,0,,例如 如果我对这个进行选择排序 那么我会写下我把 5 和其他所有人进行比较
Dialogue: 0,0:36:35.91,0:36:39.91,英文,,0,0,0,,and then I compare the 3 to everybody else, and so forth, or whatever.
Dialogue: 0,0:36:35.91,0:36:39.91,中文,,0,0,0,,然后我把 3 和其他所有人进行比较 等等 诸如此类
Dialogue: 0,0:36:39.91,0:36:42.59,英文,,0,0,0,,So I can write down the sequence of comparisons that I make.
Dialogue: 0,0:36:39.91,0:36:42.59,中文,,0,0,0,,我可以写下我进行的比较序列
Dialogue: 0,0:36:42.59,0:36:53.26,英文,,0,0,0,,And it turns out that if you write down the sequence of comparisons that QuickSort makes, and you write down the sequence of comparisons that BinarySearchTreeSort makes, you get the exact sequence of comparisons.
Dialogue: 0,0:36:42.59,0:36:53.26,中文,,0,0,0,,事实证明 如果你写下快速排序进行的比较序列 以及二叉搜索树排序进行的比较序列 你会得到完全相同的比较序列
Dialogue: 0,0:36:53.26,0:36:59.87,英文,,0,0,0,,At a very deep level, QuickSort and BSTsort are thinking about the exact same things.
Dialogue: 0,0:36:53.26,0:36:59.87,中文,,0,0,0,,在很深的层次上 快速排序和二叉搜索树排序考虑的是完全相同的事情
Dialogue: 0,0:36:59.87,0:37:01.55,英文,,0,0,0,,So here's what I mean.
Dialogue: 0,0:36:59.87,0:37:01.55,中文,,0,0,0,,我的意思是这样的
Dialogue: 0,0:37:01.55,0:37:06.69,英文,,0,0,0,,And honestly, this is one of those ones where if you just write out the full sequence of comparisons, I think it's easier to see.
Dialogue: 0,0:37:01.55,0:37:06.69,中文,,0,0,0,,说实话 这个例子直接把所有比较过程写出来会更容易理解
Dialogue: 0,0:37:06.69,0:37:09.09,英文,,0,0,0,,But I'll just show a rough picture for now.
Dialogue: 0,0:37:06.69,0:37:09.09,中文,,0,0,0,,不过现在我只简单画个图
Dialogue: 0,0:37:09.09,0:37:11.27,英文,,0,0,0,,So let's say I want to partition on the 5.
Dialogue: 0,0:37:09.09,0:37:11.27,中文,,0,0,0,,假设我想以 5 为基准进行分区
Dialogue: 0,0:37:11.27,0:37:16.54,英文,,0,0,0,,What are all of the items that had to get compared to 5 to finish the partition?
Dialogue: 0,0:37:11.27,0:37:16.54,中文,,0,0,0,,完成分区后 哪些元素需要与 5 进行比较？
Dialogue: 0,0:37:16.54,0:37:17.52,英文,,0,0,0,,I want to partition on 5.
Dialogue: 0,0:37:16.54,0:37:17.52,中文,,0,0,0,,我想以 5 为基准进行分区
Dialogue: 0,0:37:17.52,0:37:26.44,英文,,0,0,0,,I have to compare everybody against 5 so that all the items less than 5 show up to the left, all the items greater than 5 show up to the right.
Dialogue: 0,0:37:17.52,0:37:26.44,中文,,0,0,0,,我需要将所有元素与 5 进行比较 这样小于 5 的元素就会出现在左边 大于 5 的元素出现在右边
Dialogue: 0,0:37:26.44,0:37:29.72,英文,,0,0,0,,So in other words, every item had to get compared to 5.
Dialogue: 0,0:37:26.44,0:37:29.72,中文,,0,0,0,,换句话说 每个元素都需要与 5 进行比较
Dialogue: 0,0:37:29.72,0:37:31.50,英文,,0,0,0,,Now switch to BST sort.
Dialogue: 0,0:37:29.72,0:37:31.50,中文,,0,0,0,,现在切换到二叉搜索树排序
Dialogue: 0,0:37:31.50,0:37:35.74,英文,,0,0,0,,In BST sort, how many items had to get compared to five?
Dialogue: 0,0:37:31.50,0:37:35.74,中文,,0,0,0,,在二叉搜索树排序中 有多少元素需要与 5 进行比较？
Dialogue: 0,0:37:35.74,0:37:37.82,英文,,0,0,0,,All of them, because 5 is the root.
Dialogue: 0,0:37:35.74,0:37:37.82,中文,,0,0,0,,所有元素都要比较 因为 5 是根节点
Dialogue: 0,0:37:37.82,0:37:42.67,英文,,0,0,0,,So to insert anything into the tree, remember how we were inserting, oh, I want to find out where 6 goes?
Dialogue: 0,0:37:37.82,0:37:42.67,中文,,0,0,0,,还记得我们是如何插入元素的吗？比如 我想知道 6 应该放在哪里？
Dialogue: 0,0:37:42.67,0:37:45.29,英文,,0,0,0,,Well, I started at the 5, and I thought 6 is greater than 5.
Dialogue: 0,0:37:42.67,0:37:45.29,中文,,0,0,0,,我从 5 开始 然后判断 6 大于 5
Dialogue: 0,0:37:45.29,0:37:47.23,英文,,0,0,0,,That was the comparison that I made.
Dialogue: 0,0:37:45.29,0:37:47.23,中文,,0,0,0,,这就是我做的比较
Dialogue: 0,0:37:47.23,0:37:52.14,英文,,0,0,0,,So BST sort checked 6 versus 5 to figure out where 6 goes.
Dialogue: 0,0:37:47.23,0:37:52.14,中文,,0,0,0,,所以二叉搜索树排序会比较 6 和 5 来确定 6 的位置
Dialogue: 0,0:37:52.14,0:37:55.92,英文,,0,0,0,,And QuickSort checked 6 versus 5, the partition on 5.
Dialogue: 0,0:37:52.14,0:37:55.92,中文,,0,0,0,,快速排序也会比较 6 和 5 也就是以 5 为基准进行分区
Dialogue: 0,0:37:55.92,0:37:57.78,英文,,0,0,0,,So both of them had that same comparison.
Dialogue: 0,0:37:55.92,0:37:57.78,中文,,0,0,0,,它们都进行了相同的比较
Dialogue: 0,0:37:57.78,0:38:02.49,英文,,0,0,0,,It turns out they have the exact same set of comparisons.
Dialogue: 0,0:37:57.78,0:38:02.49,中文,,0,0,0,,事实上 它们进行的比较完全相同
Dialogue: 0,0:38:02.49,0:38:04.78,英文,,0,0,0,,That's the initial value, which is 5.
Dialogue: 0,0:38:02.49,0:38:04.78,中文,,0,0,0,,这是初始值 也就是 5
Dialogue: 0,0:38:04.78,0:38:09.68,英文,,0,0,0,,Everybody gets compared to 5, whether you're using QuickSort or BST Sort.
Dialogue: 0,0:38:04.78,0:38:09.68,中文,,0,0,0,,无论你使用快速排序还是二叉搜索树排序 所有元素都需要与 5 进行比较
Dialogue: 0,0:38:09.68,0:38:11.58,英文,,0,0,0,,Now we have two smaller subproblems.
Dialogue: 0,0:38:09.68,0:38:11.58,中文,,0,0,0,,现在我们有两个更小的子问题
Dialogue: 0,0:38:11.58,0:38:15.43,英文,,0,0,0,,What are all of the items that get compared to 3?
Dialogue: 0,0:38:11.58,0:38:15.43,中文,,0,0,0,,哪些元素会和 3 进行比较呢？
Dialogue: 0,0:38:15.43,0:38:18.29,英文,,0,0,0,,Well, it's these items, 2, 1, and 4.
Dialogue: 0,0:38:15.43,0:38:18.29,中文,,0,0,0,,嗯 是这些：2、1 和 4
Dialogue: 0,0:38:18.29,0:38:19.97,英文,,0,0,0,,Now look at the BST version.
Dialogue: 0,0:38:18.29,0:38:19.97,中文,,0,0,0,,现在看看 BST 版本
Dialogue: 0,0:38:19.97,0:38:23.42,英文,,0,0,0,,What are all of the items that get compared to 3?
Dialogue: 0,0:38:19.97,0:38:23.42,中文,,0,0,0,,哪些元素会和 3 进行比较呢？
Dialogue: 0,0:38:23.42,0:38:29.56,英文,,0,0,0,,2, 1, and 4, all of the items below 3, these are the items where I stopped at 3 and I asked, is the item greater than 3?
Dialogue: 0,0:38:23.42,0:38:29.56,中文,,0,0,0,,2、1 和 4 所有小于 3 的元素 这些是在我停在 3 的位置 并询问“这个元素是否大于 3” 的元素
Dialogue: 0,0:38:29.56,0:38:31.58,英文,,0,0,0,,Then go to my right.
Dialogue: 0,0:38:29.56,0:38:31.58,中文,,0,0,0,,然后转向我的右边
Dialogue: 0,0:38:31.58,0:38:32.52,英文,,0,0,0,,Or is it less than 3?
Dialogue: 0,0:38:31.58,0:38:32.52,中文,,0,0,0,,或者它小于 3？
Dialogue: 0,0:38:32.52,0:38:33.76,英文,,0,0,0,,Go to my left.
Dialogue: 0,0:38:32.52,0:38:33.76,中文,,0,0,0,,那就转向我的左边
Dialogue: 0,0:38:33.76,0:38:39.69,英文,,0,0,0,,So in the same way that here I had to compare 2, 1, and 4 to partition on 3 in the binary search tree picture,
Dialogue: 0,0:38:33.76,0:38:39.69,中文,,0,0,0,,就像在这里我必须比较 2、1 和 4 来在二叉搜索树图中对 3 进行分区一样
Dialogue: 0,0:38:39.69,0:38:44.69,英文,,0,0,0,,I had to compare 2, 1, and 4 to 3 to figure out should I turn left or should I turn right.
Dialogue: 0,0:38:39.69,0:38:44.69,中文,,0,0,0,,我也必须比较 2、1 和 4 来判断我应该向左还是向右
Dialogue: 0,0:38:44.69,0:38:46.05,英文,,0,0,0,,after visiting 3.
Dialogue: 0,0:38:44.69,0:38:46.05,中文,,0,0,0,,在访问 3 之后
Dialogue: 0,0:38:46.05,0:38:50.73,英文,,0,0,0,,All these other items did not get compared to 3, because they're in different parts of the tree.
Dialogue: 0,0:38:46.05,0:38:50.73,中文,,0,0,0,,所有其他元素都没有与 3 进行比较 因为它们位于树的不同部分
Dialogue: 0,0:38:50.73,0:38:56.87,英文,,0,0,0,,And same in Quicksort, they're in different parts or different partitions, so I don't have to check these items against 3.
Dialogue: 0,0:38:50.73,0:38:56.87,中文,,0,0,0,,在快速排序中也是一样 它们位于不同的部分或不同的分区 所以我不必将这些元素与 3 进行比较
Dialogue: 0,0:38:56.87,0:38:58.35,英文,,0,0,0,,Same thing on the right side.
Dialogue: 0,0:38:56.87,0:38:58.35,中文,,0,0,0,,右边也是一样
Dialogue: 0,0:38:58.35,0:39:02.10,英文,,0,0,0,,So here I have 7, 8 and 6 are the items that got compared against 7.
Dialogue: 0,0:38:58.35,0:39:02.10,中文,,0,0,0,,这里 7、8 和 6 是与 7 进行比较的元素
Dialogue: 0,0:39:02.10,0:39:10.16,英文,,0,0,0,,And if you do this all the way down to the base level, you will see that Quicksort and BSTsort actually end up doing the same types of comparisons.
Dialogue: 0,0:39:02.10,0:39:10.16,中文,,0,0,0,,如果你一直这样做到底层 你会发现快速排序和二叉搜索树排序最终进行的比较类型是相同的
Dialogue: 0,0:39:10.16,0:39:12.84,英文,,0,0,0,,Or rather, the exact same sequence of comparisons.
Dialogue: 0,0:39:10.16,0:39:12.84,中文,,0,0,0,,或者更确切地说 是完全相同的比较序列
Dialogue: 0,0:39:12.84,0:39:14.94,英文,,0,0,0,,So they end up being the exact same sort.
Dialogue: 0,0:39:12.84,0:39:14.94,中文,,0,0,0,,它们最终是完全相同的排序
Dialogue: 0,0:39:14.94,0:39:19.27,英文,,0,0,0,,If you implemented them, the amount of comparisons you do is exactly the same.
Dialogue: 0,0:39:14.94,0:39:19.27,中文,,0,0,0,,如果你实现了它们 你进行的比较次数是完全相同的
Dialogue: 0,0:39:19.27,0:39:25.25,英文,,0,0,0,,Whereas if you did, say, quick sort and merge sort, the amount of comparisons is not guaranteed to be the same.
Dialogue: 0,0:39:19.27,0:39:25.25,中文,,0,0,0,,而如果你使用快速排序和归并排序 比较次数就不一定是相同的
Dialogue: 0,0:39:25.25,0:39:27.39,英文,,0,0,0,,It's kind of cool, kind of mind-bending.
Dialogue: 0,0:39:25.25,0:39:27.39,中文,,0,0,0,,这有点酷 有点烧脑
Dialogue: 0,0:39:27.39,0:39:29.12,英文,,0,0,0,,OK. That's the key idea.
Dialogue: 0,0:39:27.39,0:39:29.12,中文,,0,0,0,,好的  这就是关键
Dialogue: 0,0:39:29.12,0:39:30.86,英文,,0,0,0,,So everyone got compared to 5.
Dialogue: 0,0:39:29.12,0:39:30.86,中文,,0,0,0,,所有元素都与 5 进行了比较
Dialogue: 0,0:39:30.86,0:39:36.37,英文,,0,0,0,,Everyone to the left of 5 got, or everyone less than 5 got compared to 3, which is exactly what we see here.
Dialogue: 0,0:39:30.86,0:39:36.37,中文,,0,0,0,,所有小于 5 的元素都与 3 进行了比较 这正是我们在这里看到的
Dialogue: 0,0:39:36.37,0:39:39.73,英文,,0,0,0,,Everyone greater than 5 got compared to 7, which is what we see here.
Dialogue: 0,0:39:36.37,0:39:39.73,中文,,0,0,0,,所有大于 5 的元素都与 7 进行了比较 这正是我们在这里看到的
Dialogue: 0,0:39:39.73,0:39:50.80,英文,,0,0,0,,And so if you remember all the way back when that other guy showed you that if you have a random binary search tree, it takes n log n time to insert items into a random binary search tree.
Dialogue: 0,0:39:39.73,0:39:50.80,中文,,0,0,0,,还记得很久以前 那个人告诉过你 如果你有一个随机二叉搜索树 将元素插入到随机二叉搜索树中需要 N log N 的时间
Dialogue: 0,0:39:50.80,0:39:57.88,英文,,0,0,0,,Well, for the same proof or with the same reason, quick sorting is also n log n time on average.
Dialogue: 0,0:39:50.80,0:39:57.88,中文,,0,0,0,,嗯 由于相同的证明或相同的原因 快速排序的平均时间也是 N log N
Dialogue: 0,0:39:57.88,0:40:03.03,英文,,0,0,0,,Because it's the same as inserting things into a random binary search tree, and that's also n log n time.
Dialogue: 0,0:39:57.88,0:40:03.03,中文,,0,0,0,,因为它和将元素插入到随机二叉搜索树中一样 也需要 N log N 的时间
Dialogue: 0,0:40:03.03,0:40:08.42,英文,,0,0,0,,Because on average, a random binary search tree is balanced.
Dialogue: 0,0:40:03.03,0:40:08.42,中文,,0,0,0,,因为平均而言 随机二叉搜索树是平衡的
Dialogue: 0,0:40:08.42,0:40:14.40,英文,,0,0,0,,By the way, I also think this is a pretty cool way to see the n log n and the n squared runtimes,
Dialogue: 0,0:40:08.42,0:40:14.40,中文,,0,0,0,,顺便说一下 我还认为这是一种非常酷的方式来看待 N log N 和 N^2运行时间
Dialogue: 0,0:40:14.40,0:40:21.40,英文,,0,0,0,,because what would be the worst case in binary search tree sort is you get the really spindly tree, and it turns out building the spindly tree would take n squared time.
Dialogue: 0,0:40:14.40,0:40:21.40,中文,,0,0,0,,因为二叉搜索树排序中最坏的情况是得到一个非常细长的树 而构建细长的树需要 N^2时间
Dialogue: 0,0:40:21.40,0:40:26.44,英文,,0,0,0,,So that's another way to see the n log n, bushy trees, n squared, spindly trees.
Dialogue: 0,0:40:21.40,0:40:26.44,中文,,0,0,0,,这是另一种看待 N log N（茂密的树）和 N^2（细长的树）的方式
Dialogue: 0,0:40:26.44,0:40:30.71,英文,,0,0,0,,It's such a weird, deep connection that those other guys would have totally screwed up.
Dialogue: 0,0:40:26.44,0:40:30.71,中文,,0,0,0,,这是一个奇怪而深刻的联系 那些家伙完全搞错了
Dialogue: 0,0:40:30.71,0:40:35.87,英文,,0,0,0,,But luckily, you have me here, and we showed you BST sort versus QuickSort.
Dialogue: 0,0:40:30.71,0:40:35.87,中文,,0,0,0,,但幸运的是 你还有我 我们向你展示了 BST 排序与快速排序
Dialogue: 0,0:40:35.87,0:40:37.86,英文,,0,0,0,,OK, thoughts, questions?
Dialogue: 0,0:40:35.87,0:40:37.86,中文,,0,0,0,,好的 有什么想法或问题吗？
Dialogue: 0,0:40:37.86,0:40:44.84,英文,,0,0,0,,Are we somewhat convinced that quicksort by proof is n log n with very high probability?
Dialogue: 0,0:40:37.86,0:40:44.84,中文,,0,0,0,,我们是否有点相信快速排序通过证明是 N log N 并且概率很高？
Dialogue: 0,0:40:44.84,0:40:46.50,英文,,0,0,0,,Here's, by the way, an experiment.
Dialogue: 0,0:40:44.84,0:40:46.50,中文,,0,0,0,,顺便说一下 这是一个实验
Dialogue: 0,0:40:46.50,0:40:52.42,英文,,0,0,0,,So if you actually ran an experiment, I took a bunch of random arrays, and I sorted them,
Dialogue: 0,0:40:46.50,0:40:52.42,中文,,0,0,0,,如果你真的做了一个实验 我拿了一堆随机数组 并对它们进行了排序
Dialogue: 0,0:40:52.42,0:40:58.42,英文,,0,0,0,,and I counted how many operations, how many compares, did it take me to sort the arrays, I can actually plot them.
Dialogue: 0,0:40:52.42,0:40:58.42,中文,,0,0,0,,我计算了排序这些数组需要多少操作 多少次比较 我实际上可以把它们画出来
Dialogue: 0,0:40:58.42,0:41:04.62,英文,,0,0,0,,So for example, this is telling me that a lot of arrays took around 12,000 compares to solve.
Dialogue: 0,0:40:58.42,0:41:04.62,中文,,0,0,0,,例如 这告诉我很多数组需要大约 12,000 次比较才能解决
Dialogue: 0,0:41:04.62,0:41:13.80,英文,,0,0,0,,And then the height of this bar tells me how many compares, or how many arrays, out of all the arrays that I tried, took 12,100 compares or whatever.
Dialogue: 0,0:41:04.62,0:41:13.80,中文,,0,0,0,,然后这个条形图的高度告诉我 在我尝试的所有数组中 有多少个数组需要 12,100 次比较或其他次数
Dialogue: 0,0:41:13.80,0:41:19.31,英文,,0,0,0,,So what we see if we plot all of the arrays that I tried and the number of compares
Dialogue: 0,0:41:13.80,0:41:19.31,中文,,0,0,0,,如果我们把我尝试的所有数组以及它们进行的比较次数都画出来
Dialogue: 0,0:41:19.31,0:41:26.31,英文,,0,0,0,,they took is that most arrays took approximately 11,000 to 13,000 compares to do.
Dialogue: 0,0:41:19.31,0:41:26.31,中文,,0,0,0,,我们会看到大多数数组大约需要 11,000 到 13,000 次比较才能完成
Dialogue: 0,0:41:26.31,0:41:32.59,英文,,0,0,0,,And by the way, here I'm assuming that the array has 1,000 items, so n equals 1,000.
Dialogue: 0,0:41:26.31,0:41:32.59,中文,,0,0,0,,假设数组里有 1,000 个元素 所以 N 等于 1,000
Dialogue: 0,0:41:32.59,0:41:36.89,英文,,0,0,0,,And if you compute n log n, turns out n log n is around 12,000.
Dialogue: 0,0:41:32.59,0:41:36.89,中文,,0,0,0,,算一下 N log N 结果大约是 12,000
Dialogue: 0,0:41:36.89,0:41:41.80,英文,,0,0,0,,So 1,000 times the log of 1,000 is approximately 12,000.
Dialogue: 0,0:41:36.89,0:41:41.80,中文,,0,0,0,,所以 1,000 乘以 log 1,000 约等于 12,000
Dialogue: 0,0:41:41.80,0:41:46.10,英文,,0,0,0,,And so you see that most arrays follow the n log n expected runtime.
Dialogue: 0,0:41:41.80,0:41:46.10,中文,,0,0,0,,大多数数组都符合 N log N 的预期运行时间
Dialogue: 0,0:41:46.10,0:41:49.70,英文,,0,0,0,,They all take around 12,000 compares, a very small number of them.
Dialogue: 0,0:41:46.10,0:41:49.70,中文,,0,0,0,,它们都用了大约 12,000 次比较 非常少
Dialogue: 0,0:41:49.70,0:41:51.48,英文,,0,0,0,,Let's say you get really unlucky.
Dialogue: 0,0:41:49.70,0:41:51.48,中文,,0,0,0,,假如你运气很差
Dialogue: 0,0:41:51.48,0:41:55.92,英文,,0,0,0,,You might have taken 16,000 compares or maybe 15,000 compares.
Dialogue: 0,0:41:51.48,0:41:55.92,中文,,0,0,0,,可能用了 16,000 次或 15,000 次比较
Dialogue: 0,0:41:55.92,0:41:58.74,英文,,0,0,0,,So there are a few arrays that kind of went out here in the tail.
Dialogue: 0,0:41:55.92,0:41:58.74,中文,,0,0,0,,有一些数组的运行时间比较长
Dialogue: 0,0:41:58.74,0:42:00.86,英文,,0,0,0,,Where's the n squared case on this picture?
Dialogue: 0,0:41:58.74,0:42:00.86,中文,,0,0,0,,N^2的情况在哪儿呢？
Dialogue: 0,0:42:00.86,0:42:02.57,英文,,0,0,0,,What is n squared?
Dialogue: 0,0:42:00.86,0:42:02.57,中文,,0,0,0,,N^2是多少？
Dialogue: 0,0:42:02.57,0:42:03.63,英文,,0,0,0,,It's a million.
Dialogue: 0,0:42:02.57,0:42:03.63,中文,,0,0,0,,一百万
Dialogue: 0,0:42:03.63,0:42:05.33,英文,,0,0,0,,Is it even on this picture?
Dialogue: 0,0:42:03.63,0:42:05.33,中文,,0,0,0,,它在这张图上吗？
Dialogue: 0,0:42:05.33,0:42:06.09,英文,,0,0,0,,Nope.
Dialogue: 0,0:42:05.33,0:42:06.09,中文,,0,0,0,,没有
Dialogue: 0,0:42:06.09,0:42:07.19,英文,,0,0,0,,Is it like here?
Dialogue: 0,0:42:06.09,0:42:07.19,中文,,0,0,0,,在这儿吗？
Dialogue: 0,0:42:07.19,0:42:07.73,英文,,0,0,0,,Nope.
Dialogue: 0,0:42:07.19,0:42:07.73,中文,,0,0,0,,没有
Dialogue: 0,0:42:07.73,0:42:08.67,英文,,0,0,0,,It's all the way.
Dialogue: 0,0:42:07.73,0:42:08.67,中文,,0,0,0,,它在很远的地方
Dialogue: 0,0:42:08.67,0:42:16.09,英文,,0,0,0,,It's like in the other building it's so far, because n squared is so far away from all of these cases.
Dialogue: 0,0:42:08.67,0:42:16.09,中文,,0,0,0,,在另一栋楼里 因为 N^2比这些情况都远得多
Dialogue: 0,0:42:16.09,0:42:22.82,英文,,0,0,0,,So imagine if you had a distribution roughly looking like this, and you wanted to land a point like one mile that way.
Dialogue: 0,0:42:16.09,0:42:22.82,中文,,0,0,0,,想象一下 如果分布大致像这样 你想落在距离一英里的地方
Dialogue: 0,0:42:22.82,0:42:29.00,英文,,0,0,0,,Like, good luck landing a point n equals a million, or rather the runtime being a million.
Dialogue: 0,0:42:22.82,0:42:29.00,中文,,0,0,0,,祝你好运 落在 N 等于一百万的地方 或者说运行时间是一百万
Dialogue: 0,0:42:29.00,0:42:32.95,英文,,0,0,0,,It's not going to happen if your array is random.
Dialogue: 0,0:42:29.00,0:42:32.95,中文,,0,0,0,,如果你的数组是随机的 这不可能发生
Dialogue: 0,0:42:32.95,0:42:34.47,英文,,0,0,0,,So that's another way to see it.
Dialogue: 0,0:42:32.95,0:42:34.47,中文,,0,0,0,,换个角度看就是这样
Dialogue: 0,0:42:34.47,0:42:35.93,英文,,0,0,0,,Lots of various take 12,000.
Dialogue: 0,0:42:34.47,0:42:35.93,中文,,0,0,0,,很多不同的情况需要 12,000 次运算
Dialogue: 0,0:42:35.93,0:42:36.95,英文,,0,0,0,,Some take 15,000.
Dialogue: 0,0:42:35.93,0:42:36.95,中文,,0,0,0,,有些需要 15,000 次
Dialogue: 0,0:42:36.95,0:42:38.79,英文,,0,0,0,,But even that's not n squared.
Dialogue: 0,0:42:36.95,0:42:38.79,中文,,0,0,0,,但这也不是 N^2
Dialogue: 0,0:42:38.79,0:42:41.30,英文,,0,0,0,,15,000 is not 1,000 squared.
Dialogue: 0,0:42:38.79,0:42:41.30,中文,,0,0,0,,15,000 不是 1,000 的平方
Dialogue: 0,0:42:41.30,0:42:45.02,英文,,0,0,0,,If you wanted 1,000 squared, you'd have to go all the way off the slide.
Dialogue: 0,0:42:41.30,0:42:45.02,中文,,0,0,0,,如果要 1,000 的平方 你得一直到幻灯片外面去
Dialogue: 0,0:42:45.02,0:42:46.40,英文,,0,0,0,,It's not happening.
Dialogue: 0,0:42:45.02,0:42:46.40,中文,,0,0,0,,那是不可能的
Dialogue: 0,0:42:46.40,0:42:49.34,英文,,0,0,0,,OK. That was our runtime analysis.
Dialogue: 0,0:42:46.40,0:42:49.34,中文,,0,0,0,,好的  这就是我们的运行时间分析
Dialogue: 0,0:42:49.34,0:42:53.10,英文,,0,0,0,,In the best case, n log n. In the worst case, n squared on average.
Dialogue: 0,0:42:49.34,0:42:53.10,中文,,0,0,0,,最佳情况是 N log N 最坏情况是 N^2 平均情况下也是 N^2
Dialogue: 0,0:42:53.10,0:42:59.35,英文,,0,0,0,,Or rather, if you have a randomly chosen array, n log n with extremely high probability.
Dialogue: 0,0:42:53.10,0:42:59.35,中文,,0,0,0,,或者更确切地说 如果你有一个随机选择的数组 N log N 的概率极高
Dialogue: 0,0:42:59.35,0:43:03.77,英文,,0,0,0,,That is, probability that you get a point all the way that way.
Dialogue: 0,0:42:59.35,0:43:03.77,中文,,0,0,0,,也就是说 得到一个那样排列的数组的概率
Dialogue: 0,0:43:03.77,0:43:06.67,英文,,0,0,0,,By the way, why do we use QuickSort instead of MergeSort?
Dialogue: 0,0:43:03.77,0:43:06.67,中文,,0,0,0,,顺便问一下 为什么我们用快速排序而不是归并排序？
Dialogue: 0,0:43:06.67,0:43:11.31,英文,,0,0,0,,This is one of those questions where even I, with all of my vision, could not tell you the answer.
Dialogue: 0,0:43:06.67,0:43:11.31,中文,,0,0,0,,这个问题即使是我 以我所有的见识 也无法告诉你答案
Dialogue: 0,0:43:11.31,0:43:16.04,英文,,0,0,0,,It turns out, in real life, if you just ran some experiments,
Dialogue: 0,0:43:11.31,0:43:16.04,中文,,0,0,0,,事实证明 在现实生活中 如果你做一些实验
Dialogue: 0,0:43:16.04,0:43:21.04,英文,,0,0,0,,QuickSorting an array and MergeSorting the same array, for some reason, QuickSort just does better.
Dialogue: 0,0:43:16.04,0:43:21.04,中文,,0,0,0,,对同一个数组进行快速排序和归并排序 出于某种原因 快速排序的效果就是更好
Dialogue: 0,0:43:21.04,0:43:29.48,英文,,0,0,0,,You'd have to go really deep down and think about how computers work, and caching, and all of these other things that we haven't seen in this class to really, truly see why it's faster.
Dialogue: 0,0:43:21.04,0:43:29.48,中文,,0,0,0,,你得深入研究计算机的工作原理、缓存以及我们在本课程中没有涉及到的其他所有东西 才能真正了解为什么它更快
Dialogue: 0,0:43:29.48,0:43:40.11,英文,,0,0,0,,But for this class, we can say that even though they are asymptotically the same runtime, turns out if you do some experiments, you will find out that QuickSort generally performs better.
Dialogue: 0,0:43:29.48,0:43:40.11,中文,,0,0,0,,但对于本课程 我们可以说 即使它们的渐近运行时间相同 但如果你做一些实验 你会发现快速排序通常表现更好
Dialogue: 0,0:43:40.11,0:43:44.76,英文,,0,0,0,,But I don't know if I have a one-sentence reason to convince you of that fact.
Dialogue: 0,0:43:40.11,0:43:44.76,中文,,0,0,0,,但我不知道我是否能用一句话让你信服这个事实
Dialogue: 0,0:43:44.76,0:43:51.84,英文,,0,0,0,,You just have to trust that I know more than that other guy or that quicksort is in the name, the faster one.
Dialogue: 0,0:43:44.76,0:43:51.84,中文,,0,0,0,,你只需要相信我比其他人懂得更多 或者相信快速排序这个名字 它是更快的那个
Dialogue: 0,0:43:51.84,0:43:54.58,英文,,0,0,0,,You can run some experiments if you're not convinced.
Dialogue: 0,0:43:51.84,0:43:54.58,中文,,0,0,0,,如果你不信服 可以自己做一些实验
Dialogue: 0,0:43:54.58,0:44:00.68,英文,,0,0,0,,So now we have finished at least seeing what quicksort is, which is the key operation is partition.
Dialogue: 0,0:43:54.58,0:44:00.68,中文,,0,0,0,,好 我们已经了解了快速排序的大概过程 关键操作就是分区
Dialogue: 0,0:44:00.68,0:44:04.06,英文,,0,0,0,,And with very high probability, it's n log n time.
Dialogue: 0,0:44:00.68,0:44:04.06,中文,,0,0,0,,而且 它有很高的概率是 N log N 的时间复杂度
Dialogue: 0,0:44:04.06,0:44:11.70,英文,,0,0,0,,Thoughts, questions before I tell you about how to avoid that n squared you were also afraid of?
Dialogue: 0,0:44:04.06,0:44:11.70,中文,,0,0,0,,在讲如何避免 N^2复杂度之前 大家有什么想法或问题吗？（N^2复杂度也就是你们担心的最坏情况）
Dialogue: 0,0:44:11.70,0:44:13.20,英文,,0,0,0,,OK.
Dialogue: 0,0:44:11.70,0:44:13.20,中文,,0,0,0,,
Dialogue: 0,0:44:13.20,0:44:21.03,英文,,0,0,0,,So while it's true that if I had a random array, I would get n log n runtime, I still don't like this n squared.
Dialogue: 0,0:44:13.20,0:44:21.03,中文,,0,0,0,,虽然对于随机数组 快速排序的时间复杂度是 N log N 但我还是不喜欢 N^2的情况
Dialogue: 0,0:44:21.03,0:44:22.21,英文,,0,0,0,,It scares me.
Dialogue: 0,0:44:21.03,0:44:22.21,中文,,0,0,0,,它让我害怕
Dialogue: 0,0:44:22.21,0:44:25.57,英文,,0,0,0,,In particular, what is the array that gives you the n squared runtime?
Dialogue: 0,0:44:22.21,0:44:25.57,中文,,0,0,0,,特别是 什么样的数组会导致 N^2的时间复杂度呢？
Dialogue: 0,0:44:25.57,0:44:27.81,英文,,0,0,0,,It's the already sorted array.
Dialogue: 0,0:44:25.57,0:44:27.81,中文,,0,0,0,,就是已经排好序的数组
Dialogue: 0,0:44:27.81,0:44:32.96,英文,,0,0,0,,That's kind of scary, because sometimes you might have an array that's already sorted,and you call quicksort on it,
Dialogue: 0,0:44:27.81,0:44:32.96,中文,,0,0,0,,这有点吓人 因为有时候你可能会遇到一个已经排好序的数组 然后你用快速排序
Dialogue: 0,0:44:32.96,0:44:37.96,英文,,0,0,0,,and it chokes, and it crashes your program because n squared is too slow, and the autograder times out.
Dialogue: 0,0:44:32.96,0:44:37.96,中文,,0,0,0,,结果程序就卡住了 崩溃了 因为 N^2太慢了 导致自动评分系统超时
Dialogue: 0,0:44:37.96,0:44:39.12,英文,,0,0,0,,But we don't want that.
Dialogue: 0,0:44:37.96,0:44:39.12,中文,,0,0,0,,但我们不希望这样
Dialogue: 0,0:44:39.12,0:44:42.54,英文,,0,0,0,,So how do we avoid the n squared runtime?
Dialogue: 0,0:44:39.12,0:44:42.54,中文,,0,0,0,,那么 如何避免 N^2的时间复杂度呢？
Dialogue: 0,0:44:42.54,0:44:46.42,英文,,0,0,0,,Well, it turns out there's actually some different strategies for doing that.
Dialogue: 0,0:44:42.54,0:44:46.42,中文,,0,0,0,,嗯 实际上有一些不同的策略可以做到这一点
Dialogue: 0,0:44:46.42,0:44:51.24,英文,,0,0,0,,So we already saw that if the pivot always lands somewhere good, you get n log n runtime.
Dialogue: 0,0:44:46.42,0:44:51.24,中文,,0,0,0,,我们已经知道 如果基准值总是落在一个好的位置 那么时间复杂度就是 N log N
Dialogue: 0,0:44:51.24,0:44:55.92,英文,,0,0,0,,And by good, we meant, for example, 10% from each edge.
Dialogue: 0,0:44:51.24,0:44:55.92,中文,,0,0,0,,好的位置是指 例如 距离数组两端各 10% 的位置
Dialogue: 0,0:44:55.92,0:44:57.60,英文,,0,0,0,,Even that could be good.
Dialogue: 0,0:44:55.92,0:44:57.60,中文,,0,0,0,,即使是这样也行
Dialogue: 0,0:44:57.60,0:44:59.92,英文,,0,0,0,,Even 1% from each edge would be good.
Dialogue: 0,0:44:57.60,0:44:59.92,中文,,0,0,0,,甚至距离数组两端各 1% 的位置也可以
Dialogue: 0,0:44:59.92,0:45:02.68,英文,,0,0,0,,But in very rare cases, you do get n squared.
Dialogue: 0,0:44:59.92,0:45:02.68,中文,,0,0,0,,但在极少数情况下 确实会出现 N^2的时间复杂度
Dialogue: 0,0:45:02.68,0:45:07.72,英文,,0,0,0,,And in real life, you can imagine you get n squared if the array is already sorted, almost sorted.
Dialogue: 0,0:45:02.68,0:45:07.72,中文,,0,0,0,,在现实生活中 可以想象 如果数组已经排好序或几乎排好序 就会出现 N^2的时间复杂度
Dialogue: 0,0:45:07.72,0:45:10.28,英文,,0,0,0,,Or if the array has all duplicates, try that one at home.
Dialogue: 0,0:45:07.72,0:45:10.28,中文,,0,0,0,,或者如果数组中所有元素都相同 大家可以试试
Dialogue: 0,0:45:10.28,0:45:11.82,英文,,0,0,0,,You'll also get n squared.
Dialogue: 0,0:45:10.28,0:45:11.82,中文,,0,0,0,,也会出现 N^2的时间复杂度
Dialogue: 0,0:45:11.82,0:45:14.23,英文,,0,0,0,,So how do you avoid worst case behavior?
Dialogue: 0,0:45:11.82,0:45:14.23,中文,,0,0,0,,那如何避免最坏情况的发生呢？
Dialogue: 0,0:45:14.23,0:45:15.09,英文,,0,0,0,,I have an open question.
Dialogue: 0,0:45:14.23,0:45:15.09,中文,,0,0,0,,我有个问题想问
Dialogue: 0,0:45:15.09,0:45:17.17,英文,,0,0,0,,There's lots of different things you can try.
Dialogue: 0,0:45:15.09,0:45:17.17,中文,,0,0,0,,可以尝试很多不同的方法
Dialogue: 0,0:45:17.17,0:45:22.57,英文,,0,0,0,,So one thing that someone said earlier was, why not just pay n at the beginning to check if the array is already sorted?
Dialogue: 0,0:45:17.17,0:45:22.57,中文,,0,0,0,,之前有人提到 为什么不一开始就支付 N 来检查数组是否已经排序了呢？
Dialogue: 0,0:45:22.57,0:45:27.23,英文,,0,0,0,,And if it is, switch to merge sort or just don't do anything that's already sorted.
Dialogue: 0,0:45:22.57,0:45:27.23,中文,,0,0,0,,如果已经排序了 就切换到归并排序 或者什么都不做
Dialogue: 0,0:45:27.23,0:45:28.37,英文,,0,0,0,,That's not a bad idea.
Dialogue: 0,0:45:27.23,0:45:28.37,中文,,0,0,0,,这主意不错
Dialogue: 0,0:45:28.37,0:45:35.83,英文,,0,0,0,,Anyone else have good ideas for how to avoid or bad ideas for how to avoid the n squared case?
Dialogue: 0,0:45:28.37,0:45:35.83,中文,,0,0,0,,还有其他人有好的或坏的避免 N^2情况的想法吗？
Dialogue: 0,0:45:35.83,0:45:40.79,英文,,0,0,0,,How do you avoid the case where you end up in the n squared case?
Dialogue: 0,0:45:35.83,0:45:40.79,中文,,0,0,0,,如何避免最终陷入 N^2的情况？
Dialogue: 0,0:45:40.79,0:45:45.81,英文,,0,0,0,,Yeah.
Dialogue: 0,0:45:40.79,0:45:45.81,中文,,0,0,0,,是的
Dialogue: 0,0:45:45.81,0:45:51.68,英文,,0,0,0,,Yeah, I think this is kind of similar to what the other guy said, which is a good idea, which is just check ahead of time, like do some analysis beforehand.
Dialogue: 0,0:45:45.81,0:45:51.68,中文,,0,0,0,,是的 我认为这与另一个人说的类似 这是个好主意 就是提前检查 比如事先做一些分析
Dialogue: 0,0:45:51.68,0:45:55.00,英文,,0,0,0,,And if it's a bad array, then switch, something like that.
Dialogue: 0,0:45:51.68,0:45:55.00,中文,,0,0,0,,如果它是一个坏数组 那就切换 诸如此类
Dialogue: 0,0:45:55.00,0:45:56.64,英文,,0,0,0,,Anything else?
Dialogue: 0,0:45:55.00,0:45:56.64,中文,,0,0,0,,还有别的吗？
Dialogue: 0,0:45:56.64,0:45:58.60,英文,,0,0,0,,I'll give you a couple if you don't have any.
Dialogue: 0,0:45:56.64,0:45:58.60,中文,,0,0,0,,如果你没有 我会给你几个
Dialogue: 0,0:45:58.60,0:46:00.29,英文,,0,0,0,,Yeah, one more.
Dialogue: 0,0:45:58.60,0:46:00.29,中文,,0,0,0,,好的 再来一个
Dialogue: 0,0:46:00.29,0:46:01.45,英文,,0,0,0,,Shuffle it, I like that.
Dialogue: 0,0:46:00.29,0:46:01.45,中文,,0,0,0,,打乱它 我喜欢这个
Dialogue: 0,0:46:01.45,0:46:04.53,英文,,0,0,0,,So what if you just take the array, shuffle it around, now it's random.
Dialogue: 0,0:46:01.45,0:46:04.53,中文,,0,0,0,,如果把数组打乱 现在它是随机的 会怎么样？
Dialogue: 0,0:46:04.53,0:46:07.89,英文,,0,0,0,,Random arrays are n log n with high probability.
Dialogue: 0,0:46:04.53,0:46:07.89,中文,,0,0,0,,随机数组很有可能是 N log N
Dialogue: 0,0:46:07.89,0:46:08.97,英文,,0,0,0,,So I like that, too.
Dialogue: 0,0:46:07.89,0:46:08.97,中文,,0,0,0,,我也喜欢这个
Dialogue: 0,0:46:08.97,0:46:10.85,英文,,0,0,0,,So here's a bunch of ideas that we have.
Dialogue: 0,0:46:08.97,0:46:10.85,中文,,0,0,0,,我们有一些想法
Dialogue: 0,0:46:10.85,0:46:13.07,英文,,0,0,0,,Shuffling, we have that one.
Dialogue: 0,0:46:10.85,0:46:13.07,中文,,0,0,0,,打乱 我们有这个
Dialogue: 0,0:46:13.07,0:46:15.05,英文,,0,0,0,,Scan through and just check if it's already sorted.
Dialogue: 0,0:46:13.07,0:46:15.05,中文,,0,0,0,,扫一眼 看看是不是已经排序好了
Dialogue: 0,0:46:15.05,0:46:18.62,英文,,0,0,0,,And don't sort if it's already sorted, or if it looks like it's going to be bad.
Dialogue: 0,0:46:15.05,0:46:18.62,中文,,0,0,0,,如果已经排序好了 或者看起来排序效果不好 就不要排序了
Dialogue: 0,0:46:18.62,0:46:21.40,英文,,0,0,0,,And avoid sorting, or use a different sort.
Dialogue: 0,0:46:18.62,0:46:21.40,中文,,0,0,0,,避免排序 或者使用不同的排序方法
Dialogue: 0,0:46:21.40,0:46:24.46,英文,,0,0,0,,Another one that none of you came up with, but still good.
Dialogue: 0,0:46:21.40,0:46:24.46,中文,,0,0,0,,还有一个你们都没想出来的 但还是不错的
Dialogue: 0,0:46:24.46,0:46:26.06,英文,,0,0,0,,I mean, maybe you could if you had more time.
Dialogue: 0,0:46:24.46,0:46:26.06,中文,,0,0,0,,我的意思是 如果你们有更多时间的话 也许可以想出来
Dialogue: 0,0:46:26.06,0:46:29.44,英文,,0,0,0,,But you could also go through the array and pick a better pivot.
Dialogue: 0,0:46:26.06,0:46:29.44,中文,,0,0,0,,但你也可以遍历数组并选择一个更好的基准值
Dialogue: 0,0:46:29.44,0:46:32.53,英文,,0,0,0,,So, so far, we've just been lazy and we said, just pick the leftmost item.
Dialogue: 0,0:46:29.44,0:46:32.53,中文,,0,0,0,,到目前为止 我们一直很懒 说 就选最左边的项
Dialogue: 0,0:46:32.53,0:46:34.85,英文,,0,0,0,,But what if you went through and actually picked a better pivot?
Dialogue: 0,0:46:32.53,0:46:34.85,中文,,0,0,0,,但是 如果你遍历并实际选择一个更好的基准值呢？
Dialogue: 0,0:46:34.85,0:46:37.69,英文,,0,0,0,,What if you picked the best pivot every single time?
Dialogue: 0,0:46:34.85,0:46:37.69,中文,,0,0,0,,如果你每次都选择最好的基准值呢？
Dialogue: 0,0:46:37.69,0:46:40.13,英文,,0,0,0,,Well, then, maybe you can avoid the worst case.
Dialogue: 0,0:46:37.69,0:46:40.13,中文,,0,0,0,,嗯 也许你可以避免最坏的情况
Dialogue: 0,0:46:40.13,0:46:41.51,英文,,0,0,0,,So here are some ideas.
Dialogue: 0,0:46:40.13,0:46:41.51,中文,,0,0,0,,以下是一些想法
Dialogue: 0,0:46:41.51,0:46:43.01,英文,,0,0,0,,Let's go through some of them.
Dialogue: 0,0:46:41.51,0:46:43.01,中文,,0,0,0,,让我们来分析其中的一些
Dialogue: 0,0:46:43.01,0:46:47.23,英文,,0,0,0,,OK. I hear Tony Ho writing Josh an email.
Dialogue: 0,0:46:43.01,0:46:47.23,中文,,0,0,0,,好的  我听到Tony Ho在给Josh写邮件
Dialogue: 0,0:46:47.23,0:46:49.69,英文,,0,0,0,,I don't know what happened, but you can read it.
Dialogue: 0,0:46:47.23,0:46:49.69,中文,,0,0,0,,我不知道发生了什么 但你可以读一下
Dialogue: 0,0:46:49.69,0:46:53.59,英文,,0,0,0,,OK. Let's talk about avoiding worst case quicksort.
Dialogue: 0,0:46:49.69,0:46:53.59,中文,,0,0,0,,好的  让我们来谈谈如何避免最坏情况下的快速排序
Dialogue: 0,0:46:53.59,0:46:56.74,英文,,0,0,0,,OK. So we already saw what quicksort is.
Dialogue: 0,0:46:53.59,0:46:56.74,中文,,0,0,0,,我们已经看到了什么是快速排序
Dialogue: 0,0:46:56.74,0:46:58.36,英文,,0,0,0,,I won't go through it again.
Dialogue: 0,0:46:56.74,0:46:58.36,中文,,0,0,0,,我不会再讲一遍了
Dialogue: 0,0:46:58.36,0:47:00.66,英文,,0,0,0,,Here are some four philosophies that we talked about.
Dialogue: 0,0:46:58.36,0:47:00.66,中文,,0,0,0,,我们之前讨论过四种哲学思想
Dialogue: 0,0:47:00.66,0:47:02.54,英文,,0,0,0,,One of them is embrace randomness.
Dialogue: 0,0:47:00.66,0:47:02.54,中文,,0,0,0,,其中之一是拥抱随机性
Dialogue: 0,0:47:02.54,0:47:05.60,英文,,0,0,0,,Just pick a random pivot or shuffle before sorting.
Dialogue: 0,0:47:02.54,0:47:05.60,中文,,0,0,0,,就是在排序之前随机选择一个基准值或进行洗牌
Dialogue: 0,0:47:05.60,0:47:11.03,英文,,0,0,0,,And we know that with very high probability, if your array is random, you're getting n log n runtime.
Dialogue: 0,0:47:05.60,0:47:11.03,中文,,0,0,0,,我们知道 如果你的数组是随机的 那么你有很高的概率得到 N log N 的运行时间
Dialogue: 0,0:47:11.03,0:47:13.09,英文,,0,0,0,,You can try and be smarter with the pivot selection.
Dialogue: 0,0:47:11.03,0:47:13.09,中文,,0,0,0,,你可以尝试更聪明地选择基准值
Dialogue: 0,0:47:13.09,0:47:14.73,英文,,0,0,0,,Don't just pick the leftmost pivot.
Dialogue: 0,0:47:13.09,0:47:14.73,中文,,0,0,0,,不要只是选择最左边的基准值
Dialogue: 0,0:47:14.73,0:47:20.49,英文,,0,0,0,,Pick one that you think will actually split the array into two roughly equally sized subproblems.
Dialogue: 0,0:47:14.73,0:47:20.49,中文,,0,0,0,,选择一个你认为可以将数组分成两个大小大致相等的子问题的基准值
Dialogue: 0,0:47:20.49,0:47:21.87,英文,,0,0,0,,You can use introspection.
Dialogue: 0,0:47:20.49,0:47:21.87,中文,,0,0,0,,你可以使用内省
Dialogue: 0,0:47:21.87,0:47:25.38,英文,,0,0,0,,This is the one you all mentioned, which is if
Dialogue: 0,0:47:21.87,0:47:25.38,中文,,0,0,0,,这是你们都提到的 那就是如果我猜你们都提到了预处理
Dialogue: 0,0:47:25.38,0:47:30.80,英文,,0,0,0,,I guess you all mentioned preprocessing, which is check the array beforehand and switch if crook sort is slow.
Dialogue: 0,0:47:25.38,0:47:30.80,中文,,0,0,0,,也就是事先检查数组 如果快速排序慢就切换
Dialogue: 0,0:47:30.80,0:47:36.42,英文,,0,0,0,,Maybe a related approach that you kind of got close to was if the recursion goes too deep, like it's taking forever,
Dialogue: 0,0:47:30.80,0:47:36.42,中文,,0,0,0,,也许你们接近的一个相关方法是 如果递归太深 比如它需要永远
Dialogue: 0,0:47:36.42,0:47:41.42,英文,,0,0,0,,just time out and call it quits and switch to a different sort, because you might be in an unsquared case.
Dialogue: 0,0:47:36.42,0:47:41.42,中文,,0,0,0,,就超时并退出 然后切换到不同的排序 因为你可能处于非平方情况下
Dialogue: 0,0:47:41.42,0:47:47.26,英文,,0,0,0,,So if the number of compares exceeds like 16,000, just switch to merge sort and call it quits.
Dialogue: 0,0:47:41.42,0:47:47.26,中文,,0,0,0,,如果比较次数超过 16,000 次 就切换到归并排序并退出
Dialogue: 0,0:47:47.26,0:47:49.42,英文,,0,0,0,,All of those approaches are valid.
Dialogue: 0,0:47:47.26,0:47:49.42,中文,,0,0,0,,所有这些方法都是有效的
Dialogue: 0,0:47:49.42,0:47:50.97,英文,,0,0,0,,Let's explore them.
Dialogue: 0,0:47:49.42,0:47:50.97,中文,,0,0,0,,让我们来探讨一下
Dialogue: 0,0:47:50.97,0:47:52.81,英文,,0,0,0,,The first one is randomness.
Dialogue: 0,0:47:50.97,0:47:52.81,中文,,0,0,0,,第一个是随机性
Dialogue: 0,0:47:52.81,0:47:58.16,英文,,0,0,0,,We already saw that if you shuffle the array ahead of time, now you have a random array,
Dialogue: 0,0:47:52.81,0:47:58.16,中文,,0,0,0,,我们已经看到 如果你提前对数组进行洗牌 现在你就有了一个随机数组
Dialogue: 0,0:47:58.16,0:48:03.16,英文,,0,0,0,,and we already saw that random arrays have n log n runtime with extremely high probability.
Dialogue: 0,0:47:58.16,0:48:03.16,中文,,0,0,0,,我们也已经看到随机数组以极高的概率具有 N log N 的运行时间
Dialogue: 0,0:48:03.16,0:48:08.42,英文,,0,0,0,,So you can either pick the pivots randomly, so instead of always choosing the leftmost pivot,
Dialogue: 0,0:48:03.16,0:48:08.42,中文,,0,0,0,,你可以随机选择基准值 而不是总是选择最左边的基准值
Dialogue: 0,0:48:08.42,0:48:13.42,英文,,0,0,0,,pick any old item in the middle and make that the pivot, or just shuffle the entire array before you sort.
Dialogue: 0,0:48:08.42,0:48:13.42,中文,,0,0,0,,选择中间的任何一个元素作为基准值 或者在排序之前对整个数组进行洗牌
Dialogue: 0,0:48:13.42,0:48:15.23,英文,,0,0,0,,So that's what you could do.
Dialogue: 0,0:48:13.42,0:48:15.23,中文,,0,0,0,,你可以这样做
Dialogue: 0,0:48:15.23,0:48:17.25,英文,,0,0,0,,And if you do that, you're more like this guy.
Dialogue: 0,0:48:15.23,0:48:17.25,中文,,0,0,0,,如果你这样做 你就会更像这个人
Dialogue: 0,0:48:17.25,0:48:20.51,英文,,0,0,0,,That's a photo of me on my motorcycle.
Dialogue: 0,0:48:17.25,0:48:20.51,中文,,0,0,0,,那是我骑摩托车时的照片
Dialogue: 0,0:48:20.51,0:48:23.26,英文,,0,0,0,,I actually don't know who this is, but it's some renegade.
Dialogue: 0,0:48:20.51,0:48:23.26,中文,,0,0,0,,这人我不认识 感觉像个特立独行的人
Dialogue: 0,0:48:23.26,0:48:25.70,英文,,0,0,0,,And he's out there being wild and free.
Dialogue: 0,0:48:23.26,0:48:25.70,中文,,0,0,0,,他活得很潇洒自在
Dialogue: 0,0:48:25.70,0:48:27.24,英文,,0,0,0,,So that's what randomness is.
Dialogue: 0,0:48:25.70,0:48:27.24,中文,,0,0,0,,这就是随机的意义
Dialogue: 0,0:48:27.24,0:48:28.61,英文,,0,0,0,,You're wild and you're free.
Dialogue: 0,0:48:27.24,0:48:28.61,中文,,0,0,0,,自由自在 无拘无束
Dialogue: 0,0:48:28.61,0:48:33.58,英文,,0,0,0,,Thoughts, questions?
Dialogue: 0,0:48:28.61,0:48:33.58,中文,,0,0,0,,有什么想法或问题吗？
Dialogue: 0,0:48:33.58,0:48:37.38,英文,,0,0,0,,Yeah, the question was, is it inefficient because you're shuffling something that's already sorted?
Dialogue: 0,0:48:33.58,0:48:37.38,中文,,0,0,0,,我想问 由于对已经排序好的数组进行shuffle 会不会效率低下？
Dialogue: 0,0:48:37.38,0:48:42.53,英文,,0,0,0,,And it's true that some of your arrays that are slow might have already been close to sorted.
Dialogue: 0,0:48:37.38,0:48:42.53,中文,,0,0,0,,没错 一些运行缓慢的数组可能已经接近排序状态
Dialogue: 0,0:48:42.53,0:48:46.65,英文,,0,0,0,,But asymptotically, you'll always get n log n runtime.
Dialogue: 0,0:48:42.53,0:48:46.65,中文,,0,0,0,,但从渐进复杂度来看 运行时间始终是 N log N
Dialogue: 0,0:48:46.65,0:48:49.43,英文,,0,0,0,,So the main thing we care about here is we're avoiding n-squared.
Dialogue: 0,0:48:46.65,0:48:49.43,中文,,0,0,0,,我们主要关注的是避免 N^2 的复杂度
Dialogue: 0,0:48:49.43,0:48:53.73,英文,,0,0,0,,If you think asymptotically, n-squared is the one that's going to crash your program.
Dialogue: 0,0:48:49.43,0:48:53.73,中文,,0,0,0,,从渐进复杂度的角度来看 N^2 复杂度会导致程序崩溃
Dialogue: 0,0:48:53.73,0:49:00.95,英文,,0,0,0,,So yes, it might take like one second longer or like a millisecond longer, but at least it won't crash your program, which is mainly what we care about here.
Dialogue: 0,0:48:53.73,0:49:00.95,中文,,0,0,0,,虽然可能多花一秒或一毫秒 但至少不会导致程序崩溃 这是我们最关心的
Dialogue: 0,0:49:00.95,0:49:02.31,英文,,0,0,0,,That's a good point, though.
Dialogue: 0,0:49:00.95,0:49:02.31,中文,,0,0,0,,说的有道理
Dialogue: 0,0:49:02.31,0:49:07.22,英文,,0,0,0,,Somehow it feels kind of weird that if the array is sorted, you're actually making it worse before you make it better.
Dialogue: 0,0:49:02.31,0:49:07.22,中文,,0,0,0,,如果数组已经排序好了 还要先把它打乱再排序 感觉有点奇怪
Dialogue: 0,0:49:07.22,0:49:12.72,英文,,0,0,0,,But at least you've avoided the n-squared case that crashes your program, because that's the worst case.
Dialogue: 0,0:49:07.22,0:49:12.72,中文,,0,0,0,,但至少避免了 N^2 复杂度导致程序崩溃的最坏情况
Dialogue: 0,0:49:12.72,0:49:14.13,英文,,0,0,0,,It's a good point, though.
Dialogue: 0,0:49:12.72,0:49:14.13,中文,,0,0,0,,说的没错
Dialogue: 0,0:49:14.13,0:49:17.87,英文,,0,0,0,,OK, here's the second approach, which is be smarter with your pivots.
Dialogue: 0,0:49:14.13,0:49:17.87,中文,,0,0,0,,第二种方法是更聪明地选择基准值
Dialogue: 0,0:49:17.87,0:49:19.15,英文,,0,0,0,,Oh, I'm almost out of time.
Dialogue: 0,0:49:17.87,0:49:19.15,中文,,0,0,0,,哦 我快没时间了
Dialogue: 0,0:49:19.15,0:49:20.38,英文,,0,0,0,,Be smarter with your pivots.
Dialogue: 0,0:49:19.15,0:49:20.38,中文,,0,0,0,,更聪明地选择基准值
Dialogue: 0,0:49:20.38,0:49:26.20,英文,,0,0,0,,So here we could say, what if, instead of choosing the leftmost item, you choose a better item?
Dialogue: 0,0:49:20.38,0:49:26.20,中文,,0,0,0,,我们可以考虑 如果选择更好的元素 而不是最左边的元素会怎么样？
Dialogue: 0,0:49:26.20,0:49:29.34,英文,,0,0,0,,For example, choose the median, the exact middle item.
Dialogue: 0,0:49:26.20,0:49:29.34,中文,,0,0,0,,例如 选择中间的元素作为基准值
Dialogue: 0,0:49:29.34,0:49:32.28,英文,,0,0,0,,Then you're guaranteed to get two subproblems of equal size.
Dialogue: 0,0:49:29.34,0:49:32.28,中文,,0,0,0,,那就能保证你得到两个大小相等的子问题
Dialogue: 0,0:49:32.28,0:49:34.79,英文,,0,0,0,,You could also do things that are a little bit more clever.
Dialogue: 0,0:49:32.28,0:49:34.79,中文,,0,0,0,,你也可以做一些更聪明的事情
Dialogue: 0,0:49:34.79,0:49:38.49,英文,,0,0,0,,So for example, let's say I had this array, ignore the green number.
Dialogue: 0,0:49:34.79,0:49:38.49,中文,,0,0,0,,例如 假设我有这个数组 忽略绿色的数字
Dialogue: 0,0:49:38.49,0:49:44.32,英文,,0,0,0,,Let's say I have this array, and I don't want to scan through the whole thing to find the median, because that seems like a lot of work.
Dialogue: 0,0:49:38.49,0:49:44.32,中文,,0,0,0,,假设我有这个数组 我不想扫描整个数组来找到中位数 因为这看起来很费劲
Dialogue: 0,0:49:44.32,0:49:51.14,英文,,0,0,0,,What if I just check the first three items, 7, 2, and 3, and I don't look at the rest of the array, which could be huge?
Dialogue: 0,0:49:44.32,0:49:51.14,中文,,0,0,0,,如果我只检查前三个元素 7、2 和 3 而不看数组的其余部分 这部分可能很大？
Dialogue: 0,0:49:51.14,0:49:54.57,英文,,0,0,0,,If I just check 7, 2, and 3, who's the best pivot?
Dialogue: 0,0:49:51.14,0:49:54.57,中文,,0,0,0,,如果我只检查 7、2 和 3 谁是最好的基准？
Dialogue: 0,0:49:54.57,0:49:55.91,英文,,0,0,0,,That's the last question before you all go.
Dialogue: 0,0:49:54.57,0:49:55.91,中文,,0,0,0,,这是你们走之前最后一个问题
Dialogue: 0,0:49:55.91,0:49:58.47,英文,,0,0,0,,7, 2, and 3, who's the best pivot?
Dialogue: 0,0:49:55.91,0:49:58.47,中文,,0,0,0,,7、2 和 3 谁是最好的基准？
Dialogue: 0,0:49:58.47,0:50:00.81,英文,,0,0,0,,I like 3, because it's the middle of the three items.
Dialogue: 0,0:49:58.47,0:50:00.81,中文,,0,0,0,,我喜欢 3 因为它是三个元素的中间值
Dialogue: 0,0:50:00.81,0:50:06.15,英文,,0,0,0,,So one thing you can do is just check a couple of items, do a bit of sampling, and pick a pivot that you think is nice.
Dialogue: 0,0:50:00.81,0:50:06.15,中文,,0,0,0,,你可以做的一件事就是检查几个元素 做一些抽样 然后选择一个你认为不错的基准
Dialogue: 0,0:50:06.15,0:50:10.48,英文,,0,0,0,,It turns out, if you do that, there's actually an adversary you can pass in bad arrays.
Dialogue: 0,0:50:06.15,0:50:10.48,中文,,0,0,0,,事实证明 如果你这样做 实际上有一个对手可以传入坏数组
Dialogue: 0,0:50:10.48,0:50:12.92,英文,,0,0,0,,But I guess I'll continue that thought next time.
Dialogue: 0,0:50:10.48,0:50:12.92,中文,,0,0,0,,但我想下次我会继续这个想法
Dialogue: 0,0:50:12.92,0:50:14.96,英文,,0,0,0,,So you can do exact median quicksort.
Dialogue: 0,0:50:12.92,0:50:14.96,中文,,0,0,0,,你可以进行精确的中位数快速排序
Dialogue: 0,0:50:14.96,0:50:16.76,英文,,0,0,0,,You can also approximate the median.
Dialogue: 0,0:50:14.96,0:50:16.76,中文,,0,0,0,,你也可以近似中位数
Dialogue: 0,0:50:16.76,0:50:19.98,英文,,0,0,0,,But if you do that, you're running into a little bit of danger.
Dialogue: 0,0:50:16.76,0:50:19.98,中文,,0,0,0,,但如果你这样做 你就会遇到一点危险
Dialogue: 0,0:50:19.98,0:50:24.39,英文,,0,0,0,,Then we talked about introspection, which is if the array
Dialogue: 0,0:50:19.98,0:50:24.39,中文,,0,0,0,,然后我们讨论了内省 如果数组
Dialogue: 0,0:50:24.39,0:50:26.73,英文,,0,0,0,,or the sword is taking too long, just switch.
Dialogue: 0,0:50:24.39,0:50:26.73,中文,,0,0,0,,或者剑花费了太长时间 那就切换
Dialogue: 0,0:50:26.73,0:50:31.91,英文,,0,0,0,,While this is perfectly reasonable, you came up with it, most people in practice don't do it.
Dialogue: 0,0:50:26.73,0:50:31.91,中文,,0,0,0,,虽然这完全合理 这是你想出来的 但实际上大多数人都不这样做
Dialogue: 0,0:50:31.91,0:50:32.91,英文,,0,0,0,,Okay.
Dialogue: 0,0:50:31.91,0:50:32.91,中文,,0,0,0,,
Dialogue: 0,0:50:32.91,0:50:37.32,英文,,0,0,0,,I was going to like depart you today in a blaze of glory, but I'll come back next time and I'll finish quicksort.
Dialogue: 0,0:50:32.91,0:50:37.32,中文,,0,0,0,,我今天本想让你光荣地离开 但下次我会回来完成快速排序
Dialogue: 0,0:50:37.32,0:50:42.98,英文,,0,0,0,,So have a good rest of your Monday and come back next time.
Dialogue: 0,0:50:37.32,0:50:42.98,中文,,0,0,0,,好好休息 下次见！
Dialogue: 0,0:50:42.98,0:50:44.00,英文,,0,0,0,,We'll do more quicksort.
Dialogue: 0,0:50:42.98,0:50:44.00,中文,,0,0,0,,下次我们继续讲快速排序
Dialogue: 0,0:50:44.00,0:50:44.74,英文,,0,0,0,,All right. See ya.
Dialogue: 0,0:50:44.00,0:50:44.74,中文,,0,0,0,,好的  再见！
